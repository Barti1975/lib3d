////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	  <3D Librairies developped during 2002-2021>
//	  Copyright (C) <2021>  <Laurent CancÃ© Francis, 10/08/1975>
//    laurent.francis.cance@outlook.fr
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
//	@file 3d_api.cpp 
//	@created 2012-12-03
////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool LOGING=false;
//#define CONSL
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef LINUX
//#	define lib3d_glGetProcAddress(x) (*glXGetProcAddressARB)((const GLubyte*)x)
#endif

#ifdef WIN32
# ifdef API3D_SDL_OPENGL
#  define lib3d_glGetProcAddress(x) (*SDL_GL_GetProcAddress)((char*)x)
# else
#  ifdef API3D_OPENGL
#  define lib3d_glGetProcAddress(x) (*wglGetProcAddress)((char*)x)
#  endif
# endif
#endif

#if defined(API3D_SDL2)&&!defined(API3D_GL_PROTOTYPES)
#  define lib3d_glGetProcAddress(x) (*SDL_GL_GetProcAddress)((char*)x)
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#if defined(_DEBUG)
#define DEBUGGING
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#if defined(IOS)||defined(WEBASM)
int LIB3D_GL_VERSION_EXPOSANT=1;
#else
int LIB3D_GL_VERSION_EXPOSANT=0;
#endif
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)
#if defined(API3D_DIRECT3D12)
#define MAX_VBQUADS 1024
#else
#define MAX_VBQUADS 512
#endif
#else
#if defined(GLESFULL)||defined(WINDOWS_PHONE)
#define MAX_VBQUADS 512
#else
#define MAX_VBQUADS 1024
#endif
#endif

#if defined(API3D_DIRECT3D12)
#define NB_LINE_MAX 128
#else
#define NB_LINE_MAX 512
#endif
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
	
comments,adds:

 
 

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */
//#define API3D_SWAP_FLAGS D3DSWAPEFFECT_COPY_VSYNC
#define API3D_SWAP_FLAGS D3DSWAPEFFECT_FLIP
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int TILE_LIGHTMAPS				=	128;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "params.h"

#include "maths.h"
#include "objects3d.h"
#include "3d_api_base.h"
#include "vertexbuffercontainer.h"
#include <math.h>

#include <stdio.h>
#include "../data/png.h"
#include "edges.h"

#ifdef IOS
#ifndef API3D_METAL
extern GLint defaultFBO;
#endif
#endif

#ifdef WEBASM
extern GLint defaultFBO;
#endif

#ifdef WIN32
void DELAY_MS(int ms)
{
	Sleep(ms);
}
#endif

#ifdef API3D_DIRECT3D12
#include "../dx12/descriptorHeap.hpp"

DescriptorHeapHandle zeroid;

#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Vertex shaders etc. for use in DrawVertexBuffer

	SHADER SCRIPTS
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#ifdef API3D_DIRECT3D
	#include "shaders_dx8_enviro.h"
	#include "shaders_dx8_multitexture.h"
	#include "shaders_dx8_bumpmapping.h"
	#include "shaders_dx8_shadowvolume.h" 
	#include "shaders_dx8_carmackshadowvolume.h"
#endif

#ifdef API3D_DIRECT3D9
	#include "shaders_dx9_enviro.h"
	#include "shaders_dx9_multitexture.h"
	#include "shaders_dx9_bumpmapping.h"
	#include "shaders_dx9_shadowvolume.h"
	#include "shaders_dx9_carmackshadowvolume.h"
#endif

#ifdef API3D_DIRECT3D10
	#include "shaders_dx10_gl20.h"
#endif

#ifdef API3D_DIRECT3D11
	#include "shaders_dx10_gl20.h"
	#include "matrix.hpp"
#endif

#ifdef API3D_DIRECT3D12
	#include "shaders_dx10_gl20.h"
	#include "matrix.hpp"
#endif

#ifdef API3D_OPENGL20
	#include "shaders_dx10_gl20.h"
#endif

#ifdef API3D_METAL
	#include "shaders_dx10_gl20.h"
	#include "matrix.hpp"
#endif

/////////////////////////////////////////////////////////////////////////////////
int Exposantde2(int x)
{
    int val=1;
    while (x>val) val*=2;
    return val;
}
/////////////////////////////////////////////////////////////////////////////////

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

functions:

	METAL Funcs

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#ifdef API3D_METAL
void	MTLSetTexture(int index,int nt);
void	MTLSetupRenderToTexture(int nt,int w,int h);
void	MTLSetCull(int param);
void	MTLSetZBufferStencil(int set,int param);
void	MTLCreateBuffer(CVertexBuffer *buf);
void	MTLUpdateIndexBuffer(CVertexBuffer *buf);
void	MTLUpdateVertexBuffer(CVertexBuffer *buf);
void	MTLFreeBuffer(CVertexBuffer *buf);
int		MTLSetProgramVertexBuffer(CVertexBuffer *buf);
void	MTLFreeProgramVertexBuffer(CVertexBuffer *buf);
void	MTLSetRenderTarget(int set);
bool	MTLBegin();
void	MTLEnd();
void	MTLFlipDoubleBuffer();
int		MTLAddTexture(void *tex,int w,int h);
int		MTLGetScreenX();
int		MTLGetScreenY();
void    MTLClearVideoAndZbuffer(float r,float g,float b);
void    MTLClearVideoAndZbuffer(float r,float g,float b,float a);
void	MTLSetScissor(float x1,float y1,float x2,float y2);
void	MTLSetViewport(float x1,float y1,float x2,float y2);
void	MTLFillMode(int tag);
void    MTLColorMask(bool r,bool g,bool b,bool a);
/////////////////////////////////////////////////////////////////////////////////
char *  MTLGetRawScreen();
char *  MTLGetRawSecondary(int ns);
char *  MTLGetRawSecondaryFast(int ns);
/////////////////////////////////////////////////////////////////////////////////
void	MTLFreeTexture(int n);
void	MTLUpdateTexture(int id,int x,int y,int sizex,int sizey,char *ptr);
int		MTLAddTextureMipMap(void *tex,int w,int h,int levels);
void	MTLCleanRenderToTexture(int nt);
void	MTLClearStencil();
void	MTLClearZBuffer();
void	MTLZBias(int value);
void    MTLSetAlgo(int shd);
void    MTLFlush();
/////////////////////////////////////////////////////////////////////////////////
void	MTLDrawPrimitives(CVertexBuffer *vb,CVertexBuffer *eff);
void	MTLDrawPrimitivesLines(CVertexBuffer *vb,CVertexBuffer *eff);
void	MTLDrawPrimitivesRangePass(int pass,CVertexBuffer *vb,int vstart,int vend,int istart,int iend,CVertexBuffer *eff);
void    MTLDrawPrimitivesRangePassStrip(int pass,CVertexBuffer *vb,int vstart,int vend,int istart,int iend,CVertexBuffer *eff);
//void    MTLDrawPrimitivesPoints(CVertexBuffer *vb,CVertexBuffer *eff);
/////////////////////////////////////////////////////////////////////////////////
void	MTLSetAlphaBlending(bool enable,int op1,int op2);
/////////////////////////////////////////////////////////////////////////////////
int     C3DAPIBASE_ZBUFFER_TEST_STENCIL=0;
extern  int MTL_primary_x,MTL_primary_y;
/////////////////////////////////////////////////////////////////////////////////

#define	METAL_ZERO						1
#define	METAL_ONE						2

#define	METAL_SRC_ALPHA					3
#define	METAL_ONE_MINUS_SRC_ALPHA		4

#define	METAL_SRC_COLOR					5
#define	METAL_ONE_MINUS_SRC_COLOR		6

#define	METAL_DST_ALPHA					7
#define	METAL_ONE_MINUS_DST_ALPHA		8

#define	METAL_DST_COLOR					9
#define	METAL_ONE_MINUS_DST_COLOR		10
/////////////////////////////////////////////////////////////////////////////////
#endif

/////////////////////////////////////////////////////////////////////////////////
#ifdef API3D_DIRECT3D12
/////////////////////////////////////////////////////////////////////////////////
#define blendStateDesc GlobalPipelineDesc.BlendState
#define depthStencilDesc GlobalPipelineDesc.DepthStencilState
#define rasterDesc GlobalPipelineDesc.RasterizerState
/////////////////////////////////////////////////////////////////////////////////
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

functions:

	FPS renderer

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#if defined(LINUX)||defined(ANDROID)

#include <time.h>

double LIB3Dtime1;
double LIB3Dtime2;
float LIB3Dafdt=1.0f;

double __ms()
{
	struct timespec res;
	clock_gettime(CLOCK_REALTIME, &res);
    return 1000.0 * res.tv_sec + (double) res.tv_nsec / 1e6;
}

void TimeInitFPS()
{
	LIB3Dtime1=__ms();
	LIB3Dafdt=1.0f;
}

float TimeGetFPS()
{
	LIB3Dtime2=__ms();
	float dt=LIB3Dtime2-LIB3Dtime1;
	float fdt=dt;
	LIB3Dtime1=LIB3Dtime2;
	LIB3Dafdt=fdt;
	return LIB3Dafdt;
}

#else
#if defined(WIN32)||defined(WINDOWS_PHONE)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
LARGE_INTEGER FPSTemps1, FPSTemps2;
LARGE_INTEGER FPSfreq;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TimeInitFPS()
{
	QueryPerformanceFrequency(&FPSfreq);
	QueryPerformanceCounter(&FPSTemps1);
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float TimeGetFPS()
{
	float dt;
	LONGLONG dT;
	QueryPerformanceCounter(&FPSTemps2);
	dT = FPSTemps2.QuadPart - FPSTemps1.QuadPart;
	dt = (float)(1000 * dT) / FPSfreq.QuadPart;
	FPSTemps1 = FPSTemps2;

	return dt;
}
#else

#if defined(WEBASM)||defined(API3D_SDL2)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

uint32_t FPSTemps1;
uint32_t FPSTemps2;


void TimeInitFPS()
{
    FPSTemps1=SDL_GetTicks();
}

float TimeGetFPS()
{
    FPSTemps2=SDL_GetTicks();
    float dt=((float)(FPSTemps2-FPSTemps1))/16.66667f;
    FPSTemps1=FPSTemps2;
    return dt;
}
#else

#ifndef ANDROID

#include <mach/mach.h>
#include <mach/mach_time.h>

double getLIB3DTime( )
{
	double timeConvert = 0.0;
	if ( timeConvert == 0.0 )
	{
		mach_timebase_info_data_t timeBase;
		(void)mach_timebase_info( &timeBase );
		timeConvert = timeBase.numer / timeBase.denom / 1000000000.0;
	}
	return (double)mach_absolute_time( ) * timeConvert;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double lib3d_prevdt=0.0;
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TimeInitFPS()
{
    lib3d_prevdt=getLIB3DTime();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
float TimeGetFPS()
{
    double actualdt=getLIB3DTime();
    float dt=(actualdt-lib3d_prevdt)*1000.0;
    lib3d_prevdt=actualdt;
    return dt;
}

#endif
#endif
#endif
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function:

Log to text file "lib3d_log.txt"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */
bool LIB3Dfirst = true;

#ifdef ANDROID
char *logfilelib3D="/sdcard/Download/lib3d_log.txt";
#else
#ifdef IOS
char *logfilelib3D="Documents/lib3d_log.txt";
void putstr(char *str);
#else
char *logfilelib3D="lib3d_log.txt";
#endif
#endif

#ifdef WINDOWS_PHONE
void dbg(char *s);
#endif


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LIB3DLog(char *str)
{
#ifdef API3D_SDL2
	printf("%s\n",str);
#else
#ifdef WINDOWS_PHONE
	dbg(str);
#else
#ifdef IOS
//    putstr(str);
#else
#if defined(API3D_METAL)||defined(WEBASM)
#if defined(WEBASM)
    emscripten_log(EM_LOG_NO_PATHS,str);
#else
    printf("%s\n",str);
#endif
#else
#ifdef CONSL
#ifdef WIN32
	char ss[512];
	sprintf(ss,"%s\n",str);
	OutputDebugStringA(ss);
#else
	printf("%s\n",str);
#endif
#else
	FILE *f;
	if (LIB3Dfirst)
	{
		f=fopen(logfilelib3D,"w");
		if(f!=NULL) {
			fprintf(f,"%s\n",str);
			fclose(f);
		}
	}
	else
	{
		f=fopen(logfilelib3D,"a");
		if(f!=NULL) {
			fprintf(f,"%s\n",str);
			fclose(f);
		}
	}
	LIB3Dfirst=false;
#endif
#endif
#endif
#endif
#endif
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LIB3DLog(char *str,CVector u)
{
    char ss[1024];
    sprintf(ss,"%s:%f,%f,%f",str,u.x,u.y,u.z);
    LIB3DLog(ss);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LIB3DLog(char *str,int n)
{
    char ss[1024];
    sprintf(ss,"%s:%d",str,n);
    LIB3DLog(ss);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define LOG(str) { if (LOGING) LIB3DLog(str); }
#define LOGV(str,param) { if (LOGING) LIB3DLog(str,param); }
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef WIN32
inline DWORD F2DW( FLOAT f ) { return *((DWORD*)&f); }
#endif
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool G_Multitexture=false;
bool G_Dot3=false;
bool G_PS=false;
bool G_PS2X=false;
bool G_BumpEnvMap=false;
bool G_VertexProgram=false;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool G_VertexProgram_ShadowVolume=false;
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char s_error[2048];
extern char dither[5][2][2];
extern char * CreateMipMap(char * ptrtex,int tile,int rgba);
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "statement.hpp"
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)


#if defined(GLES)||defined(GLES20)
#if defined(ANDROID)&&!defined(UNSIGNEDSHORTINDICES)
unsigned int LIB3D_TYPE_INDEX=GL_UNSIGNED_INT;
#else
unsigned int LIB3D_TYPE_INDEX=GL_UNSIGNED_SHORT;
#define SHORTY
#endif
#else
unsigned int LIB3D_TYPE_INDEX=GL_UNSIGNED_INT;
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef API3D_OPENGL20
void C3DAPIBASE::setPO(CMatrix *m,float w,float h)
{

	m->a[0][0] = 2.0f/w;
	m->a[1][0] = 0.0f;
	m->a[2][0] = 0.0f;
	m->a[3][0] = 0.0f;

	m->a[0][1] = 0.0f;

    if (SelectedRenderTarget>=0) m->a[1][1] = 2.0f/h;
	else m->a[1][1] = -2.0f/h;

	m->a[2][1] = 0.0f;
	m->a[3][1] = 0.0f;

	m->a[0][2] = 0.0f;
	m->a[1][2] = 0.0f;
	m->a[2][2] = 2.0f;
	m->a[3][2] = -1.0f;

	m->a[0][3] = 0.0f;
	m->a[1][3] = 0.0f;
	m->a[2][3] = 0.0f;
	m->a[3][3] = 1.0f;
}
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Check OpenGL extension strings	

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

bool CheckExtension(char *extName, const char *extString)
{
    char *p = (char *)extString;
    char *end;
    int extNameLen;

    extNameLen = strlen(extName);
    end = p + strlen(p);

    while (p < end) {
	int n = strcspn(p, " ");
	if ((extNameLen == n) && (strncmp(extName, p, n) == 0)) {
	    return true;
	}
	p += (n + 1);
    }
    return false;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Textures power of 2	

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#if defined(LINUX)
/////////////////////////////////////////////////////////////////
void GLVersionForTexturesSize()
{
	LIB3D_GL_VERSION_EXPOSANT=0;
	if (!CheckExtension("ARB_texture_non_power_of_two",(char*)glGetString(GL_EXTENSIONS))) LIB3D_GL_VERSION_EXPOSANT=1;
}
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  vars:

		openGL functions pointers/wrapper


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#ifdef __APPLE__
#define NOGETPROC
#endif

#if defined(GLES)||defined(GLES20)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define glActiveTextureARB glActiveTexture
#define glClientActiveTextureARB glClientActiveTexture

#define glBindBufferARB	glBindBuffer
#define glBufferDataARB glBufferData
#define glDeleteBuffersARB	glDeleteBuffers
#define glGenBuffersARB	glGenBuffers
#define glBufferSubDataARB	glBufferSubData

#define	GL_ELEMENT_ARRAY_BUFFER_ARB GL_ELEMENT_ARRAY_BUFFER
#define	GL_ARRAY_BUFFER_ARB GL_ARRAY_BUFFER

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef GLES
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//																												GLES11
#define GL_TEXTURE0_ARB GL_TEXTURE0
#define GL_TEXTURE1_ARB GL_TEXTURE1
#define GL_COMBINE_ARB GL_COMBINE
#define GL_SOURCE0_RGB_ARB GL_SRC0_RGB
#define GL_SOURCE1_RGB_ARB GL_SRC1_RGB
#define GL_OPERAND0_RGB_ARB GL_OPERAND0_RGB
#define GL_OPERAND1_RGB_ARB GL_OPERAND1_RGB
#define GL_SOURCE0_ALPHA_ARB GL_SRC0_ALPHA
#define GL_SOURCE1_ALPHA_ARB GL_SRC1_ALPHA
#define GL_OPERAND0_ALPHA_ARB GL_OPERAND0_ALPHA
#define GL_OPERAND1_ALPHA_ARB GL_OPERAND1_ALPHA
#define GL_COMBINE_RGB_ARB GL_COMBINE_RGB
#define GL_COMBINE_ALPHA_ARB GL_COMBINE_ALPHA
#define GL_PRIMARY_COLOR_ARB GL_PRIMARY_COLOR
#define GL_PREVIOUS_ARB GL_PREVIOUS

#define glGenRenderbuffers glGenRenderbuffersOES
#define glBindRenderbuffer glBindRenderbufferOES
#define glGenFramebuffers glGenFramebuffersOES
#define glBindFramebuffer glBindFramebufferOES
#define glGenRenderBuffers glGenRenderBuffersOES
#define glRenderbufferStorage glRenderbufferStorageOES
#define glFramebufferRenderbuffer glFramebufferRenderbufferOES
#define glFramebufferTexture2D glFramebufferTexture2DOES

#define glVertexAttribPointerARB glVertexAttribPointer
#define glEnableVertexAttribArrayARB glEnableVertexAttribArray
#define glDisableVertexAttribArrayARB glDisableVertexAttribArray

#else
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//																												GLES20
#define GL_TEXTURE0_ARB GL_TEXTURE0
#define GL_TEXTURE1_ARB GL_TEXTURE1
#define GL_TEXTURE2_ARB GL_TEXTURE2
#define GL_TEXTURE3_ARB GL_TEXTURE3

#define glBindAttribLocationARB glBindAttribLocation
#define glGetAttribLocationARB glGetAttribLocation
#define glCreateProgramObjectARB glCreateProgram
#define glCreateShaderObjectARB glCreateShader
#define glShaderSourceARB glShaderSource
#define glCompileShaderARB glCompileShader
#define glGetObjectParameterivARB glGetShaderiv
#define glAttachObjectARB glAttachShader
#define glGetInfoLogARB glGetShaderInfoLog
#define glLinkProgramARB glLinkProgram
#define glUseProgramObjectARB glUseProgram
#define glGetUniformLocationARB glGetUniformLocation
#define glDetachObjectARB glDetachShader
#define glDeleteObjectARB glDeleteShader
#define glGetProgramivARB glGetProgramiv
#define glValidateProgramARB glValidateProgram
#define GLcharARB GLchar
#define GL_OBJECT_COMPILE_STATUS_ARB GL_COMPILE_STATUS

#define glVertexAttribPointerARB glVertexAttribPointer
#define glEnableVertexAttribArrayARB glEnableVertexAttribArray
#define glDisableVertexAttribArrayARB glDisableVertexAttribArray
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif
#endif

#ifdef API3D_VR

#ifdef OCULUS

#define GL_TEXTURE0_ARB GL_TEXTURE0
#define GL_TEXTURE1_ARB GL_TEXTURE1
#define GL_COMBINE_ARB GL_COMBINE
#define GL_SOURCE0_RGB_ARB GL_SRC0_RGB
#define GL_SOURCE1_RGB_ARB GL_SRC1_RGB
#define GL_OPERAND0_RGB_ARB GL_OPERAND0_RGB
#define GL_OPERAND1_RGB_ARB GL_OPERAND1_RGB
#define GL_SOURCE0_ALPHA_ARB GL_SRC0_ALPHA
#define GL_SOURCE1_ALPHA_ARB GL_SRC1_ALPHA
#define GL_OPERAND0_ALPHA_ARB GL_OPERAND0_ALPHA
#define GL_OPERAND1_ALPHA_ARB GL_OPERAND1_ALPHA
#define GL_COMBINE_RGB_ARB GL_COMBINE_RGB
#define GL_COMBINE_ALPHA_ARB GL_COMBINE_ALPHA
#define GL_PRIMARY_COLOR_ARB GL_PRIMARY_COLOR
#define GL_PREVIOUS_ARB GL_PREVIOUS

#define glActiveTextureARB glActiveTexture
#define glClientActiveTextureARB glClientActiveTexture

#define glBindBufferARB	glBindBuffer
#define glBufferDataARB glBufferData
#define glDeleteBuffersARB	glDeleteBuffers
#define glGenBuffersARB	glGenBuffers
#define glBufferSubDataARB	glBufferSubData

#define	GL_ELEMENT_ARRAY_BUFFER_ARB GL_ELEMENT_ARRAY_BUFFER
#define	GL_ARRAY_BUFFER_ARB GL_ARRAY_BUFFER

#define GL_TEXTURE0_ARB GL_TEXTURE0
#define GL_TEXTURE1_ARB GL_TEXTURE1
#define GL_TEXTURE2_ARB GL_TEXTURE2
#define GL_TEXTURE3_ARB GL_TEXTURE3

#define glBindAttribLocationARB glBindAttribLocation
#define glGetAttribLocationARB glGetAttribLocation
#define glCreateProgramObjectARB glCreateProgram
#define glCreateShaderObjectARB glCreateShader
#define glShaderSourceARB glShaderSource
#define glCompileShaderARB glCompileShader
#define glGetObjectParameterivARB glGetShaderiv
#define glAttachObjectARB glAttachShader
#define glGetInfoLogARB glGetShaderInfoLog
#define glLinkProgramARB glLinkProgram
#define glUseProgramObjectARB glUseProgram
#define glGetUniformLocationARB glGetUniformLocation
#define glDetachObjectARB glDetachShader
#define glDeleteObjectARB glDeleteShader
#define glGetProgramivARB glGetProgramiv
#define glValidateProgramARB glValidateProgram
#define GLcharARB GLchar
#define GL_OBJECT_COMPILE_STATUS_ARB GL_COMPILE_STATUS

#define glVertexAttribPointerARB glVertexAttribPointer
#define glEnableVertexAttribArrayARB glEnableVertexAttribArray
#define glDisableVertexAttribArrayARB glDisableVertexAttribArray
#endif


#define NOGETPROC
#endif

#if defined(API3D_GL_PROTOTYPES)
#define GL_TEXTURE0_ARB GL_TEXTURE0
#define GL_TEXTURE1_ARB GL_TEXTURE1
#define GL_COMBINE_ARB GL_COMBINE
#define GL_SOURCE0_RGB_ARB GL_SRC0_RGB
#define GL_SOURCE1_RGB_ARB GL_SRC1_RGB
#define GL_OPERAND0_RGB_ARB GL_OPERAND0_RGB
#define GL_OPERAND1_RGB_ARB GL_OPERAND1_RGB
#define GL_SOURCE0_ALPHA_ARB GL_SRC0_ALPHA
#define GL_SOURCE1_ALPHA_ARB GL_SRC1_ALPHA
#define GL_OPERAND0_ALPHA_ARB GL_OPERAND0_ALPHA
#define GL_OPERAND1_ALPHA_ARB GL_OPERAND1_ALPHA
#define GL_COMBINE_RGB_ARB GL_COMBINE_RGB
#define GL_COMBINE_ALPHA_ARB GL_COMBINE_ALPHA
#define GL_PRIMARY_COLOR_ARB GL_PRIMARY_COLOR
#define GL_PREVIOUS_ARB GL_PREVIOUS

#define glActiveTextureARB glActiveTexture
#define glClientActiveTextureARB glClientActiveTexture

#define glBindBufferARB	glBindBuffer
#define glBufferDataARB glBufferData
#define glDeleteBuffersARB	glDeleteBuffers
#define glGenBuffersARB	glGenBuffers
#define glBufferSubDataARB	glBufferSubData

#define	GL_ELEMENT_ARRAY_BUFFER_ARB GL_ELEMENT_ARRAY_BUFFER
#define	GL_ARRAY_BUFFER_ARB GL_ARRAY_BUFFER

#define GL_TEXTURE0_ARB GL_TEXTURE0
#define GL_TEXTURE1_ARB GL_TEXTURE1
#define GL_TEXTURE2_ARB GL_TEXTURE2
#define GL_TEXTURE3_ARB GL_TEXTURE3

#define glBindAttribLocationARB glBindAttribLocation
#define glGetAttribLocationARB glGetAttribLocation
#define glCreateProgramObjectARB glCreateProgram
#define glCreateShaderObjectARB glCreateShader
#define glShaderSourceARB glShaderSource
#define glCompileShaderARB glCompileShader
#define glGetObjectParameterivARB glGetShaderiv
#define glAttachObjectARB glAttachShader
#define glGetInfoLogARB glGetShaderInfoLog
#define glLinkProgramARB glLinkProgram
#define glUseProgramObjectARB glUseProgram
#define glGetUniformLocationARB glGetUniformLocation
#define glDetachObjectARB glDetachShader
#define glDeleteObjectARB glDeleteShader
#define glGetProgramivARB glGetProgramiv
#define glValidateProgramARB glValidateProgram
#define GLcharARB GLchar
#define GL_OBJECT_COMPILE_STATUS_ARB GL_COMPILE_STATUS

#define glVertexAttribPointerARB glVertexAttribPointer
#define glEnableVertexAttribArrayARB glEnableVertexAttribArray
#define glDisableVertexAttribArrayARB glDisableVertexAttribArray
#define NOGETPROC
#endif


#if !defined( NOGETPROC)&&!defined(LINUX)&&!defined(GLES)&&!defined(GLES20)
#ifdef OPENGL_MULTITEXTURING
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PFNGLMULTITEXCOORD2FARBPROC				glMultiTexCoord2fARB			=	NULL;
PFNGLACTIVETEXTUREARBPROC				glActiveTextureARB				=	NULL;
PFNGLCLIENTACTIVETEXTUREARBPROC			glClientActiveTextureARB		=	NULL;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif

#ifdef OPENGL_VBO
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PFNGLBINDBUFFERARBPROC					glBindBufferARB					=	NULL;
PFNGLBUFFERDATAARBPROC					glBufferDataARB					=	NULL;
PFNGLDELETEBUFFERSARBPROC				glDeleteBuffersARB				=	NULL;
PFNGLGENBUFFERSARBPROC					glGenBuffersARB					=	NULL;
PFNGLBUFFERSUBDATAARBPROC				glBufferSubDataARB				=	NULL;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif

#ifdef OPENGL_GLSL
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PFNGLBINDATTRIBLOCATIONARBPROC			glBindAttribLocationARB			=	NULL;
PFNGLGETATTRIBLOCATIONARBPROC			glGetAttribLocationARB			=	NULL;
PFNGLCREATEPROGRAMOBJECTARBPROC			glCreateProgramObjectARB		=	NULL;
PFNGLCREATESHADEROBJECTARBPROC			glCreateShaderObjectARB			=	NULL;
PFNGLSHADERSOURCEARBPROC				glShaderSourceARB				=	NULL;
PFNGLCOMPILESHADERARBPROC				glCompileShaderARB				=	NULL;
PFNGLGETOBJECTPARAMETERIVARBPROC		glGetObjectParameterivARB		=	NULL;
PFNGLATTACHOBJECTARBPROC				glAttachObjectARB				=	NULL;
PFNGLGETINFOLOGARBPROC					glGetInfoLogARB					=	NULL;
PFNGLLINKPROGRAMARBPROC					glLinkProgramARB				=	NULL;
PFNGLUSEPROGRAMOBJECTARBPROC			glUseProgramObjectARB			=	NULL;
PFNGLGETUNIFORMLOCATIONARBPROC			glGetUniformLocationARB			=	NULL;
PFNGLDETACHOBJECTARBPROC				glDetachObjectARB				=	NULL;
PFNGLDELETEOBJECTARBPROC				glDeleteObjectARB				=	NULL;
PFNGLGETPROGRAMIVARBPROC				glGetProgramivARB				=	NULL;
PFNGLUNIFORM4FARBPROC					glUniform4f						=	NULL;
PFNGLUNIFORM4FVARBPROC					glUniform4fv					=	NULL;
PFNGLUNIFORMMATRIX4FVARBPROC			glUniformMatrix4fv				=	NULL;
PFNGLUNIFORM1IARBPROC					glUniform1i						=	NULL;
PFNGLVALIDATEPROGRAMARBPROC				glValidateProgramARB			=	NULL;
#ifndef OPENGL_VERTEXPROGRAMS
PFNGLVERTEXATTRIBPOINTERARBPROC			glVertexAttribPointerARB		=	NULL;
PFNGLENABLEVERTEXATTRIBARRAYARBPROC		glEnableVertexAttribArrayARB	=	NULL;
PFNGLDISABLEVERTEXATTRIBARRAYARBPROC	glDisableVertexAttribArrayARB	=	NULL;
#endif
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif

#ifdef OPENGL_VERTEXPROGRAMS
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PFNGLPROGRAMSTRINGARBPROC				glProgramStringARB				=	NULL;
PFNGLBINDPROGRAMARBPROC					glBindProgramARB				=	NULL;
PFNGLDELETEPROGRAMSARBPROC				glDeleteProgramsARB				=	NULL;
PFNGLGENPROGRAMSARBPROC					glGenProgramsARB				=	NULL;
PFNGLPROGRAMENVPARAMETER4FARBPROC		glProgramEnvParameter4fARB		=	NULL;
PFNGLPROGRAMLOCALPARAMETER4FARBPROC		glProgramLocalParameter4fARB	=	NULL;
PFNGLISPROGRAMARBPROC					glIsProgramARB					=	NULL;
PFNGLVERTEXATTRIBPOINTERARBPROC			glVertexAttribPointerARB		=	NULL;
PFNGLENABLEVERTEXATTRIBARRAYARBPROC		glEnableVertexAttribArrayARB	=	NULL;
PFNGLDISABLEVERTEXATTRIBARRAYARBPROC	glDisableVertexAttribArrayARB	=	NULL;
PFNGLGETPROGRAMSTRINGARBPROC			glGetProgramStringARB			=	NULL;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif

#ifdef OPENGL_PBUFFERS
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PFNWGLCHOOSEPIXELFORMATARBPROC			wglChoosePixelFormatARB			=	NULL;
PFNWGLCREATEPBUFFERARBPROC				wglCreatePbufferARB				=	NULL;
PFNWGLDESTROYPBUFFERARBPROC				wglDestroyPbufferARB			=	NULL;
PFNWGLGETPBUFFERDCARBPROC				wglGetPbufferDCARB				=	NULL;
PFNWGLRELEASEPBUFFERDCARBPROC			wglReleasePbufferDCARB			=	NULL;
PFNWGLQUERYPBUFFERARBPROC				wglQueryPbufferARB				=	NULL;
PFNWGLBINDTEXIMAGEARBPROC				wglBindTexImageARB				=	NULL;
PFNWGLRELEASETEXIMAGEARBPROC			wglReleaseTexImageARB			=	NULL;
PFNWGLGETEXTENSIONSSTRINGARBPROC		wglGetExtensionsStringARB		=	NULL;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#else
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
PFNGLGENRENDERBUFFERSPROC				glGenRenderbuffers				=	NULL;
PFNGLDELETERENDERBUFFERSPROC			glDeleteRenderbuffers			=	NULL;
PFNGLBINDRENDERBUFFERPROC				glBindRenderbuffer				=	NULL;
PFNGLGENFRAMEBUFFERSPROC				glGenFramebuffers				=	NULL;
PFNGLDELETEFRAMEBUFFERSPROC				glDeleteFramebuffers			=	NULL;
PFNGLBINDFRAMEBUFFERPROC                glBindFramebuffer               =   NULL;
PFNGLBLITFRAMEBUFFERPROC                glBlitFramebuffer               =   NULL;
PFNGLGENRENDERBUFFERSPROC				glGenRenderBuffers				=	NULL;
PFNGLRENDERBUFFERSTORAGEPROC			glRenderbufferStorage			=	NULL;
PFNGLFRAMEBUFFERRENDERBUFFERPROC		glFramebufferRenderbuffer		=	NULL;
PFNGLFRAMEBUFFERTEXTURE2DPROC			glFramebufferTexture2D			=	NULL;
PFNGLDRAWBUFFERSPROC					glDrawBuffers					=	NULL;

PFNGLSTENCILOPSEPARATEPROC				glStencilOpSeparate				=	NULL;
PFNGLSTENCILFUNCSEPARATEPROC			glStencilFuncSeparate			=	NULL;
PFNGLSTENCILMASKSEPARATEPROC			glStencilMaskSeparate			=	NULL;
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif
#endif
/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  functions:

		Basic secondary buffering functions


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */
#ifdef OPENGL_PBUFFERS
bool C3DAPIBASE::pbufferInit(int n)
{
	if (pbufferInitialized[n]) pbufferDestroy(n);

	int attr[] =
	{
		WGL_SUPPORT_OPENGL_ARB,	GL_TRUE,
		WGL_DRAW_TO_PBUFFER_ARB, GL_TRUE,
		WGL_BIND_TO_TEXTURE_RGB_ARB, GL_TRUE,
		WGL_RED_BITS_ARB, 8,
		WGL_GREEN_BITS_ARB,	8,
		WGL_BLUE_BITS_ARB, 8,
		WGL_DEPTH_BITS_ARB,	24,
		WGL_STENCIL_BITS_ARB, 8,
		WGL_DOUBLE_BUFFER_ARB, FALSE,
		0
	};
	
	unsigned int count = 0;
	int			 pixelFormat;

	wglChoosePixelFormatARB(hGLDC, (const int*)attr, NULL, 1, &pixelFormat, &count);
   
	if(count == 0) return false;

	int pAttrib[] =
	{
		WGL_TEXTURE_FORMAT_ARB,	WGL_TEXTURE_RGB_ARB,
		WGL_TEXTURE_TARGET_ARB,	WGL_TEXTURE_2D_ARB,
		WGL_MIPMAP_TEXTURE_ARB, 0,
		0
	};

	hPBuffer[n] = wglCreatePbufferARB(hGLDC, pixelFormat, tile_secondarysurfaces[n],tile_secondarysurfaces[n], pAttrib);
	
	if(!hPBuffer[n]) return false;

	hPBufferDC[n] = wglGetPbufferDCARB(hPBuffer[n]);

	if(!hPBufferDC[n]) return false;

	hPBufferRC[n] = wglCreateContext(hPBufferDC[n]);

	if(!hPBufferRC[n]) return false;

	wglMakeCurrent(hGLDC,hGLRC);

	glEnable(GL_TEXTURE_2D);
	glGenTextures(1,&pbufferTextureID[n]);
	glBindTexture(GL_TEXTURE_2D, pbufferTextureID[n]);
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP_TO_EDGE);

	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	pbufferInitialized[n]=true;

	return true;	
}

void C3DAPIBASE::pbufferEnable(int n)
{
	if (!(pbufferInitialized[n])) return;
	if ((n>=0)&&(n<10))
	{
		wglMakeCurrent(hPBufferDC[n],hPBufferRC[n]);
		
		glDrawBuffer(GL_FRONT);
		glReadBuffer(GL_FRONT);

		glViewport(0,0,tile_secondarysurfaces[n],tile_secondarysurfaces[n]);
	}
}

void C3DAPIBASE::pbufferDisable(int n)
{
	wglMakeCurrent(hGLDC,hGLRC);
	glDrawBuffer(GL_BACK);
	glReadBuffer(GL_BACK);
	glViewport(0,0,SCREEN_X,SCREEN_Y);
//	glBindTexture(GL_TEXTURE_2D, pbufferTextureID[n]);
//	wglBindTexImageARB(hPBuffer[n],WGL_FRONT_LEFT_ARB);
}

void C3DAPIBASE::pbufferBind(int n)
{
	glBindTexture(GL_TEXTURE_2D, pbufferTextureID[n]);
	wglBindTexImageARB(hPBuffer[n],WGL_FRONT_LEFT_ARB);
}

void C3DAPIBASE::pbufferRelease(int n)
{
	glBindTexture(GL_TEXTURE_2D, pbufferTextureID[n]);
	wglReleaseTexImageARB(hPBuffer[n],WGL_FRONT_LEFT_ARB);
}

void C3DAPIBASE::pbufferDestroy(int n)
{
	wglReleaseTexImageARB(hPBuffer[n],WGL_FRONT_LEFT_ARB);
	wglDestroyPbufferARB(hPBuffer[n]);
	pbufferInitialized[n]=false;
}

#endif
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		check if a file exist

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

int FichierExistant(char * str)
{
	FILE * f;

	f=fopen(str,"rb");
	if (f==NULL)
	{
		// le fichier n'existe pas
		return 0;
	}
	else 
	{
		fclose(f);
		return 1;
	}
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Fonctions openGL
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Fonctions direct3D

	Multi device support

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------

#endif

C3DAPIBASE *			TheClass3DAPI=NULL;

#ifdef API3D_DIRECT3D

bool					HardwareVertexProcessing=false;
//------------------------------------------------------------------------------------------------ DIRECT3D ----------




/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		
		Global function for devices

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

LPDIRECT3DDEVICE8       D3DDevicePrincipal=NULL; 

void SetDEVICE(LPDIRECT3DDEVICE8 Device)
{
	if (D3DDevicePrincipal==NULL)
		D3DDevicePrincipal=Device;
}

#endif

#ifdef API3D_DIRECT3D9

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
bool					HardwareVertexProcessing=false;

LPDIRECT3DDEVICE9       D3DDevicePrincipal=NULL; 

void SetDEVICE(LPDIRECT3DDEVICE9 Device)
{
	if (D3DDevicePrincipal==NULL) D3DDevicePrincipal=Device;
}

#endif


#ifdef API3D_DIRECT3D10

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
bool					HardwareVertexProcessing=false;

#ifdef API3D_VERSION_DX10_1
ID3D10Device1*	       D3DDevicePrincipal=NULL; 

void SetDEVICE(ID3D10Device1* Device)
{
	if (D3DDevicePrincipal==NULL) D3DDevicePrincipal=Device;
}

#else

ID3D10Device*	       D3DDevicePrincipal=NULL; 

void SetDEVICE(ID3D10Device* Device)
{
	if (D3DDevicePrincipal==NULL) D3DDevicePrincipal=Device;
}

#endif
#endif


#ifdef API3D_DIRECT3D11

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
bool					HardwareVertexProcessing=false;

#ifndef WINDOWS_PHONE
ID3D11Device*	       D3DDevicePrincipal=NULL; 
ID3D11DeviceContext*   D3DDeviceContextPrincipal=NULL; 

void SetDEVICE(ID3D11Device* Device,ID3D11DeviceContext *DeviceContext)
{
	if (D3DDevicePrincipal==NULL) D3DDevicePrincipal=Device;
	if (D3DDeviceContextPrincipal==NULL) D3DDeviceContextPrincipal=DeviceContext;
}
#else
ID3D11Device2*	       D3DDevicePrincipal=NULL; 
ID3D11DeviceContext2*   D3DDeviceContextPrincipal=NULL; 

void SetDEVICE(ID3D11Device2* Device,ID3D11DeviceContext2 *DeviceContext)
{
	if (D3DDevicePrincipal==NULL) D3DDevicePrincipal=Device;
	if (D3DDeviceContextPrincipal==NULL) D3DDeviceContextPrincipal=DeviceContext;
}
#endif
#endif

#ifdef API3D_DIRECT3D12
bool					HardwareVertexProcessing=false;

ID3D12Device *			D3DDevicePrincipal=NULL;
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


  function:

	Call to change video mode in SDL
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::DeInitVideo()
{

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	//SDL_FreeSurface(screen);
	FreeAllTextures();
#ifdef OPENGL_PBUFFERS
	if (SecondarySurface)
		for (int n=0;n<nSecondaries;n++) pbufferDestroy(n);
#endif


	if (vp_stencilshadow)
	{
#if !defined(GLES)&&!defined(GLES20)


	glDetachObjectARB(glslprogram_sv,vert_shader_sv);
	glDeleteObjectARB(vert_shader_sv);
	glDeleteObjectARB(glslprogram_sv);


#endif
		vp_stencilshadow=0;
	}

	VertexBufferContainer.Release();

#endif

#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -------------
#endif

#ifdef API3D_DIRECT3D

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#endif

#ifdef API3D_DIRECT3D9

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#endif

#ifdef API3D_DIRECT3D10

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#endif

#ifdef API3D_DIRECT3D11

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#endif


#ifdef API3D_DIRECT3D12

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#ifndef BIGRESOURCE
	for (int s=0;s<1024;s++)
	{
		ID3D12Resource **pres;
		DescriptorHeapHandle *pid;

		for (int n=0;n<D3D_NBUFFERS;n++)
		{
			pres=ConstantBuffers[n][s].GetFirst();
			while (pres)
			{
				(*pres)->Release();
				pres=ConstantBuffers[n][s].DeleteAndGetNext();
			}

			pid=ConstantBuffersId[n][s].GetFirst();
			while (pid)
			{
				heap->FreeHeapHandle(*pid);
				pid=ConstantBuffersId[n][s].DeleteAndGetNext();
			}
		
			ConstantBuffersPtr[n][s].Free();
		}
	}
#endif

#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Free resources
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */
void C3DAPIBASE::FreeVideo()
{

	MiscFree();

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#ifdef API3D_DIRECT3D12
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
    
    FreePipelinesandSignatures();
    
	VertexBufferContainer.Release(device);
	VertexBufferContainer.Free(device);

	if (SecondarySurface)
	{
		for (int n=0;n<nSecondaries;n++) cleanRenderTexture(n);
	}

#else
#ifdef API3D_DIRECT3D11
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	VertexBufferContainer.Release(device);
	VertexBufferContainer.Free(device);

	if (SecondarySurface)
	{
		for (int n=0;n<nSecondaries;n++)
		{
			renderTargetTexture[n]->Release();
			renderSndTargetView[n]->Release();
			shaderResourceView[n]->Release();
			shaderResourceViewDepth[n]->Release();
			renderDepthStencilBuffer[n]->Release();
			renderDepthStencilView[n]->Release();
		}
	}

#ifndef WINDOWS_PHONE
	depthStencilBuffer->Release();
	renderTargetView->Release();
	depthStencilView->Release();
	swapChain->Release();

	devicecontext->Release();
	device->Release();
#endif
#else
#ifdef API3D_DIRECT3D10
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	VertexBufferContainer.Release(device);
	VertexBufferContainer.Free(device);

	if (SecondarySurface)
	{
		for (int n=0;n<nSecondaries;n++)
		{
			renderTargetTexture[n]->Release();
			renderSndTargetView[n]->Release();
			shaderResourceView[n]->Release();
			shaderResourceViewDepth[n]->Release();
			renderDepthStencilBuffer[n]->Release();
			renderDepthStencilView[n]->Release();
		}
	}

	depthStencilBuffer->Release();
	renderTargetView->Release();
	depthStencilView->Release();
	swapChain->Release();

	device->Release();
#else

	VertexBufferContainer.Release(D3DDevice);
	VertexBufferContainer.Free(D3DDevice);

	if (ENV_VSH_activated)
	{
		Effect_ENV_VSH->Release();
		Effect_ENV2_VSH->Release();
	}

	if (MULTI00) MULTI00->Release();
	if (MULTI10) MULTI10->Release();
	if (MULTI01) MULTI01->Release();
	if (MULTI11) MULTI11->Release();
	if (SHDVOLUME) SHDVOLUME->Release();
	if (SHDVOLUMEm) SHDVOLUMEm->Release();
	if (SHDVOLUME_CR1) SHDVOLUME_CR1->Release();
	if (SHDVOLUME_CR2) SHDVOLUME_CR2->Release();
	if (SHDVOLUME_CR1m) SHDVOLUME_CR1m->Release();
	if (SHDVOLUME_CR2m) SHDVOLUME_CR2m->Release();
	if (SHDVOLUMEc) SHDVOLUMEc->Release();
	if (SHDVOLUMEmc) SHDVOLUMEmc->Release();
	if (SHDVOLUMEn) SHDVOLUMEn->Release();
	if (SHDVOLUMEcn) SHDVOLUMEcn->Release();

	if (BML) BML->Release();
	if (BMLD) BMLD->Release();
	if (BMLa) BMLa->Release();

	Effect_ENV_VSH=NULL;
	Effect_ENV2_VSH=NULL;
	ENV_VSH_activated=false;
	MULTI00=NULL;
	MULTI10=NULL;
	MULTI01=NULL;
	MULTI11=NULL;
	SHDVOLUME=NULL;
	SHDVOLUMEm=NULL;
	SHDVOLUMEn=NULL;
	SHDVOLUMEcn=NULL;
	SHDVOLUMEc=NULL;
	SHDVOLUMEmc=NULL;
	SHDVOLUME_CR1=NULL;
	SHDVOLUME_CR2=NULL;
	SHDVOLUME_CR1m=NULL;
	SHDVOLUME_CR2m=NULL;
	BML=NULL;
	BMLD=NULL;
	BMLa=NULL;
#endif
#endif
#endif
#else

	VertexBufferContainer.Release();

#endif

	ReleaseLightmaps();
	FreeAllTextures();

#ifdef API3D_DIRECT3D12
    HandleContainer.Reset();
#endif
	
#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	#ifndef _DEFINES_OPENGL_NO_SDL_INIT_
		if (screen) SDL_FreeSurface(screen);
		screen=NULL;
	#endif
	#ifdef OPENGL_PBUFFEERS
		if (SecondarySurface)
		{
			for (int n=0;n<nSecondaries;n++) pbufferDestroy(n);
		}
	#endif
#endif

#ifdef API3D_DIRECT3D
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DVB_XYZCOLORTEX->Release();
	D3DVB_XYZCOLOR->Release();

	if (SurfaceBack) SurfaceBack->Release();
	SurfaceBack=NULL;
	if (SecondarySurface)
	{
		for (int n=0;n<nSecondaries;n++)
		{
			if (D3DTextureSecondary[n]) D3DTextureSecondary[n]->Release();
			if (D3DSecondary[n]) D3DSecondary[n]->Release();
			if (D3DSecondaryZbuffer[n]) D3DSecondaryZbuffer[n]->Release();
			D3DTextureSecondary[n]=NULL;
			D3DSecondary[n]=NULL;
			D3DSecondaryZbuffer[n]=NULL;
		}
	}
	if (D3DDevice) D3DDevice->Release();
	if (D3D) D3D->Release();
	D3DDevice=NULL;
	D3D=NULL;
	SETTINGS_ADAPTER=-1;
#endif

#ifdef API3D_DIRECT3D9
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DVB_XYZCOLORTEX->Release();
	D3DVB_XYZCOLOR->Release();

	if (SurfaceBack) SurfaceBack->Release();
	SurfaceBack=NULL;

	if (SecondarySurface)
	{
		for (int n=0;n<nSecondaries;n++)
		{
			if (D3DTextureSecondary[n]) D3DTextureSecondary[n]->Release();
			if (D3DSecondary[n]) D3DSecondary[n]->Release();
			if (D3DSecondaryZbuffer[n]) D3DSecondaryZbuffer[n]->Release();
			D3DTextureSecondary[n]=NULL;
			D3DSecondary[n]=NULL;
			D3DSecondaryZbuffer[n]=NULL;
		}
	}

	if (D3DDevice) D3DDevice->Release();
	if (D3D) D3D->Release();
	D3DDevice=NULL;
	D3D=NULL;
	SETTINGS_ADAPTER=-1;
#endif
}

#if (!defined(GLES)&&!defined(GLES20))||defined(GLESFULL)
/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Screenshots PNG TGA
	Thumbnails
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#ifdef API3D_DIRECT3D11
void GetWinAppBackBufferPtr();
extern ID3D11Texture2D* backBufferTempFromWindowsStoreApp;
#endif

void C3DAPIBASE::SaveThumbnailPNG(char * name)
{
#if defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ METAL -------------

	// TODO

#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	int r,g,b;
	int x,y;
	struct IMAGE_DATAS im;
	int n1,n2;
    unsigned char * bits;
    unsigned char * lines;

    
    bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*4);
    lines=(unsigned char *) malloc(SCREEN_X*4);
    
    glPixelStorei(GL_UNPACK_ALIGNMENT,0);

#ifndef GLESFULL
    glPixelStorei(GL_UNPACK_ROW_LENGTH,0);
    glPixelStorei(GL_UNPACK_SKIP_ROWS,0);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS,0);
#endif

    for (n2=0;n2<SCREEN_Y;n2++)
    {
        glReadPixels(0,n2,SCREEN_X,1,GL_RGB,GL_UNSIGNED_BYTE,lines);
        
        for (n1=0;n1<SCREEN_X;n1++)
        {
            bits[(n1+(SCREEN_Y-1-n2)*SCREEN_X)*4+0]=lines[n1*3+0];
            bits[(n1+(SCREEN_Y-1-n2)*SCREEN_X)*4+1]=lines[n1*3+1];
            bits[(n1+(SCREEN_Y-1-n2)*SCREEN_X)*4+2]=lines[n1*3+2];
        }
    }
    
    free(lines);

    im.Alpha=0;
    im.Grayscale=0;
    im.X=256;
    im.Y=256;
    im.ptrImageDATAS=(char*) malloc(256*256*4);
    
    for (n1=0;n1<256;n1++)
        for (n2=0;n2<256;n2++)
        {
            x=(SCREEN_X*n1)/256;
            y=(SCREEN_Y*n2)/256;
            
            r=bits[4*(x+SCREEN_X*y)+0]&255;
            g=bits[4*(x+SCREEN_X*y)+1]&255;
            b=bits[4*(x+SCREEN_X*y)+2]&255;
            
            im.ptrImageDATAS[4*(n1+256*n2)+0]=r;
            im.ptrImageDATAS[4*(n1+256*n2)+1]=g;
            im.ptrImageDATAS[4*(n1+256*n2)+2]=b;
        }
    
    
    QUICKSAVE_PNG(name,&im,FILTER_SUB);
    
    free(im.ptrImageDATAS);
    free(bits);
    
    return;

#endif
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#ifdef API3D_DIRECT3D12
	// TODO
#else
#ifdef API3D_DIRECT3D11
	unsigned char * bits,*bits2;
	int x,y;
	int n,n1,n2;
	struct IMAGE_DATAS im;

	bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
	bits2=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*4 + 4);

	int r,g,b,adr;
	unsigned char * ptr;	

	int pitch;
	D3D11_MAPPED_SUBRESOURCE mappedTex;

	ID3D11Texture2D *BackBufferStaging=NULL;

#ifdef WINDOWS_STORE
	GetWinAppBackBufferPtr();
	backBufferPtr=backBufferTempFromWindowsStoreApp;
#endif

	D3D11_TEXTURE2D_DESC StagingDesc;
	backBufferPtr->GetDesc(&StagingDesc);
	StagingDesc.Usage = D3D11_USAGE_STAGING;
	StagingDesc.BindFlags = 0;
	StagingDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	StagingDesc.MiscFlags = 0;
	device->CreateTexture2D(&StagingDesc, NULL, &BackBufferStaging);
  
	devicecontext->OMSetRenderTargets( 0, NULL, NULL );   
	devicecontext->CopyResource(BackBufferStaging, backBufferPtr);
	
	devicecontext->OMSetRenderTargets(1, &renderTargetView, depthStencilView);

	unsigned int subresource = D3D11CalcSubresource(0,0,0);
	devicecontext->Map(BackBufferStaging,subresource, D3D11_MAP_READ, 0, &mappedTex );
	ptr = (unsigned char*)mappedTex.pData;
	pitch = mappedTex.RowPitch;

	adr=0;

	for (n2=0;n2<SCREEN_Y;n2++)
	{
		n=n2*pitch;
		for (n1=0;n1<SCREEN_X;n1++)
		{
			r=ptr[n+0]&255;
			g=ptr[n+1]&255;
			b=ptr[n+2]&255;
			n+=4;

			bits[adr+0]=r;
			bits[adr+1]=g;
			bits[adr+2]=b;
			adr+=3;
		}
	}

	devicecontext->Unmap(BackBufferStaging, 0 );
	BackBufferStaging->Release();

#ifdef WINDOWS_STORE
	backBufferPtr->Release();
#endif

	unsigned char byteskip;
	short int shortskip;

	unsigned char imagetype;
	int colormode;
	unsigned char bitdepth;
	short int w,h;
	
	imagetype=2;
	bitdepth=24;
	colormode=3;
	byteskip=0;
	shortskip=0;
	w=SCREEN_X;
	h=SCREEN_Y;

	for (n1=0;n1<SCREEN_X;n1++)
	{
		for (n2=0;n2<SCREEN_Y;n2++)
		{
			bits2[(n1+(n2)*SCREEN_X)*4+0]=bits[(n1+n2*SCREEN_X)*3+0]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+1]=bits[(n1+n2*SCREEN_X)*3+1]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+2]=bits[(n1+n2*SCREEN_X)*3+2]&255;
		}
	}

	im.X=256;
	im.Y=256;
	im.ptrImageDATAS=(char*) malloc(256*256*4);

	for (n1=0;n1<256;n1++)
		for (n2=0;n2<256;n2++)
		{
			x=(SCREEN_X*n1)/256;
			y=(SCREEN_Y*n2)/256;

			r=bits2[4*(x+SCREEN_X*y)+0]&255;
			g=bits2[4*(x+SCREEN_X*y)+1]&255;
			b=bits2[4*(x+SCREEN_X*y)+2]&255;

			im.ptrImageDATAS[4*(n1+256*n2)+0]=b;
			im.ptrImageDATAS[4*(n1+256*n2)+1]=g;
			im.ptrImageDATAS[4*(n1+256*n2)+2]=r;
		}


	QUICKSAVE_PNG(name,&im,FILTER_SUB);

	free(bits);
	free(bits2);

	free(im.ptrImageDATAS);

#else
#ifdef API3D_DIRECT3D10
	unsigned char * bits,*bits2;
	int x,y;
	int n,n1,n2;
	struct IMAGE_DATAS im;

	bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
	bits2=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*4 + 4);

	int r,g,b,adr;
	unsigned char * ptr;	

	int pitch;
	D3D10_MAPPED_TEXTURE2D mappedTex;

	ID3D10Texture2D *BackBufferStaging;

	D3D10_TEXTURE2D_DESC StagingDesc;
	backBufferPtr->GetDesc(&StagingDesc);
	StagingDesc.Usage = D3D10_USAGE_STAGING;
	StagingDesc.BindFlags = 0;
	StagingDesc.CPUAccessFlags = D3D10_CPU_ACCESS_READ;
	StagingDesc.MiscFlags = 0;
	device->CreateTexture2D(&StagingDesc, NULL, &BackBufferStaging);
  
	device->OMSetRenderTargets( 0, NULL, NULL );   
	device->CopyResource(BackBufferStaging, backBufferPtr);
	
	device->OMSetRenderTargets(1, &renderTargetView, depthStencilView);

	BackBufferStaging->Map( 0, D3D10_MAP_READ, 0, &mappedTex );
	ptr = (unsigned char*)mappedTex.pData;
	pitch = mappedTex.RowPitch;

	adr=0;

	for (n2=0;n2<SCREEN_Y;n2++)
	{
		n=n2*pitch;
		for (n1=0;n1<SCREEN_X;n1++)
		{
			r=ptr[n+0]&255;
			g=ptr[n+1]&255;
			b=ptr[n+2]&255;
			n+=4;

			bits[adr+0]=r;
			bits[adr+1]=g;
			bits[adr+2]=b;
			adr+=3;
		}
	}

	BackBufferStaging->Unmap( 0 );
	BackBufferStaging->Release();

	unsigned char byteskip;
	short int shortskip;

	unsigned char imagetype;
	int colormode;
	unsigned char bitdepth;
	short int w,h;
	
	imagetype=2;
	bitdepth=24;
	colormode=3;
	byteskip=0;
	shortskip=0;
	w=SCREEN_X;
	h=SCREEN_Y;

	for (n1=0;n1<SCREEN_X;n1++)
	{
		for (n2=0;n2<SCREEN_Y;n2++)
		{
			bits2[(n1+(n2)*SCREEN_X)*4+0]=bits[(n1+n2*SCREEN_X)*3+0]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+1]=bits[(n1+n2*SCREEN_X)*3+1]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+2]=bits[(n1+n2*SCREEN_X)*3+2]&255;
		}
	}

	im.X=256;
	im.Y=256;
	im.ptrImageDATAS=(char*) malloc(256*256*4);

	for (n1=0;n1<256;n1++)
		for (n2=0;n2<256;n2++)
		{
			x=(SCREEN_X*n1)/256;
			y=(SCREEN_Y*n2)/256;

			r=bits2[4*(x+SCREEN_X*y)+0]&255;
			g=bits2[4*(x+SCREEN_X*y)+1]&255;
			b=bits2[4*(x+SCREEN_X*y)+2]&255;

			im.ptrImageDATAS[4*(n1+256*n2)+0]=r;
			im.ptrImageDATAS[4*(n1+256*n2)+1]=g;
			im.ptrImageDATAS[4*(n1+256*n2)+2]=b;
		}


	QUICKSAVE_PNG(name,&im,FILTER_SUB);

	free(bits);
	free(bits2);

	free(im.ptrImageDATAS);

#else
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	unsigned char * bits,*bits2;
	int x,y;
	int n,n1,n2;
	struct IMAGE_DATAS im;

	bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
	bits2=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*4 + 4);

	unsigned char c1,c2;
	WORD ww;
	int r,g,b,adr;
	unsigned char * ptr;
	D3DLOCKED_RECT Locked;


	SurfaceBack->LockRect(&Locked,NULL,D3DLOCK_READONLY);
	ptr=(unsigned char *)Locked.pBits;
	adr=0;

	for (n2=0;n2<SCREEN_Y;n2++)
	{
		n=n2*Locked.Pitch;
		for (n1=0;n1<SCREEN_X;n1++)
		{
			switch (SurfaceBackFormat)
			{
			case D3DFMT_R5G6B5:
				
				c1=ptr[n+0];
				c2=ptr[n+1];
				
				ww=c1+(c2<<8);
				r=((ww>>11)&31)<<3;
				g=((ww>>5)&63)<<2;
				b=(ww&31)<<3;
				
				n+=2;

				break;
			case D3DFMT_X1R5G5B5:
				c1=ptr[n+0];
				c2=ptr[n+1];
				ww=c1+(c2<<8);

				r=((ww>>10)&31)<<3;
				g=((ww>>5)&31)<<3;
				b=(ww&31)<<3;
				n+=2;

				break;
			case D3DFMT_X8R8G8B8:
				b=ptr[n+0]&255;
				g=ptr[n+1]&255;
				r=ptr[n+2]&255;
				n+=4;
				break;
			};

			bits[adr+0]=r;
			bits[adr+1]=g;
			bits[adr+2]=b;
			adr+=3;

		}
	}

	SurfaceBack->UnlockRect();

	unsigned char byteskip;
	short int shortskip;

	unsigned char imagetype;
	int colormode;
	unsigned char bitdepth;
	short int w,h;
	
	imagetype=2;
	bitdepth=24;
	colormode=3;
	byteskip=0;
	shortskip=0;
	w=SCREEN_X;
	h=SCREEN_Y;

	for (n1=0;n1<SCREEN_X;n1++)
	{
		for (n2=0;n2<SCREEN_Y;n2++)
		{
			bits2[(n1+(n2)*SCREEN_X)*4+0]=bits[(n1+n2*SCREEN_X)*3+0]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+1]=bits[(n1+n2*SCREEN_X)*3+1]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+2]=bits[(n1+n2*SCREEN_X)*3+2]&255;
		}
	}

	im.X=256;
	im.Y=256;
	im.ptrImageDATAS=(char*) malloc(256*256*4);

	for (n1=0;n1<256;n1++)
		for (n2=0;n2<256;n2++)
		{
			x=(SCREEN_X*n1)/256;
			y=(SCREEN_Y*n2)/256;

			r=bits2[4*(x+SCREEN_X*y)+0]&255;
			g=bits2[4*(x+SCREEN_X*y)+1]&255;
			b=bits2[4*(x+SCREEN_X*y)+2]&255;

			im.ptrImageDATAS[4*(n1+256*n2)+0]=r;
			im.ptrImageDATAS[4*(n1+256*n2)+1]=g;
			im.ptrImageDATAS[4*(n1+256*n2)+2]=b;
		}


	QUICKSAVE_PNG(name,&im,FILTER_SUB);

	free(bits);
	free(bits2);

	free(im.ptrImageDATAS);
#endif
#endif
#endif
#endif
}


void C3DAPIBASE::SaveScreenPNG(char * name)
{
#if defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ METAL -------------

	// TODO

#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	char str[512];
	int n,res;
	struct IMAGE_DATAS im;
	int n1,n2;

    unsigned char * bits;
    unsigned char * lines;    
    
    bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*4);
    lines=(unsigned char *) malloc(SCREEN_X*4);
    
    glPixelStorei(GL_UNPACK_ALIGNMENT,0);

#ifndef GLESFULL
    glPixelStorei(GL_UNPACK_ROW_LENGTH,0);
    glPixelStorei(GL_UNPACK_SKIP_ROWS,0);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS,0);
#endif

    for (n2=0;n2<SCREEN_Y;n2++)
    {
        glReadPixels(0,n2,SCREEN_X,1,GL_RGB,GL_UNSIGNED_BYTE,lines);
        
        for (n1=0;n1<SCREEN_X;n1++)
        {
            bits[(n1+(SCREEN_Y-1-n2)*SCREEN_X)*4+0]=lines[n1*3+0];
            bits[(n1+(SCREEN_Y-1-n2)*SCREEN_X)*4+1]=lines[n1*3+1];
            bits[(n1+(SCREEN_Y-1-n2)*SCREEN_X)*4+2]=lines[n1*3+2];
        }
    }
    
    free(lines);
    
    im.Alpha=0;
    im.Grayscale=0;
    im.X=SCREEN_X;
    im.Y=SCREEN_Y;
    im.ptrImageDATAS=(char*)bits;
    
    n=0;
    res=0;
    
    while (res==0)
    {
        if (n<10) sprintf(str,"%s000%d.png",name,n);
        else
            if (n<100) sprintf(str,"%s00%d.png",name,n);
            else
                if (n<1000) sprintf(str,"%s0%d.png",name,n);
                else
                    sprintf(str,"%s%d.png",name,n);
        
        if (FichierExistant(str)==0) res=1;
        n++;
    }
    
    QUICKSAVE_PNG(str,&im,FILTER_SUB);
    
    free(bits);

    return;

#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#ifdef API3D_DIRECT3D12
	// TODO
#else
#ifdef API3D_DIRECT3D11
	char str[512];
	unsigned char * bits,*bits2;

	int n,n1,n2,res;
	struct IMAGE_DATAS im;

	bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
	bits2=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*4 + 4);

	int r,g,b,adr;
	unsigned char * ptr;
	int pitch;
	D3D11_MAPPED_SUBRESOURCE mappedTex;

	ID3D11Texture2D *BackBufferStaging;

	D3D11_TEXTURE2D_DESC StagingDesc;
	backBufferPtr->GetDesc(&StagingDesc);
	StagingDesc.Usage = D3D11_USAGE_STAGING;
	StagingDesc.BindFlags = 0;
	StagingDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	StagingDesc.MiscFlags = 0;
	device->CreateTexture2D(&StagingDesc, NULL, &BackBufferStaging);
  
	devicecontext->OMSetRenderTargets( 0, NULL, NULL );   
	devicecontext->CopyResource(BackBufferStaging, backBufferPtr);
	
	devicecontext->OMSetRenderTargets(1, &renderTargetView, depthStencilView);

	devicecontext->Map(BackBufferStaging, 0, D3D11_MAP_READ, 0, &mappedTex );
	ptr = (unsigned char*)mappedTex.pData;
	pitch = mappedTex.RowPitch;

	adr=0;

	for (n2=0;n2<SCREEN_Y;n2++)
	{
		n=n2*pitch;
		for (n1=0;n1<SCREEN_X;n1++)
		{
			r=ptr[n+0]&255;
			g=ptr[n+1]&255;
			b=ptr[n+2]&255;
			n+=4;

			bits[adr+0]=r;
			bits[adr+1]=g;
			bits[adr+2]=b;
			adr+=3;
		}
	}

	devicecontext->Unmap(BackBufferStaging, 0 );
	BackBufferStaging->Release();

	unsigned char byteskip;
	short int shortskip;

	unsigned char imagetype;
	int colormode;
	unsigned char bitdepth;
	short int w,h;
	


	imagetype=2;
	bitdepth=24;
	colormode=3;
	byteskip=0;
	shortskip=0;
	w=SCREEN_X;
	h=SCREEN_Y;

	for (n1=0;n1<SCREEN_X;n1++)
	{
		for (n2=0;n2<SCREEN_Y;n2++)
		{
			bits2[(n1+(n2)*SCREEN_X)*4+0]=bits[(n1+n2*SCREEN_X)*3+0]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+1]=bits[(n1+n2*SCREEN_X)*3+1]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+2]=bits[(n1+n2*SCREEN_X)*3+2]&255;
		}
	}

	im.X=SCREEN_X;
	im.Y=SCREEN_Y;
	im.ptrImageDATAS=(char*)bits2;

	n=0;
	res=0;

	while (res==0)
	{
		if (n<10) sprintf(str,"%s000%d.png",name,n);
		else
		if (n<100) sprintf(str,"%s00%d.png",name,n);
		else
		if (n<1000) sprintf(str,"%s0%d.png",name,n);
		else
			sprintf(str,"%s%d.png",name,n);

		if (FichierExistant(str)==0) res=1;
		n++;
	}

	QUICKSAVE_PNG(str,&im,FILTER_SUB);

	free(bits);
	free(bits2);
#else
#ifdef API3D_DIRECT3D10
	char str[512];
	unsigned char * bits,*bits2;

	int n,n1,n2,res;
	struct IMAGE_DATAS im;

	bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
	bits2=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*4 + 4);

	int r,g,b,adr;
	unsigned char * ptr;
	int pitch;
	D3D10_MAPPED_TEXTURE2D mappedTex;

	ID3D10Texture2D *BackBufferStaging;

	D3D10_TEXTURE2D_DESC StagingDesc;
	backBufferPtr->GetDesc(&StagingDesc);
	StagingDesc.Usage = D3D10_USAGE_STAGING;
	StagingDesc.BindFlags = 0;
	StagingDesc.CPUAccessFlags = D3D10_CPU_ACCESS_READ;
	StagingDesc.MiscFlags = 0;
	device->CreateTexture2D(&StagingDesc, NULL, &BackBufferStaging);
  
	device->OMSetRenderTargets( 0, NULL, NULL );
	device->CopyResource(BackBufferStaging, backBufferPtr);
	
	device->OMSetRenderTargets(1, &renderTargetView, depthStencilView);

	BackBufferStaging->Map( 0, D3D10_MAP_READ, 0, &mappedTex );
	ptr = (unsigned char*)mappedTex.pData;
	pitch = mappedTex.RowPitch;

	adr=0;

	for (n2=0;n2<SCREEN_Y;n2++)
	{
		n=n2*pitch;
		for (n1=0;n1<SCREEN_X;n1++)
		{
			r=ptr[n+0]&255;
			g=ptr[n+1]&255;
			b=ptr[n+2]&255;
			n+=4;

			bits[adr+0]=r;
			bits[adr+1]=g;
			bits[adr+2]=b;
			adr+=3;
		}
	}

	BackBufferStaging->Unmap( 0 );
	BackBufferStaging->Release();

	unsigned char byteskip;
	short int shortskip;

	unsigned char imagetype;
	int colormode;
	unsigned char bitdepth;
	short int w,h;

	imagetype=2;
	bitdepth=24;
	colormode=3;
	byteskip=0;
	shortskip=0;
	w=SCREEN_X;
	h=SCREEN_Y;

	for (n1=0;n1<SCREEN_X;n1++)
	{
		for (n2=0;n2<SCREEN_Y;n2++)
		{
			bits2[(n1+(n2)*SCREEN_X)*4+0]=bits[(n1+n2*SCREEN_X)*3+0]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+1]=bits[(n1+n2*SCREEN_X)*3+1]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+2]=bits[(n1+n2*SCREEN_X)*3+2]&255;
		}
	}

	im.X=SCREEN_X;
	im.Y=SCREEN_Y;
	im.ptrImageDATAS=(char*)bits2;

	n=0;
	res=0;

	while (res==0)
	{
		if (n<10) sprintf(str,"%s000%d.png",name,n);
		else
		if (n<100) sprintf(str,"%s00%d.png",name,n);
		else
		if (n<1000) sprintf(str,"%s0%d.png",name,n);
		else
			sprintf(str,"%s%d.png",name,n);

		if (FichierExistant(str)==0) res=1;
		n++;
	}

	QUICKSAVE_PNG(str,&im,FILTER_SUB);

	free(bits);
	free(bits2);
	
#else

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	char str[512];
	unsigned char * bits,*bits2;

	int n,n1,n2,res;
	struct IMAGE_DATAS im;

	bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
	bits2=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*4 + 4);

	unsigned char c1,c2;
	WORD ww;
	int r,g,b,adr;
	unsigned char * ptr;
	D3DLOCKED_RECT Locked;

	SurfaceBack->LockRect(&Locked,NULL,D3DLOCK_READONLY);
	ptr=(unsigned char *)Locked.pBits;
	adr=0;

	for (n2=0;n2<SCREEN_Y;n2++)
	{
		n=n2*Locked.Pitch;
		for (n1=0;n1<SCREEN_X;n1++)
		{
			switch (SurfaceBackFormat)
			{
			case D3DFMT_R5G6B5:
				
				c1=ptr[n+0];
				c2=ptr[n+1];
				
				ww=c1+(c2<<8);
				r=((ww>>11)&31)<<3;
				g=((ww>>5)&63)<<2;
				b=(ww&31)<<3;
				
				n+=2;

				break;
			case D3DFMT_X1R5G5B5:
				c1=ptr[n+0];
				c2=ptr[n+1];
				ww=c1+(c2<<8);

				r=((ww>>10)&31)<<3;
				g=((ww>>5)&31)<<3;
				b=(ww&31)<<3;
				n+=2;

				break;
			case D3DFMT_X8R8G8B8:
				b=ptr[n+0]&255;
				g=ptr[n+1]&255;
				r=ptr[n+2]&255;
				n+=4;
				break;
			};

			bits[adr+0]=r;
			bits[adr+1]=g;
			bits[adr+2]=b;
			adr+=3;

		}
	}

	SurfaceBack->UnlockRect();

	unsigned char byteskip;
	short int shortskip;

	unsigned char imagetype;
	int colormode;
	unsigned char bitdepth;
	short int w,h;

	imagetype=2;
	bitdepth=24;
	colormode=3;
	byteskip=0;
	shortskip=0;
	w=SCREEN_X;
	h=SCREEN_Y;

	for (n1=0;n1<SCREEN_X;n1++)
	{
		for (n2=0;n2<SCREEN_Y;n2++)
		{
			bits2[(n1+(n2)*SCREEN_X)*4+0]=bits[(n1+n2*SCREEN_X)*3+0]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+1]=bits[(n1+n2*SCREEN_X)*3+1]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+2]=bits[(n1+n2*SCREEN_X)*3+2]&255;
		}
	}

	im.X=SCREEN_X;
	im.Y=SCREEN_Y;
	im.ptrImageDATAS=(char*)bits2;

	n=0;
	res=0;

	while (res==0)
	{
		if (n<10) sprintf(str,"%s000%d.png",name,n);
		else
		if (n<100) sprintf(str,"%s00%d.png",name,n);
		else
		if (n<1000) sprintf(str,"%s0%d.png",name,n);
		else
			sprintf(str,"%s%d.png",name,n);

		if (FichierExistant(str)==0) res=1;
		n++;
	}

	QUICKSAVE_PNG(str,&im,FILTER_SUB);

	free(bits);
	free(bits2);
#endif
#endif
#endif
#endif
}


void C3DAPIBASE::GetScreenRAW(struct IMAGE_DATAS *im)
{
#if defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ METAL -------------

//    im->X=SCREEN_X;
//    im->Y=SCREEN_Y;
    im->ptrImageDATAS=(char*)MTLGetRawScreen();
    im->X=MTL_primary_x;
    im->Y=MTL_primary_y;
    
    return;
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------		
	unsigned char * bits;
    unsigned char * lines;
	int n1,n2;

    bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*4);
    lines=(unsigned char *) malloc(SCREEN_X*4);
    
    glPixelStorei(GL_UNPACK_ALIGNMENT,0);

#ifndef GLESFULL
    glPixelStorei(GL_UNPACK_ROW_LENGTH,0);
    glPixelStorei(GL_UNPACK_SKIP_ROWS,0);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS,0);    
#endif

    for (n2=0;n2<SCREEN_Y;n2++)
    {
        glReadPixels(0,n2,SCREEN_X,1,GL_RGB,GL_UNSIGNED_BYTE,lines);

        for (n1=0;n1<SCREEN_X;n1++)
        {
            bits[(n1+(SCREEN_Y-1-n2)*SCREEN_X)*4+0]=lines[n1*3+0];
            bits[(n1+(SCREEN_Y-1-n2)*SCREEN_X)*4+1]=lines[n1*3+1];
            bits[(n1+(SCREEN_Y-1-n2)*SCREEN_X)*4+2]=lines[n1*3+2];
        }
    }
    
    free(lines);
    im->X=SCREEN_X;
    im->Y=SCREEN_Y;
    im->ptrImageDATAS=(char*)bits;

    return;
    
#endif
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#ifdef API3D_DIRECT3D12

	ID3D12Resource *pSource=renderTargets[oldframeIndex];
	ID3D12Resource *pStaging;

	if (commandList) CloseAndExecuteCommandList(commandList);
	commandList=NULL;

	ID3D12GraphicsCommandList* cmd;
	device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, nullptr, IID_PPV_ARGS(&cmd));

	ID3D12Fence* fnce;
	device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fnce));
	
	CD3DX12_HEAP_PROPERTIES defaultHeapProperties(D3D12_HEAP_TYPE_DEFAULT);
	CD3DX12_HEAP_PROPERTIES readBackHeapProperties(D3D12_HEAP_TYPE_READBACK);

	D3D12_RESOURCE_DESC desc=pSource->GetDesc();

	int width=(SCREEN_X+255)>>8;

	D3D12_RESOURCE_DESC bufferDesc = {};
        bufferDesc.DepthOrArraySize = 1;
        bufferDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
        bufferDesc.Flags = D3D12_RESOURCE_FLAG_NONE;
        bufferDesc.Format = DXGI_FORMAT_UNKNOWN;
        bufferDesc.Height = 1;
        bufferDesc.Width = 256* width * desc.Height * 4;
        bufferDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
        bufferDesc.MipLevels = 1;
        bufferDesc.SampleDesc.Count = 1;

	device->CreateCommittedResource(&readBackHeapProperties,D3D12_HEAP_FLAG_NONE,&bufferDesc,D3D12_RESOURCE_STATE_COPY_DEST, nullptr,IID_PPV_ARGS(&pStaging));


	cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(pSource, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_COPY_SOURCE));

	D3D12_PLACED_SUBRESOURCE_FOOTPRINT bufferFootprint = {};
	
	bufferFootprint.Footprint.Width = static_cast<UINT>(SCREEN_X);
	bufferFootprint.Footprint.Height = static_cast<UINT>(SCREEN_Y);
	bufferFootprint.Footprint.Depth = 1;
	
	bufferFootprint.Footprint.RowPitch = static_cast<UINT>(256*width*4);
//	bufferFootprint.Footprint.RowPitch = static_cast<UINT>(SCREEN_X*4);
	bufferFootprint.Footprint.Format = desc.Format;

	ID3D12Resource * copySource(pSource);

	CD3DX12_TEXTURE_COPY_LOCATION copyDest(pStaging, bufferFootprint);
	CD3DX12_TEXTURE_COPY_LOCATION copySrc(copySource, 0);

	CD3DX12_BOX box(0,0,SCREEN_X,SCREEN_Y);

	cmd->CopyTextureRegion(&copyDest, 0, 0, 0, &copySrc, &box);
	
	cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(pSource,D3D12_RESOURCE_STATE_COPY_SOURCE, D3D12_RESOURCE_STATE_COMMON));

	CloseAndExecuteCommandList(cmd);

	commandQueue->Signal(fnce,1);

	while (fnce->GetCompletedValue() < 1) {}

	im->X=SCREEN_X;
	im->Y=SCREEN_Y;
	im->Alpha=0;
	im->Grayscale=0;
	im->ptrImageDATAS=(char*)malloc(im->X*im->Y*4);

	CD3DX12_RANGE readRange(0, 0);
	char *pdata;
	pStaging->Map(0, &readRange, reinterpret_cast<void**>(&pdata));
	for (int y=0;y<im->Y;y++)
		memcpy(&im->ptrImageDATAS[im->X*y*4],&pdata[256*4*width*y], im->X*4);
	pStaging->Unmap(0, nullptr);

	pStaging->Release();
#else
#ifdef API3D_DIRECT3D11
	unsigned char * bits,*bits2;
	int n,n1,n2;	

	bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
	bits2=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*4 + 4);

	int r,g,b,adr;
	unsigned char * ptr;

	int pitch;
	D3D11_MAPPED_SUBRESOURCE mappedTex;

	ID3D11Texture2D *BackBufferStaging;

	D3D11_TEXTURE2D_DESC StagingDesc;
	backBufferPtr->GetDesc(&StagingDesc);
	StagingDesc.Usage = D3D11_USAGE_STAGING;
	StagingDesc.BindFlags = 0;
	StagingDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	StagingDesc.MiscFlags = 0;
	device->CreateTexture2D(&StagingDesc, NULL, &BackBufferStaging);
  
	devicecontext->OMSetRenderTargets( 0, NULL, NULL );   
	devicecontext->CopyResource(BackBufferStaging, backBufferPtr);
	
	devicecontext->OMSetRenderTargets(1, &renderTargetView, depthStencilView);

	devicecontext->Map( BackBufferStaging, 0, D3D11_MAP_READ, 0, &mappedTex );
	ptr = (unsigned char*)mappedTex.pData;
	pitch = mappedTex.RowPitch;

	adr=0;

	for (n2=0;n2<SCREEN_Y;n2++)
	{
		n=n2*pitch;
		for (n1=0;n1<SCREEN_X;n1++)
		{
			r=ptr[n+0]&255;
			g=ptr[n+1]&255;
			b=ptr[n+2]&255;
			n+=4;

			bits[adr+0]=r;
			bits[adr+1]=g;
			bits[adr+2]=b;
			adr+=3;
		}
	}

	devicecontext->Unmap( BackBufferStaging, 0 );
	BackBufferStaging->Release();

	for (n1=0;n1<SCREEN_X;n1++)
	{
		for (n2=0;n2<SCREEN_Y;n2++)
		{
			bits2[(n1+(n2)*SCREEN_X)*4+0]=bits[(n1+n2*SCREEN_X)*3+0]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+1]=bits[(n1+n2*SCREEN_X)*3+1]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+2]=bits[(n1+n2*SCREEN_X)*3+2]&255;
		}
	}

	im->X=SCREEN_X;
	im->Y=SCREEN_Y;
	im->ptrImageDATAS=(char*)bits2;

	free(bits);

#else
#ifdef API3D_DIRECT3D10
	unsigned char * bits,*bits2;

	int n,n1,n2;	

	bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
	bits2=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*4 + 4);

	int r,g,b,adr;
	unsigned char * ptr;

	
	int pitch;
	D3D10_MAPPED_TEXTURE2D mappedTex;

	ID3D10Texture2D *BackBufferStaging;

	D3D10_TEXTURE2D_DESC StagingDesc;
	backBufferPtr->GetDesc(&StagingDesc);
	StagingDesc.Usage = D3D10_USAGE_STAGING;
	StagingDesc.BindFlags = 0;
	StagingDesc.CPUAccessFlags = D3D10_CPU_ACCESS_READ;
	StagingDesc.MiscFlags = 0;
	device->CreateTexture2D(&StagingDesc, NULL, &BackBufferStaging);
  
	device->OMSetRenderTargets( 0, NULL, NULL );
	device->CopyResource(BackBufferStaging, backBufferPtr);
	
	device->OMSetRenderTargets(1, &renderTargetView, depthStencilView);

	BackBufferStaging->Map( 0, D3D10_MAP_READ, 0, &mappedTex );
	ptr = (unsigned char*)mappedTex.pData;
	pitch = mappedTex.RowPitch;

	adr=0;

	for (n2=0;n2<SCREEN_Y;n2++)
	{
		n=n2*pitch;
		for (n1=0;n1<SCREEN_X;n1++)
		{
			r=ptr[n+0]&255;
			g=ptr[n+1]&255;
			b=ptr[n+2]&255;
			n+=4;

			bits[adr+0]=r;
			bits[adr+1]=g;
			bits[adr+2]=b;
			adr+=3;
		}
	}

	BackBufferStaging->Unmap( 0 );
	BackBufferStaging->Release();

	for (n1=0;n1<SCREEN_X;n1++)
	{
		for (n2=0;n2<SCREEN_Y;n2++)
		{
			bits2[(n1+(n2)*SCREEN_X)*4+0]=bits[(n1+n2*SCREEN_X)*3+0]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+1]=bits[(n1+n2*SCREEN_X)*3+1]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+2]=bits[(n1+n2*SCREEN_X)*3+2]&255;
		}
	}

	im->X=SCREEN_X;
	im->Y=SCREEN_Y;
	im->ptrImageDATAS=(char*)bits2;

	free(bits);

#else

//------------------------------------------------------------------------------------------------ DIRECT3D ----------	
	unsigned char * bits,*bits2;

	int n,n1,n2;	

	bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
	bits2=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*4 + 4);

	unsigned char c1,c2;
	WORD ww;
	int r,g,b,adr;
	unsigned char * ptr;
	D3DLOCKED_RECT Locked;

	SurfaceBack->LockRect(&Locked,NULL,D3DLOCK_READONLY);
	ptr=(unsigned char *)Locked.pBits;
	adr=0;

	for (n2=0;n2<SCREEN_Y;n2++)
	{
		n=n2*Locked.Pitch;
		for (n1=0;n1<SCREEN_X;n1++)
		{
			switch (SurfaceBackFormat)
			{
			case D3DFMT_R5G6B5:
				c1=ptr[n+0];
				c2=ptr[n+1];
				ww=c1+(c2<<8);
				r=((ww>>11)&31)<<3;
				g=((ww>>5)&63)<<2;
				b=(ww&31)<<3;
				n+=2;
				break;

			case D3DFMT_X1R5G5B5:
				c1=ptr[n+0];
				c2=ptr[n+1];
				ww=c1+(c2<<8);
				r=((ww>>10)&31)<<3;
				g=((ww>>5)&31)<<3;
				b=(ww&31)<<3;
				n+=2;
				break;

			case D3DFMT_X8R8G8B8:
				b=ptr[n+0]&255;
				g=ptr[n+1]&255;
				r=ptr[n+2]&255;
				n+=4;
				break;

			case D3DFMT_A8R8G8B8:
				b=ptr[n+0]&255;
				g=ptr[n+1]&255;
				r=ptr[n+2]&255;
				n+=4;
				break;

			case D3DFMT_R8G8B8:
				b=ptr[n+0]&255;
				g=ptr[n+1]&255;
				r=ptr[n+2]&255;
				n+=3;
				break;
			};

			bits[adr+0]=r;
			bits[adr+1]=g;
			bits[adr+2]=b;
			adr+=3;
		}
	}

	SurfaceBack->UnlockRect();

	for (n1=0;n1<SCREEN_X;n1++)
	{
		for (n2=0;n2<SCREEN_Y;n2++)
		{
			bits2[(n1+(n2)*SCREEN_X)*4+0]=bits[(n1+n2*SCREEN_X)*3+0]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+1]=bits[(n1+n2*SCREEN_X)*3+1]&255;
			bits2[(n1+(n2)*SCREEN_X)*4+2]=bits[(n1+n2*SCREEN_X)*3+2]&255;
		}
	}

	im->X=SCREEN_X;
	im->Y=SCREEN_Y;
	im->ptrImageDATAS=(char*)bits2;

	free(bits);
#endif
#endif
#endif
#endif
}


void C3DAPIBASE::SaveScreenTGA(char * name)
{
#if defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ METAL -------------

	// TODO

#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)

    //------------------------------------------------------------------------------------------------ OPEN GL -----------
	char str[512];
	int n,res;
    int n1,n2;
	unsigned char * bits,*bits2;
	FILE * f;
    
    
    bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
    bits2=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
    
    unsigned char * lines=(unsigned char *) malloc(SCREEN_X*4);
    
    glPixelStorei(GL_UNPACK_ALIGNMENT,0);

#ifndef GLESFULL
    glPixelStorei(GL_UNPACK_ROW_LENGTH,0);
    glPixelStorei(GL_UNPACK_SKIP_ROWS,0);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS,0);
#endif

    for (n2=0;n2<SCREEN_Y;n2++)
    {
        glReadPixels(0,n2,SCREEN_X,1,GL_RGB,GL_UNSIGNED_BYTE,lines);
        
        for (n1=0;n1<SCREEN_X;n1++)
        {
            bits[(n1+n2*SCREEN_X)*3+0]=lines[n1*3+0];
            bits[(n1+n2*SCREEN_X)*3+1]=lines[n1*3+1];
            bits[(n1+n2*SCREEN_X)*3+2]=lines[n1*3+2];
        }
    }
    
    free(lines);

    unsigned char byteskip;
    short int shortskip;
    
    unsigned char imagetype;
    int colormode;
    //		unsigned char colorswap;
    unsigned char bitdepth;
    short int w,h;
    
    
    imagetype=2;
    bitdepth=24;
    colormode=3;
    byteskip=0;
    shortskip=0;
    w=SCREEN_X;
    h=SCREEN_Y;
    
    for (n1=0;n1<SCREEN_X;n1++)
    {
        for (n2=0;n2<SCREEN_Y;n2++)
        {
            bits2[(n1+n2*SCREEN_X)*3+0]=bits[(n1+n2*SCREEN_X)*3+2]&255;
            bits2[(n1+n2*SCREEN_X)*3+1]=bits[(n1+n2*SCREEN_X)*3+1]&255;
            bits2[(n1+n2*SCREEN_X)*3+2]=bits[(n1+n2*SCREEN_X)*3+0]&255;
        }
    }
    n=0;
    res=0;
    
    while (res==0)
    {
        if (n<10) sprintf(str,"%s000%d.tga",name,n);
        else
            if (n<100) sprintf(str,"%s00%d.tga",name,n);
            else
                if (n<1000) sprintf(str,"%s0%d.tga",name,n);
                else
                    sprintf(str,"%s%d.tga",name,n);
        
        if (FichierExistant(str)==0) res=1;
        n++;
    }
    
    f=fopen(str,"wb");
    if(f==NULL) {
        return;
    }
    fwrite(&byteskip,1,1,f);
    fwrite(&byteskip,1,1,f);
    
    fwrite(&imagetype,1,1,f);
    
    fwrite(&shortskip,2,1,f);
    fwrite(&shortskip,2,1,f);
    
    fwrite(&byteskip,1,1,f);
    
    fwrite(&shortskip,2,1,f);
    fwrite(&shortskip,2,1,f);
    
    
    fwrite(&w,2,1,f);
    fwrite(&h,2,1,f);
    
    fwrite(&bitdepth,1,1,f);
    
    fwrite(&byteskip,1,1,f);
    
    fwrite(bits2,1,w*h*3,f);
    
    fclose(f);
    
    free(bits);
    free(bits2);



#endif
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#ifdef API3D_DIRECT3D12
	// TODO
#else
#ifdef API3D_DIRECT3D11

	char str[512];
	unsigned char * bits,*bits2;
	FILE * f;
	int n,n1,n2,res;

	bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
	bits2=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);

	int r,g,b,adr;
	unsigned char * ptr;

	int pitch;
	D3D11_MAPPED_SUBRESOURCE mappedTex;

	ID3D11Texture2D *BackBufferStaging;

	D3D11_TEXTURE2D_DESC StagingDesc;
	backBufferPtr->GetDesc(&StagingDesc);
	StagingDesc.Usage = D3D11_USAGE_STAGING;
	StagingDesc.BindFlags = 0;
	StagingDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	StagingDesc.MiscFlags = 0;
	device->CreateTexture2D(&StagingDesc, NULL, &BackBufferStaging);
  
	devicecontext->OMSetRenderTargets( 0, NULL, NULL );   
	devicecontext->CopyResource(BackBufferStaging, backBufferPtr);
	
	devicecontext->OMSetRenderTargets(1, &renderTargetView, depthStencilView);

	devicecontext->Map( BackBufferStaging, 0, D3D11_MAP_READ, 0, &mappedTex );
	ptr = (unsigned char*)mappedTex.pData;
	pitch = mappedTex.RowPitch;

	adr=0;

	for (n2=0;n2<SCREEN_Y;n2++)
	{
		n=n2*pitch;
		for (n1=0;n1<SCREEN_X;n1++)
		{
			r=ptr[n+0]&255;
			g=ptr[n+1]&255;
			b=ptr[n+2]&255;
			n+=4;

			bits[adr+0]=r;
			bits[adr+1]=g;
			bits[adr+2]=b;
			adr+=3;
		}
	}

	devicecontext->Unmap( BackBufferStaging, 0 );
	BackBufferStaging->Release();

	unsigned char byteskip;
	short int shortskip;

	unsigned char imagetype;
	int colormode;
	unsigned char bitdepth;
	short int w,h;

	imagetype=2;
	bitdepth=24;
	colormode=3;
	byteskip=0;
	shortskip=0;
	w=SCREEN_X;
	h=SCREEN_Y;

	for (n1=0;n1<SCREEN_X;n1++)
	{
		for (n2=0;n2<SCREEN_Y;n2++)
		{
			bits2[(n1+(n2)*SCREEN_X)*3+0]=bits[(n1+n2*SCREEN_X)*3+2]&255;
			bits2[(n1+(n2)*SCREEN_X)*3+1]=bits[(n1+n2*SCREEN_X)*3+1]&255;
			bits2[(n1+(n2)*SCREEN_X)*3+2]=bits[(n1+n2*SCREEN_X)*3+0]&255;
		}
	}

	n=0;
	res=0;

	while (res==0)
	{
		if (n<10) sprintf(str,"%s000%d.tga",name,n);
		else
		if (n<100) sprintf(str,"%s00%d.tga",name,n);
		else
		if (n<1000) sprintf(str,"%s0%d.tga",name,n);
		else
			sprintf(str,"%s%d.tga",name,n);

		if (FichierExistant(str)==0) res=1;
		n++;
	}


	f=fopen(str,"wb");
	if(f==NULL) {
	  return;
	}

	fwrite(&byteskip,1,1,f);
	fwrite(&byteskip,1,1,f);

	fwrite(&imagetype,1,1,f);

	fwrite(&shortskip,2,1,f);
	fwrite(&shortskip,2,1,f);

	fwrite(&byteskip,1,1,f);

	fwrite(&shortskip,2,1,f);
	fwrite(&shortskip,2,1,f);

	
	fwrite(&w,2,1,f);
	fwrite(&h,2,1,f);

	fwrite(&bitdepth,1,1,f);

	fwrite(&byteskip,1,1,f);

	fwrite(bits2,1,w*h*3,f);

	fclose(f);

	free(bits);
	free(bits2);
#else
#ifdef API3D_DIRECT3D10

	char str[512];
	unsigned char * bits,*bits2;
	FILE * f;
	int n,n1,n2,res;

	bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
	bits2=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);

	int r,g,b,adr;
	unsigned char * ptr;

	int pitch;
	D3D10_MAPPED_TEXTURE2D mappedTex;

	ID3D10Texture2D *BackBufferStaging;

	D3D10_TEXTURE2D_DESC StagingDesc;
	backBufferPtr->GetDesc(&StagingDesc);
	StagingDesc.Usage = D3D10_USAGE_STAGING;
	StagingDesc.BindFlags = 0;
	StagingDesc.CPUAccessFlags = D3D10_CPU_ACCESS_READ;
	StagingDesc.MiscFlags = 0;
	device->CreateTexture2D(&StagingDesc, NULL, &BackBufferStaging);
  
	device->OMSetRenderTargets( 0, NULL, NULL );
	device->CopyResource(BackBufferStaging, backBufferPtr);
	
	device->OMSetRenderTargets(1, &renderTargetView, depthStencilView);

	BackBufferStaging->Map( 0, D3D10_MAP_READ, 0, &mappedTex );
	ptr = (unsigned char*)mappedTex.pData;
	pitch = mappedTex.RowPitch;

	adr=0;

	for (n2=0;n2<SCREEN_Y;n2++)
	{
		n=n2*pitch;
		for (n1=0;n1<SCREEN_X;n1++)
		{
			r=ptr[n+0]&255;
			g=ptr[n+1]&255;
			b=ptr[n+2]&255;
			n+=4;

			bits[adr+0]=r;
			bits[adr+1]=g;
			bits[adr+2]=b;
			adr+=3;
		}
	}

	BackBufferStaging->Unmap( 0 );
	BackBufferStaging->Release();

	unsigned char byteskip;
	short int shortskip;

	unsigned char imagetype;
	int colormode;
	unsigned char bitdepth;
	short int w,h;

	imagetype=2;
	bitdepth=24;
	colormode=3;
	byteskip=0;
	shortskip=0;
	w=SCREEN_X;
	h=SCREEN_Y;

	for (n1=0;n1<SCREEN_X;n1++)
	{
		for (n2=0;n2<SCREEN_Y;n2++)
		{
			bits2[(n1+(n2)*SCREEN_X)*3+0]=bits[(n1+n2*SCREEN_X)*3+2]&255;
			bits2[(n1+(n2)*SCREEN_X)*3+1]=bits[(n1+n2*SCREEN_X)*3+1]&255;
			bits2[(n1+(n2)*SCREEN_X)*3+2]=bits[(n1+n2*SCREEN_X)*3+0]&255;
		}
	}

	n=0;
	res=0;

	while (res==0)
	{
		if (n<10) sprintf(str,"%s000%d.tga",name,n);
		else
		if (n<100) sprintf(str,"%s00%d.tga",name,n);
		else
		if (n<1000) sprintf(str,"%s0%d.tga",name,n);
		else
			sprintf(str,"%s%d.tga",name,n);

		if (FichierExistant(str)==0) res=1;
		n++;
	}


	f=fopen(str,"wb");
	if(f==NULL) {
	  return;
	}

	fwrite(&byteskip,1,1,f);
	fwrite(&byteskip,1,1,f);

	fwrite(&imagetype,1,1,f);

	fwrite(&shortskip,2,1,f);
	fwrite(&shortskip,2,1,f);

	fwrite(&byteskip,1,1,f);

	fwrite(&shortskip,2,1,f);
	fwrite(&shortskip,2,1,f);

	
	fwrite(&w,2,1,f);
	fwrite(&h,2,1,f);

	fwrite(&bitdepth,1,1,f);

	fwrite(&byteskip,1,1,f);

	fwrite(bits2,1,w*h*3,f);

	fclose(f);

	free(bits);
	free(bits2);
#else

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	char str[512];
	unsigned char * bits,*bits2;
	FILE * f;
	int n,n1,n2,res;

	bits=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);
	bits2=(unsigned char *) malloc(SCREEN_X*SCREEN_Y*3 + 4);

	unsigned char c1,c2;
	WORD ww;
	int r,g,b,adr;
	unsigned char * ptr;
	D3DLOCKED_RECT Locked;


	SurfaceBack->LockRect(&Locked,NULL,D3DLOCK_READONLY);
	ptr=(unsigned char *)Locked.pBits;
	adr=0;

	for (n2=0;n2<SCREEN_Y;n2++)
	{
		n=n2*Locked.Pitch;
		for (n1=0;n1<SCREEN_X;n1++)
		{
			switch (SurfaceBackFormat)
			{
			case D3DFMT_R5G6B5:
				
				c1=ptr[n+0];
				c2=ptr[n+1];
				
				ww=c1+(c2<<8);
				r=((ww>>11)&31)<<3;
				g=((ww>>5)&63)<<2;
				b=(ww&31)<<3;
				
				n+=2;

				break;
			case D3DFMT_X1R5G5B5:
				c1=ptr[n+0];
				c2=ptr[n+1];
				ww=c1+(c2<<8);

				r=((ww>>10)&31)<<3;
				g=((ww>>5)&31)<<3;
				b=(ww&31)<<3;
				n+=2;

				break;
			case D3DFMT_X8R8G8B8:
				b=ptr[n+0]&255;
				g=ptr[n+1]&255;
				r=ptr[n+2]&255;
				n+=4;
				break;
			};

			bits[adr+0]=r;
			bits[adr+1]=g;
			bits[adr+2]=b;
			adr+=3;

		}
	}

	SurfaceBack->UnlockRect();

	unsigned char byteskip;
	short int shortskip;

	unsigned char imagetype;
	int colormode;
	unsigned char bitdepth;
	short int w,h;
	
	imagetype=2;
	bitdepth=24;
	colormode=3;
	byteskip=0;
	shortskip=0;
	w=SCREEN_X;
	h=SCREEN_Y;

	for (n1=0;n1<SCREEN_X;n1++)
	{
		for (n2=0;n2<SCREEN_Y;n2++)
		{
			bits2[(n1+(SCREEN_Y-1-n2)*SCREEN_X)*3+0]=bits[(n1+n2*SCREEN_X)*3+2]&255;
			bits2[(n1+(SCREEN_Y-1-n2)*SCREEN_X)*3+1]=bits[(n1+n2*SCREEN_X)*3+1]&255;
			bits2[(n1+(SCREEN_Y-1-n2)*SCREEN_X)*3+2]=bits[(n1+n2*SCREEN_X)*3+0]&255;
		}
	}

	n=0;
	res=0;

	while (res==0)
	{
		if (n<10) sprintf(str,"%s000%d.tga",name,n);
		else
		if (n<100) sprintf(str,"%s00%d.tga",name,n);
		else
		if (n<1000) sprintf(str,"%s0%d.tga",name,n);
		else
			sprintf(str,"%s%d.tga",name,n);

		if (FichierExistant(str)==0) res=1;
		n++;
	}


	f=fopen(str,"wb");
	if(f==NULL) {
	  return;
	}

	fwrite(&byteskip,1,1,f);
	fwrite(&byteskip,1,1,f);

	fwrite(&imagetype,1,1,f);

	fwrite(&shortskip,2,1,f);
	fwrite(&shortskip,2,1,f);

	fwrite(&byteskip,1,1,f);

	fwrite(&shortskip,2,1,f);
	fwrite(&shortskip,2,1,f);

	
	fwrite(&w,2,1,f);
	fwrite(&h,2,1,f);

	fwrite(&bitdepth,1,1,f);

	fwrite(&byteskip,1,1,f);

	fwrite(bits2,1,w*h*3,f);

	fclose(f);

	free(bits);
	free(bits2);
#endif
#endif
#endif
#endif
}
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
	
		void GetDataSecondary(int ns,unsigned char *bits,int *w,int *h)
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::GetDataSecondary(int ns,unsigned char **pbits,int *w,int *h)
{
#if defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ METAL -------------

    int n=ns-SECONDARY1;
    int x=tile_secondarysurfacesW[n];
    int y=tile_secondarysurfacesH[n];
    *pbits=(unsigned char *)MTLGetRawSecondary(n);
    *w=x;
    *h=y;

    return;
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)

    //------------------------------------------------------------------------------------------------ OPEN GL -----------
#if !defined(GLESFULL)&&!defined(GLES20)
	int n=ns-SECONDARY1;
	int x=tile_secondarysurfacesW[n];
	int y=tile_secondarysurfacesH[n];
	unsigned char * raw=(unsigned char *)malloc(x*y*4);
	glBindTexture(GL_TEXTURE_2D,renderedTexture[n]);
	glGetTexImage(GL_TEXTURE_2D,0,GL_RGBA,GL_UNSIGNED_BYTE,raw);
	*w=x;
	*h=y;
	*pbits=(unsigned char *)malloc(x*y*4);
    for (n=0;n<y;n++)
        memcpy(&(*pbits)[n*x*4],&raw[(y-1-n)*x*4],x*4);
    
    free(raw);
#else
    int n=ns-SECONDARY1;
    *w=tile_secondarysurfacesW[n];
    *h=tile_secondarysurfacesH[n];
    unsigned char * raw;
	int n1,n2;

	int srt=SelectedRenderTarget;

	SetParams(API3D_RENDERTARGET,ns);

    raw=(unsigned char *) malloc((*h)*(*w)*4);

    glPixelStorei(GL_UNPACK_ALIGNMENT,0);

    *pbits=(unsigned char *)malloc((*w)*(*h)*4);

    glReadPixels(0,0,(*w),(*h),GL_RGBA,GL_UNSIGNED_BYTE,raw);

    for (n=0;n<(*h);n++)
        memcpy(&(*pbits)[n*(*w)*4],&raw[((*h)-1-n)*(*w)*4],(*w)*4);

/*
    for (n2=0;n2<(*h);n2++)
    {
        glReadPixels(0,n2,(*w),1,GL_RGBA,GL_UNSIGNED_BYTE,raw);

        for (n1=0;n1<(*w);n1++)
        {
            (*pbits)[(n1+((*h)-1-n2)*(*w))*4+0]=raw[n1*4+0];
            (*pbits)[(n1+((*h)-1-n2)*(*w))*4+1]=raw[n1*4+1];
            (*pbits)[(n1+((*h)-1-n2)*(*w))*4+2]=raw[n1*4+2];
        }
    }
/**/
    free(raw);
    if (srt==-1) SetParams(API3D_RENDERTARGET,PRIMARY); else SetParams(API3D_RENDERTARGET,SelectedRenderTarget+SECONDARY1);
#endif

#endif
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#ifdef API3D_DIRECT3D12
	int n=ns-SECONDARY1;

	ID3D12Resource *pSource=renderTargetTexture[n];
	ID3D12Resource *pStaging;
	*w=tile_secondarysurfacesW[n];
	*h=tile_secondarysurfacesH[n];

	if (commandList) CloseAndExecuteCommandList(commandList);
	commandList=NULL;

	ID3D12GraphicsCommandList* cmd;
	device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, nullptr, IID_PPV_ARGS(&cmd));

	ID3D12Fence* fnce;
	device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fnce));

	CD3DX12_HEAP_PROPERTIES defaultHeapProperties(D3D12_HEAP_TYPE_DEFAULT);
	CD3DX12_HEAP_PROPERTIES readBackHeapProperties(D3D12_HEAP_TYPE_READBACK);

	D3D12_RESOURCE_DESC desc=pSource->GetDesc();

	D3D12_RESOURCE_DESC bufferDesc = {};
        bufferDesc.DepthOrArraySize = 1;
        bufferDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
        bufferDesc.Flags = D3D12_RESOURCE_FLAG_NONE;
        bufferDesc.Format = DXGI_FORMAT_UNKNOWN;
        bufferDesc.Height = 1;
        bufferDesc.Width = (*w) * desc.Height * 4;
        bufferDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
        bufferDesc.MipLevels = 1;
        bufferDesc.SampleDesc.Count = 1;

	device->CreateCommittedResource(&readBackHeapProperties,D3D12_HEAP_FLAG_NONE,&bufferDesc,D3D12_RESOURCE_STATE_COPY_DEST, nullptr,IID_PPV_ARGS(&pStaging));


	cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(pSource, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_COPY_SOURCE));

	D3D12_PLACED_SUBRESOURCE_FOOTPRINT bufferFootprint = {};
	
	bufferFootprint.Footprint.Width = static_cast<UINT>(*w);
	bufferFootprint.Footprint.Height = static_cast<UINT>(*h);
	bufferFootprint.Footprint.Depth = 1;
	bufferFootprint.Footprint.RowPitch = static_cast<UINT>((*w)*4);
	bufferFootprint.Footprint.Format = desc.Format;

	ID3D12Resource * copySource(pSource);

	CD3DX12_TEXTURE_COPY_LOCATION copyDest(pStaging, bufferFootprint);
	CD3DX12_TEXTURE_COPY_LOCATION copySrc(copySource, 0);

	CD3DX12_BOX box(0,0,*w,*h);

	cmd->CopyTextureRegion(&copyDest, 0, 0, 0, &copySrc, &box);

	cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(pSource,D3D12_RESOURCE_STATE_COPY_SOURCE, D3D12_RESOURCE_STATE_COMMON));

	CloseAndExecuteCommandList(cmd);

	commandQueue->Signal(fnce,1);

	while (fnce->GetCompletedValue() < 1) {}

	*pbits=(unsigned char*)malloc((*w)*(*h)*4);

	CD3DX12_RANGE readRange(0, 0);
	char *pdata;
	pStaging->Map(0, &readRange, reinterpret_cast<void**>(&pdata));
	memcpy(*pbits,pdata, (*w)*(*h)*4);
	pStaging->Unmap(0, nullptr);

	pStaging->Release();

#else
#ifdef API3D_DIRECT3D11

	int n=ns-SECONDARY1;
	int x=tile_secondarysurfacesW[n];
	int y=tile_secondarysurfacesH[n];
	unsigned char * raw=(unsigned char *)malloc(x*y*4);

	int n1,n2;
	int r,g,b,a,adr,pn;
	D3D11_MAPPED_SUBRESOURCE mappedTex;
	ID3D11Texture2D *staging;

	D3D11_TEXTURE2D_DESC StagingDesc;
	renderTargetTexture[n]->GetDesc(&StagingDesc);
	StagingDesc.Usage = D3D11_USAGE_STAGING;
	StagingDesc.BindFlags = 0;
	StagingDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
	StagingDesc.MiscFlags = 0;
	device->CreateTexture2D(&StagingDesc, NULL, &staging);

	devicecontext->CopyResource(staging,renderTargetTexture[n]);

	devicecontext->Map( staging, 0, D3D11_MAP_READ, 0, &mappedTex );
	unsigned char * ptr = (unsigned char*)mappedTex.pData;
	int pitch = mappedTex.RowPitch;

	adr=0;
	for (n2=0;n2<y;n2++)
	{
		pn=n2*pitch;
		for (n1=0;n1<x;n1++)
		{
			r=ptr[pn+0]; g=ptr[pn+1]; b=ptr[pn+2]; a=ptr[pn+3];
			pn+=4;
			raw[adr+0]=r; raw[adr+1]=g;  raw[adr+2]=b; raw[adr+3]=a;
			adr+=4;
		}
	}

	devicecontext->Unmap( staging, 0 );

	staging->Release();

	*w=x;
	*h=y;
	*pbits=raw;

#else
#ifdef API3D_DIRECT3D10

	int n=ns-SECONDARY1;
	int x=tile_secondarysurfacesW[n];
	int y=tile_secondarysurfacesH[n];
	unsigned char * raw=(unsigned char *)malloc(x*y*4);

	int n1,n2;
	int r,g,b,a,adr,pn;

	D3D10_MAPPED_TEXTURE2D mappedTex;
	ID3D10Texture2D *staging;

	D3D10_TEXTURE2D_DESC StagingDesc;
	renderTargetTexture[n]->GetDesc(&StagingDesc);
	StagingDesc.Usage = D3D10_USAGE_STAGING;
	StagingDesc.BindFlags = 0;
	StagingDesc.CPUAccessFlags = D3D10_CPU_ACCESS_READ;
	StagingDesc.MiscFlags = 0;
	device->CreateTexture2D(&StagingDesc, NULL, &staging);

	device->CopyResource(staging,renderTargetTexture[n]);

	staging->Map( 0, D3D10_MAP_READ, 0, &mappedTex );
	unsigned char * ptr = (unsigned char*)mappedTex.pData;
	int pitch = mappedTex.RowPitch;

	adr=0;
	for (n2=0;n2<y;n2++)
	{
		pn=n2*pitch;
		for (n1=0;n1<x;n1++)
		{
			r=ptr[pn+0]; g=ptr[pn+1]; b=ptr[pn+2]; a=ptr[pn+3];
			pn+=4;
			raw[adr+0]=r; raw[adr+1]=g;  raw[adr+2]=b; raw[adr+3]=a;
			adr+=4;
		}
	}

	staging->Unmap( 0 );

	staging->Release();

	*w=x;
	*h=y;
	*pbits=raw;

#else

//------------------------------------------------------------------------------------------------ DIRECT3D ----------

	int n=ns-SECONDARY1;
	int x=tile_secondarysurfacesW[n];
	int y=tile_secondarysurfacesH[n];
	unsigned char * raw=(unsigned char *)malloc(x*y*4);

	int n1,n2;
	int r,g,b,a,adr,pn;
	unsigned char * ptr;
	D3DLOCKED_RECT Locked;

	LPDIRECT3DSURFACE9 surface;
	D3DDevice->CreateOffscreenPlainSurface(x,y,D3DFMT_A8R8G8B8,D3DPOOL_SYSTEMMEM,&surface,NULL);

	D3DDevice->GetRenderTargetData(D3DSecondary[n],surface);

	surface->LockRect(&Locked,NULL,D3DLOCK_READONLY);
	ptr=(unsigned char *)Locked.pBits;

	adr=0;
	for (n2=0;n2<y;n2++)
	{
		pn=n2*Locked.Pitch;
		for (n1=0;n1<x;n1++)
		{
			b=ptr[pn+0]; g=ptr[pn+1]; r=ptr[pn+2]; a=ptr[pn+3];
			pn+=4;

			raw[adr+0]=r;
			raw[adr+1]=g;
			raw[adr+2]=b;
			raw[adr+3]=a;
			adr+=4;
		}
	}

	surface->UnlockRect();
	surface->Release();

	*w=x;
	*h=y;
	*pbits=raw;

#endif
#endif
#endif
#endif
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::GetDataSecondaryFast(int ns,unsigned char **pbits,int *w,int *h)
{
#if defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ METAL -------------

    int n=ns-SECONDARY1;
    int x=tile_secondarysurfacesW[n];
    int y=tile_secondarysurfacesH[n];
    *pbits=(unsigned char *)MTLGetRawSecondaryFast(n);
    *w=x;
    *h=y;

    return;
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)

    //------------------------------------------------------------------------------------------------ OPEN GL -----------
#if !defined(GLESFULL)&&!defined(GLES20)
    int n=ns-SECONDARY1;
    int x=tile_secondarysurfacesW[n];
    int y=tile_secondarysurfacesH[n];
    unsigned char * raw=(unsigned char *)malloc(x*y*4);
    glBindTexture(GL_TEXTURE_2D,renderedTexture[n]);
    glGetTexImage(GL_TEXTURE_2D,0,GL_RGBA,GL_UNSIGNED_BYTE,raw);
    *w=x;
    *h=y;
    *pbits=(unsigned char *)malloc(x*y*4);
    for (n=0;n<y;n++)
        memcpy(&(*pbits)[n*x*4],&raw[(y-1-n)*x*4],x*4);
    
    free(raw);
#else
    int n=ns-SECONDARY1;
    *w=tile_secondarysurfacesW[n];
    *h=tile_secondarysurfacesH[n];
    unsigned char * raw;
    int n1,n2;

    int srt=SelectedRenderTarget;

    SetParams(API3D_RENDERTARGET,ns);

    raw=(unsigned char *) malloc((*h)*(*w)*4);

    glPixelStorei(GL_UNPACK_ALIGNMENT,0);

    *pbits=(unsigned char *)malloc((*w)*(*h)*4);

    glReadPixels(0,0,(*w),(*h),GL_RGBA,GL_UNSIGNED_BYTE,raw);

    for (n=0;n<(*h);n++)
        memcpy(&(*pbits)[n*(*w)*4],&raw[((*h)-1-n)*(*w)*4],(*w)*4);

/*
    for (n2=0;n2<(*h);n2++)
    {
        glReadPixels(0,n2,(*w),1,GL_RGBA,GL_UNSIGNED_BYTE,raw);

        for (n1=0;n1<(*w);n1++)
        {
            (*pbits)[(n1+((*h)-1-n2)*(*w))*4+0]=raw[n1*4+0];
            (*pbits)[(n1+((*h)-1-n2)*(*w))*4+1]=raw[n1*4+1];
            (*pbits)[(n1+((*h)-1-n2)*(*w))*4+2]=raw[n1*4+2];
        }
    }
/**/
    free(raw);
    if (srt==-1) SetParams(API3D_RENDERTARGET,PRIMARY); else SetParams(API3D_RENDERTARGET,SelectedRenderTarget+SECONDARY1);
#endif

#endif
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#ifdef API3D_DIRECT3D12
    int n=ns-SECONDARY1;

    ID3D12Resource *pSource=renderTargetTexture[n];
    ID3D12Resource *pStaging;
    *w=tile_secondarysurfacesW[n];
    *h=tile_secondarysurfacesH[n];

    if (commandList) CloseAndExecuteCommandList(commandList);
    commandList=NULL;

    ID3D12GraphicsCommandList* cmd;
    device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, nullptr, IID_PPV_ARGS(&cmd));

    ID3D12Fence* fnce;
    device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fnce));

    CD3DX12_HEAP_PROPERTIES defaultHeapProperties(D3D12_HEAP_TYPE_DEFAULT);
    CD3DX12_HEAP_PROPERTIES readBackHeapProperties(D3D12_HEAP_TYPE_READBACK);

    D3D12_RESOURCE_DESC desc=pSource->GetDesc();

    D3D12_RESOURCE_DESC bufferDesc = {};
        bufferDesc.DepthOrArraySize = 1;
        bufferDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
        bufferDesc.Flags = D3D12_RESOURCE_FLAG_NONE;
        bufferDesc.Format = DXGI_FORMAT_UNKNOWN;
        bufferDesc.Height = 1;
        bufferDesc.Width = (*w) * desc.Height * 4;
        bufferDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
        bufferDesc.MipLevels = 1;
        bufferDesc.SampleDesc.Count = 1;

    device->CreateCommittedResource(&readBackHeapProperties,D3D12_HEAP_FLAG_NONE,&bufferDesc,D3D12_RESOURCE_STATE_COPY_DEST, nullptr,IID_PPV_ARGS(&pStaging));


    cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(pSource, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_COPY_SOURCE));

    D3D12_PLACED_SUBRESOURCE_FOOTPRINT bufferFootprint = {};
    
    bufferFootprint.Footprint.Width = static_cast<UINT>(*w);
    bufferFootprint.Footprint.Height = static_cast<UINT>(*h);
    bufferFootprint.Footprint.Depth = 1;
    bufferFootprint.Footprint.RowPitch = static_cast<UINT>((*w)*4);
    bufferFootprint.Footprint.Format = desc.Format;

    ID3D12Resource * copySource(pSource);

    CD3DX12_TEXTURE_COPY_LOCATION copyDest(pStaging, bufferFootprint);
    CD3DX12_TEXTURE_COPY_LOCATION copySrc(copySource, 0);

    CD3DX12_BOX box(0,0,*w,*h);

    cmd->CopyTextureRegion(&copyDest, 0, 0, 0, &copySrc, &box);

    cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(pSource,D3D12_RESOURCE_STATE_COPY_SOURCE, D3D12_RESOURCE_STATE_COMMON));

    CloseAndExecuteCommandList(cmd);

    commandQueue->Signal(fnce,1);

    while (fnce->GetCompletedValue() < 1) {}

    *pbits=(unsigned char*)malloc((*w)*(*h)*4);

    CD3DX12_RANGE readRange(0, 0);
    char *pdata;
    pStaging->Map(0, &readRange, reinterpret_cast<void**>(&pdata));
    memcpy(*pbits,pdata, (*w)*(*h)*4);
    pStaging->Unmap(0, nullptr);

    pStaging->Release();

#else
#ifdef API3D_DIRECT3D11

    int n=ns-SECONDARY1;
    int x=tile_secondarysurfacesW[n];
    int y=tile_secondarysurfacesH[n];
    unsigned char * raw=(unsigned char *)malloc(x*y*4);

    int n1,n2;
    int r,g,b,a,adr,pn;
    D3D11_MAPPED_SUBRESOURCE mappedTex;
    ID3D11Texture2D *staging;

    D3D11_TEXTURE2D_DESC StagingDesc;
    renderTargetTexture[n]->GetDesc(&StagingDesc);
    StagingDesc.Usage = D3D11_USAGE_STAGING;
    StagingDesc.BindFlags = 0;
    StagingDesc.CPUAccessFlags = D3D11_CPU_ACCESS_READ;
    StagingDesc.MiscFlags = 0;
    device->CreateTexture2D(&StagingDesc, NULL, &staging);

    devicecontext->CopyResource(staging,renderTargetTexture[n]);

    devicecontext->Map( staging, 0, D3D11_MAP_READ, 0, &mappedTex );
    unsigned char * ptr = (unsigned char*)mappedTex.pData;
    int pitch = mappedTex.RowPitch;

    adr=0;
    for (n2=0;n2<y;n2++)
    {
        pn=n2*pitch;
        for (n1=0;n1<x;n1++)
        {
            r=ptr[pn+0]; g=ptr[pn+1]; b=ptr[pn+2]; a=ptr[pn+3];
            pn+=4;
            raw[adr+0]=r; raw[adr+1]=g;  raw[adr+2]=b; raw[adr+3]=a;
            adr+=4;
        }
    }

    devicecontext->Unmap( staging, 0 );

    staging->Release();

    *w=x;
    *h=y;
    *pbits=raw;

#else
#ifdef API3D_DIRECT3D10

    int n=ns-SECONDARY1;
    int x=tile_secondarysurfacesW[n];
    int y=tile_secondarysurfacesH[n];
    unsigned char * raw=(unsigned char *)malloc(x*y*4);

    int n1,n2;
    int r,g,b,a,adr,pn;

    D3D10_MAPPED_TEXTURE2D mappedTex;
    ID3D10Texture2D *staging;

    D3D10_TEXTURE2D_DESC StagingDesc;
    renderTargetTexture[n]->GetDesc(&StagingDesc);
    StagingDesc.Usage = D3D10_USAGE_STAGING;
    StagingDesc.BindFlags = 0;
    StagingDesc.CPUAccessFlags = D3D10_CPU_ACCESS_READ;
    StagingDesc.MiscFlags = 0;
    device->CreateTexture2D(&StagingDesc, NULL, &staging);

    device->CopyResource(staging,renderTargetTexture[n]);

    staging->Map( 0, D3D10_MAP_READ, 0, &mappedTex );
    unsigned char * ptr = (unsigned char*)mappedTex.pData;
    int pitch = mappedTex.RowPitch;

    adr=0;
    for (n2=0;n2<y;n2++)
    {
        pn=n2*pitch;
        for (n1=0;n1<x;n1++)
        {
            r=ptr[pn+0]; g=ptr[pn+1]; b=ptr[pn+2]; a=ptr[pn+3];
            pn+=4;
            raw[adr+0]=r; raw[adr+1]=g;  raw[adr+2]=b; raw[adr+3]=a;
            adr+=4;
        }
    }

    staging->Unmap( 0 );

    staging->Release();

    *w=x;
    *h=y;
    *pbits=raw;

#else

//------------------------------------------------------------------------------------------------ DIRECT3D ----------

    int n=ns-SECONDARY1;
    int x=tile_secondarysurfacesW[n];
    int y=tile_secondarysurfacesH[n];
    unsigned char * raw=(unsigned char *)malloc(x*y*4);

    int n1,n2;
    int r,g,b,a,adr,pn;
    unsigned char * ptr;
    D3DLOCKED_RECT Locked;

    LPDIRECT3DSURFACE9 surface;
    D3DDevice->CreateOffscreenPlainSurface(x,y,D3DFMT_A8R8G8B8,D3DPOOL_SYSTEMMEM,&surface,NULL);

    D3DDevice->GetRenderTargetData(D3DSecondary[n],surface);

    surface->LockRect(&Locked,NULL,D3DLOCK_READONLY);
    ptr=(unsigned char *)Locked.pBits;

    adr=0;
    for (n2=0;n2<y;n2++)
    {
        pn=n2*Locked.Pitch;
        for (n1=0;n1<x;n1++)
        {
            b=ptr[pn+0]; g=ptr[pn+1]; r=ptr[pn+2]; a=ptr[pn+3];
            pn+=4;

            raw[adr+0]=r;
            raw[adr+1]=g;
            raw[adr+2]=b;
            raw[adr+3]=a;
            adr+=4;
        }
    }

    surface->UnlockRect();
    surface->Release();

    *w=x;
    *h=y;
    *pbits=raw;

#endif
#endif
#endif
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Fonctions direct3D
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#ifndef WINDOWS_PHONE

void C3DAPIBASE::SetHandleWindow(HWND hwnd)
{
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	hWindow=hwnd;
}

void C3DAPIBASE::SetHandleInstance(HINSTANCE hInst)
{
	hInstance=hInst;
}

#endif
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Shaders
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */
#if defined(API3D_DIRECT3D12) || defined(API3D_DIRECT3D11) || defined(API3D_DIRECT3D10) || defined(API3D_OPENGL20) || defined(API3D_METAL)
typedef struct
{
	CVertexBuffer * vb;
	char *shader_script;
	char *desc;
	int init;

} BuiltInShader;

// MULTIQUADS
CVertexBuffer			effect_hll_quads;
CVertexBuffer			effect_hll_quads_blend;
CVertexBuffer			effect_hll_quads_snd;
CVertexBuffer			effect_hll_quads_alphatest;	
CVertexBuffer			effect_hll_quad2;
CVertexBuffer			effect_hll_quadblur;
CVertexBuffer			effect_hll_quadbump;
CVertexBuffer			effect_hll_quadspec;
CVertexBuffer			effect_hll_quadglow;
CVertexBuffer           effect_hll_quadglow2;
// COLORTEX
CVertexBuffer			effect_hll_point_cloud;
CVertexBuffer           effect_hll_diffuse;
CVertexBuffer           effect_hll_diffuse_alphatest;
CVertexBuffer           effect_hll_diffuse_model;
CVertexBuffer           effect_hll_diffuse_alphatest_model;
// COLOR
CVertexBuffer			effect_hll_diffuse_nomap;
// MULTITEXTURE
CVertexBuffer			effect_hll_multi00,effect_hll_multi01,effect_hll_multi10,effect_hll_multi11;
CVertexBuffer			effect_hll_multi00_at,effect_hll_multi01_at,effect_hll_multi10_at,effect_hll_multi11_at;
// TNL
CVertexBuffer			effect_hll_TNL;
CVertexBuffer			effect_hll_TNL_specular;
CVertexBuffer			effect_hll_TNL_morph;
CVertexBuffer			effect_hll_TNL_specular_morph;
CVertexBuffer			effect_hll_TNL_alphatest;
CVertexBuffer			effect_hll_TNL_specular_alphatest;
CVertexBuffer			effect_hll_TNL_morph_alphatest;
CVertexBuffer			effect_hll_TNL_specular_morph_alphatest;
// STENCIL
CVertexBuffer			effect_hll_stencil_simple;
CVertexBuffer			effect_hll_stencil_alternative;
CVertexBuffer			effect_hll_stencil_simple_morph;
CVertexBuffer			effect_hll_stencil_alternative_morph;
// ENVMAP
CVertexBuffer			effect_hll_envmap1;
CVertexBuffer			effect_hll_envmap1_morph;
CVertexBuffer			effect_hll_envmap2;
CVertexBuffer			effect_hll_envmap2_morph;
// BUMP MAPPING
CVertexBuffer			effect_hll_bump_mapping;
CVertexBuffer			effect_hll_bump_mapping_s;
CVertexBuffer			effect_hll_bump_mapping_anim;
// BUMP MAPPING DISPLACEMENT
CVertexBuffer			effect_hll_bump_mapping_displacement;
CVertexBuffer			effect_hll_bump_mapping_displacement_s;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BuiltInShader BUILTIN[]={
    { &effect_hll_diffuse,                      shader_hll_diffuse,                         "DIFFUSE"                       , 1     },
    { &effect_hll_diffuse_alphatest,            shader_hll_diffuse_alphatest,               "DIFFUSEAT"                     , 1     },
    { &effect_hll_diffuse_model,                shader_hll_diffuse_model,                   "DIFFUSEMDL"                    , 1     },
    { &effect_hll_diffuse_alphatest_model,      shader_hll_diffuse_alphatest_model,         "DIFFUSEATMDL"                  , 1     },
	{ &effect_hll_diffuse_nomap,				shader_hll_diffuse_nomap,					"DIFFUSEONLY"					, 1		},
	{ &effect_hll_quads,						shader_hll_quad,							"QUADS"							, 1		},
	{ &effect_hll_quads_blend,					shader_hll_quad_blend,						"QUADSBLEND"					, 1		},
	{ &effect_hll_quads_snd,					shader_hll_quad_snd,						"QUADS"							, 1		},
	{ &effect_hll_quads_alphatest,				shader_hll_quad_alphatest,					"QUADSAT"						, 1		},
	{ &effect_hll_quad2,						shader_hll_quad2,							"QUAD2"							, 1		},
	{ &effect_hll_quadblur,						shader_hll_quadblur,						"QUADBLUR"						, 1		},
	{ &effect_hll_quadbump,						shader_hll_quadbump,						"QUADBUMP"						, 1		},
	{ &effect_hll_quadspec,						shader_hll_quadspec,						"QUADSPEC"						, 1		},
#if ((defined(WINDOWS_PHONE)&&!defined(WINDOWS_STORE))||defined(WEBASM))
	{ &effect_hll_quadglow,						shader_hll_quadglow,						"QUADGLOW"						, 0		},
    { &effect_hll_quadglow2,                    shader_hll_quad_pow2,                       "QUADGLOW2"                     , 1        },
#else
	{ &effect_hll_quadglow,						shader_hll_quadglow,						"QUADGLOW"						, 1		},
    { &effect_hll_quadglow2,                    shader_hll_quadglow2,                       "QUADGLOW2"                     , 1        },
#endif
	{ &effect_hll_multi00,						shader_hll_multitexture_mod_mod,			"MULTI00"						, 0		},
	{ &effect_hll_multi00_at,					shader_hll_multitexture_mod_mod_at,			"MULTI00AT"						, 0		},
	{ &effect_hll_multi01,						shader_hll_multitexture_mod_add,			"MULTI01"						, 0		},
	{ &effect_hll_multi01_at,					shader_hll_multitexture_mod_add_at,			"MULTI01AT"						, 0		},
	{ &effect_hll_multi10,						shader_hll_multitexture_add_mod,			"MULTI10"						, 0		},
	{ &effect_hll_multi10_at,					shader_hll_multitexture_add_mod_at,			"MULTI10AT"						, 0		},
	{ &effect_hll_multi11,						shader_hll_multitexture_add_add,			"MULTI11"						, 0		},
	{ &effect_hll_multi11_at,					shader_hll_multitexture_add_add_at,			"MULTI11AT"						, 0		},
	{ &effect_hll_TNL_morph,					shader_hll_lighting_8_morph,				"TNL MORPH"						, 0		},
	{ &effect_hll_TNL_specular_morph,			shader_hll_lighting_8_specular_morph,		"TNL SPECULAR MORPH"			, 0		},
	{ &effect_hll_TNL_morph_alphatest,			shader_hll_lighting_8_morph_at,				"TNL MORPH AT"					, 0		},
	{ &effect_hll_TNL_specular_morph_alphatest,	shader_hll_lighting_8_specular_morph_at,	"TNL SPECULAR MORPH AT"			, 0		},
	{ &effect_hll_TNL,							shader_hll_lighting_8,						"TNL"							, 0		},
	{ &effect_hll_TNL_alphatest,				shader_hll_lighting_8_at,					"TNL ALPHA"						, 0		},
	{ &effect_hll_TNL_specular,					shader_hll_lighting_8_specular,				"TNL SPECULAR"					, 0		},
	{ &effect_hll_TNL_specular_alphatest,		shader_hll_lighting_8_specular_at,			"TNL SPECULAR_ALPHA"			, 0		},
	{ &effect_hll_stencil_simple,				script_hll_stencil_simple,					"STENCIL SIMPLE"				, 0		},
	{ &effect_hll_stencil_alternative,			script_hll_stencil_alternative,				"STENCIL ALTERNATIVE"			, 0		},
	{ &effect_hll_stencil_simple_morph,			script_hll_stencil_simple_morph,			"STENCIL SIMPLE MORPH"			, 0		},
	{ &effect_hll_stencil_alternative_morph,	script_hll_stencil_alternative_morph,		"STENCIL ALTERNATIVE MORPH"		, 0		},
	{ &effect_hll_envmap1,						shader_hll_envmap1,							"ENVMAP 1"						, 0		},
	{ &effect_hll_envmap1_morph,				shader_hll_envmap1_morph,					"ENVMAP 1 MORPH"				, 0		},
	{ &effect_hll_envmap2,						shader_hll_envmap2,							"ENVMAP 2"						, 0		},
	{ &effect_hll_envmap2_morph,				shader_hll_envmap2_morph,					"ENVMAP 2 MORPH"				, 0		},
	{ &effect_hll_bump_mapping,					shader_hll_bump_mapping,					"BUMP MAPPING"					, 0		},
	{ &effect_hll_bump_mapping_s,				shader_hll_bump_mapping_s,					"BUMP MAPPING STENCIL"			, 0		},
	{ &effect_hll_bump_mapping_anim,			shader_hll_bump_mapping_anim,				"BUMP MAPPING ANIMATED"			, 0		},
	{ &effect_hll_bump_mapping_displacement,	shader_hll_bump_mapping_displacement,		"BUMP MAPPING DISPLACE"			, 0		},
	{ &effect_hll_bump_mapping_displacement_s,	shader_hll_bump_mapping_displacement_s,		"BUMP MAPPING DISPLACE STENCIL"	, 0		},
	{ &effect_hll_point_cloud,					shader_hll_point_cloud,						"POINT CLOUDS"					, 1		},

	
	{ NULL,NULL }
};

#else
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

char * shader_hll_point_cloud=
"[VERTEXFORMAT]\n"
"	XYZ DIFFUSE TEX0\n"
"[DEFINES]\n"
"	MATRIX MODEL;\n"
"	MATRIX WORLDVIEW;\n"
"	VECTOR PSIZE;\n"
"	TEXTURE Tex;\n"
"[TECHNIQUE] Model3\n"
"[PASS0]\n"	 
"	[POSITION]\n"
"		oPos = iPos *4 MODEL;\n"
"		tmp = iPos *4 WORLDVIEW;\n"
"		oPos.x = oPos.x / oPos.w;\n"
"		oPos.y = oPos.y / oPos.w;\n"
"		d.x = PSIZE.x*(iTexture0.x-0.5)/tmp.z;\n"
"		d.y = PSIZE.y*(iTexture0.y-0.5)/tmp.z;\n"
"		oPos.z = oPos.z / oPos.w;\n"
"		oPos.w = 1.0;\n"
"		oPos.xy += d.xy;\n"
"	[DIFFUSE]\n"
"		oDiffuse = iDiffuse;\n"
"	[MAPPING0]\n"
"		oTexture0.xy = iTexture0.xy;\n"
"	[SHADER]\n"
"		col = sample(0,Tex0);\n"
"		if (col.a<0.5) discard;\n"
"		Out = Diffuse;\n"
"    [RENDER_STATE]\n"
"		Blend False\n"
"		Texture[0] Tex\n"
"		TextureCoordinate[0] TexCoo0\n"

"[END]\n"
"\n";

CVertexBuffer			*effect_hll_point_cloud=NULL;

#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		MiscFree
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::MiscFree()
{
	SHADOW_MAPPINGBL.Release();
	SHADOW_MAPPING.Release();
	SHADOW_FLAT.Release();
	SHADOW_VOLUME.Release();

#if defined(API3D_DIRECT3D10) || defined(API3D_DIRECT3D11) || defined(API3D_OPENGL20) || defined(API3D_METAL) || defined(API3D_DIRECT3D12)
	int n=0;
	while (BUILTIN[n].vb)
	{ 
		BUILTIN[n].vb->Release();
		n++;
	}

	vbquads.UnlockVertices();

	vbquadsXYZ.UnlockVertices();

	nMultiQuads=0;
	nMultiQuadsXYZ=0;

	vbquadsXYZ.Release();

	vbquads.Release();
	vbquad2.Release();
	vbline.Release();
#ifdef API3D_METAL
    vbline.Release();
#endif
	vbquadblur.Release();
	vbquad_xyzcolortex.Release();
	vbquad_xyzcolor.Release();
#endif
#if !defined(API3D_METAL)
#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
	glDeleteTextures(1,(const GLuint*)&Noir);
	glDeleteTextures(1,(const GLuint*)&Blanc);
#else
#ifndef API3D_DIRECT3D10
#ifndef API3D_DIRECT3D11
#ifndef API3D_DIRECT3D12
	Noir->Release();
	Blanc->Release();
#endif
#endif
#endif
#endif
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		BUILTIN SHADERS
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#if defined(API3D_DIRECT3D12) || defined(API3D_DIRECT3D11) || defined(API3D_DIRECT3D10) || defined(API3D_OPENGL20) || defined(API3D_METAL)

void SetBUILTINVertexBuffer(CVertexBuffer * vb)
{
	if (vb->Type&API3D_VERTEXPROGRAM) return;

	int n=0;
	while (BUILTIN[n].vb)
	{
		if (vb==BUILTIN[n].vb)
		{
			vb->SetVertexProgram(BUILTIN[n].shader_script);
			return;
		}
		n++;
	}
}

#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		Misc
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::Misc()
{
	int n; 

	TimeInitFPS();

	SetParams(API3D_CULL,ON);
	SetParams(API3D_CULL,CCW);
    
#if defined(API3D_DIRECT3D12) || defined(API3D_DIRECT3D11) || defined(API3D_DIRECT3D10) || defined(API3D_OPENGL20) || defined(API3D_METAL)
    
	n=0;
	while (BUILTIN[n].vb)
	{
		BUILTIN[n].vb->SetAPI(this);
		BUILTIN[n].vb->BasicEffect();
		if (BUILTIN[n].init)
		{
			LOG(BUILTIN[n].desc);
			BUILTIN[n].vb->SetVertexProgram(BUILTIN[n].shader_script);
		}
		n++;
	}

	

	// QUADS
	vbquads.SetAPI(this);
	vbquads.Grouped=false;
	vbquads.SetType(API3D_VERTEXDATAS|API3D_COLORDATAS4|API3D_TEXCOODATAS|API3D_TEXPERVERTEX|API3D_DYNAMIC);
	vbquads.Init(MAX_VBQUADS*4,MAX_VBQUADS*3*2);

	vbquads.LockIndices();
	for (n=0;n<MAX_VBQUADS;n++)
	{
		vbquads.SetIndices(n*2+0,n*4+0,n*4+1,n*4+2);
		vbquads.SetIndices(n*2+1,n*4+0,n*4+2,n*4+3);
	}
	vbquads.UnlockIndices();

	// QUADS XYZ
	vbquadsXYZ.SetAPI(this);
	vbquadsXYZ.Grouped=false;
	vbquadsXYZ.SetType(API3D_VERTEXDATAS|API3D_COLORDATAS4|API3D_TEXCOODATAS|API3D_TEXCOO2DATAS|API3D_TEXCOO3BUMP|API3D_TEXPERVERTEX|API3D_DYNAMIC);
	vbquadsXYZ.Init(MAX_VBQUADS*4,MAX_VBQUADS*3*2);

	vbquadsXYZ.LockIndices();
	for (n=0;n<MAX_VBQUADS;n++)
	{
		vbquadsXYZ.SetIndices(n*2+0,n*4+0,n*4+1,n*4+2);
		vbquadsXYZ.SetIndices(n*2+1,n*4+0,n*4+2,n*4+3);
	}
	vbquadsXYZ.UnlockIndices();

	// QUADS AND TRIS
	vbquad_xyzcolortex.SetAPI(this);
	vbquad_xyzcolortex.Grouped=false;
	vbquad_xyzcolortex.SetType(API3D_VERTEXDATAS|API3D_COLORDATAS4|API3D_TEXCOODATAS|API3D_TEXPERVERTEX|API3D_DYNAMIC);
	vbquad_xyzcolortex.Init(4,3*2);
	vbquad_xyzcolortex.LockIndices();
	vbquad_xyzcolortex.SetIndices(0,0,1,2);
	vbquad_xyzcolortex.SetIndices(1,0,2,3);
	vbquad_xyzcolortex.UnlockIndices();

	vbquad_xyzcolor.SetAPI(this);
	vbquad_xyzcolor.Grouped=false;
	vbquad_xyzcolor.SetType(API3D_VERTEXDATAS|API3D_COLORDATAS4|API3D_DYNAMIC);
	vbquad_xyzcolor.Init(4,3*2);
	vbquad_xyzcolor.LockIndices();
	vbquad_xyzcolor.SetIndices(0,0,1,2);
	vbquad_xyzcolor.SetIndices(1,0,2,3);
	vbquad_xyzcolor.UnlockIndices();

	// MULTITEXTURE
	vbquad2.SetAPI(this);
	vbquad2.Grouped=false;
	vbquad2.SetType(API3D_VERTEXDATAS|API3D_COLORDATAS4|API3D_TEXCOODATAS|API3D_TEXCOODATAS2|API3D_TEXPERVERTEX|API3D_DYNAMIC);
	vbquad2.Init(4,3*2);

	vbquad2.LockIndices();
	n=0;
	vbquad2.SetIndices(n*2+0,n*4+0,n*4+1,n*4+2);
	vbquad2.SetIndices(n*2+1,n*4+0,n*4+2,n*4+3);
	vbquad2.UnlockIndices();

	// LINES
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    vbline.SetAPI(this);
    vbline.Grouped=false;
    vbline.SetType(API3D_VERTEXDATAS|API3D_COLORDATAS4|API3D_DYNAMIC);
    vbline.Init(NB_LINE_MAX,3);
    
    vbline.LockIndices();
    vbline.SetIndices(0,0,1,2);
    vbline.UnlockIndices();
    
    vbline3d.SetAPI(this);
    vbline3d.Grouped=false;
    vbline3d.SetType(API3D_VERTEXDATAS|API3D_COLORDATAS4|API3D_DYNAMIC);
    vbline3d.Init(NB_LINE_MAX,3);
    
    vbline3d.LockIndices();
    vbline3d.SetIndices(0,0,1,2);
    vbline3d.UnlockIndices();
    
    vbline.LockVertices();
    vbline3d.LockVertices();
    
    nbline=0;
    nbline3d=0;
    
#else
    vbline.SetAPI(this);
    vbline.Grouped=false;
    vbline.SetType(API3D_VERTEXDATAS|API3D_COLORDATAS4|API3D_DYNAMIC);
    vbline.Init(2,3);
    
    vbline.LockIndices();
    vbline.SetIndices(0,0,1,2);
    vbline.UnlockIndices();
#endif
	// BLUR
	vbquadblur.SetAPI(this);
	vbquadblur.Grouped=false;
	vbquadblur.SetType(API3D_FOURTEX|API3D_DYNAMIC);
	vbquadblur.Init(4,3*2);

	vbquadblur.LockIndices();
	n=0;
	vbquadblur.SetIndices(n*2+0,n*4+0,n*4+1,n*4+2);
	vbquadblur.SetIndices(n*2+1,n*4+0,n*4+2,n*4+3);
	vbquadblur.UnlockIndices();
    
#ifdef API3D_METAL
    char *ptex[16*16*4];
    memset(ptex,255,16*16*4);
    Blanc=MTLAddTextureMipMap(ptex,16,16,0);
#endif

	// SETTINGS

	vbquadsXYZ.LockVertices();
	nMultiQuadsXYZ=0;

#if defined(API3D_DIRECT3D12) || defined(API3D_DIRECT3D11) || defined(API3D_METAL)
	MatrixOrthoLHS( &ProjOrtho, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );
	vbquads.LockVertices();
#if defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)
	MultiQuads=(struct CUSTOMVERTEX0 *)vbquads.pVertices;
#endif
	nMultiQuads=0;
#else
#ifdef API3D_DIRECT3D10
	D3DXMATRIX proj;
	D3DXMatrixOrthoLH( &proj, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );

	ProjOrtho.a[0][0]=proj._11;	ProjOrtho.a[1][0]=proj._21;	ProjOrtho.a[2][0]=proj._31;	ProjOrtho.a[3][0]=proj._41;
	ProjOrtho.a[0][1]=-proj._12; ProjOrtho.a[1][1]=-proj._22; ProjOrtho.a[2][1]=-proj._32; ProjOrtho.a[3][1]=-proj._42;
	ProjOrtho.a[0][2]=proj._13;	ProjOrtho.a[1][2]=proj._23;	ProjOrtho.a[2][2]=proj._33;	ProjOrtho.a[3][2]=proj._43;
	ProjOrtho.a[0][3]=proj._14;	ProjOrtho.a[1][3]=proj._24;	ProjOrtho.a[2][3]=proj._34;	ProjOrtho.a[3][3]=proj._44;

	vbquads.LockVertices();
	MultiQuads=(struct CUSTOMVERTEX0 *)vbquads.pVertices;
	nMultiQuads=0;
#else  //GL20

	float w=(float)SCREEN_X;
	float h=(float)SCREEN_Y;

	setPO(&ProjOrtho,w,h);

	vbquads.LockVertices();
	nMultiQuads=0;

#endif
#endif
#endif

	if (!tag_tile)
	{
		for (n=0;n<MAX_SECONDARIES;n++)
		{
			if (n==0) tile_secondarysurfaces[n]=TILE_SecondarySurface/2;
			else tile_secondarysurfaces[n]=TILE_SecondarySurface;
		}
		tag_tile=true;
	}

	for (n=0;n<MAX_SECONDARIES;n++)
	{
		if (tile_secondarysurfaces[n]>states(TEXTURE_MAX_WIDTH)) tile_secondarysurfaces[n]=states(TEXTURE_MAX_WIDTH);
	}	

	SHADOW_FLAT.SetType(API3D_VERTEXDATAS|API3D_COLORDATAS4|API3D_TEXPERVERTEX);
	SHADOW_FLAT.Init(NUMBER_MAX_VERTICES_SHADOW,NUMBER_MAX_INDICES_SHADOW);
	
	SHADOW_MAPPING.SetType(API3D_VERTEXDATAS|API3D_COLORDATAS4|API3D_TEXCOODATAS|API3D_TEXPERVERTEX);
	SHADOW_MAPPING.Init(NUMBER_MAX_VERTICES_SHADOW,NUMBER_MAX_INDICES_SHADOW);
	
	SHADOW_VOLUME.SetType(API3D_VERTEXDATAS|API3D_COLORDATAS);
	SHADOW_VOLUME.Init(NUMBER_MAX_VERTICES_SHADOW,NUMBER_MAX_INDICES_SHADOW);

	SHADOW_MAPPINGBL.SetType(API3D_VERTEXDATAS|API3D_COLORDATAS|API3D_TEXCOODATAS|API3D_TEXCOO2LIGHTMAP|API3D_TEXCOO3BUMP|API3D_TEXPERVERTEX);
	SHADOW_MAPPINGBL.Init(NUMBER_MAX_VERTICES_SHADOW,NUMBER_MAX_INDICES_SHADOW);
	
	ShadowVertexBuffer=&SHADOW_MAPPING;

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)

	MultiQuadsZbuffer=0;
	zb=zbw=0;

	char *ptrtex=(char*) malloc(16*16*3);

	memset(ptrtex,0,16*16*3);

	glPixelStorei(GL_UNPACK_ALIGNMENT,1);
#if !defined(GLES)&&!defined(GLES20)
	glPixelStorei(GL_UNPACK_ROW_LENGTH,0);
	glPixelStorei(GL_UNPACK_SKIP_ROWS,0);
	glPixelStorei(GL_UNPACK_SKIP_PIXELS,0);
#endif
	glEnable(GL_TEXTURE_2D);
	glGenTextures(1,(GLuint*) &Noir);			
	glBindTexture(GL_TEXTURE_2D,(GLuint) Noir);

	if (states(TEXTURES_MIPMAP_ACTIVE)==1)
	{
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
	}
	else
	{
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
	}

#if !defined(GLES)&&!defined(GLES20)
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);

	if (states(TEXTURES_MIPMAP_ACTIVE)==0) glTexImage2D(GL_TEXTURE_2D,0,GL_RGB,16,16,0,GL_RGB,GL_UNSIGNED_BYTE,ptrtex);
	else
	{
#ifdef OCULUS
		glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,16,16,0,GL_RGBA,GL_UNSIGNED_BYTE,ptrtex);
		glGenerateMipmap(GL_TEXTURE_2D);
#else
		gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGB,16,16,GL_RGB,GL_UNSIGNED_BYTE,ptrtex);
#endif
	}
#else
	glTexImage2D(GL_TEXTURE_2D,0,GL_RGB,16,16,0,GL_RGB,GL_UNSIGNED_BYTE,ptrtex);

#endif

	memset(ptrtex,255,16*16*3);

	glPixelStorei(GL_UNPACK_ALIGNMENT,1);
#if !defined(GLES)&&!defined(GLES20)
	glPixelStorei(GL_UNPACK_ROW_LENGTH,0);
	glPixelStorei(GL_UNPACK_SKIP_ROWS,0);
	glPixelStorei(GL_UNPACK_SKIP_PIXELS,0);
#endif
	glEnable(GL_TEXTURE_2D);
	glGenTextures(1,(GLuint*) &Blanc);			
	glBindTexture(GL_TEXTURE_2D,(GLuint) Blanc);

	if (states(TEXTURES_MIPMAP_ACTIVE)==1)
	{
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
	}
	else
	{
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
	}


#if !defined(GLES)&&!defined(GLES20)
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
	if (states(TEXTURES_MIPMAP_ACTIVE)==0) glTexImage2D(GL_TEXTURE_2D,0,GL_RGB,16,16,0,GL_RGB,GL_UNSIGNED_BYTE,ptrtex);
	else
	{
#ifdef OCULUS
		glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,16,16,0,GL_RGBA,GL_UNSIGNED_BYTE,ptrtex);
		glGenerateMipmap(GL_TEXTURE_2D);
#else
		gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGB,16,16,GL_RGB,GL_UNSIGNED_BYTE,ptrtex);
#endif
	}
#else
	glTexImage2D(GL_TEXTURE_2D,0,GL_RGB,16,16,0,GL_RGB,GL_UNSIGNED_BYTE,ptrtex);
#endif

	free(ptrtex);

#endif

#ifdef API3D_DIRECT3D
	D3DFORMAT Formats[3]={
					    D3DFMT_R5G6B5,      
						D3DFMT_X1R5G5B5,    
						D3DFMT_A4R4G4B4
						};

	D3DLOCKED_RECT Locked;
	int nn,n1,n2;
	unsigned int pitch;
	WORD * ptrdest;

	nn=0;
	while ((nn<3)&&(FAILED(D3DDevice->CreateTexture(16,16,1,0,Formats[nn],D3DPOOL_MANAGED,&Noir)))) nn++;

	Noir->LockRect(0,&Locked,NULL,0);
	ptrdest=(WORD *) Locked.pBits;
	pitch=Locked.Pitch/2;

	for (n2=0;n2<16;n2++)
		for (n1=0;n1<16;n1++) ptrdest[n1+pitch*n2]=0;

	Noir->UnlockRect(0);

	nn=0;
	while ((nn<3)&&(FAILED(D3DDevice->CreateTexture(16,16,1,0,Formats[nn],D3DPOOL_MANAGED,&Blanc)))) nn++;

	Blanc->LockRect(0,&Locked,NULL,0);
	ptrdest=(WORD *) Locked.pBits;
	pitch=Locked.Pitch/2;

	for (n2=0;n2<16;n2++)
		for (n1=0;n1<16;n1++) ptrdest[n1+pitch*n2]=65535;

	Blanc->UnlockRect(0);

#endif

#ifdef API3D_DIRECT3D9
	D3DFORMAT Formats[3]={
					    D3DFMT_R5G6B5,      
						D3DFMT_X1R5G5B5,    
						D3DFMT_A4R4G4B4
						};

	D3DLOCKED_RECT Locked;
	int nn,n1,n2;
	unsigned int pitch;
	WORD * ptrdest;

	nn=0;
	while ((nn<3)&&(FAILED(D3DDevice->CreateTexture(16,16,1,0,Formats[nn],D3DPOOL_MANAGED,&Noir,NULL)))) nn++;

	Noir->LockRect(0,&Locked,NULL,0);
	ptrdest=(WORD *) Locked.pBits;
	pitch=Locked.Pitch/2;

	for (n2=0;n2<16;n2++)
		for (n1=0;n1<16;n1++) ptrdest[n1+pitch*n2]=0;

	Noir->UnlockRect(0);

	nn=0;
	while ((nn<3)&&(FAILED(D3DDevice->CreateTexture(16,16,1,0,Formats[nn],D3DPOOL_MANAGED,&Blanc,NULL)))) nn++;

	Blanc->LockRect(0,&Locked,NULL,0);
	ptrdest=(WORD *) Locked.pBits;
	pitch=Locked.Pitch/2;

	for (n2=0;n2<16;n2++)
		for (n1=0;n1<16;n1++) ptrdest[n1+pitch*n2]=65535;

	Blanc->UnlockRect(0);

	// QUADS /////////////////////////////////////////////////////////////////////////////////////////

	vbquads.SetAPI(this);
	vbquads.Grouped=false;
	vbquads.SetType(API3D_VERTEXDATAS|API3D_COLORDATAS4|API3D_TEXCOODATAS|API3D_TEXPERVERTEX);
	vbquads.Init(MAX_VBQUADS*4,MAX_VBQUADS*3*2);

	vbquads.LockIndices();
	for (n=0;n<MAX_VBQUADS;n++)
	{
		vbquads.SetIndices(n*2+0,n*4+0,n*4+1,n*4+2);
		vbquads.SetIndices(n*2+1,n*4+0,n*4+2,n*4+3);
	}
	vbquads.UnlockIndices();

	char * shader_hll_quad=
	"[VERTEXFORMAT]\n"
	"	XYZ DIFFUSE TEX0\n"
	"[DEFINES]\n"
	"	TEXTURE Tex;\n"
	"	MATRIX PROJ;\n"
	"[TECHNIQUE]\n"
	"[PASS0]\n"	 
	"	[POSITION]\n"
	"		oPos = iPos *4 PROJ;\n"
	"	[DIFFUSE]\n"
	"		oDiffuse = iDiffuse;\n"
	"	[MAPPING0]\n"
	"		oTexture0.xy = iTexture0.xy;\n"
	"	[RENDER_STATE]\n"
	"		ShadeMode				Smooth\n"
	"		ColorOp[0]				Modulate\n"
	"		ColorArg1[0]			Texture\n"
	"		ColorArg2[0]			Diffuse\n"
	"		AlphaOp[0]				Modulate\n"
	"		AlphaArg1[0]			Texture\n"
	"		AlphaArg2[0]			Diffuse\n"
	"		ColorOp[1]				Disable\n"
	"		AlphaOp[1]				Disable\n"
	"		Texture[0]				Tex\n"
	"		TextureCoordinate[0]	TexCoo0\n"
	"[END]\n"
	"\n";

	QuadEffect=new CVertexBuffer;
	QuadEffect->SetAPI(this);
	QuadEffect->BasicEffect();
	QuadEffect->SetVertexProgram(shader_hll_quad);

	D3DXMATRIX proj;
	D3DXMatrixOrthoLH( &proj, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );

	ProjOrtho.a[0][0]=proj._11;	ProjOrtho.a[1][0]=proj._21;	ProjOrtho.a[2][0]=proj._31;	ProjOrtho.a[3][0]=proj._41;
	ProjOrtho.a[0][1]=-proj._12; ProjOrtho.a[1][1]=-proj._22; ProjOrtho.a[2][1]=-proj._32; ProjOrtho.a[3][1]=-proj._42;
	ProjOrtho.a[0][2]=proj._13;	ProjOrtho.a[1][2]=proj._23;	ProjOrtho.a[2][2]=proj._33;	ProjOrtho.a[3][2]=proj._43;
	ProjOrtho.a[0][3]=proj._14;	ProjOrtho.a[1][3]=proj._24;	ProjOrtho.a[2][3]=proj._34;	ProjOrtho.a[3][3]=proj._44;

	vbquads.LockVertices();
	nMultiQuads=0;

#endif

#ifdef API3D_OPENGL20
    PreviousRS.ZBuffer=PreviousRS.ZBufferWrite=_UNDEFINED;
    PreviousEffect=NULL;
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		openglstuff
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */
#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
#if !defined(GLES)&&!defined(GLES20)
int C3DAPIBASE::openglstuff()
{
	int n;
    
    *states[TEXTURE_MAX_WIDTH]=8192;

#ifdef OPENGL_MULTITEXTURING
#if defined(NOGETPROC)||defined(LINUX)
	MultiTexture=true;
	dot3=true;
#else

	MultiTexture=false;
	if (CheckExtension("GL_ARB_texture_env_dot3",(char*)glGetString(GL_EXTENSIONS))) dot3=true;
	else dot3=false;
	if (!CheckExtension("GL_ARB_texture_env_combine",(char*)glGetString(GL_EXTENSIONS))) dot3=false;

	if (CheckExtension("GL_ARB_multitexture",(char*)glGetString(GL_EXTENSIONS)))
	{
		glMultiTexCoord2fARB=(PFNGLMULTITEXCOORD2FARBPROC) lib3d_glGetProcAddress("glMultiTexCoord2fARB"); //wgl
		glActiveTextureARB=(PFNGLACTIVETEXTUREARBPROC) lib3d_glGetProcAddress("glActiveTextureARB");
		glClientActiveTextureARB=(PFNGLCLIENTACTIVETEXTUREARBPROC) lib3d_glGetProcAddress("glClientActiveTextureARB");
		MultiTexture=true;

		int error=0;

		if (!glMultiTexCoord2fARB) error=1;
		if (!glActiveTextureARB) error=1;
		if (!glClientActiveTextureARB) error=1;

		if (error) return -1;
	}
	else MultiTexture=false;
#endif
#endif

	G_PS2X=false;
	G_PS=false;
	G_Multitexture=MultiTexture;
	G_Dot3=dot3;
	G_VertexProgram=false;

#ifdef OPENGL_GLSL
#if (!defined(NOGETPROC))&&(!defined(LINUX))
	glBindAttribLocationARB=(PFNGLBINDATTRIBLOCATIONARBPROC)lib3d_glGetProcAddress("glBindAttribLocationARB");
	glGetAttribLocationARB=(PFNGLGETATTRIBLOCATIONARBPROC)lib3d_glGetProcAddress("glGetAttribLocationARB");
	glCreateProgramObjectARB = (PFNGLCREATEPROGRAMOBJECTARBPROC)lib3d_glGetProcAddress("glCreateProgramObjectARB");
	glCreateShaderObjectARB = (PFNGLCREATESHADEROBJECTARBPROC)lib3d_glGetProcAddress("glCreateShaderObjectARB");
	glShaderSourceARB = (PFNGLSHADERSOURCEARBPROC)lib3d_glGetProcAddress("glShaderSourceARB");
	glCompileShaderARB = (PFNGLCOMPILESHADERARBPROC)lib3d_glGetProcAddress("glCompileShaderARB");
	glGetObjectParameterivARB = (PFNGLGETOBJECTPARAMETERIVARBPROC)lib3d_glGetProcAddress("glGetObjectParameterivARB");
	glAttachObjectARB = (PFNGLATTACHOBJECTARBPROC)lib3d_glGetProcAddress("glAttachObjectARB");
	glGetInfoLogARB = (PFNGLGETINFOLOGARBPROC)lib3d_glGetProcAddress("glGetInfoLogARB");
	glLinkProgramARB = (PFNGLLINKPROGRAMARBPROC)lib3d_glGetProcAddress("glLinkProgramARB");
	glUseProgramObjectARB = (PFNGLUSEPROGRAMOBJECTARBPROC)lib3d_glGetProcAddress("glUseProgramObjectARB");
	glDetachObjectARB=(PFNGLDETACHOBJECTARBPROC)lib3d_glGetProcAddress("glDetachObjectARB");
	glDeleteObjectARB=(PFNGLDELETEOBJECTARBPROC)lib3d_glGetProcAddress("glDeleteObjectARB");
	glGetProgramivARB=(PFNGLGETPROGRAMIVARBPROC)lib3d_glGetProcAddress("glGetProgramivARB");
	glGetUniformLocationARB = (PFNGLGETUNIFORMLOCATIONARBPROC)lib3d_glGetProcAddress("glGetUniformLocationARB");
	glUniform4f = (PFNGLUNIFORM4FARBPROC)lib3d_glGetProcAddress("glUniform4fARB");
	glUniform4fv = (PFNGLUNIFORM4FVARBPROC)lib3d_glGetProcAddress("glUniform4fvARB");
	glUniform1i = (PFNGLUNIFORM1IARBPROC)lib3d_glGetProcAddress("glUniform1iARB");
	glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVARBPROC)lib3d_glGetProcAddress("glUniformMatrix4fvARB");
	glValidateProgramARB=(PFNGLVALIDATEPROGRAMARBPROC)lib3d_glGetProcAddress("glValidateProgramARB");
#endif
	G_PS2X=true;
#endif

#ifndef OPENGL_VERTEXPROGRAMS
#if (!defined(NOGETPROC))&&(!defined(LINUX))
	glVertexAttribPointerARB=(PFNGLVERTEXATTRIBPOINTERARBPROC) lib3d_glGetProcAddress("glVertexAttribPointerARB");			
	glEnableVertexAttribArrayARB=(PFNGLENABLEVERTEXATTRIBARRAYARBPROC) lib3d_glGetProcAddress("glEnableVertexAttribArrayARB");
	glDisableVertexAttribArrayARB=(PFNGLDISABLEVERTEXATTRIBARRAYARBPROC	) lib3d_glGetProcAddress("glDisableVertexAttribArrayARB");
#endif
#endif
#ifdef OPENGL_VERTEXPROGRAMS
#if (defined(NOGETPROC))||(defined(LINUX))
	VertexPrograms=G_VertexProgram=true;
	G_PS=true;
#else
	if (CheckExtension("GL_ARB_vertex_program",(char*) glGetString(GL_EXTENSIONS)))
	{
		VertexPrograms=G_VertexProgram=true;
		glProgramStringARB=(PFNGLPROGRAMSTRINGARBPROC) lib3d_glGetProcAddress("glProgramStringARB");
		glBindProgramARB=(PFNGLBINDPROGRAMARBPROC) lib3d_glGetProcAddress("glBindProgramARB");
		glDeleteProgramsARB=(PFNGLDELETEPROGRAMSARBPROC) lib3d_glGetProcAddress("glDeleteProgramsARB");
		glGenProgramsARB=(PFNGLGENPROGRAMSARBPROC) lib3d_glGetProcAddress("glGenProgramsARB");
		glProgramEnvParameter4fARB=(PFNGLPROGRAMENVPARAMETER4FARBPROC) lib3d_glGetProcAddress("glProgramEnvParameter4fARB");
		glIsProgramARB=(PFNGLISPROGRAMARBPROC) lib3d_glGetProcAddress("glIsProgramARB");
		glVertexAttribPointerARB=(PFNGLVERTEXATTRIBPOINTERARBPROC) lib3d_glGetProcAddress("glVertexAttribPointerARB");			
		glEnableVertexAttribArrayARB=(PFNGLENABLEVERTEXATTRIBARRAYARBPROC) lib3d_glGetProcAddress("glEnableVertexAttribArrayARB");
		glDisableVertexAttribArrayARB=(PFNGLDISABLEVERTEXATTRIBARRAYARBPROC	) lib3d_glGetProcAddress("glDisableVertexAttribArrayARB");
		if (!glGetProgramivARB) glGetProgramivARB=(PFNGLGETPROGRAMIVARBPROC) lib3d_glGetProcAddress("glGetProgramivARB");
		glGetProgramStringARB=(PFNGLGETPROGRAMSTRINGARBPROC) lib3d_glGetProcAddress("glGetProgramStringARB");
		glProgramLocalParameter4fARB=(PFNGLPROGRAMLOCALPARAMETER4FARBPROC) lib3d_glGetProcAddress("glProgramLocalParameter4fARB");
		
	}
	else
	{
		VertexPrograms=G_VertexProgram=false;
	}

	if (CheckExtension("GL_ARB_fragment_program",(char*) glGetString(GL_EXTENSIONS))) G_PS=true;
	else G_PS=false;
	int error=0;

	if (glGetProgramStringARB==NULL) error=1;
	if (glGetProgramivARB==NULL) error=1;
	if (glProgramStringARB==NULL) error=1;
	if (glBindProgramARB==NULL) error=1;
	if (glDeleteProgramsARB==NULL) error=1;
	if (glGenProgramsARB==NULL) error=1;
	if (glProgramEnvParameter4fARB==NULL) error=1;
	if (glIsProgramARB==NULL) error=1;
	if (glVertexAttribPointerARB==NULL) error=1;
	if (glEnableVertexAttribArrayARB==NULL) error=1;
	if (glDisableVertexAttribArrayARB==NULL) error=1;

	if (error) return -2;
#endif
#endif

#ifdef OPENGL_VBO
#if (!defined(NOGETPROC))&&(!defined(LINUX))
	glBindBufferARB = (PFNGLBINDBUFFERARBPROC) lib3d_glGetProcAddress("glBindBufferARB");
	glBufferDataARB = (PFNGLBUFFERDATAARBPROC) lib3d_glGetProcAddress("glBufferDataARB");
	glDeleteBuffersARB = (PFNGLDELETEBUFFERSARBPROC) lib3d_glGetProcAddress("glDeleteBuffersARB");
	glGenBuffersARB = (PFNGLGENBUFFERSARBPROC) lib3d_glGetProcAddress("glGenBuffersARB");
	glBufferSubDataARB = (PFNGLBUFFERSUBDATAARBPROC) lib3d_glGetProcAddress("glBufferSubDataARB");
#endif
#endif

#ifdef OPENGL_PBUFFERS
	wglGetExtensionsStringARB=(PFNWGLGETEXTENSIONSSTRINGARBPROC) lib3d_glGetProcAddress("wglGetExtensionsStringARB");

	hGLDC=wglGetCurrentDC();

	if (wglGetExtensionsStringARB)
	{
		if (CheckExtension("WGL_ARB_render_texture",(char*)wglGetExtensionsStringARB(hGLDC)))
		{
			wglChoosePixelFormatARB = (PFNWGLCHOOSEPIXELFORMATARBPROC) lib3d_glGetProcAddress("wglChoosePixelFormatARB");
			wglCreatePbufferARB = (PFNWGLCREATEPBUFFERARBPROC) lib3d_glGetProcAddress("wglCreatePbufferARB");
			wglDestroyPbufferARB = (PFNWGLDESTROYPBUFFERARBPROC) lib3d_glGetProcAddress("wglDestroyPbufferARB");
			wglGetPbufferDCARB = (PFNWGLGETPBUFFERDCARBPROC) lib3d_glGetProcAddress("wglGetPbufferDCARB");
			wglReleasePbufferDCARB = (PFNWGLRELEASEPBUFFERDCARBPROC) lib3d_glGetProcAddress("wglReleasePbufferDCARB");
			wglQueryPbufferARB = (PFNWGLQUERYPBUFFERARBPROC) lib3d_glGetProcAddress("wglQueryPbufferARB");
			wglBindTexImageARB = (PFNWGLBINDTEXIMAGEARBPROC)lib3d_glGetProcAddress("wglBindTexImageARB");
			wglReleaseTexImageARB = (PFNWGLRELEASETEXIMAGEARBPROC) lib3d_glGetProcAddress("wglReleaseTexImageARB");	

			int error=0;

			if (!wglChoosePixelFormatARB) error=1;
			if (!wglCreatePbufferARB) error=1;
			if (!wglDestroyPbufferARB) error=1;
			if (!wglGetPbufferDCARB) error=1;
			if (!wglReleasePbufferDCARB) error=1;
			if (!wglQueryPbufferARB) error=1;
			if (!wglBindTexImageARB) error=1;
			if (!wglReleaseTexImageARB) error=1;

			if (error) return -3;

		}
		else SecondarySurface=false;
	}
	else SecondarySurface=false;


	hGLRC = wglGetCurrentContext();

	if (SecondarySurface)
	{
		//NEW
		int texwidth=states(TEXTURE_MAX_WIDTH);
		for (n=0;n<nSecondaries;n++) { if (tile_secondarysurfaces[n]>texwidth) tile_secondarysurfaces[n]=texwidth; }

		for (n=0;n<nSecondaries;n++)
		{
			if (!pbufferInit(n)) SecondarySurface=false; 
		}

		for (n=0;n<nSecondaries;n++) wglShareLists(hGLRC,hPBufferRC[n]);

	}

	if (SecondarySurface)
	{
		for (n=0;n<nSecondaries;n++)
		{
			SetParams(API3D_RENDERTARGET,SECONDARY1+n);
			SetParams(API3D_ZBUFFER,ON);
			ClearVideoAndZBuffer();
		}
		SetParams(API3D_RENDERTARGET,PRIMARY);
	}
#else
#ifdef OPENGL_FRAMEBUFFERS
	
	SecondarySurface=false;


#if (!defined(NOGETPROC))&&(!defined(LINUX))
	glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC) lib3d_glGetProcAddress("glGenFramebuffers");
	glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC) lib3d_glGetProcAddress("glGenRenderbuffers");

	glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC) lib3d_glGetProcAddress("glDeleteFramebuffers");
	glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC) lib3d_glGetProcAddress("glDeleteRenderbuffers");

	glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC) lib3d_glGetProcAddress("glBindFramebuffer");
    glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC) lib3d_glGetProcAddress("glBlitFramebuffer");
	glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC) lib3d_glGetProcAddress("glBindRenderbuffer");
	glGenRenderBuffers = (PFNGLGENRENDERBUFFERSPROC) lib3d_glGetProcAddress("glGenRenderBuffers");
	glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC) lib3d_glGetProcAddress("glRenderbufferStorage");
	glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC) lib3d_glGetProcAddress("glFramebufferRenderbuffer");
	glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC) lib3d_glGetProcAddress("glFramebufferTexture2D");
	glDrawBuffers = (PFNGLDRAWBUFFERSPROC) lib3d_glGetProcAddress("glDrawBuffers");

	glStencilOpSeparate=(PFNGLSTENCILOPSEPARATEPROC) lib3d_glGetProcAddress("glStencilOpSeparate");
	glStencilFuncSeparate=(PFNGLSTENCILFUNCSEPARATEPROC) lib3d_glGetProcAddress("glStencilFuncSeparate");
	glStencilMaskSeparate=(PFNGLSTENCILMASKSEPARATEPROC) lib3d_glGetProcAddress("glStencilMaskSeparate");

	int error4=0;

	if (!glDrawBuffers) error4=1;
	if (!glGenRenderbuffers) error4=1;
	if (!glBindRenderbuffer) error4=1;
	if (!glGenFramebuffers) error4=1;
	if (!glBindFramebuffer) error4=1;
	if (!glGenRenderBuffers) error4=1;
	if (!glRenderbufferStorage) error4=1;
	if (!glFramebufferRenderbuffer) error4=1;
	if (!glFramebufferTexture2D) error4=1;
#endif	
	SecondarySurface=true;
#endif
	if (SecondarySurface)
	{
		//NEW
		int texwidth=states(TEXTURE_MAX_WIDTH);
		for (n=0;n<nSecondaries;n++) { if (tile_secondarysurfaces[n]>texwidth) tile_secondarysurfaces[n]=texwidth; }

		framesurfacetexture=false;

		for (int n=0;n<nSecondaries;n++)
			if (!setupRenderTexture(n,tile_secondarysurfaces[n],tile_secondarysurfaces[n])) return -1;

		SetParams(API3D_RENDERTARGET,PRIMARY);

	}
	
#endif
	return 0;
}
#else
#ifndef GLES

int C3DAPIBASE::openglstuff()
{
	int n;

    *states[TEXTURE_MAX_WIDTH]=4096;
    
	SecondarySurface=true;
	if (SecondarySurface)
	{
		if (initframebuffer)
		{
			for (n=0;n<nSecondaries;n++)
			{
				glDeleteFramebuffers(1, &FramebufferName[n]);
				if (!framesurfacetexture) glDeleteRenderbuffers(1, &depthrenderbuffer[n]);
				else glDeleteTextures(1, &depthrenderTexture[n]);
				glDeleteTextures(1, &renderedTexture[n]);

			}
		}

		initframebuffer=true;

		framesurfacetexture=false;

		//NEW
		int texwidth=states(TEXTURE_MAX_WIDTH);
		for (n=0;n<nSecondaries;n++) { if (tile_secondarysurfaces[n]>texwidth) tile_secondarysurfaces[n]=texwidth; }

		for (int n=0;n<nSecondaries;n++)
			if (!setupRenderTexture(n,tile_secondarysurfaces[n],tile_secondarysurfaces[n])) return -1;

		glBindFramebuffer(GL_FRAMEBUFFER, 0);
	}

	return 0;
}
#endif
#endif
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Clean secondary
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
void C3DAPIBASE::cleanRenderTexture(int nt)
{
	glDeleteTextures(1, &renderedTexture[nt]);

	if (!framesurfacetexture) glDeleteRenderbuffers(1, &depthrenderbuffer[nt]);
    else glDeleteTextures(1,&depthrenderTexture[nt]);
    
	glDeleteFramebuffers(1, &FramebufferName[nt]);
}
#endif

#if defined(API3D_DIRECT3D)||defined(API3D_DIRECT3D9)
void C3DAPIBASE::cleanRenderTexture(int nt)
{
	if (D3DTextureSecondary[nt]) D3DTextureSecondary[nt]->Release();
	if (D3DSecondary[nt]) D3DSecondary[nt]->Release();
	if (D3DSecondaryZbuffer[nt]) D3DSecondaryZbuffer[nt]->Release();
}
#endif

#if defined(API3D_DIRECT3D10)
void C3DAPIBASE::cleanRenderTexture(int nt)
{
	renderTargetTexture[nt]->Release();
	renderSndTargetView[nt]->Release();
	shaderResourceView[nt]->Release();
	shaderResourceViewDepth[nt]->Release();
	renderDepthStencilBuffer[nt]->Release();
	renderDepthStencilView[nt]->Release();
}
#endif

#if defined(API3D_DIRECT3D11)
void C3DAPIBASE::cleanRenderTexture(int nt)
{
	if (renderTargetTexture[nt]) renderTargetTexture[nt]->Release();
	if (renderSndTargetView[nt]) renderSndTargetView[nt]->Release();
	if (shaderResourceView[nt]) shaderResourceView[nt]->Release();
	if (shaderResourceViewDepth[nt]) shaderResourceViewDepth[nt]->Release();
	if (renderDepthStencilBuffer[nt]) renderDepthStencilBuffer[nt]->Release();
	if (renderDepthStencilView[nt]) renderDepthStencilView[nt]->Release();
}
#endif

#if defined(API3D_METAL)
void C3DAPIBASE::cleanRenderTexture(int nt)
{
	MTLCleanRenderToTexture(nt);
}
#endif

#ifdef API3D_DIRECT3D12
void C3DAPIBASE::cleanRenderTexture(int nt)
{
	if (renderTargetTexture[nt]) renderTargetTexture[nt]->Release();
	if (renderDepthStencilBuffer[nt]) renderDepthStencilBuffer[nt]->Release();
}
#endif


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		GL
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)

bool C3DAPIBASE::setupRenderTexture(int nt,int w,int h)
{
    int ww=w;
	int hh=h;

	if (LIB3D_GL_VERSION_EXPOSANT)
	{
		ww=Exposantde2(w);
		hh=Exposantde2(h);
	}

	tile_secondarysurfacesW[nt]=ww;
	tile_secondarysurfacesH[nt]=hh;


#ifdef RISCV

    glGenFramebuffers(1, &FramebufferName[nt]);
    glBindFramebuffer(GL_FRAMEBUFFER, FramebufferName[nt]);
    
    glGenTextures(1, &renderedTexture[nt]);
    glBindTexture(GL_TEXTURE_2D, renderedTexture[nt]);
    glTexImage2D(GL_TEXTURE_2D, 0,GL_RGBA, ww, hh, 0,GL_RGBA, GL_UNSIGNED_BYTE, 0);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    
    glGenTextures(1, &depthrenderTexture[nt]);
    glBindTexture(GL_TEXTURE_2D, depthrenderTexture[nt]);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, ww, hh, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, 0);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthrenderTexture[nt],0);
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depthrenderTexture[nt],0);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, renderedTexture[nt],0);

	GLenum status0 = glCheckFramebufferStatus(GL_FRAMEBUFFER);

	if (status0!=GL_FRAMEBUFFER_COMPLETE) 
	{
		glGenRenderbuffers(1, &depthrenderbuffer[nt]);
		glBindRenderbuffer(GL_RENDERBUFFER, depthrenderbuffer[nt]);
	
		glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, ww,hh);
		glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer[nt]);
		glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer[nt]);
		glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, renderedTexture[nt], 0);
	
		GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);

		if (status!=GL_FRAMEBUFFER_COMPLETE) 
		{
			glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, ww,hh);
			glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer[nt]);
			glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, renderedTexture[nt], 0);
		}
	}
	else framesurfacetexture=true;
#else

#if !defined(GLES)&&!defined(GLES20)
	
	glGenFramebuffers(1, &FramebufferName[nt]);
	glBindFramebuffer(GL_FRAMEBUFFER, FramebufferName[nt]);

	glGenTextures(1, &renderedTexture[nt]);
 	glBindTexture(GL_TEXTURE_2D, renderedTexture[nt]);
	glTexImage2D(GL_TEXTURE_2D, 0,GL_RGBA, ww, hh, 0,GL_RGBA, GL_UNSIGNED_BYTE, 0);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

//	glGenRenderbuffers(1, &depthrenderbuffer[nt]);
//	glBindRenderbuffer(GL_RENDERBUFFER, depthrenderbuffer[nt]);
    
    glGenTextures(1, &depthrenderTexture[nt]);
    glBindTexture(GL_TEXTURE_2D, depthrenderTexture[nt]);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, ww, hh, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, 0);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, depthrenderTexture[nt], 0);
    
	//glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, ww, hh);
	//glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer[nt]);
    //glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer[nt]);
    

	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, renderedTexture[nt], 0);


	framesurfacetexture=true;

//	GLenum DrawBuffers[2] = {GL_COLOR_ATTACHMENT0};
//	glDrawBuffers(1, DrawBuffers);
#else
#ifdef WEBASM
    
    glGenFramebuffers(1, &FramebufferName[nt]);
    glBindFramebuffer(GL_FRAMEBUFFER, FramebufferName[nt]);
    
    glGenTextures(1, &renderedTexture[nt]);
    glBindTexture(GL_TEXTURE_2D, renderedTexture[nt]);
    glTexImage2D(GL_TEXTURE_2D, 0,GL_RGBA, ww, hh, 0,GL_RGBA, GL_UNSIGNED_BYTE, 0);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    
    glGenRenderbuffers(1, &depthrenderbuffer[nt]);
    glBindRenderbuffer(GL_RENDERBUFFER, depthrenderbuffer[nt]);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, ww,hh);
    //glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8_OES, w,h);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer[nt]);
    //glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer[nt]);
    
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, renderedTexture[nt], 0);
#else
#ifdef IOS
    
    glGenFramebuffers(1, &FramebufferName[nt]);
    glBindFramebuffer(GL_FRAMEBUFFER, FramebufferName[nt]);
            
    // depth
    glGenRenderbuffers(1, &depthrenderbuffer[nt]);
    glBindRenderbuffer(GL_RENDERBUFFER, depthrenderbuffer[nt]);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8_OES, ww,hh);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer[nt]);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer[nt]);

    // texture
    glGenTextures(1, &renderedTexture[nt]);
    glBindTexture(GL_TEXTURE_2D, renderedTexture[nt]);
            
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexImage2D(GL_TEXTURE_2D, 0,GL_RGBA, ww, hh, 0,GL_RGBA, GL_UNSIGNED_BYTE, 0);
            
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, renderedTexture[nt], 0);
            
#else
    
	glGenFramebuffers(1, &FramebufferName[nt]);
	glBindFramebuffer(GL_FRAMEBUFFER, FramebufferName[nt]);
/*
	glGenRenderbuffers(1, &depthrenderbuffer[nt]);
	glBindRenderbuffer(GL_RENDERBUFFER, depthrenderbuffer[nt]);
*/
//  glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT16, w, h);
//  glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer[nt]);


#ifdef GL_DEPTH24_STENCIL8_OES  // oes

    glGenTextures(1, &depthrenderTexture[nt]);
    glBindTexture(GL_TEXTURE_2D, depthrenderTexture[nt]);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8_OES, ww, hh, 0, GL_DEPTH_STENCIL_OES, GL_UNSIGNED_INT_24_8_OES, 0);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_TEXTURE_2D, depthrenderTexture[nt], 0);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthrenderTexture[nt], 0);
	
#else // normal
    glGenTextures(1, &depthrenderTexture[nt]);
    glBindTexture(GL_TEXTURE_2D, depthrenderTexture[nt]);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH24_STENCIL8, ww, hh, 0, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, 0);

    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);

    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, depthrenderTexture[nt], 0);
#endif

	framesurfacetexture=true;

/*
#ifdef GL_DEPTH24_STENCIL8_OES
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8_OES, ww,hh);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer[nt]);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer[nt]);
#else
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, ww,hh);
	glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depthrenderbuffer[nt]);
#endif
/**/
	glGenTextures(1, &renderedTexture[nt]);
	glBindTexture(GL_TEXTURE_2D, renderedTexture[nt]);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexImage2D(GL_TEXTURE_2D, 0,GL_RGBA, ww, hh, 0,GL_RGBA, GL_UNSIGNED_BYTE, 0);

	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, renderedTexture[nt], 0);

#endif
#endif

    GLenum OStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (OStatus!=GL_FRAMEBUFFER_COMPLETE) SecondarySurface=false;

#endif  // WEBASM
#endif

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
    
	return SecondarySurface;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		DX8
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#ifdef VR_SCREENPROJ
void C3DAPIBASE::setupRenderTextureSPVR(int w,int h)
{
	SPVRw=w;
	SPVRh=h;

	glGenFramebuffers(1, &FramebufferNameSPVR);
	glBindFramebuffer(GL_FRAMEBUFFER, FramebufferNameSPVR);

	glGenTextures(1, &renderedTextureSPVR);
 	glBindTexture(GL_TEXTURE_2D, renderedTextureSPVR);
	glTexImage2D(GL_TEXTURE_2D, 0,GL_RGBA, w, h, 0,GL_RGBA, GL_UNSIGNED_BYTE, 0);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

	glGenRenderbuffers(1, &depthrenderbufferSPVR);
	glBindRenderbuffer(GL_RENDERBUFFER, depthrenderbufferSPVR);
	glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, w, h);
	glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthrenderbufferSPVR);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depthrenderbufferSPVR);
    
	glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, renderedTextureSPVR, 0);

    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}

#endif
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		DX8
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#ifdef API3D_DIRECT3D
bool C3DAPIBASE::setupRenderTexture(int nt,int w,int h)
{
	tile_secondarysurfacesW[nt]=w;
	tile_secondarysurfacesH[nt]=h;

	if (D3DDevice->CreateTexture(w,h,1,D3DUSAGE_RENDERTARGET,SecondaryFormat,D3DPOOL_DEFAULT,&D3DTextureSecondary[nt])==D3D_OK)
	{
		if (D3DTextureSecondary[nt]->GetSurfaceLevel(0,&D3DSecondary[nt])==D3D_OK)
		{
			if SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,SurfaceBackFormat,SecondaryFormat,D3DFMT_D24S8)) SecondaryFormatZ=D3DFMT_D24S8;
			else
			if SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,SurfaceBackFormat,SecondaryFormat,D3DFMT_D32)) SecondaryFormatZ=D3DFMT_D32;
			else
			if SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,SurfaceBackFormat,SecondaryFormat,D3DFMT_D24X8)) SecondaryFormatZ=D3DFMT_D24X8;
			else
			if SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,SurfaceBackFormat,SecondaryFormat,D3DFMT_D16)) SecondaryFormatZ=D3DFMT_D16;
			else SecondarySurface=false;

			if (SecondarySurface)
			{
				if (D3DDevice->CreateDepthStencilSurface(w,h,
														SecondaryFormatZ,D3DMULTISAMPLE_NONE,
														&D3DSecondaryZbuffer[nt])!=D3D_OK) SecondarySurface=false;
			}
		}
		else SecondarySurface=false;
	}
	else SecondarySurface=false;

	SecondaryViewport[nt].Width=w;
	SecondaryViewport[nt].Height=h;
	SecondaryViewport[nt].X=0;
	SecondaryViewport[nt].Y=0;
	SecondaryViewport[nt].MinZ=0.0f;
	SecondaryViewport[nt].MaxZ=1.0f;

	return SecondarySurface;
}
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		DX9
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#ifdef API3D_DIRECT3D9
bool C3DAPIBASE::setupRenderTexture(int nt,int w,int h)
{
	tile_secondarysurfacesW[nt]=w;
	tile_secondarysurfacesH[nt]=h;

	if (D3DDevice->CreateTexture(w,h,1,D3DUSAGE_RENDERTARGET,SecondaryFormat,D3DPOOL_DEFAULT,&D3DTextureSecondary[nt],NULL)==D3D_OK)
	{
		if (D3DTextureSecondary[nt]->GetSurfaceLevel(0,&D3DSecondary[nt])==D3D_OK)
		{
			if SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,SurfaceBackFormat,SecondaryFormat,D3DFMT_D24S8)) SecondaryFormatZ=D3DFMT_D24S8;
			else
			if SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,SurfaceBackFormat,SecondaryFormat,D3DFMT_D32)) SecondaryFormatZ=D3DFMT_D32;
			else
			if SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,SurfaceBackFormat,SecondaryFormat,D3DFMT_D24X8)) SecondaryFormatZ=D3DFMT_D24X8;
			else
			if SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,SurfaceBackFormat,SecondaryFormat,D3DFMT_D16)) SecondaryFormatZ=D3DFMT_D16;
			else SecondarySurface=false;

			if (SecondarySurface)
			if (D3DDevice->CreateDepthStencilSurface(w,h,SecondaryFormatZ,D3DMULTISAMPLE_NONE,0,TRUE,&D3DSecondaryZbuffer[nt],NULL)==D3D_OK)
			{
				SecondaryViewport[nt].Width=w;
				SecondaryViewport[nt].Height=h;
				SecondaryViewport[nt].X=0;
				SecondaryViewport[nt].Y=0;
				SecondaryViewport[nt].MinZ=0.0f;
				SecondaryViewport[nt].MaxZ=1.0f;
			}
			else 
			{
				SecondarySurface=false;
			}
		}
		else 
		{
			SecondarySurface=false;
		}
	}
	else SecondarySurface=false;

	return SecondarySurface;
}
#endif

#ifdef API3D_DIRECT3D10
bool C3DAPIBASE::setupRenderTexture(int nt,int w,int h)
{
	D3D10_TEXTURE2D_DESC textureDesc;
	D3D10_RENDER_TARGET_VIEW_DESC renderTargetViewDesc;
	D3D10_SHADER_RESOURCE_VIEW_DESC shaderResourceViewDesc;

	tile_secondarysurfacesW[nt]=w;
	tile_secondarysurfacesH[nt]=h;

	ZeroMemory(&textureDesc, sizeof(textureDesc));
	textureDesc.Width = w;
	textureDesc.Height = h;
	textureDesc.MipLevels = 1;
	textureDesc.ArraySize = 1;
	textureDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	textureDesc.SampleDesc.Count = 1;
	textureDesc.SampleDesc.Quality = 0;
	textureDesc.Usage = D3D10_USAGE_DEFAULT;
	textureDesc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
	textureDesc.CPUAccessFlags = 0;
	textureDesc.MiscFlags = 0;
	if (FAILED(device->CreateTexture2D(&textureDesc, NULL, &renderTargetTexture[nt]))) return false;
	
	ZeroMemory(&renderTargetViewDesc,sizeof(renderTargetViewDesc));
	renderTargetViewDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	renderTargetViewDesc.ViewDimension = D3D10_RTV_DIMENSION_TEXTURE2D;
	renderTargetViewDesc.Texture2D.MipSlice = 0;
	if(FAILED(device->CreateRenderTargetView(renderTargetTexture[nt], &renderTargetViewDesc, &renderSndTargetView[nt]))) return false;

	ZeroMemory(&shaderResourceViewDesc,sizeof(shaderResourceViewDesc));
	shaderResourceViewDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	shaderResourceViewDesc.ViewDimension = D3D10_SRV_DIMENSION_TEXTURE2D;
	shaderResourceViewDesc.Texture2D.MostDetailedMip = 0;
	shaderResourceViewDesc.Texture2D.MipLevels = 1;
	if (FAILED(device->CreateShaderResourceView(renderTargetTexture[nt], &shaderResourceViewDesc, &shaderResourceView[nt]))) return false;	// shader texture color

	ZeroMemory(&rdepthBufferDesc[nt], sizeof(rdepthBufferDesc[nt]));
	rdepthBufferDesc[nt].Width = w;
	rdepthBufferDesc[nt].Height = h;
	rdepthBufferDesc[nt].MipLevels = 1;
	rdepthBufferDesc[nt].ArraySize = 1;
	rdepthBufferDesc[nt].Format = DXGI_FORMAT_R24G8_TYPELESS;
	rdepthBufferDesc[nt].SampleDesc.Count = 1;
	rdepthBufferDesc[nt].SampleDesc.Quality = 0;
	rdepthBufferDesc[nt].Usage = D3D10_USAGE_DEFAULT;
	rdepthBufferDesc[nt].BindFlags = D3D10_BIND_DEPTH_STENCIL | D3D10_BIND_SHADER_RESOURCE;
	rdepthBufferDesc[nt].CPUAccessFlags = 0;
	rdepthBufferDesc[nt].MiscFlags = 0;
	if (FAILED(device->CreateTexture2D(&rdepthBufferDesc[nt], NULL, &renderDepthStencilBuffer[nt]))) return false;

	ZeroMemory(&rdepthStencilViewDesc[nt], sizeof(rdepthStencilViewDesc[nt]));
	rdepthStencilViewDesc[nt].Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	rdepthStencilViewDesc[nt].ViewDimension = D3D10_DSV_DIMENSION_TEXTURE2D;
	rdepthStencilViewDesc[nt].Texture2D.MipSlice = 0;
	if (FAILED(device->CreateDepthStencilView(renderDepthStencilBuffer[nt], &rdepthStencilViewDesc[nt], &renderDepthStencilView[nt]))) return false;

	ZeroMemory(&shaderResourceViewDesc,sizeof(shaderResourceViewDesc));
	shaderResourceViewDesc.Format = DXGI_FORMAT_R24_UNORM_X8_TYPELESS;	
	shaderResourceViewDesc.ViewDimension = D3D10_SRV_DIMENSION_TEXTURE2D;
	shaderResourceViewDesc.Texture2D.MostDetailedMip = 0;
	shaderResourceViewDesc.Texture2D.MipLevels = 1;
	if (FAILED(device->CreateShaderResourceView(renderDepthStencilBuffer[nt], &shaderResourceViewDesc, &shaderResourceViewDepth[nt]))) return false;	// shader texture depth


	SndViewport[nt].Width = w;
    SndViewport[nt].Height = h;
    SndViewport[nt].MinDepth = 0.0f;
    SndViewport[nt].MaxDepth = 1.0f;
    SndViewport[nt].TopLeftX = 0;
    SndViewport[nt].TopLeftY = 0;

	return true;
}
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#ifdef API3D_DIRECT3D11
bool C3DAPIBASE::setupRenderTexture(int nt,int w,int h)
{
	D3D11_TEXTURE2D_DESC textureDesc;
	D3D11_RENDER_TARGET_VIEW_DESC renderTargetViewDesc;
	D3D11_SHADER_RESOURCE_VIEW_DESC shaderResourceViewDesc;

	tile_secondarysurfacesW[nt]=w;
	tile_secondarysurfacesH[nt]=h;

	ZeroMemory(&textureDesc, sizeof(textureDesc));
	textureDesc.Width = w;
	textureDesc.Height = h;
	textureDesc.MipLevels = 1;
	textureDesc.ArraySize = 1;
	textureDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	textureDesc.SampleDesc.Count = 1;
	textureDesc.SampleDesc.Quality = 0;
	textureDesc.Usage = D3D11_USAGE_DEFAULT;
	textureDesc.BindFlags = D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE;
	textureDesc.CPUAccessFlags = 0;
	textureDesc.MiscFlags = 0;
	if (FAILED(device->CreateTexture2D(&textureDesc, NULL, &renderTargetTexture[nt]))) return false;
	
	ZeroMemory(&renderTargetViewDesc,sizeof(renderTargetViewDesc));
	renderTargetViewDesc.Format = textureDesc.Format;
	renderTargetViewDesc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
	renderTargetViewDesc.Texture2D.MipSlice = 0;
	if(FAILED(device->CreateRenderTargetView(renderTargetTexture[nt], &renderTargetViewDesc, &renderSndTargetView[nt]))) return false;

	ZeroMemory(&shaderResourceViewDesc,sizeof(shaderResourceViewDesc));
	shaderResourceViewDesc.Format = textureDesc.Format;
	shaderResourceViewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
	shaderResourceViewDesc.Texture2D.MostDetailedMip = 0;
	shaderResourceViewDesc.Texture2D.MipLevels = 1;
	if (FAILED(device->CreateShaderResourceView(renderTargetTexture[nt], &shaderResourceViewDesc, &shaderResourceView[nt]))) return false;	// shader texture color

	ZeroMemory(&rdepthBufferDesc[nt], sizeof(rdepthBufferDesc[nt]));
	rdepthBufferDesc[nt].Width = w;
	rdepthBufferDesc[nt].Height = h;
	rdepthBufferDesc[nt].MipLevels = 1;
	rdepthBufferDesc[nt].ArraySize = 1;

	// DXGI_FORMAT_R24_UNORM_X8_TYPELESS
	// DXGI_FORMAT_X24_TYPELESS_G8_UINT
	// DXGI_FORMAT_R16_TYPELESS
  	// DXGI_FORMAT_R32G8X24_TYPELESS
  	// DXGI_FORMAT_D32_FLOAT_S8X24_UINT
  	// DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS
  	// DXGI_FORMAT_X32_TYPELESS_G8X24_UINT
	// DXGI_FORMAT_D24_UNORM_S8_UINT

	if (StencilBuffer) rdepthBufferDesc[nt].Format = DXGI_FORMAT_R24G8_TYPELESS;
	else rdepthBufferDesc[nt].Format = DXGI_FORMAT_R16_TYPELESS;
	
	rdepthBufferDesc[nt].SampleDesc.Count = 1;
	rdepthBufferDesc[nt].SampleDesc.Quality = 0;
	rdepthBufferDesc[nt].Usage = D3D11_USAGE_DEFAULT;
	rdepthBufferDesc[nt].BindFlags = D3D11_BIND_DEPTH_STENCIL | D3D11_BIND_SHADER_RESOURCE;
	rdepthBufferDesc[nt].CPUAccessFlags = 0;
	rdepthBufferDesc[nt].MiscFlags = 0;
	if (FAILED(device->CreateTexture2D(&rdepthBufferDesc[nt], NULL, &renderDepthStencilBuffer[nt]))) return false;

	ZeroMemory(&rdepthStencilViewDesc[nt], sizeof(rdepthStencilViewDesc[nt]));

	if (StencilBuffer) rdepthStencilViewDesc[nt].Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	else rdepthStencilViewDesc[nt].Format = DXGI_FORMAT_D16_UNORM;

	rdepthStencilViewDesc[nt].ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;
	rdepthStencilViewDesc[nt].Texture2D.MipSlice = 0;
	if (FAILED(device->CreateDepthStencilView(renderDepthStencilBuffer[nt], &rdepthStencilViewDesc[nt], &renderDepthStencilView[nt]))) return false;

	ZeroMemory(&shaderResourceViewDesc,sizeof(shaderResourceViewDesc));
	if (StencilBuffer) shaderResourceViewDesc.Format = DXGI_FORMAT_R24_UNORM_X8_TYPELESS;
	else shaderResourceViewDesc.Format = DXGI_FORMAT_R16_FLOAT;
	shaderResourceViewDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
	shaderResourceViewDesc.Texture2D.MostDetailedMip = 0;
	shaderResourceViewDesc.Texture2D.MipLevels = 1;
	if (FAILED(device->CreateShaderResourceView(renderDepthStencilBuffer[nt], &shaderResourceViewDesc, &shaderResourceViewDepth[nt]))) return false;	// shader texture depth

	SndViewport[nt].Width =(float) w;
    SndViewport[nt].Height =(float) h;
    SndViewport[nt].MinDepth = 0.0f;
    SndViewport[nt].MaxDepth = 1.0f;
    SndViewport[nt].TopLeftX = 0;
    SndViewport[nt].TopLeftY = 0;

	return true;
}
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		DX12
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#ifdef API3D_DIRECT3D12
bool C3DAPIBASE::setupRenderTexture(int nt,int w,int h)
{
	tile_secondarysurfacesW[nt]=w;
	tile_secondarysurfacesH[nt]=h;
	
	D3D12_CLEAR_VALUE zval = {};
	zval.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	zval.DepthStencil.Depth = 1.0f;
	zval.DepthStencil.Stencil = 0;

	D3D12_CLEAR_VALUE col = {};
	col.Format=DXGI_FORMAT_R8G8B8A8_UNORM;
	col.Color[0]=0;
	col.Color[1]=0;
	col.Color[2]=0;
	col.Color[3]=0;

	CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(rtvHeap->GetCPUDescriptorHandleForHeapStart());
	CD3DX12_CPU_DESCRIPTOR_HANDLE dsvHandle(dsvHeap->GetCPUDescriptorHandleForHeapStart());

	rtvHandle.Offset(2+nt, rtvDescriptorSize);
	dsvHandle.Offset(2+nt, dsvDescriptorSize);
	
	D3D12_RESOURCE_DESC textureDesc = CD3DX12_RESOURCE_DESC::Tex2D(
		swapChainDesc.Format,
		w,h,
		1u,1u,
		swapChainDesc.SampleDesc.Count,swapChainDesc.SampleDesc.Quality,
		D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET,D3D12_TEXTURE_LAYOUT_UNKNOWN,0u);
	
	device->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),D3D12_HEAP_FLAG_NONE,&textureDesc,
									D3D12_RESOURCE_STATE_RENDER_TARGET,&col,IID_PPV_ARGS(&renderTargetTexture[nt]));

	device->CreateRenderTargetView(renderTargetTexture[nt], nullptr, rtvHandle);

	renderSndTargetView[nt]=rtvHandle;

	
	D3D12_RESOURCE_DESC zbufDesc = {};
	zbufDesc.MipLevels = 1;
	zbufDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	zbufDesc.Width = w;
	zbufDesc.Height = h;
	zbufDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
	zbufDesc.DepthOrArraySize = 1;
	zbufDesc.SampleDesc.Count = 1;
	zbufDesc.SampleDesc.Quality = 0;
	zbufDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
		
	device->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),D3D12_HEAP_FLAG_NONE,&zbufDesc,
							D3D12_RESOURCE_STATE_DEPTH_WRITE,&zval,IID_PPV_ARGS(&renderDepthStencilBuffer[nt]));

	device->CreateDepthStencilView(renderDepthStencilBuffer[nt],nullptr,dsvHandle);
	
	renderDepthStencilView[nt]=dsvHandle;

    D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc = {};
    srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
    srvDesc.Format = textureDesc.Format;
    srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
    srvDesc.Texture2D.MipLevels = 1;

	shaderResourceView[nt]=HandleContainer.GetNewHeapHandleNotRecycle();
    device->CreateShaderResourceView(renderTargetTexture[nt], &srvDesc, shaderResourceView[nt].GetCPUHandle());


    D3D12_SHADER_RESOURCE_VIEW_DESC dsvDesc = {};
    dsvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
    dsvDesc.Format = DXGI_FORMAT_R24_UNORM_X8_TYPELESS;
    dsvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
    dsvDesc.Texture2D.MipLevels = 1;

	shaderResourceViewDepth[nt]=HandleContainer.GetNewHeapHandleNotRecycle();
    device->CreateShaderResourceView(renderDepthStencilBuffer[nt], &dsvDesc, shaderResourceViewDepth[nt].GetCPUHandle());

	SndViewport[nt].Width =(float) w;
    SndViewport[nt].Height =(float) h;
    SndViewport[nt].MinDepth = 0.0f;
    SndViewport[nt].MaxDepth = 1.0f;
    SndViewport[nt].TopLeftX = 0;
    SndViewport[nt].TopLeftY = 0;

	SndScissorRect[nt]=CD3DX12_RECT(0, 0, static_cast<LONG>(w), static_cast<LONG>(h));

	return true;
}
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		METAL
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#ifdef API3D_METAL
bool C3DAPIBASE::setupRenderTexture(int nt,int w,int h)
{
#ifdef IOS
    tile_secondarysurfacesW[nt]=Exposantde2(w);
    tile_secondarysurfacesH[nt]=Exposantde2(h);
    if (tile_secondarysurfacesW[nt]>4096) tile_secondarysurfacesW[nt]=4096;
    if (tile_secondarysurfacesH[nt]>4096) tile_secondarysurfacesH[nt]=4096;
#else
    tile_secondarysurfacesW[nt]=w;
    tile_secondarysurfacesH[nt]=h;
#endif
    
    MTLSetupRenderToTexture(nt,tile_secondarysurfacesW[nt],tile_secondarysurfacesH[nt]);
    
	SndViewport[nt].Width =(float) tile_secondarysurfacesW[nt];
    SndViewport[nt].Height =(float) tile_secondarysurfacesH[nt];
    SndViewport[nt].MinDepth = 0.0f;
    SndViewport[nt].MaxDepth = 1.0f;
    SndViewport[nt].TopLeftX = 0;
    SndViewport[nt].TopLeftY = 0;

	return true;
}
#endif


#ifdef API3D_DIRECT3D12

/////////////////////////////////////////////////////////////////////////////////////////////////////////
int C3DAPIBASE::GetCrcStates()
{
    if (!dirtyCRCState) return CRCState;
    
    int crc=0;
       
    // BLEND
    if (blendStateDesc.RenderTarget[0].BlendEnable)
    {
        crc=256;
        
        int src=0;
        switch (blendStateDesc.RenderTarget[0].SrcBlend)
        {
            case D3D12_BLEND_ZERO: src=1; break;
            case D3D12_BLEND_ONE: src=2; break;
            case D3D12_BLEND_SRC_COLOR: src=3; break;
            case D3D12_BLEND_INV_SRC_COLOR: src=4; break;
            case D3D12_BLEND_SRC_ALPHA: src=5; break;
            case D3D12_BLEND_INV_SRC_ALPHA: src=6; break;
            case D3D12_BLEND_DEST_ALPHA: src=7; break;
            case D3D12_BLEND_INV_DEST_ALPHA: src=8; break;
            case D3D12_BLEND_DEST_COLOR: src=9; break;
            case D3D12_BLEND_INV_DEST_COLOR: src=10; break;
        };
        
        int dst=0;
        switch (blendStateDesc.RenderTarget[0].DestBlend)
        {
            case D3D12_BLEND_ZERO: dst=1; break;
            case D3D12_BLEND_ONE: dst=2; break;
            case D3D12_BLEND_SRC_COLOR: dst=3; break;
            case D3D12_BLEND_INV_SRC_COLOR: dst=4; break;
            case D3D12_BLEND_SRC_ALPHA: dst=5; break;
            case D3D12_BLEND_INV_SRC_ALPHA: dst=6; break;
            case D3D12_BLEND_DEST_ALPHA: dst=7; break;
            case D3D12_BLEND_INV_DEST_ALPHA: dst=8; break;
            case D3D12_BLEND_DEST_COLOR: dst=9; break;
            case D3D12_BLEND_INV_DEST_COLOR: dst=10; break;
        };

        crc+=src+16*dst;
    }
    
    // ZBUFFER

    if (depthStencilDesc.DepthEnable) crc+=1024;
    if (depthStencilDesc.DepthWriteMask == D3D12_DEPTH_WRITE_MASK_ALL) crc+=512;
    if (depthStencilDesc.DepthFunc == D3D12_COMPARISON_FUNC_GREATER) crc+=2048;
    if (depthStencilDesc.DepthFunc == D3D12_COMPARISON_FUNC_GREATER_EQUAL) crc+=2048;

    // CULL

    if (rasterDesc.CullMode == D3D12_CULL_MODE_FRONT) crc+=4096;
    if (rasterDesc.CullMode == D3D12_CULL_MODE_BACK) crc+=8192;
    
    if (depthStencilDesc.StencilEnable)
    {
		int a1=depthStencilDesc.FrontFace.StencilDepthFailOp;
		int a2=depthStencilDesc.FrontFace.StencilFunc;
		int a3=depthStencilDesc.BackFace.StencilFunc;
		int a4=0;
		if (depthStencilDesc.FrontFace.StencilPassOp==D3D12_STENCIL_OP_KEEP) a4=1;

		int aa=8*32768*(a1+a2*8+a3*8*8+a4*8*8*8);
		crc+=aa;
    }
    
    int stencil=0;
	switch (states(RENDER_TARGET_OPTIONS))
	{
	case ZBUFFER:
		stencil=1;
		break;
	case BOTH:
		stencil=2;
		break;
	case BOTH_WRITE_Z:
		stencil=3;
		break;
	case STENCIL:
		stencil=4;
		break;
	case STENCIL_NO_ZTEST:
		stencil=5;
		break;
	};

    crc+=32768*stencil;

	if (ZBiasComment!=0) crc+=16384;

	if (vbdraw_line) crc+=32768;
    
    CRCState=crc;
    dirtyCRCState=false;

    return crc;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::CleanPipelines()
{
	CVertexBuffer **pvb=VBVP.GetFirst();
	while (pvb)
	{
		ID3D12PipelineState** p_pipe=(*pvb)->pipelines.GetFirst();
		while (p_pipe)
		{
			(*p_pipe)->Release();
			p_pipe=(*pvb)->pipelines.DeleteAndGetNext();
		}

		pvb=VBVP.GetNext();
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
ID3D12GraphicsCommandList* C3DAPIBASE::CreatePipelineState(CVertexBuffer *vb,ID3D12GraphicsCommandList* cmdbase,int p,D3D12_INPUT_ELEMENT_DESC *layout,UINT nblayout,bool lines)
{
    ID3DFXEffect *fx=vb->effect;
    ID3D12GraphicsCommandList* cmdres=NULL;
	ID3D12GraphicsCommandList* cmd=cmdbase;
	ID3D12PipelineState* pipe;
	ID3D12PipelineState** p_pipe=NULL;

	int crc=GetCrcStates();
	if (crc>=0)
	{
		p_pipe=vb->pipelines(crc);

		if (p_pipe)
		{
			pipe=*p_pipe;

			if ((previouspipe==pipe)&&(cmd))
			{
				if (viewportmodified)
				{
					cmd->RSSetViewports(1, &ViewportActual);
					cmd->RSSetScissorRects(1, &ScissorRectActual);
					viewportmodified=false;
				}

				return cmd;
			}
			else
			{
				/*
				if (cmd)
				{
					cmd->Close();
					ID3D12CommandList* list[] = { cmd };
					commandQueue->ExecuteCommandLists(1, list);
				}
				/**/
				if (cmd) cmdres=cmd;
				else
				{
					device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, pipe, IID_PPV_ARGS(&cmdres));
					cmdres->SetDescriptorHeaps(1,&HandleContainer.DescriptorHeap);
				}
			}
		}
		else
		{
			/*
			if (cmd)
			{
				cmd->Close();
				ID3D12CommandList* list[] = { cmd };
				commandQueue->ExecuteCommandLists(1, list);
			}
			/**/
			GlobalPipelineDesc.InputLayout = { layout, nblayout };
			GlobalPipelineDesc.pRootSignature = vb->signature;
			GlobalPipelineDesc.VS = CD3DX12_SHADER_BYTECODE(fx->_vertexShader[p]);
			GlobalPipelineDesc.PS = CD3DX12_SHADER_BYTECODE(fx->_pixelShader[p]);
			//GlobalPipelineDesc.CachedPSO = {};
			GlobalPipelineDesc.SampleMask = UINT_MAX;
			if (!lines) GlobalPipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
			else GlobalPipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE;
			GlobalPipelineDesc.NumRenderTargets = 1;
			GlobalPipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
			GlobalPipelineDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
			GlobalPipelineDesc.SampleDesc.Count = 1;
    
			device->CreateGraphicsPipelineState(&GlobalPipelineDesc, IID_PPV_ARGS(&pipe));
			
			vb->pipelines.Add(crc,pipe);

			nbpiplelines++;

			if (cmd) cmdres=cmd;
			else
			{
				device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, pipe, IID_PPV_ARGS(&cmdres));
				cmdres->SetDescriptorHeaps(1,&HandleContainer.DescriptorHeap);
			}
		}		
		
		actualpipeline=pipe;
	}
	else
	{
		/*
		if (cmd)
		{
			cmd->Close();
			ID3D12CommandList* list[] = { cmd };
			commandQueue->ExecuteCommandLists(1, list);
		}
		/**/
		GlobalPipelineDesc.InputLayout = { layout, nblayout };
		GlobalPipelineDesc.pRootSignature = vb->signature;
		GlobalPipelineDesc.VS = CD3DX12_SHADER_BYTECODE(fx->_vertexShader[p]);
		GlobalPipelineDesc.PS = CD3DX12_SHADER_BYTECODE(fx->_pixelShader[p]);
		//GlobalPipelineDesc.CachedPSO = {};
		GlobalPipelineDesc.SampleMask = UINT_MAX;
		if (!lines) GlobalPipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
		else GlobalPipelineDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE;
		GlobalPipelineDesc.NumRenderTargets = 1;
		GlobalPipelineDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM;
		GlobalPipelineDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
		GlobalPipelineDesc.SampleDesc.Count = 1;
    
		device->CreateGraphicsPipelineState(&GlobalPipelineDesc, IID_PPV_ARGS(&pipe));
		pipelineState[frameIndex].Add(pipe);
		if (cmd) cmdres=cmd;
		else
		{
			device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, pipe, IID_PPV_ARGS(&cmdres));
			cmdres->SetDescriptorHeaps(1,&HandleContainer.DescriptorHeap);
		}

		actualpipeline=NULL;
	}

	vb->actualcrc=crc;

	if (cmd)
	{		
		//cmdres->Reset(commandAllocator,pipe);
		cmdres->SetPipelineState(pipe);
		//cmdres->SetDescriptorHeaps(1,&HandleContainer.DescriptorHeap);
	}

	if (lines) cmdres->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_LINELIST);
	else cmdres->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	if (prevTarget!=resTarget)
	{
		//if (prevTarget) cmdres->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(prevTarget,D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_COMMON));
		//if (resTarget) cmdres->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(resTarget, D3D12_RESOURCE_STATE_COMMON,D3D12_RESOURCE_STATE_RENDER_TARGET));
	}
	prevTarget=resTarget;

	cmdres->SetGraphicsRootSignature(vb->signature);
	prevSurface=rtvSurface;
	cmdres->OMSetRenderTargets(1, &rtvSurface, FALSE,&dsvDepthStencil);
	cmdres->OMSetStencilRef(StencilREF);
	cmdres->RSSetViewports(1, &ViewportActual);
	cmdres->RSSetScissorRects(1, &ScissorRectActual);

	previouspipe=pipe;

	return cmdres;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
ID3D12GraphicsCommandList* C3DAPIBASE::CreatePreviousSetCommandList(CVertexBuffer *vb,ID3D12GraphicsCommandList* cmd)
{
	if (cmd) return cmd;

	ID3D12GraphicsCommandList* cmdres;
    
	if (actualpipeline)
	{
		device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, actualpipeline, IID_PPV_ARGS(&cmdres));
	}
	else
	{
		ID3D12PipelineState* pipe=*pipelineState[frameIndex].Last();
		device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, pipe, IID_PPV_ARGS(&cmdres));
	}

	cmdres->SetDescriptorHeaps(1,&HandleContainer.DescriptorHeap);

    cmdres->SetGraphicsRootSignature(vb->signature);

	prevSurface=rtvSurface;
	cmdres->OMSetRenderTargets(1, &rtvSurface, FALSE,&dsvDepthStencil);
	cmdres->OMSetStencilRef(StencilREF);
	cmdres->RSSetViewports(1, &ViewportActual);
	cmdres->RSSetScissorRects(1, &ScissorRectActual);

	if (prevTarget!=resTarget)
	{
		//cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(prevTarget,D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_COMMON));
		//cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(resTarget, D3D12_RESOURCE_STATE_COMMON,D3D12_RESOURCE_STATE_RENDER_TARGET));
	}
	prevTarget=resTarget;
	/**/
    return cmdres;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::GraphicDescriptorTable(CVertexBuffer *vb,ID3D12GraphicsCommandList* cmd)
{
	int n;
	ID3DFXEffect *fx=vb->effect;
    
    //fx->Update();

    int p=0;
    
    if ((fx->vp->npsvectors==0)&&(fx->vp->npsmatrices==0))
    {
        cmd->SetGraphicsRootDescriptorTable(0, fx->_constants_vs->id.GetGPUHandle());
        p=1;
    }
    else
    {
        cmd->SetGraphicsRootDescriptorTable(0, fx->_constants_vs->id.GetGPUHandle());
        cmd->SetGraphicsRootDescriptorTable(1, fx->_constants_ps->id.GetGPUHandle());
        p=2;
    }
    
    for (n=0;n<16;n++)
    {
        if (fx->vp->texture[n])
        {
			if (fx->variabletextures[n]->tex)
				cmd->SetGraphicsRootDescriptorTable(p, fx->variabletextures[n]->tex->GetGPUHandle());
            p++;
        }
    }
    
    for (n=0;n<16;n++)
    {
        if (fx->vp->texturevs[n])
        {
			if (fx->variabletextures_vs[n]->tex)
				cmd->SetGraphicsRootDescriptorTable(p, fx->variabletextures_vs[n]->tex->GetGPUHandle());
            p++;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::ExecuteIndirect(CVertexBuffer *vb,CVertexBuffer *eff,int istart,int iend,ID3D12GraphicsCommandList* cmd)
{
	/*
	int n;
	ID3DFXEffect *fx=eff->effect;
    
	D3D12_DRAW_INDEXED_ARGUMENTS indexed;
	
	indexed.IndexCountPerInstance=iend-istart;
	indexed.StartIndexLocation=istart;
	indexed.InstanceCount=1;
	indexed.BaseVertexLocation=0;
	indexed.StartInstanceLocation=0;

	int basesize=sizeof(D3D12_DRAW_INDEXED_ARGUMENTS);

	int shr=(basesize+255)/256;
	int size=256*shr;

	ID3D12Resource *res=heapConstantBuffers[frameIndex];
	UINT64 offset=ofsConstantBuffers[frameIndex];

	void *pdata=pdataConstantBuffer[frameIndex]+offset;
	memcpy(pdata, (char*)&indexed, basesize);

	ofsConstantBuffers[frameIndex]+=size;

	cmd->ExecuteIndirect(eff->commandsignature,1,res,offset,nullptr,0);

	commandsexecuted[frameIndex]=true;
	/**/
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::CreateRootSignature(CVertexBuffer *vb)
{
	if (vb->signature) return;

    int n,p;
    bool tex=false;
    ID3D12RootSignature* rootSignature;
    CD3DX12_DESCRIPTOR_RANGE1 ranges[32];
    CD3DX12_ROOT_PARAMETER1 rootParameters[32];
    ID3DFXEffect *fx=vb->effect;

    D3D12_FEATURE_DATA_ROOT_SIGNATURE featureData = {};
    featureData.HighestVersion = D3D_ROOT_SIGNATURE_VERSION_1_0;		// BUG 1_1
    
    p=0;
    
    if ((fx->vp->npsvectors==0)&&(fx->vp->npsmatrices==0))
    {
        ranges[0].Init(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, 1, 0, 0, D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);
        rootParameters[0].InitAsDescriptorTable(1, &ranges[0], D3D12_SHADER_VISIBILITY_VERTEX);
        p=1;
    }
    else
    {
        ranges[0].Init(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, 1, 0, 0, D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);
        ranges[1].Init(D3D12_DESCRIPTOR_RANGE_TYPE_CBV, 1, 0, 0, D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);
        rootParameters[0].InitAsDescriptorTable(1, &ranges[0], D3D12_SHADER_VISIBILITY_VERTEX);
        rootParameters[1].InitAsDescriptorTable(1, &ranges[1], D3D12_SHADER_VISIBILITY_PIXEL);
        p=2;
    }

	int nt=0;

    for (n=0;n<16;n++)
    {
        if (fx->vp->texture[n])
        {
            // fx->variabletextures[n]
            ranges[p].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, nt++, 0, D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);
            rootParameters[p].InitAsDescriptorTable(1, &ranges[p], D3D12_SHADER_VISIBILITY_PIXEL);
            tex=true;
            p++;
        }
    }
    
	nt=0;
    for (n=0;n<16;n++)
    {
        if (fx->vp->texturevs[n])
        {
            // fx->variabletextures_vs[n]
            ranges[p].Init(D3D12_DESCRIPTOR_RANGE_TYPE_SRV, 1, nt++, 0, D3D12_DESCRIPTOR_RANGE_FLAG_DATA_STATIC);
            rootParameters[p].InitAsDescriptorTable(1, &ranges[p], D3D12_SHADER_VISIBILITY_VERTEX);
            tex=true;
            p++;
        }
    }

    D3D12_ROOT_SIGNATURE_FLAGS rootSignatureFlags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT|D3D12_ROOT_SIGNATURE_FLAG_DENY_HULL_SHADER_ROOT_ACCESS|D3D12_ROOT_SIGNATURE_FLAG_DENY_DOMAIN_SHADER_ROOT_ACCESS|D3D12_ROOT_SIGNATURE_FLAG_DENY_GEOMETRY_SHADER_ROOT_ACCESS;

    D3D12_STATIC_SAMPLER_DESC sampler = {};
    sampler.Filter = D3D12_FILTER_MIN_MAG_MIP_POINT;
    sampler.Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
    sampler.AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    sampler.AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    sampler.AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
    sampler.MipLODBias = 0;
    sampler.MaxAnisotropy = 0;
    sampler.ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
    sampler.BorderColor = D3D12_STATIC_BORDER_COLOR_TRANSPARENT_BLACK;
    sampler.MinLOD = 0.0f;
    sampler.MaxLOD = D3D12_FLOAT32_MAX;
    sampler.ShaderRegister = 0;
    sampler.RegisterSpace = 0;
    sampler.ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
    sampler.ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;

    CD3DX12_VERSIONED_ROOT_SIGNATURE_DESC rootSignatureDesc;
    if (tex) rootSignatureDesc.Init_1_1(p, rootParameters, 1, &sampler, rootSignatureFlags);
    else rootSignatureDesc.Init_1_1(p, rootParameters, 0, nullptr, rootSignatureFlags);

    ID3DBlob* signature=nullptr;
    ID3DBlob* error=nullptr;
    D3DX12SerializeVersionedRootSignature(&rootSignatureDesc, featureData.HighestVersion, &signature, &error);
    device->CreateRootSignature(0, signature->GetBufferPointer(), signature->GetBufferSize(), IID_PPV_ARGS(&rootSignature));

	if (signature) signature->Release();
	if (error) error->Release();

	vb->signature=rootSignature;

	D3D12_INDIRECT_ARGUMENT_DESC args[1];
	args[0].Type=D3D12_INDIRECT_ARGUMENT_TYPE_DRAW_INDEXED;

	D3D12_COMMAND_SIGNATURE_DESC cmdSignDesc={};

	cmdSignDesc.pArgumentDescs=args;
	cmdSignDesc.NumArgumentDescs=1;
	cmdSignDesc.ByteStride=36;

	ID3D12CommandSignature *cmdSignature;

	device->CreateCommandSignature(&cmdSignDesc,nullptr,IID_PPV_ARGS(&cmdSignature));

	vb->commandsignature=cmdSignature;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::FreePipelinesandSignatures()
{

	ID3D12PipelineState**pipe=pipelineState[frameIndex].GetFirst();
	while (pipe)
	{
		(*pipe)->Release();
		pipe=pipelineState[frameIndex].DeleteAndGetNext();
	}

	ID3D12Resource **res=DynamicResources[frameIndex].GetFirst();
	while (res)
	{
		(*res)->Release();
		res=DynamicResources[frameIndex].DeleteAndGetNext();
	}

	DescriptorHeapHandle *pid=DynamicResourcesId[frameIndex].GetFirst();
	while (pid)
	{
		HandleContainer.FreeHeapHandle(*pid);
		pid=DynamicResourcesId[frameIndex].DeleteAndGetNext();
	}

	ID3DFXEffect** pfx=ActualEffects.GetFirst();
    while (pfx)
    {
        (*pfx)->dirty_vs_constants=true;
        (*pfx)->dirty_ps_constants=true;
        pfx=ActualEffects.GetNext();
    }

#ifndef BIGRESOURCE
	for (int s=0;s<1024;s++)
	{
		ConstantBuffers[frameIndex][s].GetFirst();
		ConstantBuffersId[frameIndex][s].GetFirst();
		ConstantBuffersPtr[frameIndex][s].GetFirst();
	}
#endif
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::CloseOpenedCommandListFence()
{
	if (commandList)
	{
		fence2->Signal(0);
		
		CloseAndExecuteCommandList(commandList);
		commandQueue->Signal(fence2, 1);

		if (fence2->GetCompletedValue() < 2)
		{
			fence2->SetEventOnCompletion(1, fenceEvent2);
			WaitForSingleObject(fenceEvent2, INFINITE);
		}

	}
	commandList=NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::CloseOpenedCommandList()
{
	if (commandList) CloseAndExecuteCommandList(commandList);
	commandList=NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::CloseAndExecuteCommandList(ID3D12GraphicsCommandList* cmd)
{
	//cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(renderTargets[frameIndex], D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));
	cmd->Close();
	ID3D12CommandList* list[] = { cmd };
    commandQueue->ExecuteCommandLists(_countof(list), list);
	cmd->Release();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::CloseAndExecuteCommandListNoRelease(ID3D12GraphicsCommandList* cmd)
{
	//cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(renderTargets[frameIndex], D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));
	cmd->Close();
	ID3D12CommandList* list[] = { cmd };
    commandQueue->ExecuteCommandLists(_countof(list), list);
	commandList=cmd;
}

#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Init windowed
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#if !defined(GLES)&&!defined(GLES20)
int C3DAPIBASE::InitVideoWindowed(int Sx,int Sy,int F)
{
	if (!TheClass3DAPI) TheClass3DAPI=(C3DAPIBASE*) this;

#ifdef API3D_DIRECT3D12

	int n;

    Viewport.TopLeftX=0;
    Viewport.TopLeftY=0;
    
    Viewport.Width=(FLOAT)Sx;
    Viewport.Height=(FLOAT)Sy;
    
    Viewport.MinDepth=0.0f;
    Viewport.MaxDepth=1.0f;

	D3D12_CLEAR_VALUE zval = {};
	zval.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	zval.DepthStencil.Depth = 1.0f;
	zval.DepthStencil.Stencil = 0;
    
	if (RESET==1)
	{
#ifdef DEBUGGING
		return 1;
#endif
		if ((Sx!=SCREEN_X)||(Sy!=SCREEN_Y))
		{
			SCREEN_X=Sx;
			SCREEN_Y=Sy;

			Viewport.Width =(float) Sx;
			Viewport.Height =(float) Sy;
			Viewport.MinDepth = 0.0f;
			Viewport.MaxDepth = 1.0f;
			Viewport.TopLeftX = 0;
			Viewport.TopLeftY = 0;
		

			Viewport=CD3DX12_VIEWPORT(0.0f, 0.0f, static_cast<float>(Sx), static_cast<float>(Sy));
			ScissorRect=CD3DX12_RECT(0, 0, static_cast<LONG>(Sx), static_cast<LONG>(Sy));

			for (n = 0; n < D3D_NBUFFERS; n++)
			{
				renderTargets[n]->Release();
				depthstencil[n]->Release();
			}

			swapChain->ResizeBuffers(D3D_NBUFFERS,Sx,Sy,DXGI_FORMAT_R8G8B8A8_UNORM,0);

			CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(rtvHeap->GetCPUDescriptorHandleForHeapStart());
			CD3DX12_CPU_DESCRIPTOR_HANDLE dsvHandle(dsvHeap->GetCPUDescriptorHandleForHeapStart());

			for ( n = 0; n < D3D_NBUFFERS; n++)
			{
				swapChain->GetBuffer(n, IID_PPV_ARGS(&renderTargets[n]));
				device->CreateRenderTargetView(renderTargets[n], nullptr, rtvHandle);
				rtv_rendertargets[n]=rtvHandle;
				rtvHandle.Offset(1, rtvDescriptorSize);

				D3D12_RESOURCE_DESC zbufDesc = {};
				zbufDesc.MipLevels = 1;
				zbufDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
				zbufDesc.Width = Sx;
				zbufDesc.Height = Sy;
				zbufDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
				zbufDesc.DepthOrArraySize = 1;
				zbufDesc.SampleDesc.Count = 1;
				zbufDesc.SampleDesc.Quality = 0;
				zbufDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
		
				device->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),D3D12_HEAP_FLAG_NONE,&zbufDesc,
										D3D12_RESOURCE_STATE_DEPTH_WRITE,&zval,IID_PPV_ARGS(&depthstencil[n]));

				device->CreateDepthStencilView(depthstencil[n],nullptr,dsvHandle);
				dsv_depthstencil[n]=dsvHandle;
				dsvHandle.Offset(1, dsvDescriptorSize);
			}

			aBack=Back;
			aFront=Front;
		}

		VIEWPORT.Id();
		VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
		VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);
		VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
		VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);
		VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
		VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);

		MatrixOrthoLHS( &ProjOrtho, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );

		InitViewport();

		frameIndex = swapChain->GetCurrentBackBufferIndex();

		// RESET OK

		return 1;
	}

	UINT dxgiFactoryFlags = 0;

#if defined(DEBUGGING)
	// Enable the debug layer (requires the Graphics Tools "optional feature").
	// NOTE: Enabling the debug layer after device creation will invalidate the active device.
	{
		ID3D12Debug* debugController;
		if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController))))
		{
			debugController->EnableDebugLayer();

			// Enable additional debug layers.
			dxgiFactoryFlags |= DXGI_CREATE_FACTORY_DEBUG;
		}
	}
#endif

	D3D_FEATURE_LEVEL featureLevel = D3D_FEATURE_LEVEL_12_1;
	
	CreateDXGIFactory2(dxgiFactoryFlags, IID_PPV_ARGS(&factory));

	D3D12CreateDevice(NULL, featureLevel, __uuidof(ID3D12Device), (void**)&device);

	D3DDevicePrincipal=device;
	TheClass3DAPI=this;


	// Describe and create the command queue.
	D3D12_COMMAND_QUEUE_DESC queueDesc = {};
	queueDesc.Flags = D3D12_COMMAND_QUEUE_FLAG_NONE;
	queueDesc.Type = D3D12_COMMAND_LIST_TYPE_DIRECT;
	//queueDesc.Priority=D3D12_COMMAND_QUEUE_PRIORITY_HIGH;

	device->CreateCommandQueue(&queueDesc, IID_PPV_ARGS(&commandQueue));

	// Describe and create the swap chain.
	swapChainDesc.BufferCount = D3D_NBUFFERS;
	swapChainDesc.Width = Sx;
	swapChainDesc.Height = Sy;
	swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;
	swapChainDesc.SampleDesc.Count = 1;
	

	IDXGISwapChain1* swapChainTemp;
	factory->CreateSwapChainForHwnd(commandQueue,hWindow,&swapChainDesc,nullptr,nullptr,&swapChainTemp);

	factory->MakeWindowAssociation(hWindow, DXGI_MWA_NO_ALT_ENTER);

	swapChainTemp->QueryInterface(__uuidof(IDXGISwapChain3), (void**)&swapChain);

	frameIndex = swapChain->GetCurrentBackBufferIndex();

	// Create descriptor heaps.

	D3D12_DESCRIPTOR_HEAP_DESC rtvHeapDesc = {};
	rtvHeapDesc.NumDescriptors = D3D_NBUFFERS+MAX_SECONDARIES;
	rtvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_RTV;
	rtvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	device->CreateDescriptorHeap(&rtvHeapDesc, IID_PPV_ARGS(&rtvHeap));

	rtvDescriptorSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);

	D3D12_DESCRIPTOR_HEAP_DESC dsvHeapDesc = {};
	dsvHeapDesc.NumDescriptors = D3D_NBUFFERS+MAX_SECONDARIES;
	dsvHeapDesc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_DSV;
	dsvHeapDesc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	device->CreateDescriptorHeap(&dsvHeapDesc, IID_PPV_ARGS(&dsvHeap));

	dsvDescriptorSize = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_DSV);

	HandleContainer.Init(device,(void*)this,D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV,65536*8);
	heap=&HandleContainer;

	zeroid=HandleContainer.GetNewHeapHandle();

	CD3DX12_CPU_DESCRIPTOR_HANDLE rtvHandle(rtvHeap->GetCPUDescriptorHandleForHeapStart());
	CD3DX12_CPU_DESCRIPTOR_HANDLE dsvHandle(dsvHeap->GetCPUDescriptorHandleForHeapStart());

	for (UINT n = 0; n < D3D_NBUFFERS; n++)
	{
		swapChain->GetBuffer(n, IID_PPV_ARGS(&renderTargets[n]));
		device->CreateRenderTargetView(renderTargets[n], nullptr, rtvHandle);
		rtv_rendertargets[n]=rtvHandle;
		rtvHandle.Offset(1, rtvDescriptorSize);

		D3D12_RESOURCE_DESC zbufDesc = {};
		zbufDesc.MipLevels = 1;
		zbufDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
		zbufDesc.Width = Sx;
		zbufDesc.Height = Sy;
		zbufDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
		zbufDesc.DepthOrArraySize = 1;
		zbufDesc.SampleDesc.Count = 1;
		zbufDesc.SampleDesc.Quality = 0;
		zbufDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
		
		device->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT),D3D12_HEAP_FLAG_NONE,&zbufDesc,
								D3D12_RESOURCE_STATE_DEPTH_WRITE,&zval,IID_PPV_ARGS(&depthstencil[n]));

		device->CreateDepthStencilView(depthstencil[n],nullptr,dsvHandle);
		dsv_depthstencil[n]=dsvHandle;
		dsvHandle.Offset(1, dsvDescriptorSize);
	}

	for (int k=0;k<D3D_NBUFFERS;k++) device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&commandAllocators[k]));

	commandAllocator=commandAllocators[frameIndex];	
	
	GlobalPipelineDesc.RasterizerState = CD3DX12_RASTERIZER_DESC(D3D12_DEFAULT);
	GlobalPipelineDesc.BlendState = CD3DX12_BLEND_DESC(D3D12_DEFAULT);
	GlobalPipelineDesc.DepthStencilState.DepthEnable = FALSE;
	GlobalPipelineDesc.DepthStencilState.StencilEnable = FALSE;


    blendStateDesc.AlphaToCoverageEnable=FALSE;
    blendStateDesc.IndependentBlendEnable=FALSE;

    blendStateDesc.RenderTarget[0].BlendEnable=false;
    blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_ONE;
    blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ZERO;
    blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_ONE;
    blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ZERO;

    rasterDesc.CullMode = D3D12_CULL_MODE_NONE;
    
	////////////////////////////////////////////////////////////////////////////////
#ifndef BIGRESOURCE
	for (int s=0;s<1024;s++)
	{
		for (int k=0;k<D3D_NBUFFERS;k++)
		{
			ConstantBuffers[k][s].Free();
			ConstantBuffersId[k][s].Free();
			ConstantBuffersPtr[k][s].Free();
		}
	}

	for (int frame=0;frame<D3D_NBUFFERS;frame++)
	{
		int shr;
		ID3D12Resource * res;
		CD3DX12_RANGE readRange(0, 0);
		UINT8* pdata;
		int size;

		for (int k=0;k<256;k++)
		{
			for (shr=1;shr<=2;shr++)
			{
				size=shr*256;
				device->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),D3D12_HEAP_FLAG_NONE,&CD3DX12_RESOURCE_DESC::Buffer(size),D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, nullptr,IID_PPV_ARGS(&res));		
				ConstantBuffers[frame][shr].Add(res);
				ConstantBuffersId[frame][shr].Add(heap->GetNewHeapHandle());
				res->Map(0, &readRange, reinterpret_cast<void**>(&pdata));
				ConstantBuffersPtr[frame][shr].Add(pdata);
			}
		}

		for (int k=0;k<32;k++)
		{
			shr=3;
			size=shr*256;
			device->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),D3D12_HEAP_FLAG_NONE,&CD3DX12_RESOURCE_DESC::Buffer(size),D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, nullptr,IID_PPV_ARGS(&res));		
			ConstantBuffers[frame][shr].Add(res);
			ConstantBuffersId[frame][shr].Add(heap->GetNewHeapHandle());
			res->Map(0, &readRange, reinterpret_cast<void**>(&pdata));
			ConstantBuffersPtr[frame][shr].Add(pdata);
				
			shr=49;
			size=shr*256;
			device->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),D3D12_HEAP_FLAG_NONE,&CD3DX12_RESOURCE_DESC::Buffer(size),D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, nullptr,IID_PPV_ARGS(&res));		
			ConstantBuffers[frame][shr].Add(res);
			ConstantBuffersId[frame][shr].Add(heap->GetNewHeapHandle());
			res->Map(0, &readRange, reinterpret_cast<void**>(&pdata));
			ConstantBuffersPtr[frame][shr].Add(pdata);
				
			shr=50;
			size=shr*256;
			device->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),D3D12_HEAP_FLAG_NONE,&CD3DX12_RESOURCE_DESC::Buffer(size),D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, nullptr,IID_PPV_ARGS(&res));		
			ConstantBuffers[frame][shr].Add(res);
			ConstantBuffersId[frame][shr].Add(heap->GetNewHeapHandle());
			res->Map(0, &readRange, reinterpret_cast<void**>(&pdata));
			ConstantBuffersPtr[frame][shr].Add(pdata);
		}
	}

#endif
	*states[TEXTURE_MAX_WIDTH]=8192*2;

	SCREEN_X=Sx;
	SCREEN_Y=Sy;

	factors[0]=factors[1]=factors[2]=factors[3]=factors[4]=factors[5]=factors[6]=factors[7]=1.0f;

	if (SecondarySurface)
	{
		for (int n=0;n<nSecondaries;n++)
			if (!setupRenderTexture(n,tile_secondarysurfaces[n],tile_secondarysurfaces[n])) return -1;
	}

    Viewport.Width =(float) Sx;
    Viewport.Height =(float) Sy;
    Viewport.MinDepth = 0.0f;
    Viewport.MaxDepth = 1.0f;
    Viewport.TopLeftX = 0;
    Viewport.TopLeftY = 0;

	ScissorRect.left=0;
	ScissorRect.right=Sx;
	ScissorRect.top=0;
	ScissorRect.bottom=Sy;

	VIEWPORT.Id();
	VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
	VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);
	VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
	VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);
	VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
	VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);

	MatrixOrthoLHS( &ProjOrtho, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );

	InitViewport();

	*states[TEXTURES_32BITS]=1;
    
    StencilBuffer=true;
	/*
	int size=HEAP_DYNAMIC_BUFFERS_SIZE;
	device->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),D3D12_HEAP_FLAG_NONE,&CD3DX12_RESOURCE_DESC::Buffer(size),D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, nullptr,IID_PPV_ARGS(&heapConstantBuffers[0]));
	device->CreateCommittedResource(&CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_UPLOAD),D3D12_HEAP_FLAG_NONE,&CD3DX12_RESOURCE_DESC::Buffer(size),D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE|D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER, nullptr,IID_PPV_ARGS(&heapConstantBuffers[1]));
	
	CD3DX12_RANGE readRange(0, 0);
	heapConstantBuffers[0]->Map(0, &readRange, reinterpret_cast<void**>(&pdataConstantBuffer[0]));
	heapConstantBuffers[1]->Map(0, &readRange, reinterpret_cast<void**>(&pdataConstantBuffer[1]));

	ofsConstantBuffers[0]=0;
	ofsConstantBuffers[1]=0;
	/**/

	RESET=1;

#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	TextureContainer->clean();
#endif

	G_Multitexture=true;
	*states[PIXELSHADER2]=1;

	SelectedRenderTarget=PRIMARY;

	Misc();

	aBack=Back;
	aFront=Front;

    // Fence
    
	for (int k=0;k<D3D_NBUFFERS;k++)
	{
		device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence[k]));
		fence[k]->Signal(0);
		fenceValue[k]=1;

		fenceEvent[k] = CreateEvent(nullptr, FALSE, FALSE, nullptr);
	}

    device->CreateFence(0, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence2));
	fence2->Signal(0);
    fenceEvent2 = CreateEvent(nullptr, FALSE, FALSE, nullptr);

	return 1;

#endif

#ifdef API3D_METAL

    Viewport.TopLeftX=0;
    Viewport.TopLeftY=0;
    
    Viewport.Width=Sx;
    Viewport.Height=Sy;
    
    Viewport.MinDepth=0.0f;
    Viewport.MaxDepth=1.0f;
    
	if (RESET==1)
	{
		if ((Sx!=SCREEN_X)||(Sy!=SCREEN_Y))
		{
			SCREEN_X=Sx;
			SCREEN_Y=Sy;

			Viewport.Width =(float) Sx;
			Viewport.Height =(float) Sy;
			Viewport.MinDepth = 0.0f;
			Viewport.MaxDepth = 1.0f;
			Viewport.TopLeftX = 0;
			Viewport.TopLeftY = 0;

            MTLSetViewport(Viewport.TopLeftX,Viewport.TopLeftY,Viewport.TopLeftX+Viewport.Width,Viewport.TopLeftY+Viewport.Height);

			VIEWPORT.Id();
			VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
			VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);
			VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
			VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);
			VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
			VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);

			MatrixOrthoLHS( &ProjOrtho, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );

			aBack=Back;
			aFront=Front;
		}

		return 1;
	}

	*states[TEXTURE_MAX_WIDTH]=8192;

	SCREEN_X=Sx;
	SCREEN_Y=Sy;

	factors[0]=factors[1]=factors[2]=factors[3]=factors[4]=factors[5]=factors[6]=factors[7]=1.0f;

	if (SecondarySurface)
	{
		for (int n=0;n<nSecondaries;n++)
			if (!setupRenderTexture(n,tile_secondarysurfaces[n],tile_secondarysurfaces[n])) return -1;
	}

    Viewport.Width =(float) Sx;
    Viewport.Height =(float) Sy;
    Viewport.MinDepth = 0.0f;
    Viewport.MaxDepth = 1.0f;
    Viewport.TopLeftX = 0;
    Viewport.TopLeftY = 0;

    MTLSetViewport(Viewport.TopLeftX,Viewport.TopLeftY,Viewport.TopLeftX+Viewport.Width,Viewport.TopLeftY+Viewport.Height);

	VIEWPORT.Id();
	VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
	VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);
	VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
	VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);
	VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
	VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);

	MatrixOrthoLHS( &ProjOrtho, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );

	*states[TEXTURES_32BITS]=1;
    
    StencilBuffer=true;

	RESET=1;

#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	TextureContainer->clean();
#endif

	G_Multitexture=true;
	*states[PIXELSHADER2]=1;

	SelectedRenderTarget=PRIMARY;

	Misc();

	aBack=Back;
	aFront=Front;

	return 1;

#endif

#ifdef API3D_DIRECT3D11

	if (RESET==1)
	{
#ifndef WINDOWS_PHONE
		if ((Sx!=swapChainDesc.BufferDesc.Width)||(Sy!=swapChainDesc.BufferDesc.Height))
		{
			renderTargetView->Release();
			depthStencilBuffer->Release();
			depthStencilView->Release();
			backBufferPtr->Release();

			swapChain->ResizeBuffers(2, Sx, Sy, DXGI_FORMAT_R8G8B8A8_UNORM, 0);

			SCREEN_X=Sx;
			SCREEN_Y=Sy;
			swapChainDesc.BufferDesc.Width = Sx;
			swapChainDesc.BufferDesc.Height = Sy;

			if (FAILED(swapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&backBufferPtr))) return -1;

			if (FAILED(device->CreateRenderTargetView(backBufferPtr, NULL, &renderTargetView))) return -1;

			ZeroMemory(&depthBufferDesc, sizeof(depthBufferDesc));

			depthBufferDesc.Width = Sx;
			depthBufferDesc.Height = Sy;
			depthBufferDesc.MipLevels = 1;
			depthBufferDesc.ArraySize = 1;
			depthBufferDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
			depthBufferDesc.SampleDesc.Count = 1;
			depthBufferDesc.SampleDesc.Quality = 0;
			depthBufferDesc.Usage = D3D11_USAGE_DEFAULT;
			depthBufferDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
			depthBufferDesc.CPUAccessFlags = 0;
			depthBufferDesc.MiscFlags = 0;

			if (FAILED(device->CreateTexture2D(&depthBufferDesc, NULL, &depthStencilBuffer))) return -1;

			ZeroMemory(&depthStencilViewDesc, sizeof(depthStencilViewDesc));
			depthStencilViewDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
			depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;
			depthStencilViewDesc.Texture2D.MipSlice = 0;

			if (FAILED(device->CreateDepthStencilView(depthStencilBuffer, &depthStencilViewDesc, &depthStencilView))) return -1;

			devicecontext->OMSetRenderTargets(1, &renderTargetView, depthStencilView);

			Viewport.Width =(float) Sx;
			Viewport.Height =(float) Sy;
			Viewport.MinDepth = 0.0f;
			Viewport.MaxDepth = 1.0f;
			Viewport.TopLeftX = 0;
			Viewport.TopLeftY = 0;

			devicecontext->RSSetViewports(1, &Viewport);

			VIEWPORT.Id();
			VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
			VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);
			VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
			VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);
			VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
			VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);

			render=renderTargetView;
			depthstencil=depthStencilView;

			MatrixOrthoLHS( &ProjOrtho, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );

			aBack=Back;
			aFront=Front;
		}
#endif
		return 1;
	}

	*states[TEXTURE_MAX_WIDTH]=8192;

	SCREEN_X=Sx;
	SCREEN_Y=Sy;

#ifndef WINDOWS_PHONE
    ZeroMemory(&swapChainDesc, sizeof(swapChainDesc));
    swapChainDesc.BufferCount = 1;
    swapChainDesc.BufferDesc.Width = Sx;
    swapChainDesc.BufferDesc.Height = Sy;
    swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;

	//if (states(VERTICAL_RETRACE)!=0)
	swapChainDesc.BufferDesc.RefreshRate.Numerator = 60;
	swapChainDesc.BufferDesc.RefreshRate.Denominator = 1;

    swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;

    swapChainDesc.OutputWindow = hWindow;

    swapChainDesc.SampleDesc.Count = 1;
    swapChainDesc.SampleDesc.Quality = 0;

	swapChainDesc.Windowed = true;

	swapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	swapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;

	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	swapChainDesc.Flags = 0;

	D3D_FEATURE_LEVEL fls;
	D3D_FEATURE_LEVEL flr = D3D_FEATURE_LEVEL_11_0;

	if (FAILED(D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, 0, &flr,1, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device,&fls,&devicecontext))) return -1;

	SetDEVICE(device,devicecontext);

	if (FAILED(swapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&backBufferPtr))) return -1;

	if (FAILED(device->CreateRenderTargetView(backBufferPtr, NULL, &renderTargetView))) return -1;
	
	ZeroMemory(&depthBufferDesc, sizeof(depthBufferDesc));

	depthBufferDesc.Width = Sx;
	depthBufferDesc.Height = Sy;
	depthBufferDesc.MipLevels = 1;
	depthBufferDesc.ArraySize = 1;
	depthBufferDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	depthBufferDesc.SampleDesc.Count = 1;
	depthBufferDesc.SampleDesc.Quality = 0;
	depthBufferDesc.Usage = D3D11_USAGE_DEFAULT;
	depthBufferDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
	depthBufferDesc.CPUAccessFlags = 0;
	depthBufferDesc.MiscFlags = 0;

	if (FAILED(device->CreateTexture2D(&depthBufferDesc, NULL, &depthStencilBuffer))) return -1;

	ZeroMemory(&depthStencilViewDesc, sizeof(depthStencilViewDesc));
	depthStencilViewDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;
	depthStencilViewDesc.Texture2D.MipSlice = 0;

	if (FAILED(device->CreateDepthStencilView(depthStencilBuffer, &depthStencilViewDesc, &depthStencilView))) return -1;

	devicecontext->OMSetRenderTargets(1, &renderTargetView, depthStencilView);
#else

	SetDEVICE(device,devicecontext);
	devicecontext->OMSetRenderTargets(1, &renderTargetView, depthStencilView);
#endif

	ZeroMemory(&depthStencilDesc, sizeof(depthStencilDesc));

	depthStencilDesc.DepthEnable = true;
	depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
	depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;

	depthStencilDesc.StencilEnable = true;
	depthStencilDesc.StencilReadMask = 0xFF;
	depthStencilDesc.StencilWriteMask = 0xFF;

	depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

	depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

	device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
	devicecontext->OMSetDepthStencilState(depthStencilState, 1);

	ZeroMemory(&rasterDesc, sizeof(rasterDesc));
	rasterDesc.AntialiasedLineEnable = false;
	rasterDesc.CullMode = D3D11_CULL_BACK;
	rasterDesc.DepthBias = 0;
	rasterDesc.DepthBiasClamp = 0.0f;
	rasterDesc.SlopeScaledDepthBias = 0.0f;
	rasterDesc.DepthClipEnable = true;
	rasterDesc.FillMode = D3D11_FILL_SOLID;
	rasterDesc.FrontCounterClockwise = false;
	rasterDesc.MultisampleEnable = false;
    rasterDesc.ScissorEnable = true;
	rasterDesc.SlopeScaledDepthBias = 0.0f;

	device->CreateRasterizerState(&rasterDesc, &rasterState);
	devicecontext->RSSetState(rasterState);

	ZeroMemory(&blendStateDesc, sizeof(blendStateDesc));

	blendStateDesc.AlphaToCoverageEnable=false;
	blendStateDesc.IndependentBlendEnable=false;

	for (int n=0;n<8;n++)
	{
		blendStateDesc.RenderTarget[n].BlendEnable=false;
		blendStateDesc.RenderTarget[n].SrcBlend=D3D11_BLEND_ONE;
		blendStateDesc.RenderTarget[n].DestBlend=D3D11_BLEND_ZERO;
		blendStateDesc.RenderTarget[n].BlendOp=D3D11_BLEND_OP_ADD;
		blendStateDesc.RenderTarget[n].BlendOpAlpha=D3D11_BLEND_OP_ADD;
		blendStateDesc.RenderTarget[n].SrcBlendAlpha=D3D11_BLEND_ONE;
		blendStateDesc.RenderTarget[n].DestBlendAlpha=D3D11_BLEND_ZERO;
		blendStateDesc.RenderTarget[n].RenderTargetWriteMask=D3D11_COLOR_WRITE_ENABLE_ALL;
	}

	device->CreateBlendState(&blendStateDesc,&blendStateOFF);
	device->CreateBlendState(&blendStateDesc,&blendStateTMP);
	
	factors[0]=factors[1]=factors[2]=factors[3]=factors[4]=factors[5]=factors[6]=factors[7]=1.0f;

	devicecontext->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);

	blendStateDesc.RenderTarget[0].BlendEnable=true;
	blendStateDesc.RenderTarget[0].SrcBlend=D3D11_BLEND_SRC_ALPHA;
	blendStateDesc.RenderTarget[0].DestBlend=D3D11_BLEND_INV_SRC_ALPHA;
	blendStateDesc.RenderTarget[0].BlendOp=D3D11_BLEND_OP_ADD;
	blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_SRC_ALPHA;
	blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_INV_SRC_ALPHA;
	blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D11_BLEND_OP_ADD;
	device->CreateBlendState(&blendStateDesc,&blendStateON);

	blendStateDesc.RenderTarget[0].BlendEnable=true;
	blendStateDesc.RenderTarget[0].SrcBlend=D3D11_BLEND_ZERO;
	blendStateDesc.RenderTarget[0].DestBlend=D3D11_BLEND_ONE;
	blendStateDesc.RenderTarget[0].BlendOp=D3D11_BLEND_OP_ADD;
	blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_ZERO;
	blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_ONE;
	blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D11_BLEND_OP_ADD;
	device->CreateBlendState(&blendStateDesc,&blendStateDISCARD);

	blendStateDesc.RenderTarget[0].BlendEnable=true;
	blendStateDesc.RenderTarget[0].SrcBlend=D3D11_BLEND_DEST_COLOR;
	blendStateDesc.RenderTarget[0].DestBlend=D3D11_BLEND_ZERO;
	blendStateDesc.RenderTarget[0].BlendOp=D3D11_BLEND_OP_ADD;
	blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_DEST_ALPHA;
	blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_ZERO;
	blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D11_BLEND_OP_ADD;
	device->CreateBlendState(&blendStateDesc,&blendStateCOLOR);

	blendStateDesc.RenderTarget[0].BlendEnable=true;
	blendStateDesc.RenderTarget[0].SrcBlend=D3D11_BLEND_INV_SRC_ALPHA;
	blendStateDesc.RenderTarget[0].DestBlend=D3D11_BLEND_SRC_ALPHA;
	blendStateDesc.RenderTarget[0].BlendOp=D3D11_BLEND_OP_ADD;
	blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_INV_SRC_ALPHA;
	blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_SRC_ALPHA;
	blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D11_BLEND_OP_ADD;
	device->CreateBlendState(&blendStateDesc,&blendStateINVERSE);

	blendStateDesc.RenderTarget[0].BlendEnable=true;
	blendStateDesc.RenderTarget[0].SrcBlend=D3D11_BLEND_SRC_ALPHA;
	blendStateDesc.RenderTarget[0].DestBlend=D3D11_BLEND_ONE;
	blendStateDesc.RenderTarget[0].BlendOp=D3D11_BLEND_OP_ADD;
	blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_SRC_ALPHA;
	blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_ONE;
	blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D11_BLEND_OP_ADD;
	device->CreateBlendState(&blendStateDesc,&blendStateGOURAUD);

	blendStateDesc.RenderTarget[0].BlendEnable=true;
	blendStateDesc.RenderTarget[0].SrcBlend=D3D11_BLEND_ONE;
	blendStateDesc.RenderTarget[0].DestBlend=D3D11_BLEND_ONE;
	blendStateDesc.RenderTarget[0].BlendOp=D3D11_BLEND_OP_ADD;
	blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_ONE;
	blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_ONE;
	blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D11_BLEND_OP_ADD;
	device->CreateBlendState(&blendStateDesc,&blendStateADD);

	blendStateDesc.RenderTarget[0].BlendEnable=false;
	blendStateDesc.RenderTarget[0].SrcBlend=D3D11_BLEND_ONE;
	blendStateDesc.RenderTarget[0].DestBlend=D3D11_BLEND_ZERO;
	blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_ONE;
	blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_ZERO;

	if (SecondarySurface)
	{
		for (int n=0;n<nSecondaries;n++)
			if (!setupRenderTexture(n,tile_secondarysurfacesW[n],tile_secondarysurfacesH[n])) return -1;
	}

    Viewport.Width =(float) Sx;
    Viewport.Height =(float) Sy;
    Viewport.MinDepth = 0.0f;
    Viewport.MaxDepth = 1.0f;
    Viewport.TopLeftX = 0;
    Viewport.TopLeftY = 0;

    devicecontext->RSSetViewports(1, &Viewport);

	VIEWPORT.Id();
	VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
	VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);
	VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
	VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);
	VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
	VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);

	render=renderTargetView;
	depthstencil=depthStencilView;

	*states[TEXTURES_32BITS]=1;

	RESET=1;

#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	TextureContainer->clean();
#endif

	G_Multitexture=true;
	*states[PIXELSHADER2]=1;

	SelectedRenderTarget=PRIMARY;

	Misc();

	aBack=Back;
	aFront=Front;

	return 1;

#endif

#ifdef API3D_DIRECT3D10

	if (RESET==1)
	{
		if ((Sx!=swapChainDesc.BufferDesc.Width)||(Sy!=swapChainDesc.BufferDesc.Height))
		{
			renderTargetView->Release();
			depthStencilBuffer->Release();
			depthStencilView->Release();
			backBufferPtr->Release();

			swapChain->ResizeBuffers(2, Sx, Sy, DXGI_FORMAT_R8G8B8A8_UNORM, 0);

			SCREEN_X=Sx;
			SCREEN_Y=Sy;
			swapChainDesc.BufferDesc.Width = Sx;
			swapChainDesc.BufferDesc.Height = Sy;

			if (FAILED(swapChain->GetBuffer(0, __uuidof(ID3D10Texture2D), (LPVOID*)&backBufferPtr))) return -1;

			if (FAILED(device->CreateRenderTargetView(backBufferPtr, NULL, &renderTargetView))) return -1;

			ZeroMemory(&depthBufferDesc, sizeof(depthBufferDesc));

			depthBufferDesc.Width = Sx;
			depthBufferDesc.Height = Sy;
			depthBufferDesc.MipLevels = 1;
			depthBufferDesc.ArraySize = 1;
			depthBufferDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
			depthBufferDesc.SampleDesc.Count = 1;
			depthBufferDesc.SampleDesc.Quality = 0;
			depthBufferDesc.Usage = D3D10_USAGE_DEFAULT;
			depthBufferDesc.BindFlags = D3D10_BIND_DEPTH_STENCIL;
			depthBufferDesc.CPUAccessFlags = 0;
			depthBufferDesc.MiscFlags = 0;

			if (FAILED(device->CreateTexture2D(&depthBufferDesc, NULL, &depthStencilBuffer))) return -1;

			ZeroMemory(&depthStencilViewDesc, sizeof(depthStencilViewDesc));
			depthStencilViewDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
			depthStencilViewDesc.ViewDimension = D3D10_DSV_DIMENSION_TEXTURE2D;
			depthStencilViewDesc.Texture2D.MipSlice = 0;

			if (FAILED(device->CreateDepthStencilView(depthStencilBuffer, &depthStencilViewDesc, &depthStencilView))) return -1;

			device->OMSetRenderTargets(1, &renderTargetView, depthStencilView);

			Viewport.Width = Sx;
			Viewport.Height = Sy;
			Viewport.MinDepth = 0.0f;
			Viewport.MaxDepth = 1.0f;
			Viewport.TopLeftX = 0;
			Viewport.TopLeftY = 0;

			device->RSSetViewports(1, &Viewport);

			VIEWPORT.Id();
			VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
			VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);
			VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
			VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);
			VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
			VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);

			render=renderTargetView;
			depthstencil=depthStencilView;

			D3DXMATRIX proj;
			D3DXMatrixOrthoLH( &proj, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );

			ProjOrtho.a[0][0]=proj._11;	ProjOrtho.a[1][0]=proj._21;	ProjOrtho.a[2][0]=proj._31;	ProjOrtho.a[3][0]=proj._41;
			ProjOrtho.a[0][1]=-proj._12; ProjOrtho.a[1][1]=-proj._22; ProjOrtho.a[2][1]=-proj._32; ProjOrtho.a[3][1]=-proj._42;
			ProjOrtho.a[0][2]=proj._13;	ProjOrtho.a[1][2]=proj._23;	ProjOrtho.a[2][2]=proj._33;	ProjOrtho.a[3][2]=proj._43;
			ProjOrtho.a[0][3]=proj._14;	ProjOrtho.a[1][3]=proj._24;	ProjOrtho.a[2][3]=proj._34;	ProjOrtho.a[3][3]=proj._44;

			aBack=Back;
			aFront=Front;
		}

		return 1;
	}

	*states[TEXTURE_MAX_WIDTH]=8192;

	SCREEN_X=Sx;
	SCREEN_Y=Sy;

    ZeroMemory(&swapChainDesc, sizeof(swapChainDesc));
    swapChainDesc.BufferCount = 1;
    swapChainDesc.BufferDesc.Width = Sx;
    swapChainDesc.BufferDesc.Height = Sy;
    swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;

	//if (states(VERTICAL_RETRACE)!=0)
	swapChainDesc.BufferDesc.RefreshRate.Numerator = 60;
	swapChainDesc.BufferDesc.RefreshRate.Denominator = 1;

    swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;

    swapChainDesc.OutputWindow = hWindow;

    swapChainDesc.SampleDesc.Count = 1;
    swapChainDesc.SampleDesc.Quality = 0;

	swapChainDesc.Windowed = true;

	swapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	swapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;

	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	swapChainDesc.Flags = 0;
#ifdef API3D_VERSION_DX10_1
	if (FAILED(D3D10CreateDeviceAndSwapChain1(NULL, D3D10_DRIVER_TYPE_HARDWARE, NULL, 0,D3D10_FEATURE_LEVEL_10_1, D3D10_1_SDK_VERSION,  &swapChainDesc, &swapChain, &device))) return -1;
#else
	if (FAILED(D3D10CreateDeviceAndSwapChain(NULL, D3D10_DRIVER_TYPE_HARDWARE, NULL, 0, D3D10_SDK_VERSION,  &swapChainDesc, &swapChain, &device))) return -1;
#endif

	SetDEVICE(device);

	if (FAILED(swapChain->GetBuffer(0, __uuidof(ID3D10Texture2D), (LPVOID*)&backBufferPtr))) return -1;

	if (FAILED(device->CreateRenderTargetView(backBufferPtr, NULL, &renderTargetView))) return -1;
	
	ZeroMemory(&depthBufferDesc, sizeof(depthBufferDesc));

	depthBufferDesc.Width = Sx;
	depthBufferDesc.Height = Sy;
	depthBufferDesc.MipLevels = 1;
	depthBufferDesc.ArraySize = 1;
	depthBufferDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	depthBufferDesc.SampleDesc.Count = 1;
	depthBufferDesc.SampleDesc.Quality = 0;
	depthBufferDesc.Usage = D3D10_USAGE_DEFAULT;
	depthBufferDesc.BindFlags = D3D10_BIND_DEPTH_STENCIL;
	depthBufferDesc.CPUAccessFlags = 0;
	depthBufferDesc.MiscFlags = 0;

	if (FAILED(device->CreateTexture2D(&depthBufferDesc, NULL, &depthStencilBuffer))) return -1;

	ZeroMemory(&depthStencilViewDesc, sizeof(depthStencilViewDesc));
	depthStencilViewDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	depthStencilViewDesc.ViewDimension = D3D10_DSV_DIMENSION_TEXTURE2D;
	depthStencilViewDesc.Texture2D.MipSlice = 0;

	if (FAILED(device->CreateDepthStencilView(depthStencilBuffer, &depthStencilViewDesc, &depthStencilView))) return -1;

	device->OMSetRenderTargets(1, &renderTargetView, depthStencilView);

	ZeroMemory(&depthStencilDesc, sizeof(depthStencilDesc));

	depthStencilDesc.DepthEnable = true;
	depthStencilDesc.DepthWriteMask = D3D10_DEPTH_WRITE_MASK_ALL;
	depthStencilDesc.DepthFunc = D3D10_COMPARISON_LESS_EQUAL;

	depthStencilDesc.StencilEnable = true;
	depthStencilDesc.StencilReadMask = 0xFF;
	depthStencilDesc.StencilWriteMask = 0xFF;

	depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

	depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

	device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
	device->OMSetDepthStencilState(depthStencilState, 1);

	ZeroMemory(&rasterDesc, sizeof(rasterDesc));
	rasterDesc.AntialiasedLineEnable = false;
	rasterDesc.CullMode = D3D10_CULL_BACK;
	rasterDesc.DepthBias = 0;
	rasterDesc.DepthBiasClamp = 0.0f;
	rasterDesc.SlopeScaledDepthBias = 0.0f;
	rasterDesc.DepthClipEnable = true;
	rasterDesc.FillMode = D3D10_FILL_SOLID;
	rasterDesc.FrontCounterClockwise = false;
	rasterDesc.MultisampleEnable = false;
	rasterDesc.ScissorEnable = true;
	rasterDesc.SlopeScaledDepthBias = 0.0f;

	device->CreateRasterizerState(&rasterDesc, &rasterState);
	device->RSSetState(rasterState);

	ZeroMemory(&blendStateDesc, sizeof(blendStateDesc));
	blendStateDesc.BlendEnable[0]=false;
	blendStateDesc.BlendEnable[1]=false;
	blendStateDesc.BlendEnable[2]=false;
	blendStateDesc.BlendEnable[3]=false;
	blendStateDesc.BlendEnable[4]=false;
	blendStateDesc.BlendEnable[5]=false;
	blendStateDesc.BlendEnable[6]=false;
	blendStateDesc.BlendEnable[7]=false;
	blendStateDesc.SrcBlend=D3D10_BLEND_ONE;
	blendStateDesc.DestBlend=D3D10_BLEND_ZERO;
	blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
	blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
	blendStateDesc.SrcBlendAlpha=D3D10_BLEND_ONE;
	blendStateDesc.DestBlendAlpha=D3D10_BLEND_ZERO;
	blendStateDesc.RenderTargetWriteMask[0]=D3D10_COLOR_WRITE_ENABLE_ALL;
	blendStateDesc.RenderTargetWriteMask[1]=D3D10_COLOR_WRITE_ENABLE_ALL;
	blendStateDesc.RenderTargetWriteMask[2]=D3D10_COLOR_WRITE_ENABLE_ALL;
	blendStateDesc.RenderTargetWriteMask[3]=D3D10_COLOR_WRITE_ENABLE_ALL;
	blendStateDesc.RenderTargetWriteMask[4]=D3D10_COLOR_WRITE_ENABLE_ALL;
	blendStateDesc.RenderTargetWriteMask[5]=D3D10_COLOR_WRITE_ENABLE_ALL;
	blendStateDesc.RenderTargetWriteMask[6]=D3D10_COLOR_WRITE_ENABLE_ALL;
	blendStateDesc.RenderTargetWriteMask[7]=D3D10_COLOR_WRITE_ENABLE_ALL;

	device->CreateBlendState(&blendStateDesc,&blendStateOFF);
	device->CreateBlendState(&blendStateDesc,&blendStateTMP);
	
	factors[0]=factors[1]=factors[2]=factors[3]=factors[4]=factors[5]=factors[6]=factors[7]=1.0f;

	device->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);

	blendStateDesc.BlendEnable[0]=true;
	blendStateDesc.SrcBlend=D3D10_BLEND_SRC_ALPHA;
	blendStateDesc.DestBlend=D3D10_BLEND_INV_SRC_ALPHA;
	blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
	blendStateDesc.SrcBlendAlpha=D3D10_BLEND_SRC_ALPHA;
	blendStateDesc.DestBlendAlpha=D3D10_BLEND_INV_SRC_ALPHA;
	blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
	device->CreateBlendState(&blendStateDesc,&blendStateON);

	blendStateDesc.BlendEnable[0]=true;
	blendStateDesc.SrcBlend=D3D10_BLEND_ZERO;
	blendStateDesc.DestBlend=D3D10_BLEND_ONE;
	blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
	blendStateDesc.SrcBlendAlpha=D3D10_BLEND_ZERO;
	blendStateDesc.DestBlendAlpha=D3D10_BLEND_ONE;
	blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
	device->CreateBlendState(&blendStateDesc,&blendStateDISCARD);

	blendStateDesc.BlendEnable[0]=true;
	blendStateDesc.SrcBlend=D3D10_BLEND_DEST_COLOR;
	blendStateDesc.DestBlend=D3D10_BLEND_ZERO;
	blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
	blendStateDesc.SrcBlendAlpha=D3D10_BLEND_DEST_ALPHA;
	blendStateDesc.DestBlendAlpha=D3D10_BLEND_ZERO;
	blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
	device->CreateBlendState(&blendStateDesc,&blendStateCOLOR);

	blendStateDesc.BlendEnable[0]=true;
	blendStateDesc.SrcBlend=D3D10_BLEND_INV_SRC_ALPHA;
	blendStateDesc.DestBlend=D3D10_BLEND_SRC_ALPHA;
	blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
	blendStateDesc.SrcBlendAlpha=D3D10_BLEND_INV_SRC_ALPHA;
	blendStateDesc.DestBlendAlpha=D3D10_BLEND_SRC_ALPHA;
	blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
	device->CreateBlendState(&blendStateDesc,&blendStateINVERSE);

	blendStateDesc.BlendEnable[0]=true;
	blendStateDesc.SrcBlend=D3D10_BLEND_SRC_ALPHA;
	blendStateDesc.DestBlend=D3D10_BLEND_ONE;
	blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
	blendStateDesc.SrcBlendAlpha=D3D10_BLEND_SRC_ALPHA;
	blendStateDesc.DestBlendAlpha=D3D10_BLEND_ONE;
	blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
	device->CreateBlendState(&blendStateDesc,&blendStateGOURAUD);

	blendStateDesc.BlendEnable[0]=true;
	blendStateDesc.SrcBlend=D3D10_BLEND_ONE;
	blendStateDesc.DestBlend=D3D10_BLEND_ONE;
	blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
	blendStateDesc.SrcBlendAlpha=D3D10_BLEND_ONE;
	blendStateDesc.DestBlendAlpha=D3D10_BLEND_ONE;
	blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
	device->CreateBlendState(&blendStateDesc,&blendStateADD);

	blendStateDesc.BlendEnable[0]=false;
	blendStateDesc.SrcBlend=D3D10_BLEND_ONE;
	blendStateDesc.DestBlend=D3D10_BLEND_ZERO;
	blendStateDesc.SrcBlendAlpha=D3D10_BLEND_ONE;
	blendStateDesc.DestBlendAlpha=D3D10_BLEND_ZERO;

	if (SecondarySurface)
	{
		for (int n=0;n<nSecondaries;n++)
			if (!setupRenderTexture(n,tile_secondarysurfacesW[n],tile_secondarysurfacesH[n])) return -1;
	}

    Viewport.Width = Sx;
    Viewport.Height = Sy;
    Viewport.MinDepth = 0.0f;
    Viewport.MaxDepth = 1.0f;
    Viewport.TopLeftX = 0;
    Viewport.TopLeftY = 0;

    device->RSSetViewports(1, &Viewport);

	VIEWPORT.Id();
	VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
	VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);
	VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
	VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);
	VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
	VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);

	render=renderTargetView;
	depthstencil=depthStencilView;

	*states[TEXTURES_32BITS]=1;

	RESET=1;

#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	TextureContainer->clean();
#endif

	G_Multitexture=true;
	*states[PIXELSHADER2]=1;

	SelectedRenderTarget=PRIMARY;

	Misc();

	aBack=Back;
	aFront=Front;

	return 1;

#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
	int n;

#ifndef _DEFINES_OPENGL_NO_SDL_INIT_
	int stencil=8;
	int bpp=32;
#endif
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	*states[TEXTURES_CLAMPING]=0;

	Lighting=false;

#ifndef _DEFINES_OPENGL_NO_SDL_INIT_
	
	bpp=SDL_VideoModeOK(Sx,Sy,32,SDL_OPENGL);

	if (bpp==0)
	{
		*states[RENDER_BIT_DEPTH]=16;
		SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5 );
		SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 6 );
		SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5 );
		SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 );
		SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );

	}
	else
	{	
	
		*states[RENDER_BIT_DEPTH]=32;
		SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 8 );
		SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 8 );
		SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 8 );
		SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
		
		if ((StencilBuffer)&&(states(RENDER_BIT_DEPTH)==32))
		{
			SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 24 );
			SDL_GL_SetAttribute( SDL_GL_STENCIL_SIZE,8);
		}
		else
		{
			SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, states(RENDER_BIT_DEPTH) );
		}

	}

	SCREEN_X=Sx;
	SCREEN_Y=Sy;

	screen=SDL_SetVideoMode(SCREEN_X,SCREEN_Y, 0,SDL_OPENGL);
	if (screen == NULL)
	{
		//SDL_Quit();
		return 0;
	}

	SDL_GL_GetAttribute( SDL_GL_STENCIL_SIZE, &stencil);

	if (stencil>0) StencilBuffer=true;
	else StencilBuffer=false;

#else

	SCREEN_X=Sx;
	SCREEN_Y=Sy;
#ifndef API3D_VR
	StencilBuffer=false;
#endif
#endif

	for (n=0;n<1024;n++) Lights[n].enabled=0;

#ifndef _DEFINES_OPENGL_NO_SDL_INIT_
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// OPENGL


#if defined(GLES)||defined(GLES20)
	MultiTexture=true;
	dot3=false;
	G_PS=false;
	G_Multitexture=MultiTexture;
	G_Dot3=dot3;
	G_VertexProgram=false;
	G_PS2X=false;

#else
	if (openglstuff()!=0) return -1;
   
#endif

	if (TAG_RESET==1)
	{
		VertexBufferContainer.Restore();
	}	
	else
	{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
		TextureContainer->clean();
#endif
		//Stating();

		Misc();
	}

	TAG_RESET=1;
	

#else
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// OPENGL ONLY

	SCREEN_X=Sx;
	SCREEN_Y=Sy;
#if !defined(GLES)&&!defined(GLES20)
    if (TAG_RESET==0)
        if (openglstuff()!=0) return -1;
    StencilBuffer=true;    
    
#endif
	if (TAG_RESET==1)
	{
		VertexBufferContainer.Restore();
	}
	else
	{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
		TextureContainer->clean();
#endif
		Misc();
	}
	TAG_RESET=1;

#endif

	SelectedRenderTarget=-1;

#ifndef _DEFINES_API_CODE_TEXTURE_MANAGER_
	for (n=0;n<NBRE_MAX_TEXTURES;n++) cTexture[n]=0;
	for (n=0;n<NBRE_MAX_TEXTURES;n++) Lightmap[n]=0;
#endif

	glDepthFunc(GL_LEQUAL);

	return 1;
	
#endif


#ifdef API3D_DIRECT3D

#ifdef API3D_SDL_DIRECT3D

	int RGB=16;
	SDL_SysWMinfo info;
	SDL_Surface *screen;

	if (F==RGB16BITS) {
		RGB=16;
	} else {
		if (F=RGB24BITS) RGB=24; else RGB=32;
	}

	screen=SDL_SetVideoMode(Sx,Sy,RGB,0);
	if (screen==0) return 0;

	SDL_VERSION(&info.version);
	SDL_GetWMInfo(&info);

	hInstance = NULL;
	hWindow = info.window;
#endif

	//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	UINT nAdapter;
	int res;
	int RESET,CHECK_ADAPTER;
	int n;
	HRESULT h;

	SCREEN_X=Sx;
	SCREEN_Y=Sy;

	RESET=0;
	CHECK_ADAPTER=0;

	if (SETTINGS_ADAPTER==-1)
	{
	    D3D=Direct3DCreate8(D3D_SDK_VERSION);
		if (D3D==NULL) return 0;

		nAdapter=D3D->GetAdapterCount();
		CHECK_ADAPTER=1;

	}
	else RESET=1;

	if (CHECK_ADAPTER==1)
	{
		if (nAdapter>1)
		{
			n=0;
			res=-1;
			while ((n<(int) nAdapter)&&(res==-1))
			{
				if (F==RGB16BITS)
				{
					if(SUCCEEDED(D3D->CheckDeviceType(n,D3DDEVTYPE_HAL,D3DFMT_R5G6B5,D3DFMT_R5G6B5,FALSE))) res=n;
					else
						if(SUCCEEDED(D3D->CheckDeviceType(n,D3DDEVTYPE_HAL,D3DFMT_X1R5G5B5,D3DFMT_X1R5G5B5,FALSE))) res=n;
				}
				else
				{
					if(SUCCEEDED(D3D->CheckDeviceType(n,D3DDEVTYPE_HAL,D3DFMT_X8R8G8B8,D3DFMT_X8R8G8B8,FALSE))) res=n;
				}
		
				n++;
			}

			if (res<0) res=0;
			SETTINGS_ADAPTER=res;
		}
		else SETTINGS_ADAPTER=0;
	}

    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.Windowed               = TRUE;
    d3dpp.SwapEffect             = API3D_SWAP_FLAGS;
    d3dpp.EnableAutoDepthStencil = TRUE;
	
	RGBbits=F;
	D3DDISPLAYMODE d3ddm;

    if( FAILED( D3D->GetAdapterDisplayMode( D3DADAPTER_DEFAULT, &d3ddm ) ) )
        return E_FAIL;
	SurfaceBackFormat=d3dpp.BackBufferFormat = d3ddm.Format;

	if (StencilBuffer)
	{
		StencilBuffer=false;
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D24S8)))
		{
			d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
			StencilBuffer=true;
		}
		else
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D32)))
			d3dpp.AutoDepthStencilFormat = D3DFMT_D32;
		else
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D24X8)))
			d3dpp.AutoDepthStencilFormat = D3DFMT_D24X8;
		else
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D16)))
			d3dpp.AutoDepthStencilFormat = D3DFMT_D16;

	}
	else
	{
		StencilBuffer=false;
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D32)))
			d3dpp.AutoDepthStencilFormat = D3DFMT_D32;
		else
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D24X8)))
			d3dpp.AutoDepthStencilFormat = D3DFMT_D24X8;
		else
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D16)))
			d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
	}

	d3dpp.BackBufferWidth=Sx;
	d3dpp.BackBufferHeight=Sy;
	d3dpp.BackBufferCount=1;
	d3dpp.hDeviceWindow=hWindow;
	
	d3dpp.Flags=D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;

	d3dpp.FullScreen_PresentationInterval=0;//D3DPRESENT_INTERVAL_IMMEDIATE;

	if (RESET==0)
	{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
		TextureContainer->clean();
#endif
		D3D->GetDeviceCaps(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,&caps); 

		*states[TEXTURE_MAX_WIDTH]=caps.MaxTextureWidth;

		if (caps.MaxSimultaneousTextures>1) G_Multitexture=true;
		else G_Multitexture=false;

		if (caps.TextureOpCaps&D3DTEXOPCAPS_DOTPRODUCT3) G_Dot3=true;
		else G_Dot3=false;

		if( D3DPS_VERSION(1,4) != caps.PixelShaderVersion ) G_PS=false;
		else G_PS=true;


		DWORD Flags;

		if (states(HARDWARE_VERTEX_PROCESSING_E))
		{
			HardwareVertexProcessing=true;
			*states[HARDWARE_VERTEX_PROCESSING]=1;
			if( D3DSHADER_VERSION_MAJOR( caps.VertexShaderVersion ) < 1.1 )
			{
				Flags=D3DCREATE_SOFTWARE_VERTEXPROCESSING;
				*states[HARDWARE_VERTEX_PROCESSING]=0;
				HardwareVertexProcessing=false;
			}
			else Flags=D3DCREATE_MIXED_VERTEXPROCESSING;
		}
		else
		{
			HardwareVertexProcessing=false;
			Flags=D3DCREATE_SOFTWARE_VERTEXPROCESSING;
		}

		Flags|=D3DCREATE_FPU_PRESERVE;

		if (caps.RasterCaps&D3DPRASTERCAPS_MIPMAPLODBIAS) *states[HARDWARE_VERTEX_PROCESSING_MIPMAP]=1;
		else *states[HARDWARE_VERTEX_PROCESSING_MIPMAP]=0;

		h=D3D->CreateDevice( SETTINGS_ADAPTER, D3DDEVTYPE_HAL, hWindow,
										  Flags,
										  &d3dpp, &D3DDevice );


		if( FAILED(h))
		{
			h=D3D->CreateDevice( SETTINGS_ADAPTER, D3DDEVTYPE_REF, hWindow,
										  D3DCREATE_SOFTWARE_VERTEXPROCESSING,
										  &d3dpp, &D3DDevice );
			if (FAILED(h)) return 0;
		}

		SetDEVICE(D3DDevice);

#ifndef _DEFINES_API_CODE_TEXTURE_MANAGER_
		for (n=0;n<NBRE_MAX_TEXTURES;n++) Texture[n]=NULL;
		for (n=0;n<NBRE_MAX_TEXTURES;n++) cTexture[n]=0;	
#endif
		LOG("vb");
		h=D3DDevice->CreateVertexBuffer(4*sizeof(struct XYZCOLORTEX),D3DUSAGE_WRITEONLY ,D3DFVF_XYZCOLORTEX,D3DPOOL_MANAGED,&D3DVB_XYZCOLORTEX);
		h=D3DDevice->CreateVertexBuffer(4*sizeof(struct XYZCOLOR),D3DUSAGE_WRITEONLY ,D3DFVF_XYZCOLOR,D3DPOOL_MANAGED,&D3DVB_XYZCOLOR);

		Misc();
		for (n=0;n<1024;n++) tagLights[n]=0;
	}
	else
	{
		VertexBufferContainer.OnLostDevice(D3DDevice);
		if (HardwareVertexProcessing) VertexBufferContainer.Release(D3DDevice);
		
		SurfaceBack->Release();

		if (SecondarySurface)
		{
			for (n=0;n<nSecondaries;n++)
			{
				D3DTextureSecondary[n]->Release();
				D3DSecondary[n]->Release();
				D3DSecondaryZbuffer[n]->Release();
			}
		}

		if (ENV_VSH_activated)
		{
			h=Effect_ENV_VSH->OnLostDevice();
			h=Effect_ENV2_VSH->OnLostDevice();

		}
		if (MULTI00) h=MULTI00->OnLostDevice();
		if (MULTI10) h=MULTI10->OnLostDevice();
		if (MULTI01) h=MULTI01->OnLostDevice();
		if (MULTI11) h=MULTI11->OnLostDevice();
		if (SHDVOLUME) h=SHDVOLUME->OnLostDevice();
		if (SHDVOLUMEm) h=SHDVOLUMEm->OnLostDevice();
		if (SHDVOLUME_CR1) h=SHDVOLUME_CR1->OnLostDevice();
		if (SHDVOLUME_CR2) h=SHDVOLUME_CR2->OnLostDevice();
		if (SHDVOLUME_CR1m) h=SHDVOLUME_CR1m->OnLostDevice();
		if (SHDVOLUME_CR2m) h=SHDVOLUME_CR2m->OnLostDevice();
		if (BML) h=BML->OnLostDevice();
		if (BMLD) h=BMLD->OnLostDevice();
		if (BMLa) h=BMLa->OnLostDevice();
		if (SHDVOLUMEc) h=SHDVOLUMEc->OnLostDevice();
		if (SHDVOLUMEmc) h=SHDVOLUMEmc->OnLostDevice();
		if (SHDVOLUMEn) h=SHDVOLUMEn->OnLostDevice();
		if (SHDVOLUMEcn) h=SHDVOLUMEcn->OnLostDevice();

		D3DDevice->Reset(&d3dpp);

		if (HardwareVertexProcessing) VertexBufferContainer.Restore(D3DDevice);
		VertexBufferContainer.OnResetDevice(D3DDevice);

		if (ENV_VSH_activated)
		{
			h=Effect_ENV_VSH->OnResetDevice();
			h=Effect_ENV2_VSH->OnResetDevice();
		}
		if (MULTI00) h=MULTI00->OnResetDevice();
		if (MULTI10) h=MULTI10->OnResetDevice();
		if (MULTI01) h=MULTI01->OnResetDevice();
		if (MULTI11) h=MULTI11->OnResetDevice();
		if (SHDVOLUME) h=SHDVOLUME->OnResetDevice();
		if (SHDVOLUMEm) h=SHDVOLUMEm->OnResetDevice();
		if (SHDVOLUME_CR1) h=SHDVOLUME_CR1->OnResetDevice();
		if (SHDVOLUME_CR2) h=SHDVOLUME_CR2->OnResetDevice();
		if (SHDVOLUME_CR1m) h=SHDVOLUME_CR1m->OnResetDevice();
		if (SHDVOLUME_CR2m) h=SHDVOLUME_CR2m->OnResetDevice();
		if (SHDVOLUMEc) h=SHDVOLUMEc->OnResetDevice();
		if (SHDVOLUMEmc) h=SHDVOLUMEmc->OnResetDevice();
		if (SHDVOLUMEn) h=SHDVOLUMEn->OnResetDevice();
		if (SHDVOLUMEcn) h=SHDVOLUMEcn->OnResetDevice();

		if (BML) h=BML->OnResetDevice();
		if (BMLD) h=BMLD->OnResetDevice();
		if (BMLa) h=BMLa->OnResetDevice();

		for (n=0;n<1024;n++)
		{
			if (tagLights[n])
			{
				if (Lights[n].directionnal)
				{
					SetLightDirectionnal(n,Lights[n].Pos,Lights[n].color[0],Lights[n].color[1],Lights[n].color[2]);
				}
				else
				{
					SetLightPoint(n,Lights[n].Pos,Lights[n].color[0],Lights[n].color[1],Lights[n].color[2],Lights[n].Attenuation,Lights[n].Range);
				}

				if (Lights[n].enabled) EnableLight(n);
				else DisableLight(n);
			}
		}
	}

	if (SecondarySurface)
	{

		if (FAILED(D3D->CheckDeviceFormat( SETTINGS_ADAPTER,D3DDEVTYPE_HAL,d3dpp.BackBufferFormat,D3DUSAGE_RENDERTARGET,D3DRTYPE_TEXTURE,D3DFMT_X8R8G8B8))) 
		{
			if (FAILED(D3D->CheckDeviceFormat( SETTINGS_ADAPTER,D3DDEVTYPE_HAL,d3dpp.BackBufferFormat,D3DUSAGE_RENDERTARGET,D3DRTYPE_TEXTURE,D3DFMT_A8R8G8B8))) 
			{
				if (FAILED(D3D->CheckDeviceFormat( SETTINGS_ADAPTER,D3DDEVTYPE_HAL,d3dpp.BackBufferFormat,D3DUSAGE_RENDERTARGET,D3DRTYPE_TEXTURE,D3DFMT_R8G8B8))) 
				{
					SecondarySurface=false;
				}
				else SecondaryFormat=D3DFMT_R8G8B8;
			}
			else SecondaryFormat=D3DFMT_A8R8G8B8;	
		}
		else SecondaryFormat=D3DFMT_X8R8G8B8;
		
		if (SecondarySurface)
		{
			for (n=0;n<nSecondaries;n++)
			{
				D3DTextureSecondary[n]=NULL;
				D3DSecondary[n]=NULL;
				D3DSecondaryZbuffer[n]=NULL;
			}

			for (int n=0;n<nSecondaries;n++)
				if (!setupRenderTexture(n,tile_secondarysurfacesW[n],tile_secondarysurfacesH[n])) return -1;

			if (!SecondarySurface)
			{
				for (n=0;n<nSecondaries;n++)
				{
					if (D3DTextureSecondary[n]) D3DTextureSecondary[n]->Release();
					if (D3DSecondary[n]) D3DSecondary[n]->Release();
					if (D3DSecondaryZbuffer[n]) D3DSecondaryZbuffer[n]->Release();
				}
			}
		}
	}

	D3DDevice->GetViewport(&ViewPort);

	D3DDevice->GetBackBuffer(0,D3DBACKBUFFER_TYPE_MONO,&SurfaceBack);
	D3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
	D3DDevice->SetTextureStageState(0,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
	D3DDevice->SetTextureStageState(0,D3DTSS_MINFILTER,D3DTEXF_LINEAR);
	D3DDevice->SetTextureStageState(1,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
	D3DDevice->SetTextureStageState(1,D3DTSS_MINFILTER,D3DTEXF_LINEAR);

	D3DDevice->SetTextureStageState(0,D3DTSS_MIPFILTER,D3DTEXF_NONE);
	D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);

	SelectedRenderTarget=PRIMARY;

	DoubleTexture=1;
#endif


#ifdef API3D_DIRECT3D9


#ifdef API3D_SDL_DIRECT3D

	int RGB=16;
	SDL_SysWMinfo info;
	SDL_Surface *screen;

	if (F==RGB16BITS) {
		RGB=16;
	} else {
		if (F=RGB24BITS) RGB=24; else RGB=32;
	}

	screen=SDL_SetVideoMode(Sx,Sy,RGB,0);
	if (screen==0) return 0;

	SDL_VERSION(&info.version);
	SDL_GetWMInfo(&info);

	hInstance = NULL;
	hWindow = info.window;
#endif


	//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	UINT nAdapter;
	int res;
	int RESET,CHECK_ADAPTER;
	int n;
	HRESULT h;

	SCREEN_X=Sx;
	SCREEN_Y=Sy;


	RESET=0;
	CHECK_ADAPTER=0;

	if (SETTINGS_ADAPTER==-1)
	{
	    D3D=Direct3DCreate9(D3D_SDK_VERSION);
		if (D3D==NULL) return 0;

		nAdapter=D3D->GetAdapterCount();
		CHECK_ADAPTER=1;

	}
	else
		RESET=1;

	if (CHECK_ADAPTER==1)
	{
		if (nAdapter>1)
		{

			n=0;
			res=-1;
			while ((n<(int) nAdapter)&&(res==-1))
			{
				if (F==RGB16BITS)
				{
					if(SUCCEEDED(D3D->CheckDeviceType(n,D3DDEVTYPE_HAL,D3DFMT_R5G6B5,D3DFMT_R5G6B5,FALSE))) res=n;
					else
						if(SUCCEEDED(D3D->CheckDeviceType(n,D3DDEVTYPE_HAL,D3DFMT_X1R5G5B5,D3DFMT_X1R5G5B5,FALSE))) res=n;
				}
				else
				{
					if(SUCCEEDED(D3D->CheckDeviceType(n,D3DDEVTYPE_HAL,D3DFMT_X8R8G8B8,D3DFMT_X8R8G8B8,FALSE))) res=n;
				}
		
				n++;
			}

			if (res<0) res=0;

			SETTINGS_ADAPTER=res;

		}
		else
		{

			SETTINGS_ADAPTER=0;
		}
		
	}

    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.Windowed               = TRUE;
    d3dpp.SwapEffect             = API3D_SWAP_FLAGS;
    d3dpp.EnableAutoDepthStencil = TRUE;

	RGBbits=F;

	D3DDISPLAYMODE d3ddm;

    if( FAILED( D3D->GetAdapterDisplayMode( D3DADAPTER_DEFAULT, &d3ddm ) ) )
        return E_FAIL;
	SurfaceBackFormat=d3dpp.BackBufferFormat = d3ddm.Format;

	if (StencilBuffer)
	{
		StencilBuffer=false;
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D24S8)))
		{
			d3dpp.AutoDepthStencilFormat = D3DFMT_D24S8;
			StencilBuffer=true;
		}
		else
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D32)))
			d3dpp.AutoDepthStencilFormat = D3DFMT_D32;
		else
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D24X8)))
			d3dpp.AutoDepthStencilFormat = D3DFMT_D24X8;
		else
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D16)))
			d3dpp.AutoDepthStencilFormat = D3DFMT_D16;

	}
	else
	{
		StencilBuffer=false;
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D32)))
			d3dpp.AutoDepthStencilFormat = D3DFMT_D32;
		else
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D24X8)))
			d3dpp.AutoDepthStencilFormat = D3DFMT_D24X8;
		else
		if (SUCCEEDED(D3D->CheckDepthStencilMatch(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL,d3ddm.Format,d3ddm.Format,D3DFMT_D16)))
			d3dpp.AutoDepthStencilFormat = D3DFMT_D16;
	}


	d3dpp.BackBufferWidth=Sx;
	d3dpp.BackBufferHeight=Sy;
	d3dpp.BackBufferCount=1;
	d3dpp.hDeviceWindow=hWindow;
	d3dpp.Flags=D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;

	if (states(VERTICAL_RETRACE)==1) d3dpp.PresentationInterval=D3DPRESENT_INTERVAL_ONE;
	else if (states(VERTICAL_RETRACE)==2) d3dpp.PresentationInterval=D3DPRESENT_INTERVAL_TWO;
	else if (states(VERTICAL_RETRACE)==3) d3dpp.PresentationInterval=D3DPRESENT_INTERVAL_THREE;
	else d3dpp.PresentationInterval=D3DPRESENT_INTERVAL_IMMEDIATE;

	//d3dpp.PresentationInterval=D3DPRESENT_INTERVAL_ONE;

	if (RESET==0)
	{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
		TextureContainer->clean();
#endif
		D3D->GetDeviceCaps(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,&caps); 

		*states[TEXTURE_MAX_WIDTH]=caps.MaxTextureWidth;

		if (caps.MaxSimultaneousTextures>1) G_Multitexture=true;
		else G_Multitexture=false;

		if (caps.TextureOpCaps&D3DTEXOPCAPS_DOTPRODUCT3) G_Dot3=true;
		else G_Dot3=false;

		if( D3DPS_VERSION(1,4) > caps.PixelShaderVersion ) G_PS=false;
		else G_PS=true;

		if (D3DPS_VERSION(2,0)<=caps.PixelShaderVersion) { *states[PIXELSHADER2]=1; G_PS2X=true; }
		else G_PS2X=false;

		if (caps.StencilCaps&D3DSTENCILCAPS_TWOSIDED) *states[TWOSIDED_STENCIL]=1;

		DWORD Flags;

		if (states(HARDWARE_VERTEX_PROCESSING_E))
		{
			HardwareVertexProcessing=true;
			*states[HARDWARE_VERTEX_PROCESSING]=1;
			if( D3DSHADER_VERSION_MAJOR( caps.VertexShaderVersion ) < 1.1 )
			{
				Flags=D3DCREATE_SOFTWARE_VERTEXPROCESSING;
				*states[HARDWARE_VERTEX_PROCESSING]=0;
				HardwareVertexProcessing=false;
			}
			else Flags=D3DCREATE_MIXED_VERTEXPROCESSING;

			Flags|=D3DCREATE_FPU_PRESERVE;
		}
		else
		{
			HardwareVertexProcessing=false;
			Flags=D3DCREATE_SOFTWARE_VERTEXPROCESSING|D3DCREATE_FPU_PRESERVE;
		}

		if (caps.RasterCaps&D3DPRASTERCAPS_MIPMAPLODBIAS) *states[HARDWARE_VERTEX_PROCESSING_MIPMAP]=1;
		else *states[HARDWARE_VERTEX_PROCESSING_MIPMAP]=0;




		h=D3D->CreateDevice( SETTINGS_ADAPTER, D3DDEVTYPE_HAL, hWindow,
										  Flags,
										  &d3dpp, &D3DDevice );

		if( FAILED(h))
		{
			h=D3D->CreateDevice( SETTINGS_ADAPTER, D3DDEVTYPE_REF, hWindow,
										  D3DCREATE_SOFTWARE_VERTEXPROCESSING,
										  &d3dpp, &D3DDevice );
			if (FAILED(h)) return 0;
		}
		SetDEVICE(D3DDevice);
#ifndef _DEFINES_API_CODE_TEXTURE_MANAGER_
		for (n=0;n<NBRE_MAX_TEXTURES;n++) Texture[n]=NULL;
		for (n=0;n<NBRE_MAX_TEXTURES;n++) cTexture[n]=0;	
#endif
		h=D3DDevice->CreateVertexBuffer(4*sizeof(struct XYZCOLORTEX),D3DUSAGE_WRITEONLY,D3DFVF_XYZCOLORTEX,D3DPOOL_MANAGED,&D3DVB_XYZCOLORTEX,NULL);
		h=D3DDevice->CreateVertexBuffer(4*sizeof(struct XYZCOLOR),D3DUSAGE_WRITEONLY,D3DFVF_XYZCOLOR,D3DPOOL_MANAGED,&D3DVB_XYZCOLOR,NULL);

		Misc();
		for (n=0;n<1024;n++) tagLights[n]=0;
	}
	else
	{
		//vbquads.UnlockVertices();

		if (D3DDevice->TestCooperativeLevel()!=D3D_OK) return 0;

		VertexBufferContainer.OnLostDevice(D3DDevice);
		if (HardwareVertexProcessing) VertexBufferContainer.Release(D3DDevice);
		
		SurfaceBack->Release();

		if (SecondarySurface)
		{
			for (n=0;n<nSecondaries;n++)
			{
				D3DTextureSecondary[n]->Release();
				D3DSecondary[n]->Release();
				D3DSecondaryZbuffer[n]->Release();
			}
		}

		if (ENV_VSH_activated)
		{
			h=Effect_ENV_VSH->OnLostDevice();
			h=Effect_ENV2_VSH->OnLostDevice();
		}

		if (MULTI00) h=MULTI00->OnLostDevice();
		if (MULTI10) h=MULTI10->OnLostDevice();
		if (MULTI01) h=MULTI01->OnLostDevice();
		if (MULTI11) h=MULTI11->OnLostDevice();
		if (SHDVOLUME) h=SHDVOLUME->OnLostDevice();
		if (SHDVOLUMEm) h=SHDVOLUMEm->OnLostDevice();
		if (SHDVOLUME_CR1) h=SHDVOLUME_CR1->OnLostDevice();
		if (SHDVOLUME_CR2) h=SHDVOLUME_CR2->OnLostDevice();
		if (SHDVOLUME_CR1m) h=SHDVOLUME_CR1m->OnLostDevice();
		if (SHDVOLUME_CR2m) h=SHDVOLUME_CR2m->OnLostDevice();
		if (SHDVOLUMEc) h=SHDVOLUMEc->OnLostDevice();
		if (SHDVOLUMEmc) h=SHDVOLUMEmc->OnLostDevice();
		if (SHDVOLUMEn) h=SHDVOLUMEn->OnLostDevice();
		if (SHDVOLUMEcn) h=SHDVOLUMEcn->OnLostDevice();

		if (BML) h=BML->OnLostDevice();
		if (BMLD) h=BMLD->OnLostDevice();
		if (BMLa) h=BMLa->OnLostDevice();

		D3DDevice->Reset(&d3dpp);

		if (HardwareVertexProcessing) VertexBufferContainer.Restore(D3DDevice);
		VertexBufferContainer.OnResetDevice(D3DDevice);

		if (ENV_VSH_activated)
		{
			h=Effect_ENV_VSH->OnResetDevice();
			h=Effect_ENV2_VSH->OnResetDevice();
		}
		if (MULTI00) h=MULTI00->OnResetDevice();
		if (MULTI10) h=MULTI10->OnResetDevice();
		if (MULTI01) h=MULTI01->OnResetDevice();
		if (MULTI11) h=MULTI11->OnResetDevice();
		if (SHDVOLUME) h=SHDVOLUME->OnResetDevice();
		if (SHDVOLUMEm) h=SHDVOLUMEm->OnResetDevice();
		if (SHDVOLUME_CR1) h=SHDVOLUME_CR1->OnResetDevice();
		if (SHDVOLUME_CR2) h=SHDVOLUME_CR2->OnResetDevice();
		if (SHDVOLUME_CR1m) h=SHDVOLUME_CR1m->OnResetDevice();
		if (SHDVOLUME_CR2m) h=SHDVOLUME_CR2m->OnResetDevice();
		if (SHDVOLUMEc) h=SHDVOLUMEc->OnResetDevice();
		if (SHDVOLUMEmc) h=SHDVOLUMEmc->OnResetDevice();
		if (SHDVOLUMEn) h=SHDVOLUMEn->OnResetDevice();
		if (SHDVOLUMEcn) h=SHDVOLUMEcn->OnResetDevice();

		if (BML) h=BML->OnResetDevice();
		if (BMLD) h=BMLD->OnResetDevice();
		if (BMLa) h=BMLa->OnResetDevice();

		for (n=0;n<1024;n++)
		{
			if (tagLights[n])
			{
				if (Lights[n].directionnal)
				{
					SetLightDirectionnal(n,Lights[n].Pos,Lights[n].color[0],Lights[n].color[1],Lights[n].color[2]);
				}
				else
				{
					SetLightPoint(n,Lights[n].Pos,Lights[n].color[0],Lights[n].color[1],Lights[n].color[2],Lights[n].Attenuation,Lights[n].Range);
				}

				if (Lights[n].enabled) EnableLight(n);
				else DisableLight(n);
			}
		}

		D3DXMATRIX proj;
		D3DXMatrixOrthoLH( &proj, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );

		ProjOrtho.a[0][0]=proj._11;	ProjOrtho.a[1][0]=proj._21;	ProjOrtho.a[2][0]=proj._31;	ProjOrtho.a[3][0]=proj._41;
		ProjOrtho.a[0][1]=-proj._12; ProjOrtho.a[1][1]=-proj._22; ProjOrtho.a[2][1]=-proj._32; ProjOrtho.a[3][1]=-proj._42;
		ProjOrtho.a[0][2]=proj._13;	ProjOrtho.a[1][2]=proj._23;	ProjOrtho.a[2][2]=proj._33;	ProjOrtho.a[3][2]=proj._43;
		ProjOrtho.a[0][3]=proj._14;	ProjOrtho.a[1][3]=proj._24;	ProjOrtho.a[2][3]=proj._34;	ProjOrtho.a[3][3]=proj._44;

		vbquads.LockVertices();
		nMultiQuads=0;
	}

	D3DDevice->GetViewport(&ViewPort);

	if (SecondarySurface)
	{
		if (FAILED(D3D->CheckDeviceFormat( SETTINGS_ADAPTER,D3DDEVTYPE_HAL,d3dpp.BackBufferFormat,D3DUSAGE_RENDERTARGET,D3DRTYPE_TEXTURE,D3DFMT_A8R8G8B8))) 
		{
			if (FAILED(D3D->CheckDeviceFormat( SETTINGS_ADAPTER,D3DDEVTYPE_HAL,d3dpp.BackBufferFormat,D3DUSAGE_RENDERTARGET,D3DRTYPE_TEXTURE,D3DFMT_X8R8G8B8)) )
			{
				if (FAILED(D3D->CheckDeviceFormat( SETTINGS_ADAPTER,D3DDEVTYPE_HAL,d3dpp.BackBufferFormat,D3DUSAGE_RENDERTARGET,D3DRTYPE_TEXTURE,D3DFMT_R8G8B8))) 
				{
					SecondarySurface=false;

				} else SecondaryFormat=D3DFMT_R8G8B8;

			} else SecondaryFormat=D3DFMT_X8R8G8B8;

		} else SecondaryFormat=D3DFMT_A8R8G8B8;

		if (SecondarySurface)
		{
			for (n=0;n<nSecondaries;n++)
			{
				D3DTextureSecondary[n]=NULL;
				D3DSecondary[n]=NULL;
				D3DSecondaryZbuffer[n]=NULL;
			}

			for (n=0;n<nSecondaries;n++)
				if (!setupRenderTexture(n,tile_secondarysurfacesW[n],tile_secondarysurfacesH[n])) return -1;

			if (!SecondarySurface)
			{
				for (n=0;n<nSecondaries;n++)
				{
					if (D3DTextureSecondary[n]) D3DTextureSecondary[n]->Release();
					if (D3DSecondary[n]) D3DSecondary[n]->Release();
					if (D3DSecondaryZbuffer[n]) D3DSecondaryZbuffer[n]->Release();
				}
			}
		}
	}

	D3DDevice->GetBackBuffer(0,0,D3DBACKBUFFER_TYPE_MONO,&SurfaceBack);

	D3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

	D3DDevice->SetSamplerState(0,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
	D3DDevice->SetSamplerState(0,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);
	D3DDevice->SetSamplerState(1,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
	D3DDevice->SetSamplerState(1,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);

	D3DDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
	D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);

	SelectedRenderTarget=PRIMARY;

	DoubleTexture=1;

#endif

	return 1;

}
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Init FULLSCREEN
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

int C3DAPIBASE::InitVideo(int Sx,int Sy,int Flag)
{
#if defined(API3D_DIRECT3D10) || defined(API3D_DIRECT3D11) || defined(API3D_DIRECT3D12) || defined(API3D_METAL)

	return -1;
#else

	int n;
	int F=Flag;

	if (!TheClass3DAPI) TheClass3DAPI=(C3DAPIBASE*) this;

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)

#ifndef _DEFINES_OPENGL_NO_SDL_INIT_
	int stencil;
#endif
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	*states[TEXTURES_CLAMPING]=0;

	Lighting=false;

#ifndef _DEFINES_OPENGL_NO_SDL_INIT_

	if (F==RGB16BITS)
	{
		*states[RENDER_BIT_DEPTH]=16;
		SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 5 );
		SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 6 );
		SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 5 );
		SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 16 );
		SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
		SDL_GL_SetAttribute( SDL_GL_BUFFER_SIZE, states(RENDER_BIT_DEPTH));
	}
	else
	{
		if (F==RGB24BITS) *states[RENDER_BIT_DEPTH]=24; else *states[RENDER_BIT_DEPTH]=32;
		SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 8 );
		SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 8 );
		SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 8 );
		SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, 24 );

		SDL_GL_SetAttribute( SDL_GL_BUFFER_SIZE, states(RENDER_BIT_DEPTH));

		if (StencilBuffer)
		SDL_GL_SetAttribute( SDL_GL_STENCIL_SIZE,8);

		SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
	}

	//SDL_GL_SetAttribute( SDL_GL_ALPHA_SIZE, 0);

	SDL_Rect **modes;
	int sw,sh,res;
	modes=SDL_ListModes(NULL, SDL_FULLSCREEN|SDL_OPENGL);

	sw=sh=0;
	res=0;
	for(n=0;modes[n];++n)
	{
		if ((modes[n]->w==Sx)&&(modes[n]->h==Sy)) res=1; 

		if (((modes[n]->w>sw)||(modes[n]->h>sh))&&(modes[n]->w<=Sx))
		{
			sw=modes[n]->w;
			sh=modes[n]->h;
		}
	}

	if (res==1)
	{
		SCREEN_X=Sx;
		SCREEN_Y=Sy;
	}
	else
	{
		SCREEN_X=sw;
		SCREEN_Y=sh;
	}

	SCREEN_X=Sx;
	SCREEN_Y=Sy;

	screen=SDL_SetVideoMode(SCREEN_X,SCREEN_Y, states(RENDER_BIT_DEPTH), SDL_FULLSCREEN|SDL_OPENGL);
	
	if (screen == NULL)
	{
		return 0;
	}

	ClearVideoAndZBuffer();
	FlipDoubleBuffer();


	SDL_GL_GetAttribute( SDL_GL_STENCIL_SIZE, &stencil);

	if (stencil>0) StencilBuffer=true;
	else StencilBuffer=false;

#else

	SCREEN_X=Sx;
	SCREEN_Y=Sy;
#endif

	for (n=0;n<1024;n++) Lights[n].enabled=0;

#ifndef _DEFINES_OPENGL_NO_SDL_INIT_
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// OPENGL

#if defined(GLES)||defined(GLES20)

#if defined(GLES20)
	MultiTexture=true;
	dot3=true;
	G_PS=true;
	G_Multitexture=MultiTexture;
	G_Dot3=dot3;
	G_VertexProgram=true;
	G_PS2X=true;
	*states[PIXELSHADER2]=1;
    
#else
	MultiTexture=true;
	dot3=false;
	G_PS=false;
	G_Multitexture=MultiTexture;
	G_Dot3=dot3;
	G_VertexProgram=false;
	G_PS2X=false;

#endif
#else
	if (openglstuff()!=0) return -1;
#endif
    
	if (TAG_RESET==1)
	{
		VertexBufferContainer.Restore();
	}	
	else
	{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
		TextureContainer->clean();
#endif
		//Stating();

		Misc();
	}

	TAG_RESET=1;	

#else
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// OPENGL ONLY

	SCREEN_X=Sx;
	SCREEN_Y=Sy;
    
#if defined(GLES20)
	MultiTexture=true;
	dot3=true;
	G_PS=true;
	G_Multitexture=MultiTexture;
	G_Dot3=dot3;
	G_VertexProgram=true;
	G_PS2X=true;
	*states[PIXELSHADER2]=1;

#if defined(GLESFULL)
	if (openglstuff()!=0) return -1;
#endif

#endif

#if defined(API3D_VR)
	MultiTexture=true;
	dot3=true;
	G_PS=true;
	G_Multitexture=MultiTexture;
	G_Dot3=dot3;
	G_VertexProgram=true;
	G_PS2X=true;
	*states[PIXELSHADER2]=1;

	if (openglstuff()!=0) return -1;

#endif

#if defined(GLES)
	MultiTexture=true;
	dot3=false;
	G_PS=false;
	G_Multitexture=MultiTexture;
	G_Dot3=dot3;
	G_VertexProgram=false;
	G_PS2X=false;

#endif
    
#if defined(GLES20)
    *states[TEXTURE_MAX_WIDTH]=8192;
#endif

	if (TAG_RESET==1)
	{
		VertexBufferContainer.Restore();
	}
	else
	{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
		TextureContainer->clean();
#endif
        
		Misc();
	}
	TAG_RESET=1;

#endif

	SelectedRenderTarget=-1;

#ifndef _DEFINES_API_CODE_TEXTURE_MANAGER_
	for (n=0;n<NBRE_MAX_TEXTURES;n++) cTexture[n]=0;
	for (n=0;n<NBRE_MAX_TEXTURES;n++) Lightmap[n]=0;
#endif

#if defined(GOOGLEVR)||defined(API3D_VR)
    PROJ.Id();
    pPROJ=PROJ;

    for (int i=0;i<4;i++)
        for (int j=0;j<4;j++)
        {
            projection[i+4*j]=PROJ.a[j][i];
        }
#endif

	glDepthFunc(GL_LEQUAL);
	return 1;

#endif
	 

#ifdef API3D_DIRECT3D

//------------------------------------------------------------------------------------------------ DIRECT3D ----------	

	int res;

#ifdef API3D_SDL_DIRECT3D

	int RGB=16;
	SDL_SysWMinfo info;
	SDL_Surface *screen;

	if (F==RGB16BITS) {
		RGB=16;
	} else {
		if (F=RGB24BITS) RGB=24; else RGB=32;
	}

	SDL_Rect **modes;
	int sdlsw,sdlsh;
	modes=SDL_ListModes(NULL, SDL_FULLSCREEN|SDL_OPENGL);

	sdlsw=sdlsh=0;
	res=0;
	for(n=0;modes[n];++n)
	{
		if ((modes[n]->w==Sx)&&(modes[n]->h==Sy)) res=1; 

		if (((modes[n]->w>sdlsw)||(modes[n]->h>sdlsh))&&(modes[n]->w<=Sx))
		{
			sdlsw=modes[n]->w;
			sdlsh=modes[n]->h;
		}
	}

	if (res==1)
	{
		sdlsw=Sx;
		sdlsh=Sy;
	}

	//screen=SDL_SetVideoMode(sdlsw,sdlsh,RGB,SDL_FULLSCREEN);
	screen=SDL_SetVideoMode(sdlsw,sdlsh,RGB,0);
	if (screen==0) return 0;

	SDL_VERSION(&info.version);
	SDL_GetWMInfo(&info);

	hInstance = NULL;
	hWindow = info.window;

#endif


	
	UINT nAdapter;
	int RESET,CHECK_ADAPTER;
	HRESULT h;
	UINT nVideoMode;
	D3DDISPLAYMODE dpm;
	UINT sw,sh;


	for (n=0;n<1024;n++) Lights[n].enabled=0;

	RESET=0;
	CHECK_ADAPTER=0;


	if (SETTINGS_ADAPTER==-1)
	{
	    D3D=Direct3DCreate8(D3D_SDK_VERSION);
		if (D3D==NULL) return 0;

		nAdapter=D3D->GetAdapterCount();
		CHECK_ADAPTER=1;
		
	}
	else
		RESET=1;

	// check video mode

	nVideoMode=D3D->GetAdapterModeCount(D3DADAPTER_DEFAULT);

	sw=sh=0;
	res=0;
	for (n=0;n<(int) nVideoMode;n++)
	{
		D3D->EnumAdapterModes(D3DADAPTER_DEFAULT,(UINT) n,&dpm);
		if ((dpm.Width==(UINT) Sx)&&(dpm.Height==(UINT) Sy)) res=1; 

		if (((dpm.Width>sw)||(dpm.Height>sh))&&(dpm.Width<=(UINT) Sx))
		{
			sw=dpm.Width;
			sh=dpm.Height;
		}
	}

	if (res==1) { SCREEN_X=Sx; SCREEN_Y=Sy; }
	else { SCREEN_X=sw; SCREEN_Y=sh; }

	if (CHECK_ADAPTER==1)
	{
		if (nAdapter>1)
		{
			n=0;
			res=-1;
			while ((n<(int) nAdapter)&&(res==-1))
			{
				if (F==RGB16BITS)
				{
					if(SUCCEEDED(D3D->CheckDeviceType(n,D3DDEVTYPE_HAL,D3DFMT_R5G6B5,D3DFMT_R5G6B5,FALSE))) res=n;
					else
						if(SUCCEEDED(D3D->CheckDeviceType(n,D3DDEVTYPE_HAL,D3DFMT_X1R5G5B5,D3DFMT_X1R5G5B5,FALSE))) res=n;
				}
				else
				{
					if(SUCCEEDED(D3D->CheckDeviceType(n,D3DDEVTYPE_HAL,D3DFMT_X8R8G8B8,D3DFMT_X8R8G8B8,FALSE))) res=n;
				}
				n++;
			}

			if (res<0) res=0;
			SETTINGS_ADAPTER=res;
		}
		else SETTINGS_ADAPTER=0;
	}

	if (F!=RGB16BITS)
	{
		if(FAILED(D3D->CheckDeviceType(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,D3DFMT_X8R8G8B8,D3DFMT_X8R8G8B8,FALSE))) F=RGB16BITS;
	}

	if(SUCCEEDED(D3D->CheckDeviceType(SETTINGS_ADAPTER,D3DDEVTYPE_REF,D3DFMT_R5G6B5,D3DFMT_R5G6B5,FALSE))) rgb16.RenderFormat=D3DFMT_R5G6B5;
	else rgb16.RenderFormat=D3DFMT_X1R5G5B5;

	rgb24.RenderFormat=D3DFMT_X8R8G8B8;
	rgb32.RenderFormat=D3DFMT_X8R8G8B8;

	bool checks=false;

	if (StencilBuffer) checks=true;

	if (F==RGB16BITS)
	{
		if ((checks)&&(SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb16.RenderFormat,rgb16.RenderFormat,D3DFMT_D24S8))))
		{
			rgb16.ZbufferFormat=D3DFMT_D24S8;
			StencilBuffer=true;
		}
		else
		if ((checks)&&(SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb16.RenderFormat,rgb16.RenderFormat,D3DFMT_D15S1))))
		{
			rgb16.ZbufferFormat=D3DFMT_D15S1;
			StencilBuffer=true;
		}
		else
		{
			if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb16.RenderFormat,rgb16.RenderFormat,D3DFMT_D16))) rgb16.ZbufferFormat=D3DFMT_D16;
			else
			if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb16.RenderFormat,rgb16.RenderFormat,D3DFMT_D24X8))) rgb16.ZbufferFormat=D3DFMT_D24X8;
			else
			if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb16.RenderFormat,rgb16.RenderFormat,D3DFMT_D32))) rgb16.ZbufferFormat=D3DFMT_D32;
			
			StencilBuffer=false;
		}
	}
	else
	{

		if (F==RGB24BITS)
		{
			if ((checks)&&(SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb24.RenderFormat,rgb24.RenderFormat,D3DFMT_D24S8))))
			{
				StencilBuffer=true;
				rgb24.ZbufferFormat=D3DFMT_D24S8;
			}
			else
			{
				StencilBuffer=false;

				if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb24.RenderFormat,rgb24.RenderFormat,D3DFMT_D32))) rgb24.ZbufferFormat=D3DFMT_D32;
				else
				if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb24.RenderFormat,rgb24.RenderFormat,D3DFMT_D24X8))) rgb24.ZbufferFormat=D3DFMT_D24X8;
				else
				if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb24.RenderFormat,rgb24.RenderFormat,D3DFMT_D16))) rgb24.ZbufferFormat=D3DFMT_D16;
			}
		}
		else
		{
			if ((checks)&&(SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb32.RenderFormat,rgb32.RenderFormat,D3DFMT_D24S8))))
			{
				StencilBuffer=true;
				rgb32.ZbufferFormat=D3DFMT_D24S8;
			}
			else
			{
				StencilBuffer=false;

				if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb32.RenderFormat,rgb32.RenderFormat,D3DFMT_D32))) rgb32.ZbufferFormat=D3DFMT_D32;
				else
				if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb32.RenderFormat,rgb32.RenderFormat,D3DFMT_D24X8))) rgb32.ZbufferFormat=D3DFMT_D24X8;
				else
				if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb32.RenderFormat,rgb32.RenderFormat,D3DFMT_D16))) rgb32.ZbufferFormat=D3DFMT_D16;
			}

		}
	}


    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.Windowed               = FALSE;
    d3dpp.SwapEffect             = D3DSWAPEFFECT_FLIP;
    d3dpp.EnableAutoDepthStencil = TRUE;

	RGBbits=F;

	if (F==RGB16BITS)
	{
	    d3dpp.AutoDepthStencilFormat = rgb16.ZbufferFormat;
		SurfaceBackFormat=d3dpp.BackBufferFormat = rgb16.RenderFormat;	
	}
	else
	{
		if (F==RGB24BITS)
		{
			d3dpp.AutoDepthStencilFormat = rgb24.ZbufferFormat;
			SurfaceBackFormat=d3dpp.BackBufferFormat = rgb24.RenderFormat;	
		}
		else
		{
			d3dpp.AutoDepthStencilFormat = rgb32.ZbufferFormat;
			SurfaceBackFormat=d3dpp.BackBufferFormat = rgb32.RenderFormat;	
		}
	}


	d3dpp.BackBufferWidth=SCREEN_X;
	d3dpp.BackBufferHeight=SCREEN_Y;
	d3dpp.BackBufferCount=1;
	d3dpp.hDeviceWindow=hWindow;
	if (states(VERTICAL_RETRACE)==1) d3dpp.FullScreen_PresentationInterval=D3DPRESENT_INTERVAL_ONE;
	else if (states(VERTICAL_RETRACE)==2) d3dpp.FullScreen_PresentationInterval=D3DPRESENT_INTERVAL_TWO;
	else if (states(VERTICAL_RETRACE)==3) d3dpp.FullScreen_PresentationInterval=D3DPRESENT_INTERVAL_THREE;
	else d3dpp.FullScreen_PresentationInterval=D3DPRESENT_INTERVAL_IMMEDIATE;
	d3dpp.FullScreen_RefreshRateInHz=D3DPRESENT_RATE_DEFAULT;
	d3dpp.Flags=D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;

	

	ViewPort.Width=SCREEN_X;
	ViewPort.Height=SCREEN_Y;
	ViewPort.X=0;
	ViewPort.Y=0;
	ViewPort.MinZ=0.0f;
	ViewPort.MaxZ=1.0f;


	if (RESET==0)
	{
		//Stating();


#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
		TextureContainer->clean();
#endif

		D3DCAPS8 caps;
		D3D->GetDeviceCaps(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,&caps); 

		*states[TEXTURE_MAX_WIDTH]=caps.MaxTextureWidth;

		if (caps.MaxSimultaneousTextures>1) G_Multitexture=true;
		else G_Multitexture=false;

		if (caps.TextureOpCaps&D3DTEXOPCAPS_DOTPRODUCT3) G_Dot3=true;
		else G_Dot3=false;

		if( D3DPS_VERSION(1,4) != caps.PixelShaderVersion ) G_PS=false;
		else G_PS=true;

		if ((caps.TextureOpCaps&D3DTEXOPCAPS_BUMPENVMAP)==0) G_BumpEnvMap=false;
		else G_BumpEnvMap=true;

		DWORD Flags;

		if (states(HARDWARE_VERTEX_PROCESSING_E))
		{
			HardwareVertexProcessing=true;
			*states[HARDWARE_VERTEX_PROCESSING]=1;
			if( D3DSHADER_VERSION_MAJOR( caps.VertexShaderVersion ) < 1.1 )
			{
				Flags=D3DCREATE_SOFTWARE_VERTEXPROCESSING;
				*states[HARDWARE_VERTEX_PROCESSING]=0;
				HardwareVertexProcessing=false;
			}
			else Flags=D3DCREATE_HARDWARE_VERTEXPROCESSING;
		}
		else
		{
			Flags=D3DCREATE_SOFTWARE_VERTEXPROCESSING;
			*states[HARDWARE_VERTEX_PROCESSING]=0;
			HardwareVertexProcessing=false;
		}

		Flags|=D3DCREATE_FPU_PRESERVE;

		if (caps.RasterCaps&D3DPRASTERCAPS_MIPMAPLODBIAS) *states[HARDWARE_VERTEX_PROCESSING_MIPMAP]=1;
		else *states[HARDWARE_VERTEX_PROCESSING_MIPMAP]=0;

		h=D3D->CreateDevice( SETTINGS_ADAPTER, D3DDEVTYPE_HAL, hWindow,
										  Flags,
										  &d3dpp, &D3DDevice );
		if( FAILED(h) )
		{
			h=D3D->CreateDevice( SETTINGS_ADAPTER, D3DDEVTYPE_REF, hWindow,
										  D3DCREATE_SOFTWARE_VERTEXPROCESSING,
										  &d3dpp, &D3DDevice );
			if (FAILED(h)) 
			{
				D3D->Release();
				SETTINGS_ADAPTER=-1;
#ifdef API3D_SDL_DIRECT3D
				SDL_FreeSurface(screen);
#endif
				return 0;
			}
		}
		SetDEVICE(D3DDevice);

#ifndef _DEFINES_API_CODE_TEXTURE_MANAGER_
		for (n=0;n<NBRE_MAX_TEXTURES;n++) Texture[n]=NULL;
		for (n=0;n<NBRE_MAX_TEXTURES;n++) cTexture[n]=0;
#endif
		h=D3DDevice->CreateVertexBuffer(4*sizeof(struct XYZCOLORTEX),D3DUSAGE_WRITEONLY ,D3DFVF_XYZCOLORTEX,D3DPOOL_MANAGED,&D3DVB_XYZCOLORTEX);
		h=D3DDevice->CreateVertexBuffer(4*sizeof(struct XYZCOLOR),D3DUSAGE_WRITEONLY ,D3DFVF_XYZCOLOR,D3DPOOL_MANAGED,&D3DVB_XYZCOLOR);

		Misc();

		for (n=0;n<1024;n++) tagLights[n]=0;

	}
	else
	{

		VertexBufferContainer.OnLostDevice(D3DDevice);
		if (HardwareVertexProcessing) VertexBufferContainer.Release(D3DDevice);
		
		SurfaceBack->Release();

		if (SecondarySurface)
		{
			for (n=0;n<nSecondaries;n++)
			{
				D3DTextureSecondary[n]->Release();
				D3DSecondary[n]->Release();
				D3DSecondaryZbuffer[n]->Release();
			}
		}


		if (ENV_VSH_activated)
		{
			h=Effect_ENV_VSH->OnLostDevice();
			h=Effect_ENV2_VSH->OnLostDevice();

		}
		if (MULTI00) h=MULTI00->OnLostDevice();
		if (MULTI10) h=MULTI10->OnLostDevice();
		if (MULTI01) h=MULTI01->OnLostDevice();
		if (MULTI11) h=MULTI11->OnLostDevice();
		if (SHDVOLUME) h=SHDVOLUME->OnLostDevice();
		if (SHDVOLUMEm) h=SHDVOLUMEm->OnLostDevice();
		if (SHDVOLUME_CR1) h=SHDVOLUME_CR1->OnLostDevice();
		if (SHDVOLUME_CR2) h=SHDVOLUME_CR2->OnLostDevice();
		if (SHDVOLUME_CR1m) h=SHDVOLUME_CR1m->OnLostDevice();
		if (SHDVOLUME_CR2m) h=SHDVOLUME_CR2m->OnLostDevice();
		if (SHDVOLUMEc) h=SHDVOLUMEc->OnLostDevice();
		if (SHDVOLUMEmc) h=SHDVOLUMEmc->OnLostDevice();
		if (SHDVOLUMEn) h=SHDVOLUMEn->OnLostDevice();
		if (SHDVOLUMEcn) h=SHDVOLUMEcn->OnLostDevice();

		if (BML) h=BML->OnLostDevice();
		if (BMLD) h=BMLD->OnLostDevice();
		if (BMLa) h=BMLa->OnLostDevice();


		D3DDevice->Reset(&d3dpp);

		if (HardwareVertexProcessing) VertexBufferContainer.Restore(D3DDevice);
		VertexBufferContainer.OnResetDevice(D3DDevice);

		if (ENV_VSH_activated)
		{
			h=Effect_ENV_VSH->OnResetDevice();
			h=Effect_ENV2_VSH->OnResetDevice();
		}
		if (MULTI00) h=MULTI00->OnResetDevice();
		if (MULTI10) h=MULTI10->OnResetDevice();
		if (MULTI01) h=MULTI01->OnResetDevice();
		if (MULTI11) h=MULTI11->OnResetDevice();
		if (SHDVOLUME) h=SHDVOLUME->OnResetDevice();
		if (SHDVOLUMEm) h=SHDVOLUMEm->OnResetDevice();
		if (SHDVOLUME_CR1) h=SHDVOLUME_CR1->OnResetDevice();
		if (SHDVOLUME_CR2) h=SHDVOLUME_CR2->OnResetDevice();
		if (SHDVOLUME_CR1m) h=SHDVOLUME_CR1m->OnResetDevice();
		if (SHDVOLUME_CR2m) h=SHDVOLUME_CR2m->OnResetDevice();
		if (SHDVOLUMEc) h=SHDVOLUMEc->OnResetDevice();
		if (SHDVOLUMEmc) h=SHDVOLUMEmc->OnResetDevice();
		if (SHDVOLUMEn) h=SHDVOLUMEn->OnResetDevice();
		if (SHDVOLUMEcn) h=SHDVOLUMEcn->OnResetDevice();

		if (BML) h=BML->OnResetDevice();
		if (BMLD) h=BMLD->OnResetDevice();
		if (BMLa) h=BMLa->OnResetDevice();

		for (n=0;n<1024;n++)
		{
			if (tagLights[n])
			{
				if (Lights[n].directionnal)
				{
					SetLightDirectionnal(n,Lights[n].Pos,Lights[n].color[0],Lights[n].color[1],Lights[n].color[2]);
				}
				else
				{
					SetLightPoint(n,Lights[n].Pos,Lights[n].color[0],Lights[n].color[1],Lights[n].color[2],Lights[n].Attenuation,Lights[n].Range);
				}

				if (Lights[n].enabled) EnableLight(n);
				else DisableLight(n);
			}
		}


	}


	if (SecondarySurface)
	{
		int texwidth=states(TEXTURE_MAX_WIDTH);
		for (n=0;n<nSecondaries;n++) { if (tile_secondarysurfaces[n]>texwidth) tile_secondarysurfaces[n]=texwidth; }

		if (FAILED(D3D->CheckDeviceFormat( SETTINGS_ADAPTER,D3DDEVTYPE_HAL,d3dpp.BackBufferFormat,D3DUSAGE_RENDERTARGET,D3DRTYPE_TEXTURE,D3DFMT_X8R8G8B8))) 
		{
			if (FAILED(D3D->CheckDeviceFormat( SETTINGS_ADAPTER,D3DDEVTYPE_HAL,d3dpp.BackBufferFormat,D3DUSAGE_RENDERTARGET,D3DRTYPE_TEXTURE,D3DFMT_A8R8G8B8))) 
			{
				if (FAILED(D3D->CheckDeviceFormat( SETTINGS_ADAPTER,D3DDEVTYPE_HAL,d3dpp.BackBufferFormat,D3DUSAGE_RENDERTARGET,D3DRTYPE_TEXTURE,D3DFMT_R8G8B8))) 
				{
					SecondarySurface=false;
				}
				else SecondaryFormat=D3DFMT_R8G8B8;
			}
			else SecondaryFormat=D3DFMT_A8R8G8B8;	
		}
		else SecondaryFormat=D3DFMT_X8R8G8B8;
		
		if (SecondarySurface)
		{
			for (n=0;n<nSecondaries;n++)
			{
				D3DTextureSecondary[n]=NULL;
				D3DSecondary[n]=NULL;
				D3DSecondaryZbuffer[n]=NULL;
			}

			for (int n=0;n<nSecondaries;n++)
				if (!setupRenderTexture(n,tile_secondarysurfacesW[n],tile_secondarysurfacesH[n])) return -1;

			if (!SecondarySurface)
			{
				for (n=0;n<nSecondaries;n++)
				{
					if (D3DTextureSecondary[n]) D3DTextureSecondary[n]->Release();
					if (D3DSecondary[n]) D3DSecondary[n]->Release();
					if (D3DSecondaryZbuffer[n]) D3DSecondaryZbuffer[n]->Release();
				}
			}
		}
	}

	D3DDevice->GetBackBuffer(0,D3DBACKBUFFER_TYPE_MONO,&SurfaceBack);

	D3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

	D3DDevice->SetTextureStageState(0,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
	D3DDevice->SetTextureStageState(0,D3DTSS_MINFILTER,D3DTEXF_LINEAR);
	D3DDevice->SetTextureStageState(1,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
	D3DDevice->SetTextureStageState(1,D3DTSS_MINFILTER,D3DTEXF_LINEAR);

	D3DDevice->SetTextureStageState(0,D3DTSS_MIPFILTER,D3DTEXF_NONE);
	D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);

	D3DDevice->SetRenderState(D3DRS_ZFUNC,D3DCMP_LESSEQUAL);

	SelectedRenderTarget=PRIMARY;
	DoubleTexture=1;

	ClearVideoAndZBuffer();
	FlipDoubleBuffer();

	if (SecondarySurface)
	{
		for (n=0;n<nSecondaries;n++)
		{
			SetParams(API3D_RENDERTARGET,SECONDARY1+n);
			SetParams(API3D_ZBUFFER,ON);
			ClearVideoAndZBuffer();
		}
		SetParams(API3D_RENDERTARGET,PRIMARY);
	}


	return 1;
#endif


#ifdef API3D_DIRECT3D9

//------------------------------------------------------------------------------------------------ DIRECT3D9 ----------	

	int res;

#ifdef API3D_SDL_DIRECT3D

	int RGB=16;
	SDL_SysWMinfo info;
	SDL_Surface *screen;

	if (F==RGB16BITS) {
		RGB=16;
	} else {
		if (F=RGB24BITS) RGB=24; else RGB=32;
	}

	SDL_Rect **modes;
	int sdlsw,sdlsh;
	modes=SDL_ListModes(NULL, SDL_FULLSCREEN|SDL_OPENGL);

	sdlsw=sdlsh=0;
	res=0;
	for(n=0;modes[n];++n)
	{
		if ((modes[n]->w==Sx)&&(modes[n]->h==Sy)) res=1; 

		if (((modes[n]->w>sdlsw)||(modes[n]->h>sdlsh))&&(modes[n]->w<=Sx))
		{
			sdlsw=modes[n]->w;
			sdlsh=modes[n]->h;
		}
	}

	if (res==1)
	{
		sdlsw=Sx;
		sdlsh=Sy;
	}

	screen=SDL_SetVideoMode(sdlsw,sdlsh,RGB,0);
	if (screen==0) return 0;

	SDL_VERSION(&info.version);
	SDL_GetWMInfo(&info);

	hInstance = NULL;
	hWindow = info.window;

#endif
	
	
	UINT nAdapter;
	int RESET,CHECK_ADAPTER;
	HRESULT h;
	UINT nVideoMode;
	D3DDISPLAYMODE dpm;
	UINT sw,sh;


	for (n=0;n<1024;n++) Lights[n].enabled=0;

	RESET=0;
	CHECK_ADAPTER=0;

	if (SETTINGS_ADAPTER==-1)
	{
	    D3D=Direct3DCreate9(D3D_SDK_VERSION);
		if (D3D==NULL) return 0;
		nAdapter=D3D->GetAdapterCount();
		CHECK_ADAPTER=1;
	}
	else RESET=1;


	D3DFORMAT fmt=D3DFMT_X8R8G8B8;

	nVideoMode=D3D->GetAdapterModeCount(D3DADAPTER_DEFAULT,fmt);

	sw=sh=0;
	res=0;
	for (n=0;n<(int) nVideoMode;n++)
	{
		D3D->EnumAdapterModes(D3DADAPTER_DEFAULT,fmt,(UINT) n,&dpm);
		if ((dpm.Width==(UINT) Sx)&&(dpm.Height==(UINT) Sy)) res=1; 

		if (((dpm.Width>sw)||(dpm.Height>sh))&&(dpm.Width<=(UINT) Sx))
		{
			sw=dpm.Width;
			sh=dpm.Height;
		}
	}

	if (res==1) { SCREEN_X=Sx; SCREEN_Y=Sy; }
	else { SCREEN_X=sw; SCREEN_Y=sh; }
	

	if (CHECK_ADAPTER==1)
	{		
		if (nAdapter>1)
		{
			n=0;
			res=-1;
			while ((n<(int) nAdapter)&&(res==-1))
			{
				if (F==RGB16BITS)
				{
					if(SUCCEEDED(D3D->CheckDeviceType(n,D3DDEVTYPE_HAL,D3DFMT_R5G6B5,D3DFMT_R5G6B5,FALSE))) res=n;
					else
						if(SUCCEEDED(D3D->CheckDeviceType(n,D3DDEVTYPE_HAL,D3DFMT_X1R5G5B5,D3DFMT_X1R5G5B5,FALSE))) res=n;
				}
				else
				{
					if(SUCCEEDED(D3D->CheckDeviceType(n,D3DDEVTYPE_HAL,D3DFMT_X8R8G8B8,D3DFMT_X8R8G8B8,FALSE))) res=n;
				}
				n++;
			}

			if (res<0) res=0;
			SETTINGS_ADAPTER=res;
		}
		else SETTINGS_ADAPTER=0;
	}

	if (F!=RGB16BITS)
	{
		if(FAILED(D3D->CheckDeviceType(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,D3DFMT_X8R8G8B8,D3DFMT_X8R8G8B8,FALSE))) F=RGB16BITS;
	}

	if(SUCCEEDED(D3D->CheckDeviceType(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,D3DFMT_R5G6B5,D3DFMT_R5G6B5,FALSE))) rgb16.RenderFormat=D3DFMT_R5G6B5;
	else rgb16.RenderFormat=D3DFMT_X1R5G5B5;

	rgb24.RenderFormat=D3DFMT_X8R8G8B8;
	rgb32.RenderFormat=D3DFMT_X8R8G8B8;

	bool checks=false;

	if (StencilBuffer) checks=true;


	if (F==RGB16BITS)
	{
		if ((checks)&&(SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb16.RenderFormat,rgb16.RenderFormat,D3DFMT_D24S8))))
		{
			rgb16.ZbufferFormat=D3DFMT_D24S8;
			StencilBuffer=true;
		}
		else
		if ((checks)&&(SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb16.RenderFormat,rgb16.RenderFormat,D3DFMT_D15S1))))
		{
			rgb16.ZbufferFormat=D3DFMT_D15S1;
			StencilBuffer=true;
		}
		else
		{
			if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb16.RenderFormat,rgb16.RenderFormat,D3DFMT_D16))) rgb16.ZbufferFormat=D3DFMT_D16;
			else
			if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb16.RenderFormat,rgb16.RenderFormat,D3DFMT_D24X8))) rgb16.ZbufferFormat=D3DFMT_D24X8;
			else
			if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb16.RenderFormat,rgb16.RenderFormat,D3DFMT_D32))) rgb16.ZbufferFormat=D3DFMT_D32;
			
			StencilBuffer=false;
		}
	}
	else
	{

		if (F==RGB24BITS)
		{
			if ((checks)&&(SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb24.RenderFormat,rgb24.RenderFormat,D3DFMT_D24S8))))
			{
				StencilBuffer=true;
				rgb24.ZbufferFormat=D3DFMT_D24S8;
			}
			else
			{
				StencilBuffer=false;

				if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb24.RenderFormat,rgb24.RenderFormat,D3DFMT_D32))) rgb24.ZbufferFormat=D3DFMT_D32;
				else
				if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb24.RenderFormat,rgb24.RenderFormat,D3DFMT_D24X8))) rgb24.ZbufferFormat=D3DFMT_D24X8;
				else
				if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb24.RenderFormat,rgb24.RenderFormat,D3DFMT_D16))) rgb24.ZbufferFormat=D3DFMT_D16;
			}
		}
		else
		{
			if ((checks)&&(SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb32.RenderFormat,rgb32.RenderFormat,D3DFMT_D24S8))))
			{
				StencilBuffer=true;
				rgb32.ZbufferFormat=D3DFMT_D24S8;
			}
			else
			{
				StencilBuffer=false;

				if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb32.RenderFormat,rgb32.RenderFormat,D3DFMT_D32))) rgb32.ZbufferFormat=D3DFMT_D32;
				else
				if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb32.RenderFormat,rgb32.RenderFormat,D3DFMT_D24X8))) rgb32.ZbufferFormat=D3DFMT_D24X8;
				else
				if (SUCCEEDED(D3D->CheckDepthStencilMatch(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,rgb32.RenderFormat,rgb32.RenderFormat,D3DFMT_D16))) rgb32.ZbufferFormat=D3DFMT_D16;
			}

		}
	}


    ZeroMemory( &d3dpp, sizeof(d3dpp) );
    d3dpp.Windowed               = FALSE;
    d3dpp.SwapEffect             = D3DSWAPEFFECT_FLIP;
    d3dpp.EnableAutoDepthStencil = TRUE;

	RGBbits=F;

	if (F==RGB16BITS)
	{
	    d3dpp.AutoDepthStencilFormat = rgb16.ZbufferFormat;
		SurfaceBackFormat=d3dpp.BackBufferFormat = rgb16.RenderFormat;	
	}
	else
	{
		if (F==RGB24BITS)
		{
			d3dpp.AutoDepthStencilFormat = rgb24.ZbufferFormat;
			SurfaceBackFormat=d3dpp.BackBufferFormat = rgb24.RenderFormat;	
		}
		else
		{
			d3dpp.AutoDepthStencilFormat = rgb32.ZbufferFormat;
			SurfaceBackFormat=d3dpp.BackBufferFormat = rgb32.RenderFormat;	
		}
	}

	d3dpp.BackBufferWidth=SCREEN_X;
	d3dpp.BackBufferHeight=SCREEN_Y;
	d3dpp.BackBufferCount=1;
	d3dpp.hDeviceWindow=hWindow;


	if (states(VERTICAL_RETRACE)==1) d3dpp.PresentationInterval=D3DPRESENT_INTERVAL_ONE;
	else if (states(VERTICAL_RETRACE)==2) d3dpp.PresentationInterval=D3DPRESENT_INTERVAL_TWO;
	else if (states(VERTICAL_RETRACE)==3) d3dpp.PresentationInterval=D3DPRESENT_INTERVAL_THREE;
	else d3dpp.PresentationInterval=D3DPRESENT_INTERVAL_IMMEDIATE;

	d3dpp.FullScreen_RefreshRateInHz=D3DPRESENT_RATE_DEFAULT;
	d3dpp.Flags=D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;

	ViewPort.Width=SCREEN_X;
	ViewPort.Height=SCREEN_Y;
	ViewPort.X=0;
	ViewPort.Y=0;
	ViewPort.MinZ=0.0f;
	ViewPort.MaxZ=1.0f;


	if (RESET==0)
	{

#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
		TextureContainer->clean();
#endif
	
		D3DCAPS9 caps;
		D3D->GetDeviceCaps(SETTINGS_ADAPTER,D3DDEVTYPE_HAL,&caps); 

		*states[TEXTURE_MAX_WIDTH]=caps.MaxTextureWidth;


		if (caps.MaxSimultaneousTextures>1) G_Multitexture=true;
		else G_Multitexture=false;

		if (caps.TextureOpCaps&D3DTEXOPCAPS_DOTPRODUCT3) G_Dot3=true;
		else G_Dot3=false;

		if( D3DPS_VERSION(1,4) > caps.PixelShaderVersion ) G_PS=false;
		else G_PS=true;		

		if (D3DPS_VERSION(2,0)<=caps.PixelShaderVersion) { *states[PIXELSHADER2]=1; G_PS2X=true; }
		else G_PS2X=false;

		if ((caps.TextureOpCaps&D3DTEXOPCAPS_BUMPENVMAP)==0) G_BumpEnvMap=false;
		else G_BumpEnvMap=true;

		DWORD Flags;

		if (states(HARDWARE_VERTEX_PROCESSING_E))
		{
			HardwareVertexProcessing=true;
			*states[HARDWARE_VERTEX_PROCESSING]=1;
			if( D3DSHADER_VERSION_MAJOR( caps.VertexShaderVersion ) < 1.1 )
			{
				Flags=D3DCREATE_SOFTWARE_VERTEXPROCESSING;
				*states[HARDWARE_VERTEX_PROCESSING]=0;
				HardwareVertexProcessing=false;
			}
			else Flags=D3DCREATE_HARDWARE_VERTEXPROCESSING;

		}
		else
		{
			Flags=D3DCREATE_SOFTWARE_VERTEXPROCESSING;
			*states[HARDWARE_VERTEX_PROCESSING]=0;
			HardwareVertexProcessing=false;
		}

		Flags|=D3DCREATE_FPU_PRESERVE;
	
		if (caps.RasterCaps&D3DPRASTERCAPS_MIPMAPLODBIAS) *states[HARDWARE_VERTEX_PROCESSING_MIPMAP]=1;
		else *states[HARDWARE_VERTEX_PROCESSING_MIPMAP]=0;

		h=D3D->CreateDevice( SETTINGS_ADAPTER, D3DDEVTYPE_HAL, hWindow,
										  Flags,
										  &d3dpp, &D3DDevice );
		if( FAILED(h) )
		{
			h=D3D->CreateDevice( SETTINGS_ADAPTER, D3DDEVTYPE_REF, hWindow,
										  D3DCREATE_SOFTWARE_VERTEXPROCESSING,
										  &d3dpp, &D3DDevice );
			if (FAILED(h)) 
			{
				D3D->Release();
				SETTINGS_ADAPTER=-1;
#ifdef API3D_SDL_DIRECT3D
				SDL_FreeSurface(screen);
#endif
				return 0;
			}
		}

		SetDEVICE(D3DDevice);

#ifndef _DEFINES_API_CODE_TEXTURE_MANAGER_
		for (n=0;n<NBRE_MAX_TEXTURES;n++) Texture[n]=NULL;
		for (n=0;n<NBRE_MAX_TEXTURES;n++) cTexture[n]=0;
#endif

		h=D3DDevice->CreateVertexBuffer(4*sizeof(struct XYZCOLORTEX),D3DUSAGE_WRITEONLY,D3DFVF_XYZCOLORTEX,D3DPOOL_MANAGED,&D3DVB_XYZCOLORTEX,NULL);
		h=D3DDevice->CreateVertexBuffer(4*sizeof(struct XYZCOLOR),D3DUSAGE_WRITEONLY,D3DFVF_XYZCOLOR,D3DPOOL_MANAGED,&D3DVB_XYZCOLOR,NULL);
		
		Misc();

		for (n=0;n<1024;n++) tagLights[n]=0;
	}
	else
	{

		VertexBufferContainer.OnLostDevice(D3DDevice);
		if (HardwareVertexProcessing) VertexBufferContainer.Release(D3DDevice);
		
		SurfaceBack->Release();

		if (SecondarySurface)
		{
			for (n=0;n<nSecondaries;n++)
			{
				D3DTextureSecondary[n]->Release();
				D3DSecondary[n]->Release();
				D3DSecondaryZbuffer[n]->Release();
			}
		}

		if (ENV_VSH_activated)
		{
			h=Effect_ENV_VSH->OnLostDevice();
			h=Effect_ENV2_VSH->OnLostDevice();
		}

		if (MULTI00) h=MULTI00->OnLostDevice();
		if (MULTI10) h=MULTI10->OnLostDevice();
		if (MULTI01) h=MULTI01->OnLostDevice();
		if (MULTI11) h=MULTI11->OnLostDevice();
		if (SHDVOLUME) h=SHDVOLUME->OnLostDevice();
		if (SHDVOLUMEm) h=SHDVOLUMEm->OnLostDevice();
		if (SHDVOLUME_CR1) h=SHDVOLUME_CR1->OnLostDevice();
		if (SHDVOLUME_CR2) h=SHDVOLUME_CR2->OnLostDevice();
		if (SHDVOLUME_CR1m) h=SHDVOLUME_CR1m->OnLostDevice();
		if (SHDVOLUME_CR2m) h=SHDVOLUME_CR2m->OnLostDevice();
		if (SHDVOLUMEc) h=SHDVOLUMEc->OnLostDevice();
		if (SHDVOLUMEmc) h=SHDVOLUMEmc->OnLostDevice();
		if (SHDVOLUMEn) h=SHDVOLUMEn->OnLostDevice();
		if (SHDVOLUMEcn) h=SHDVOLUMEcn->OnLostDevice();


		if (BML) h=BML->OnLostDevice();
		if (BMLD) h=BMLD->OnLostDevice();
		if (BMLa) h=BMLa->OnLostDevice();


		D3DDevice->Reset(&d3dpp);

		if (HardwareVertexProcessing) VertexBufferContainer.Restore(D3DDevice);
		VertexBufferContainer.OnResetDevice(D3DDevice);

		if (ENV_VSH_activated)
		{
			h=Effect_ENV_VSH->OnResetDevice();
			h=Effect_ENV2_VSH->OnResetDevice();
		}
		if (MULTI00) h=MULTI00->OnResetDevice();
		if (MULTI10) h=MULTI10->OnResetDevice();
		if (MULTI01) h=MULTI01->OnResetDevice();
		if (MULTI11) h=MULTI11->OnResetDevice();
		if (SHDVOLUME) h=SHDVOLUME->OnResetDevice();
		if (SHDVOLUMEm) h=SHDVOLUMEm->OnResetDevice();
		if (SHDVOLUME_CR1) h=SHDVOLUME_CR1->OnResetDevice();
		if (SHDVOLUME_CR2) h=SHDVOLUME_CR2->OnResetDevice();
		if (SHDVOLUME_CR1m) h=SHDVOLUME_CR1m->OnResetDevice();
		if (SHDVOLUME_CR2m) h=SHDVOLUME_CR2m->OnResetDevice();
		if (SHDVOLUMEc) h=SHDVOLUMEc->OnResetDevice();
		if (SHDVOLUMEmc) h=SHDVOLUMEmc->OnResetDevice();
		if (SHDVOLUMEn) h=SHDVOLUMEn->OnResetDevice();
		if (SHDVOLUMEcn) h=SHDVOLUMEcn->OnResetDevice();

		if (BML) h=BML->OnResetDevice();
		if (BMLD) h=BMLD->OnResetDevice();
		if (BMLa) h=BMLa->OnResetDevice();

		for (n=0;n<1024;n++)
		{
			if (tagLights[n])
			{
				if (Lights[n].directionnal)
				{
					SetLightDirectionnal(n,Lights[n].Pos,Lights[n].color[0],Lights[n].color[1],Lights[n].color[2]);
				}
				else
				{
					SetLightPoint(n,Lights[n].Pos,Lights[n].color[0],Lights[n].color[1],Lights[n].color[2],Lights[n].Attenuation,Lights[n].Range);
				}

				if (Lights[n].enabled) EnableLight(n);
				else DisableLight(n);
			}
		}
	}


	if (SecondarySurface)
	{
		int texwidth=states(TEXTURE_MAX_WIDTH);
		for (n=0;n<nSecondaries;n++) { if (tile_secondarysurfaces[n]>texwidth) tile_secondarysurfaces[n]=texwidth; }

		if (FAILED(D3D->CheckDeviceFormat( SETTINGS_ADAPTER,D3DDEVTYPE_HAL,d3dpp.BackBufferFormat,D3DUSAGE_RENDERTARGET,D3DRTYPE_TEXTURE,D3DFMT_X8R8G8B8))) 
		{
			if (FAILED(D3D->CheckDeviceFormat( SETTINGS_ADAPTER,D3DDEVTYPE_HAL,d3dpp.BackBufferFormat,D3DUSAGE_RENDERTARGET,D3DRTYPE_TEXTURE,D3DFMT_A8R8G8B8))) 
			{
				if (FAILED(D3D->CheckDeviceFormat( SETTINGS_ADAPTER,D3DDEVTYPE_HAL,d3dpp.BackBufferFormat,D3DUSAGE_RENDERTARGET,D3DRTYPE_TEXTURE,D3DFMT_R8G8B8))) 
				{
					SecondarySurface=false;
				}
				else SecondaryFormat=D3DFMT_R8G8B8;
			}
			else SecondaryFormat=D3DFMT_A8R8G8B8;	
		}
		else SecondaryFormat=D3DFMT_X8R8G8B8;
		


		if (SecondarySurface)
		{

			for (n=0;n<nSecondaries;n++)
			{
				D3DTextureSecondary[n]=NULL;
				D3DSecondary[n]=NULL;
				D3DSecondaryZbuffer[n]=NULL;
			}

			for (n=0;n<nSecondaries;n++)
				if (!setupRenderTexture(n,tile_secondarysurfaces[n],tile_secondarysurfaces[n])) return -1;

			if (!SecondarySurface)
			{
				for (n=0;n<nSecondaries;n++)
				{
					if (D3DTextureSecondary[n]) D3DTextureSecondary[n]->Release();
					if (D3DSecondary[n]) D3DSecondary[n]->Release();
					if (D3DSecondaryZbuffer[n]) D3DSecondaryZbuffer[n]->Release();
				}
			}
		}
	}

	D3DDevice->GetBackBuffer(0,0,D3DBACKBUFFER_TYPE_MONO,&SurfaceBack);
	D3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

	D3DDevice->SetSamplerState(0,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
	D3DDevice->SetSamplerState(0,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);
	D3DDevice->SetSamplerState(1,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
	D3DDevice->SetSamplerState(1,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);

	D3DDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
	D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);

	D3DDevice->SetRenderState(D3DRS_ZFUNC,D3DCMP_LESSEQUAL);

	SelectedRenderTarget=PRIMARY;
	DoubleTexture=1;

	ClearVideoAndZBuffer();
	FlipDoubleBuffer();

	if (SecondarySurface)
	{
		for (n=0;n<nSecondaries;n++)
		{
			SetParams(API3D_RENDERTARGET,SECONDARY1+n);
			SetParams(API3D_ZBUFFER,ON);
			ClearVideoAndZBuffer();
		}
		SetParams(API3D_RENDERTARGET,PRIMARY);
	}

	return 1;
#endif

#endif
}
/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	Init Viewport

	Usage: to be called after InitVideoXXX
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::InitViewport()
{
#if defined(GOOGLEVR)||defined(API3D_VR)
    return;
#endif

#ifdef API3D_METAL
	int w,h;
	w=GetWidth();
	h=GetHeight();

	Viewport.Width =(float) w;
	Viewport.Height =(float) h;
	Viewport.MinDepth = 0.0f;
	Viewport.MaxDepth = 1.0f;
	Viewport.TopLeftX = 0;
	Viewport.TopLeftY = 0;

    MTLSetViewport(Viewport.TopLeftX,Viewport.TopLeftY,Viewport.TopLeftX+Viewport.Width,Viewport.TopLeftY+Viewport.Height);

	VIEWPORT.Id();
	VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
	VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);
	VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
	VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);
	VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
	VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);

	MatrixOrthoLHS( &ProjOrtho, (float)w, (float)h, 0.0f, 1.0f );
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)	
	int w,h;
	w=GetWidth();
	h=GetHeight();

	if (h==0) h=1;
	glViewport(0,0,w,h);

	//TODO
	VIEWPORT.Id();

	VIEWPORT.a[0][0]=(float) (w/2);
	VIEWPORT.a[3][0]=(float) (0+w/2);

	VIEWPORT.a[1][1]=((float) (h/2));
	VIEWPORT.a[3][1]=(float) (0+h/2);

	VIEWPORT.a[2][2]=(float) (1.0f);
	VIEWPORT.a[3][2]=(float) (0.0f);

#endif
#ifdef API3D_DIRECT3D
	D3DVIEWPORT8 view;

	view.Width=SCREEN_X;
	view.Height=SCREEN_Y;
	view.X=0;
	view.Y=0;
	view.MinZ=0.0f;
	view.MaxZ=1.0f;

	D3DDevice->SetViewport(&view);

	D3DDevice->GetViewport(&ViewPort);

	VIEWPORT.Id();
	VIEWPORT.a[0][0]=(float) (ViewPort.Width/2);
	VIEWPORT.a[3][0]=(float) (ViewPort.X+ViewPort.Width/2);

	VIEWPORT.a[1][1]=((float) (ViewPort.Height/2));
	VIEWPORT.a[3][1]=(float) (ViewPort.Y+ViewPort.Height/2);

	VIEWPORT.a[2][2]=(float) (ViewPort.MaxZ-ViewPort.MinZ);
	VIEWPORT.a[3][2]=(float) (ViewPort.MinZ);

#endif

#ifdef API3D_DIRECT3D9
	D3DVIEWPORT9 view;

	view.Width=SCREEN_X;
	view.Height=SCREEN_Y;
	view.X=0;
	view.Y=0;
	view.MinZ=0.0f;
	view.MaxZ=1.0f;

	D3DDevice->SetViewport(&view);

	D3DDevice->GetViewport(&ViewPort);

	VIEWPORT.Id();
	VIEWPORT.a[0][0]=(float) (ViewPort.Width/2);
	VIEWPORT.a[3][0]=(float) (ViewPort.X+ViewPort.Width/2);

	VIEWPORT.a[1][1]=((float) (ViewPort.Height/2));
	VIEWPORT.a[3][1]=(float) (ViewPort.Y+ViewPort.Height/2);

	VIEWPORT.a[2][2]=(float) (ViewPort.MaxZ-ViewPort.MinZ);
	VIEWPORT.a[3][2]=(float) (ViewPort.MinZ);

#endif

	SetViewport(0,0,SCREEN_X,SCREEN_Y);
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

    Set Scissor

    Usage: to be called after InitVideoXXX
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetScissor(int x1,int y1,int x2,int y2)
{
#if defined(GOOGLEVR)||defined(API3D_VR)

#else

#if defined(API3D_METAL)
    MTLSetScissor(x1,y1,x2,y2);
#endif
    
#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
    if (states(RENDER_TARGET)==PRIMARY)
    {
        glEnable(GL_SCISSOR_TEST);
        glScissor(x1,y1,x2,y2);
    }
    else glDisable(GL_SCISSOR_TEST);
#endif
    
#if defined(API3D_DIRECT3D10)
    if (states(RENDER_TARGET)==PRIMARY)
    {
        scissor.top=y1;
        scissor.left=x1;
        scissor.right=x2;
        scissor.bottom=y2;
        device->RSSetScissorRects( 1, &scissor );

        rasterDesc.ScissorEnable = true;

        if (rasterState) rasterState->Release();
        device->CreateRasterizerState(&rasterDesc, &rasterState);
        device->RSSetState(rasterState);
    }
    else
    {
        rasterDesc.ScissorEnable = false;
    
        if (rasterState) rasterState->Release();
        device->CreateRasterizerState(&rasterDesc, &rasterState);
        device->RSSetState(rasterState);
    }
#endif

#if defined(API3D_DIRECT3D11)
    if (states(RENDER_TARGET)==PRIMARY)
    {
        scissor.top=y1;
        scissor.left=x1;
        scissor.right=x2;
        scissor.bottom=y2;
        devicecontext->RSSetScissorRects( 1, &scissor );

        rasterDesc.ScissorEnable = true;

        if (rasterState) rasterState->Release();
        device->CreateRasterizerState(&rasterDesc, &rasterState);
        devicecontext->RSSetState(rasterState);
    }
    else
    {
        rasterDesc.ScissorEnable = false;
    
        if (rasterState) rasterState->Release();
        device->CreateRasterizerState(&rasterDesc, &rasterState);
        devicecontext->RSSetState(rasterState);
    }
#endif

#if defined(API3D_DIRECT3D12)
    viewportmodified=true;
    ScissorRect.top=(LONG)y1;
    ScissorRect.left=(LONG)x1;
    ScissorRect.bottom=(LONG)y2;
    ScissorRect.right=(LONG)x2;
    ScissorRectActual=ScissorRect;
#endif

#if defined(API3D_DIRECT3D9)
    if (states(RENDER_TARGET)==PRIMARY)
    {
        scissor.top=y1;
        scissor.left=x1;
        scissor.right=x2;
        scissor.bottom=y2;
        D3DDevice->SetRenderState(D3DRS_SCISSORTESTENABLE,TRUE);
        D3DDevice->SetScissorRect(&scissor);
    }
    else
    {
        D3DDevice->SetRenderState(D3DRS_SCISSORTESTENABLE,FALSE);
    }
#endif
    
#endif
    
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	Set Viewport

	Usage: to be called after InitVideoXXX
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetViewport(int _x1,int _y1,int _x2,int _y2)
{
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif
    
#if defined(GOOGLEVR)||defined(API3D_VR)

    int x1=_x1;
    int y1=_y1;
    int x2=_x2;
    int y2=_y2;

    if (SelectedRenderTarget<0)
    {
        glViewport(viewportVR[0],viewportVR[1],viewportVR[2],viewportVR[3]);

        X1base=0;
        Y1base=0;
        X2base=viewportVR[2];
        Y2base=viewportVR[3];

        float ww=(float)viewportVR[2];
        float hh=(float)viewportVR[3];

        ProjOrtho.a[0][0] = 2.0f/ww;
        ProjOrtho.a[1][0] = 0.0f;
        ProjOrtho.a[2][0] = 0.0f;
        ProjOrtho.a[3][0] = 0.0f;

        ProjOrtho.a[0][1] = 0.0f;
        ProjOrtho.a[1][1] = -2.0f/hh;
		ProjOrtho.a[2][1] = 0.0f;
        ProjOrtho.a[3][1] = 0.0f;

        ProjOrtho.a[0][2] = 0.0f;
        ProjOrtho.a[1][2] = 0.0f;
        ProjOrtho.a[2][2] = 2.0f;
        ProjOrtho.a[3][2] = -1.0f;

        ProjOrtho.a[0][3] = 0.0f;
        ProjOrtho.a[1][3] = 0.0f;
        ProjOrtho.a[2][3] = 0.0f;
        ProjOrtho.a[3][3] = 1.0f;

        VIEWPORT.Id();

        VIEWPORT.a[0][0]=(float) (ww/2);
        VIEWPORT.a[3][0]=(float) (0+ww/2);

        VIEWPORT.a[1][1]=((float) (hh/2));
        VIEWPORT.a[3][1]=(float) (0+hh/2);

        VIEWPORT.a[2][2]=(float) (1.0f);
        VIEWPORT.a[3][2]=(float) (0.0f);

    }
    else
    {
        int w=(int)(x2-x1);
        int h=(int)(y2-y1);

        X1base=(int)x1;
        Y1base=(int)y1;
        X2base=(int)x2;
        Y2base=(int)y2;

        if (h==0) h=1;

        int maxy=tile_secondarysurfacesH[SelectedRenderTarget];
       	//glViewport((int)x1,maxy-(int)y2,w,h);
		glViewport(0.495f+(int)x1,0.495f+maxy-(int)y2,w,h);


        setPO(&ProjOrtho,(float)w,(float)h);

        VIEWPORT.Id();

        VIEWPORT.a[0][0]=(float) (w/2);
        VIEWPORT.a[3][0]=(float) (x1+w/2);

        VIEWPORT.a[1][1]=((float) (h/2));
        VIEWPORT.a[3][1]=(float) (y1+h/2);

        VIEWPORT.a[2][2]=(float) (1.0f);
        VIEWPORT.a[3][2]=(float) (0.0f);

    }
#else

    int x1=_x1;
    int y1=_y1;
    int x2=_x2;
    int y2=_y2;
    
    if (states(RENDER_TARGET)==PRIMARY)
    {
        x1-=(int)overscanX;
        x2+=(int)overscanX;
    }

	int w=(int)(x2-x1);
	int h=(int)(y2-y1);

    X1base=(int)x1;
    Y1base=(int)y1;
    X2base=(int)x2;
    Y2base=(int)y2;

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)

	if (h==0) h=1;

	int maxy=SCREEN_Y;
	if (SelectedRenderTarget>=0) maxy=tile_secondarysurfacesH[SelectedRenderTarget];
	//glViewport(x1,maxy-y2,w,h);

	glViewport(x1,maxy-y2,w,h);
    
#if !defined(GLES20)
	glLoadIdentity();
#endif

#if defined(API3D_OPENGL20)
	setPO(&ProjOrtho,(float)w,(float)h);
#endif
	
    VIEWPORT.Id();
    
	VIEWPORT.a[0][0]=(float) (w/2);
	VIEWPORT.a[3][0]=(float) (x1+w/2);
    
	VIEWPORT.a[1][1]=((float) (h/2));
	VIEWPORT.a[3][1]=(float) (y1+h/2);
    
	VIEWPORT.a[2][2]=(float) (1.0f);
	VIEWPORT.a[3][2]=(float) (0.0f);
    
    if (states(RENDER_TARGET)==PRIMARY) SetScissor(_x1,maxy-_y2,(int)(w+overscanX),h);
    else glDisable(GL_SCISSOR_TEST);
    
#endif
#endif
#ifdef API3D_DIRECT3D

	D3DVIEWPORT8 view;

	view.Width=w;
	view.Height=h;
	view.X=x1;
	view.Y=y1;
	view.MinZ=0.0f;
	view.MaxZ=1.0f;

	D3DDevice->SetViewport(&view);
	D3DDevice->GetViewport(&ViewPort);

	VIEWPORT.Id();
	VIEWPORT.a[0][0]=(float) (ViewPort.Width/2);
	VIEWPORT.a[3][0]=(float) (ViewPort.X+ViewPort.Width/2);

	VIEWPORT.a[1][1]=((float) (ViewPort.Height/2));
	VIEWPORT.a[3][1]=(float) (ViewPort.Y+ViewPort.Height/2);

	VIEWPORT.a[2][2]=(float) (ViewPort.MaxZ-ViewPort.MinZ);
	VIEWPORT.a[3][2]=(float) (ViewPort.MinZ);

    if (states(RENDER_TARGET)==PRIMARY) SetScissor(_x1,_y1,(int)(_x2+overscanX),_y2);
    else SetScissor(_x1,_y1,_x2,_y2);

#endif

#ifdef API3D_DIRECT3D9

	D3DVIEWPORT9 view;

	view.Width=w;
	view.Height=h;
	view.X=(DWORD)x1;
	view.Y=(DWORD)y1;
	view.MinZ=0.0f;
	view.MaxZ=1.0f;

	D3DDevice->SetViewport(&view);
	D3DDevice->GetViewport(&ViewPort);

	VIEWPORT.Id();
	VIEWPORT.a[0][0]=(float) (ViewPort.Width/2);
	VIEWPORT.a[3][0]=(float) (ViewPort.X+ViewPort.Width/2);

	VIEWPORT.a[1][1]=((float) (ViewPort.Height/2));
	VIEWPORT.a[3][1]=(float) (ViewPort.Y+ViewPort.Height/2);

	VIEWPORT.a[2][2]=(float) (ViewPort.MaxZ-ViewPort.MinZ);
	VIEWPORT.a[3][2]=(float) (ViewPort.MinZ);

	D3DXMATRIX proj;
	D3DXMatrixOrthoLH( &proj, (float)w, (float)h, 0.0f,1.0f );

	ProjOrtho.a[0][0]=proj._11;	ProjOrtho.a[1][0]=proj._21;	ProjOrtho.a[2][0]=proj._31;	ProjOrtho.a[3][0]=proj._41;
	ProjOrtho.a[0][1]=-proj._12; ProjOrtho.a[1][1]=-proj._22; ProjOrtho.a[2][1]=-proj._32; ProjOrtho.a[3][1]=-proj._42;
	ProjOrtho.a[0][2]=proj._13;	ProjOrtho.a[1][2]=proj._23;	ProjOrtho.a[2][2]=proj._33;	ProjOrtho.a[3][2]=proj._43;
	ProjOrtho.a[0][3]=proj._14;	ProjOrtho.a[1][3]=proj._24;	ProjOrtho.a[2][3]=proj._34;	ProjOrtho.a[3][3]=proj._44;

    if (states(RENDER_TARGET)==PRIMARY) SetScissor(_x1,_y1,(int)(_x2+overscanX),_y2);
    else SetScissor(_x1,_y1,_x2,_y2);

#endif

#ifdef API3D_DIRECT3D10

    Viewport.Width = w;
    Viewport.Height = h;
    Viewport.MinDepth = 0.0f;
    Viewport.MaxDepth = 1.0f;
    Viewport.TopLeftX = (INT) x1;
    Viewport.TopLeftY = (INT) y1;

    device->RSSetViewports(1, &Viewport);

	VIEWPORT.Id();
	VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
	VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);

	VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
	VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);

	VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
	VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);

	D3DXMATRIX proj;
	D3DXMatrixOrthoLH( &proj, (float)w, (float)h, 0.0f,1.0f );

	ProjOrtho.a[0][0]=proj._11;	ProjOrtho.a[1][0]=proj._21;	ProjOrtho.a[2][0]=proj._31;	ProjOrtho.a[3][0]=proj._41;
	ProjOrtho.a[0][1]=-proj._12; ProjOrtho.a[1][1]=-proj._22; ProjOrtho.a[2][1]=-proj._32; ProjOrtho.a[3][1]=-proj._42;
	ProjOrtho.a[0][2]=proj._13;	ProjOrtho.a[1][2]=proj._23;	ProjOrtho.a[2][2]=proj._33;	ProjOrtho.a[3][2]=proj._43;
	ProjOrtho.a[0][3]=proj._14;	ProjOrtho.a[1][3]=proj._24;	ProjOrtho.a[2][3]=proj._34;	ProjOrtho.a[3][3]=proj._44;

    if (states(RENDER_TARGET)==PRIMARY) SetScissor(_x1,_y1,(int)(_x2+overscanX),_y2);
    else SetScissor(_x1,_y1,_x2,_y2);

#endif

#ifdef API3D_DIRECT3D11

    Viewport.Width =(float) w;
    Viewport.Height =(float) h;
    Viewport.MinDepth = 0.0f;
    Viewport.MaxDepth = 1.0f;
    Viewport.TopLeftX = (float)x1;
    Viewport.TopLeftY = (float)y1;

	devicecontext->RSSetViewports(1, &Viewport);

	VIEWPORT.Id();
	VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
	VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);

	VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
	VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);

	VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
	VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);

	MatrixOrthoLHS( &ProjOrtho, (float)w, (float)h, 0.0f,1.0f );

    if (states(RENDER_TARGET)==PRIMARY) SetScissor(_x1,_y1,(int)(_x2+overscanX),_y2);
    else SetScissor(_x1,_y1,_x2,_y2);

#endif

#ifdef API3D_DIRECT3D12

	viewportmodified=true;

    Viewport.Width =(float) w;
    Viewport.Height =(float) h;
    Viewport.MinDepth = 0.0f;
    Viewport.MaxDepth = 1.0f;
    Viewport.TopLeftX = (float)x1;
    Viewport.TopLeftY = (float)y1;

    ScissorRect.top=(LONG)y1;
    ScissorRect.left=(LONG)x1;
    ScissorRect.bottom=(LONG)y2;
    ScissorRect.right=(LONG)x2;
    
    ViewportActual=Viewport;
    ScissorRectActual=ScissorRect;
    
    VIEWPORT.Id();
    VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
    VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);

    VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
    VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);

    VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
    VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);

    MatrixOrthoLHS( &ProjOrtho, (float)w, (float)h, 0.0f,1.0f );

    if (states(RENDER_TARGET)==PRIMARY) SetScissor(_x1,_y1,(int)(_x2+overscanX),_y2);
    else SetScissor(_x1,_y1,_x2,_y2);

#endif

#ifdef API3D_METAL

    Viewport.Width =(float) w;
    Viewport.Height =(float) h;
    Viewport.MinDepth = 0.0f;
    Viewport.MaxDepth = 1.0f;
    Viewport.TopLeftX = (float)x1;
    Viewport.TopLeftY = (float)y1;

    MTLSetViewport(Viewport.TopLeftX,Viewport.TopLeftY,Viewport.TopLeftX+Viewport.Width,Viewport.TopLeftY+Viewport.Height);

	VIEWPORT.Id();
	VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
	VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);

	VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
	VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);

	VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
	VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);

	MatrixOrthoLHS( &ProjOrtho, (float)w, (float)h, 0.0f,1.0f );

    if (states(RENDER_TARGET)==PRIMARY) SetScissor(_x1,_y1,(int)(_x2+overscanX),_y2);
    else SetScissor(_x1,_y1,_x2,_y2);

#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Clear video buffers


  Usage: to be called either before or after ::BEGIN
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::ClearVideoAndZBuffer()
{
	StencilClear=true;

#ifdef API3D_METAL
	MTLClearVideoAndZbuffer(0,0,0);
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)

	if (StencilBuffer)
	{
		glClearStencil(0);
		glClearColor(0.0f,0.0f,0.0f,0.0f);
		glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);
		glStencilMask(0xffffffff);
	}
	else
	{
		glClearColor(0.0f,0.0f,0.0f,0.0f);
		glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
	}

#endif
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#ifdef API3D_DIRECT3D12
    ID3D12GraphicsCommandList* cmd=commandList;
	if (cmd==NULL)
	{
		device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, nullptr, IID_PPV_ARGS(&cmd));
		const float clearColor[] = { 0.0f, 0.0f, 0.0f, 0.0f };
		/*
		if (primaryneeds)
		{
			cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(resTarget, D3D12_RESOURCE_STATE_PRESENT,D3D12_RESOURCE_STATE_RENDER_TARGET));
			cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(resDepth, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_STATE_DEPTH_WRITE,D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES,D3D12_RESOURCE_BARRIER_FLAG_END_ONLY));
		}
		/**/
		cmd->ClearRenderTargetView(rtvSurface, clearColor, 0, nullptr);
		cmd->ClearDepthStencilView(dsvDepthStencil,D3D12_CLEAR_FLAG_DEPTH|D3D12_CLEAR_FLAG_STENCIL,1.0f,0,0,nullptr);
		//CloseAndExecuteCommandList(cmd);
		cmd->SetDescriptorHeaps(1,&HandleContainer.DescriptorHeap);
		commandList=cmd;
		previouspipe=NULL;
		prevEffect=NULL;
	}
	else
	{
		const float clearColor[] = { 0.0f, 0.0f, 0.0f, 0.0f };
		cmd->ClearRenderTargetView(rtvSurface, clearColor, 0, nullptr);
		cmd->ClearDepthStencilView(dsvDepthStencil,D3D12_CLEAR_FLAG_DEPTH|D3D12_CLEAR_FLAG_STENCIL,1.0f,0,0,nullptr);
	}

#else
#ifdef API3D_DIRECT3D11

	float color[4]={ 0,0,0,0 };
	devicecontext->ClearRenderTargetView(render, color);

	if (StencilBuffer) devicecontext->ClearDepthStencilView(depthstencil, D3D11_CLEAR_DEPTH|D3D11_CLEAR_STENCIL, 1.0f, 0);	
	else devicecontext->ClearDepthStencilView(depthstencil, D3D11_CLEAR_DEPTH, 1.0f, 0);	
#else
#ifdef API3D_DIRECT3D10

	float color[4]={ 0,0,0,0 };
	device->ClearRenderTargetView(render, color);

	if (StencilBuffer) device->ClearDepthStencilView(depthstencil, D3D10_CLEAR_DEPTH|D3D10_CLEAR_STENCIL, 1.0f, 0);	
	else device->ClearDepthStencilView(depthstencil, D3D10_CLEAR_DEPTH, 1.0f, 0);	
#else

	if (StencilBuffer) D3DDevice->Clear(0,NULL,D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,0,1.0f,0);
	else D3DDevice->Clear(0,NULL,D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,0,1.0f,0);

	D3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

	D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
	D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );


	D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
	D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );

	D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
	D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG2, D3DTA_CURRENT );
#endif
#endif
#endif
#endif
}


void C3DAPIBASE::ClearVideoAndZBuffer(float r,float g,float b)
{
	StencilClear=true;

#ifdef API3D_METAL
	MTLClearVideoAndZbuffer(r,g,b);
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)

	if (StencilBuffer)
	{
		glClearStencil(0);
		glClearColor(r,g,b,0.0f);
		glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);
		glStencilMask(0xffffffff);
	}
	else
	{
		glClearColor(r,g,b,0.0f);
		glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
	}

#endif
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)

#ifdef API3D_DIRECT3D12

    ID3D12GraphicsCommandList* cmd=commandList;
	if (cmd==NULL)
	{
		device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, nullptr, IID_PPV_ARGS(&cmd));
		const float clearColor[] = { r, g, b, 0.0f };
		cmd->ClearRenderTargetView(rtvSurface, clearColor, 0, nullptr);
		cmd->ClearDepthStencilView(dsvDepthStencil,D3D12_CLEAR_FLAG_DEPTH|D3D12_CLEAR_FLAG_STENCIL,1.0f,0,0,nullptr);
		//CloseAndExecuteCommandList(cmd);
		cmd->SetDescriptorHeaps(1,&HandleContainer.DescriptorHeap);
		commandList=cmd;
		previouspipe=NULL;
		prevEffect=NULL;
	}
	else
	{
		const float clearColor[] = { r, g, b, 0.0f };
		cmd->ClearRenderTargetView(rtvSurface, clearColor, 0, nullptr);
		cmd->ClearDepthStencilView(dsvDepthStencil,D3D12_CLEAR_FLAG_DEPTH|D3D12_CLEAR_FLAG_STENCIL,1.0f,0,0,nullptr);
	}

#else

#ifdef API3D_DIRECT3D11

	float color[4]={ r,g,b,0 };
	devicecontext->ClearRenderTargetView(render, color);
	devicecontext->ClearDepthStencilView(depthstencil, D3D11_CLEAR_DEPTH|D3D11_CLEAR_STENCIL, 1.0f, 0);	

#else
#ifdef API3D_DIRECT3D10

	float color[4]={ r,g,b,0 };
	device->ClearRenderTargetView(render, color);
	device->ClearDepthStencilView(depthstencil, D3D10_CLEAR_DEPTH|D3D10_CLEAR_STENCIL, 1.0f, 0);	

#else
	if (StencilBuffer) D3DDevice->Clear(0,NULL,D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,D3DCOLOR_COLORVALUE(r,g,b,0),1.0f,0);
	else D3DDevice->Clear(0,NULL,D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,D3DCOLOR_COLORVALUE(r,g,b,0),1.0f,0);

	D3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
	D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

	D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
	D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );


	D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
	D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );

	D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
	D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG2, D3DTA_CURRENT );
#endif
#endif
#endif
#endif
}

void C3DAPIBASE::ClearVideoAndZBuffer(float r,float g,float b,float a)
{
    StencilClear=true;
    
#ifdef API3D_METAL
    MTLClearVideoAndZbuffer(r,g,b,a);
#endif
    
#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
    
    if (StencilBuffer)
    {
        glClearStencil(0);
        glClearColor(r,g,b,a);
        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);
        glStencilMask(0xffffffff);
    }
    else
    {
        glClearColor(r,g,b,a);
        glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    }
    
#endif
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
    
#ifdef API3D_DIRECT3D12

    ID3D12GraphicsCommandList* cmd=commandList;
	if (cmd==NULL)
	{
		device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, nullptr, IID_PPV_ARGS(&cmd));
		const float clearColor[] = { r, g, b, a };
		cmd->ClearRenderTargetView(rtvSurface, clearColor, 0, nullptr);
		cmd->ClearDepthStencilView(dsvDepthStencil,D3D12_CLEAR_FLAG_DEPTH|D3D12_CLEAR_FLAG_STENCIL,1.0f,0,0,nullptr);
		//CloseAndExecuteCommandList(cmd);
		cmd->SetDescriptorHeaps(1,&HandleContainer.DescriptorHeap);
		commandList=cmd;
		previouspipe=NULL;
		prevEffect=NULL;
	}
	else
	{
		const float clearColor[] = { r, g, b, a };
		cmd->ClearRenderTargetView(rtvSurface, clearColor, 0, nullptr);
		cmd->ClearDepthStencilView(dsvDepthStencil,D3D12_CLEAR_FLAG_DEPTH|D3D12_CLEAR_FLAG_STENCIL,1.0f,0,0,nullptr);
	}

#else

#ifdef API3D_DIRECT3D11
    
    float color[4]={ r,g,b,a };
    devicecontext->ClearRenderTargetView(render, color);
    devicecontext->ClearDepthStencilView(depthstencil, D3D11_CLEAR_DEPTH|D3D11_CLEAR_STENCIL, 1.0f, 0);
    
#else
#ifdef API3D_DIRECT3D10
    
    float color[4]={ r,g,b,a };
    device->ClearRenderTargetView(render, color);
    device->ClearDepthStencilView(depthstencil, D3D10_CLEAR_DEPTH|D3D10_CLEAR_STENCIL, 1.0f, 0);
    
#else
    if (StencilBuffer) D3DDevice->Clear(0,NULL,D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER|D3DCLEAR_STENCIL,D3DCOLOR_COLORVALUE(r,g,b,a),1.0f,0);
    else D3DDevice->Clear(0,NULL,D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,D3DCOLOR_COLORVALUE(r,g,b,a),1.0f,0);
    
    D3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
    D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
    
    D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
    D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
    
    
    D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
    D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
    D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );
    
    D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
    D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
    D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG2, D3DTA_CURRENT );
#endif
#endif
#endif
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Clear ZBuffer

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::ClearZBuffer()
{
#ifdef API3D_METAL
	MTLClearZBuffer();
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
	glClearColor(0.0f,0.0f,0.0f,0.0f);
	glClear(GL_DEPTH_BUFFER_BIT);
#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#ifdef API3D_DIRECT3D12

    ID3D12GraphicsCommandList* cmd=commandList;
	if (cmd==NULL)
	{
		device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, nullptr, IID_PPV_ARGS(&cmd));

		cmd->ClearDepthStencilView(dsvDepthStencil,D3D12_CLEAR_FLAG_DEPTH,1.0f,0,0,nullptr);
		//CloseAndExecuteCommandList(cmd);
		cmd->SetDescriptorHeaps(1,&HandleContainer.DescriptorHeap);
		commandList=cmd;
		previouspipe=NULL;
		prevEffect=NULL;
	}
	else
	{
		cmd->ClearDepthStencilView(dsvDepthStencil,D3D12_CLEAR_FLAG_DEPTH,1.0f,0,0,nullptr);
	}

#else
#ifdef API3D_DIRECT3D11
	devicecontext->ClearDepthStencilView(depthstencil, D3D11_CLEAR_DEPTH, 1.0f, 0);	
#else
#ifdef API3D_DIRECT3D10
	device->ClearDepthStencilView(depthstencil, D3D10_CLEAR_DEPTH, 1.0f, 0);	
#else
	D3DDevice->Clear(0,NULL,D3DCLEAR_ZBUFFER,0,1.0f,0);
#endif
#endif
#endif
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Clear ZBuffer

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::ClearZBuffer(int x1,int y1,int x2,int y2)
{
#ifdef API3D_METAL
	MTLClearZBuffer();
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
	glClearColor(0.0f,0.0f,0.0f,0.0f);
	glClear(GL_DEPTH_BUFFER_BIT);
#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)

#ifdef API3D_DIRECT3D12
    ID3D12GraphicsCommandList* cmd=commandList;
	if (cmd==NULL)
	{
		device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, nullptr, IID_PPV_ARGS(&cmd));
		cmd->ClearDepthStencilView(dsvDepthStencil,D3D12_CLEAR_FLAG_DEPTH,1.0f,0,0,nullptr);
		//CloseAndExecuteCommandList(cmd);
		cmd->SetDescriptorHeaps(1,&HandleContainer.DescriptorHeap);
		commandList=cmd;
		previouspipe=NULL;
		prevEffect=NULL;
	}
	else
	{
		cmd->ClearDepthStencilView(dsvDepthStencil,D3D12_CLEAR_FLAG_DEPTH,1.0f,0,0,nullptr);
	}

#else
#ifdef API3D_DIRECT3D11
#else
#ifdef API3D_DIRECT3D10
#else
	D3DRECT r;
	r.x1=x1; r.y1=y1;
	r.x2=x2; r.y2=y2;
	D3DDevice->Clear(0,&r,D3DCLEAR_ZBUFFER,0,1.0f,0);
#endif
#endif
#endif
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		"BEGIN" rendering scene

		This function manages lost devices in D3D and resets from lost device.

  Usage:

		if (Render.BEGIN())
		{
			// clear
			// draw

			Render.END();
			Render.Flip()
		}
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

bool C3DAPIBASE::BEGIN()
{
	count_nv=count_nf=count_nfavoid=count_nvb=0;
#ifdef API3D_DIRECT3D12
	CounterCommandList=0;
#endif
    SetParams(API3D_ZBUFFER,LESSEQUAL);

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------

    PreviousEffect=NULL;

	PreviousRS.ZBuffer=_TRUE;
	PreviousRS.ZBufferWrite=_TRUE;

	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_TRUE);

#ifdef VR_SCREENPROJ
	glGetIntegerv(GL_FRAMEBUFFER_BINDING,&defaultFBOPrimary);
	defaultFBO=defaultFBOPrimary;
#else
#if defined(IOS)||defined(GOOGLEVR)||defined(API3D_VR)||defined(WEBASM)
    glGetIntegerv(GL_FRAMEBUFFER_BINDING,&defaultFBO);	
#endif
#endif

#if defined(GOOGLEVR)||defined(API3D_VR)

#if defined(GOOGLEVR)
    glEnable(GL_SCISSOR_TEST);
#endif

    glGetIntegerv(GL_VIEWPORT,viewportVR);

    X1base=0;
    Y1base=0;
    X2base=viewportVR[2];
    Y2base=viewportVR[3];

    SelectedRenderTarget=-1;

    float w=(float)viewportVR[2];
    float h=(float)viewportVR[3];

    ProjOrtho.a[0][0] = 2.0f/w;
    ProjOrtho.a[1][0] = 0.0f;
    ProjOrtho.a[2][0] = 0.0f;
    ProjOrtho.a[3][0] = 0.0f;

    ProjOrtho.a[0][1] = 0.0f;
    ProjOrtho.a[1][1] = -2.0f/h;
    ProjOrtho.a[2][1] = 0.0f;
    ProjOrtho.a[3][1] = 0.0f;

    ProjOrtho.a[0][2] = 0.0f;
    ProjOrtho.a[1][2] = 0.0f;
    ProjOrtho.a[2][2] = 2.0f;
    ProjOrtho.a[3][2] = -1.0f;

    ProjOrtho.a[0][3] = 0.0f;
    ProjOrtho.a[1][3] = 0.0f;
    ProjOrtho.a[2][3] = 0.0f;
    ProjOrtho.a[3][3] = 1.0f;

    VIEWPORT.Id();

    VIEWPORT.a[0][0]=(float) (w/2);
    VIEWPORT.a[3][0]=(float) (0+w/2);

    VIEWPORT.a[1][1]=((float) (h/2));
    VIEWPORT.a[3][1]=(float) (0+h/2);

    VIEWPORT.a[2][2]=(float) (1.0f);
    VIEWPORT.a[3][2]=(float) (0.0f);
#endif

	return true;
#endif

#ifdef API3D_METAL
	return MTLBegin();
#endif

#ifdef API3D_DIRECT3D12

    FreePipelinesandSignatures();

	CVertexBuffer **pvb=TemporaryVertexBuffers[frameIndex].GetFirst();
	while (pvb)
	{
		(*pvb)->Release();
		delete *pvb;
		pvb=TemporaryVertexBuffers[frameIndex].DeleteAndGetNext();
	}

	rendering=true;
    
    rtvSurface=rtv_rendertargets[frameIndex];
    dsvDepthStencil=dsv_depthstencil[frameIndex];

	commandAllocator=commandAllocators[frameIndex];

	if (commandsexecuted[frameIndex]) commandAllocator->Reset();
	
	ID3D12GraphicsCommandList*cmd;
    device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, nullptr, IID_PPV_ARGS(&cmd));
	cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(renderTargets[frameIndex], D3D12_RESOURCE_STATE_PRESENT,D3D12_RESOURCE_STATE_RENDER_TARGET));
	//cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(depthstencil[frameIndex], D3D12_RESOURCE_STATE_COMMON,D3D12_RESOURCE_STATE_DEPTH_WRITE,D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES,D3D12_RESOURCE_BARRIER_FLAG_END_ONLY));
	CloseAndExecuteCommandList(cmd);
	/**/
	
	prevTarget=resTarget=renderTargets[frameIndex];
	prevDepth=resDepth=depthstencil[frameIndex];

    prevEffect=NULL;

//	if (ofsConstantBuffers[frameIndex]>max_videomemory_used) max_videomemory_used=ofsConstantBuffers[frameIndex];
//	ofsConstantBuffers[frameIndex]=0;

	commandList=NULL;
	actualpipeline=NULL;
	previouspipe=NULL;

	commandsexecuted[frameIndex]=false;

	return true;
#endif

#ifdef API3D_DIRECT3D11
#ifndef WINDOWS_PHONE
	if (IsIconic(hWindow)) return false;
#endif

#ifdef WINDOWS_STORE
	SelectedRenderTarget = -666;
	SetParams(API3D_RENDERTARGET, PRIMARY);
#endif
	return true;
#endif

#ifdef API3D_DIRECT3D10

	if (IsIconic(hWindow)) return false;
	return true;
#endif


#ifdef API3D_DIRECT3D

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	HRESULT h;
	int n;
	D3DFORMAT Formats[3]={
					    D3DFMT_R5G6B5,      
						D3DFMT_X1R5G5B5,    
						D3DFMT_A4R4G4B4
						};

	h=D3DDevice->TestCooperativeLevel();

	if (h==D3DERR_DEVICELOST) 
	{
		return false;
	}
	else 
	{
		if (h==D3DERR_DEVICENOTRESET)
		{

			if (ENV_VSH_activated)
			{
				h=Effect_ENV_VSH->OnLostDevice();
				h=Effect_ENV2_VSH->OnLostDevice();
			}
			if (MULTI00) h=MULTI00->OnLostDevice();
			if (MULTI10) h=MULTI10->OnLostDevice();
			if (MULTI01) h=MULTI01->OnLostDevice();
			if (MULTI11) h=MULTI11->OnLostDevice();
			if (SHDVOLUME) h=SHDVOLUME->OnLostDevice();
			if (SHDVOLUMEm) h=SHDVOLUMEm->OnLostDevice();
			if (SHDVOLUME_CR1) h=SHDVOLUME_CR1->OnLostDevice();
			if (SHDVOLUME_CR2) h=SHDVOLUME_CR2->OnLostDevice();
			if (SHDVOLUME_CR1m) h=SHDVOLUME_CR1m->OnLostDevice();
			if (SHDVOLUME_CR2m) h=SHDVOLUME_CR2m->OnLostDevice();

			if (SHDVOLUMEc) h=SHDVOLUMEc->OnLostDevice();
			if (SHDVOLUMEmc) h=SHDVOLUMEmc->OnLostDevice();
			if (SHDVOLUMEn) h=SHDVOLUMEn->OnLostDevice();
			if (SHDVOLUMEcn) h=SHDVOLUMEcn->OnLostDevice();

			if (BML) h=BML->OnLostDevice();
			if (BMLD) h=BMLD->OnLostDevice();
			if (BMLa) h=BMLa->OnLostDevice();

			VertexBufferContainer.OnLostDevice(D3DDevice);

			if (PixelShaderBump!=0) D3DDevice->DeletePixelShader(PixelShaderBump);
			PixelShaderBump=0;

			if (PixelShaderBlur!=0) D3DDevice->DeletePixelShader(PixelShaderBlur);
			PixelShaderBlur=0;

			if (handle_morph!=0) D3DDevice->DeleteVertexShader(handle_morph);
			handle_morph=0;

			if (HardwareVertexProcessing) VertexBufferContainer.Release(D3DDevice);
			if (SurfaceBack) SurfaceBack->Release();
			SurfaceBack=NULL;

			if (SecondarySurface)
			{
				for (n=0;n<nSecondaries;n++)
				{
					if (D3DTextureSecondary[n])
					{
						D3DTextureSecondary[n]->Release();
						D3DSecondary[n]->Release();
						D3DSecondaryZbuffer[n]->Release();

						D3DTextureSecondary[n]=NULL;
					}
				}
			}
			
			h=D3DDevice->Reset(&d3dpp);

			if (FAILED(h)) 
			{
				if (h==D3DERR_DRIVERINTERNALERROR) LOG("drvier error");
				if (h==D3DERR_INVALIDCALL) LOG("invalid call");
				if (h==D3DERR_OUTOFVIDEOMEMORY) LOG("memory");
				if (h==D3DERR_DEVICELOST) LOG("lost");
			}

			if (ENV_VSH_activated)
			{
				h=Effect_ENV_VSH->OnResetDevice();
				h=Effect_ENV2_VSH->OnResetDevice();
			}
			if (MULTI00) h=MULTI00->OnResetDevice();
			if (MULTI10) h=MULTI10->OnResetDevice();
			if (MULTI01) h=MULTI01->OnResetDevice();
			if (MULTI11) h=MULTI11->OnResetDevice();
			if (SHDVOLUME) h=SHDVOLUME->OnResetDevice();
			if (SHDVOLUMEm) h=SHDVOLUMEm->OnResetDevice();
			if (SHDVOLUME_CR1) h=SHDVOLUME_CR1->OnResetDevice();
			if (SHDVOLUME_CR2) h=SHDVOLUME_CR2->OnResetDevice();
			if (SHDVOLUME_CR1m) h=SHDVOLUME_CR1m->OnResetDevice();
			if (SHDVOLUME_CR2m) h=SHDVOLUME_CR2m->OnResetDevice();

			if (SHDVOLUMEc) h=SHDVOLUMEc->OnResetDevice();
			if (SHDVOLUMEmc) h=SHDVOLUMEmc->OnResetDevice();
			if (SHDVOLUMEn) h=SHDVOLUMEn->OnResetDevice();
			if (SHDVOLUMEcn) h=SHDVOLUMEcn->OnResetDevice();


			if (BML) h=BML->OnResetDevice();
			if (BMLD) h=BMLD->OnResetDevice();
			if (BMLa) h=BMLa->OnResetDevice();

			D3DDevice->GetBackBuffer(0,D3DBACKBUFFER_TYPE_MONO,&SurfaceBack);
			D3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

			D3DDevice->SetTextureStageState(0,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetTextureStageState(0,D3DTSS_MINFILTER,D3DTEXF_LINEAR);

			if (HardwareVertexProcessing) VertexBufferContainer.Restore(D3DDevice);

			VertexBufferContainer.OnResetDevice(D3DDevice);
				if (SecondarySurface)
				{
					for (n=0;n<nSecondaries;n++)
						setupRenderTexture(n,tile_secondarysurfacesW[n],tile_secondarysurfacesH[n]);
				}
//			}

			if (SecondarySurface)
			{
				for (n=0;n<nSecondaries;n++)
				{
					SetParams(API3D_RENDERTARGET,SECONDARY1+n);
					SetParams(API3D_ZBUFFER,ON);
					ClearVideoAndZBuffer();
				}
				SetParams(API3D_RENDERTARGET,PRIMARY);
			}

			for (n=0;n<1024;n++)
			{
				if (tagLights[n])
				{
					if (Lights[n].directionnal)
					{
						SetLightDirectionnal(n,Lights[n].Pos,Lights[n].color[0],Lights[n].color[1],Lights[n].color[2]);
					}
					else
					{
						SetLightPoint(n,Lights[n].Pos,Lights[n].color[0],Lights[n].color[1],Lights[n].color[2],Lights[n].Attenuation,Lights[n].Range);
					}

					if (Lights[n].enabled) EnableLight(n);
					else DisableLight(n);
				}
			}

			return false;
			
		}
		if (h==D3D_OK)
		{
			D3DDevice->BeginScene();
			return true;
		}
		else return false;
	}

#endif

#ifdef API3D_DIRECT3D9


	VertexBufferContainer.UpdateDevice(D3DDevice);

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	HRESULT h;
	int n;
	D3DFORMAT Formats[3]={
					    D3DFMT_R5G6B5,      
						D3DFMT_X1R5G5B5,    
						D3DFMT_A4R4G4B4
						};

	h=D3DDevice->TestCooperativeLevel();

	if (h==D3DERR_DEVICELOST) 
	{
		return false;
	}
	else 
	{
		if (h==D3DERR_DEVICENOTRESET)
		{

			if (ENV_VSH_activated)
			{
				h=Effect_ENV_VSH->OnLostDevice();
				h=Effect_ENV2_VSH->OnLostDevice();
			}

			if (MULTI00) h=MULTI00->OnLostDevice();
			if (MULTI10) h=MULTI10->OnLostDevice();
			if (MULTI01) h=MULTI01->OnLostDevice();
			if (MULTI11) h=MULTI11->OnLostDevice();
			if (SHDVOLUME) h=SHDVOLUME->OnLostDevice();
			if (SHDVOLUMEm) h=SHDVOLUMEm->OnLostDevice();
			if (SHDVOLUME_CR1) h=SHDVOLUME_CR1->OnLostDevice();
			if (SHDVOLUME_CR2) h=SHDVOLUME_CR2->OnLostDevice();
			if (SHDVOLUME_CR1m) h=SHDVOLUME_CR1m->OnLostDevice();
			if (SHDVOLUME_CR2m) h=SHDVOLUME_CR2m->OnLostDevice();
			if (SHDVOLUMEc) h=SHDVOLUMEc->OnLostDevice();
			if (SHDVOLUMEmc) h=SHDVOLUMEmc->OnLostDevice();
			if (SHDVOLUMEn) h=SHDVOLUMEn->OnLostDevice();
			if (SHDVOLUMEcn) h=SHDVOLUMEcn->OnLostDevice();

			if (BML) h=BML->OnLostDevice();
			if (BMLD) h=BMLD->OnLostDevice();
			if (BMLa) h=BMLa->OnLostDevice();

			VertexBufferContainer.OnLostDevice(D3DDevice);

			if (HardwareVertexProcessing) VertexBufferContainer.Release(D3DDevice);

			if (SurfaceBack) SurfaceBack->Release();

			SurfaceBack=NULL;

			if (SecondarySurface)
			{
				for (n=0;n<nSecondaries;n++)
				{
					if (D3DTextureSecondary[n])
					{
						D3DTextureSecondary[n]->Release();
						D3DSecondary[n]->Release();
						D3DSecondaryZbuffer[n]->Release();

						D3DTextureSecondary[n]=NULL;
					}
				}
			}

			h=D3DDevice->Reset(&d3dpp);

			if (FAILED(h)) 
			{
				LOG("ERROR"); 
				if (h==D3DERR_DRIVERINTERNALERROR) LOG("drvier error");
				if (h==D3DERR_INVALIDCALL) LOG("invalid call");
				if (h==D3DERR_OUTOFVIDEOMEMORY) LOG("memory");
				if (h==D3DERR_DEVICELOST) LOG("lost");
			}

			if (ENV_VSH_activated)
			{
				h=Effect_ENV_VSH->OnResetDevice();
				h=Effect_ENV2_VSH->OnResetDevice();
			}

			if (MULTI00) h=MULTI00->OnResetDevice();
			if (MULTI10) h=MULTI10->OnResetDevice();
			if (MULTI01) h=MULTI01->OnResetDevice();
			if (MULTI11) h=MULTI11->OnResetDevice();
			if (SHDVOLUME) h=SHDVOLUME->OnResetDevice();
			if (SHDVOLUMEm) h=SHDVOLUMEm->OnResetDevice();
			if (SHDVOLUME_CR1) h=SHDVOLUME_CR1->OnResetDevice();
			if (SHDVOLUME_CR2) h=SHDVOLUME_CR2->OnResetDevice();
			if (SHDVOLUME_CR1m) h=SHDVOLUME_CR1m->OnResetDevice();
			if (SHDVOLUME_CR2m) h=SHDVOLUME_CR2m->OnResetDevice();
			if (SHDVOLUMEc) h=SHDVOLUMEc->OnResetDevice();
			if (SHDVOLUMEmc) h=SHDVOLUMEmc->OnResetDevice();
			if (SHDVOLUMEn) h=SHDVOLUMEn->OnResetDevice();
			if (SHDVOLUMEcn) h=SHDVOLUMEcn->OnResetDevice();
			
			if (BML) h=BML->OnResetDevice();
			if (BMLD) h=BMLD->OnResetDevice();
			if (BMLa) h=BMLa->OnResetDevice();

			D3DDevice->GetBackBuffer(0,0,D3DBACKBUFFER_TYPE_MONO,&SurfaceBack);

			D3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );

			D3DDevice->SetSamplerState(0,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetSamplerState(0,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);


			if (HardwareVertexProcessing) VertexBufferContainer.Restore(D3DDevice);

			VertexBufferContainer.OnResetDevice(D3DDevice);

			if (SecondarySurface)
			{
				for (n=0;n<nSecondaries;n++)
					setupRenderTexture(n,tile_secondarysurfacesW[n],tile_secondarysurfacesH[n]);
			}

			if (SecondarySurface)
			{
				for (n=0;n<nSecondaries;n++)
				{
					SetParams(API3D_RENDERTARGET,SECONDARY1+n);
					SetParams(API3D_ZBUFFER,ON);
					ClearVideoAndZBuffer();
				}
				SetParams(API3D_RENDERTARGET,PRIMARY);
			}


			for (n=0;n<1024;n++)
			{
				if (tagLights[n])
				{
					if (Lights[n].directionnal)
					{
						SetLightDirectionnal(n,Lights[n].Pos,Lights[n].color[0],Lights[n].color[1],Lights[n].color[2]);
					}
					else
					{
						SetLightPoint(n,Lights[n].Pos,Lights[n].color[0],Lights[n].color[1],Lights[n].color[2],Lights[n].Attenuation,Lights[n].Range);
					}

					if (Lights[n].enabled) EnableLight(n);
					else DisableLight(n);
				}
			}

			return false;
			
		}
		if (h==D3D_OK)
		{
			D3DDevice->BeginScene();
			return true;
		}
		else return false;
	}

#endif

}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  Function:

		END() 

  Usage: see BEGIN()
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::END()
{

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)
	Flush();
	if (SelectedRenderTarget!=PRIMARY) SelectedRenderTarget=PRIMARY;
#ifdef API3D_DIRECT3D12
	primaryneeds=false;
	rendering=false;
#endif
#else
	RECT DirtyRect;
	int n;
	CQuad *q,s;

	Flush();

	if (SelectedRenderTarget!=PRIMARY)
	{
		SelectedRenderTarget=PRIMARY;

#ifdef API3D_DIRECT3D9
		D3DDevice->SetRenderTarget(0,PreviousRenderTarget);
		D3DDevice->SetDepthStencilSurface(PreviousZbuffer);
		D3DDevice->SetViewport(&PreviousViewport);
#else
		D3DDevice->SetRenderTarget(PreviousRenderTarget,PreviousZbuffer);
		D3DDevice->SetViewport(&PreviousViewport);
#endif
		VIEWPORT.Id();
		VIEWPORT.a[0][0]=(float) (PreviousViewport.Width/2);
		VIEWPORT.a[3][0]=(float) (PreviousViewport.X+PreviousViewport.Width/2);

		VIEWPORT.a[1][1]=((float) (PreviousViewport.Height/2));
		VIEWPORT.a[3][1]=(float) (PreviousViewport.Y+PreviousViewport.Height/2);

		VIEWPORT.a[2][2]=(float) (PreviousViewport.MaxZ-PreviousViewport.MinZ);
		VIEWPORT.a[3][2]=(float) (PreviousViewport.MinZ);

		PreviousRenderTarget->Release();
		PreviousZbuffer->Release();
	}

	for (n=0;n<NBRE_MAX_TEXTURES;n++)
	{
		if (cTexture[n])
		{
			if (iTexture[n]->LQ.Length()>0)
			{

				q=iTexture[n]->LQ.GetFirst();
				s=*q;

				q=iTexture[n]->LQ.GetNext();
				while (q)
				{
					if (q->x2>s.x2) s.x2=q->x2;
					if (q->y2>s.y2) s.y2=q->y2;

					if (q->x1<s.x1) s.x1=q->x1;
					if (q->y1<s.y1) s.y1=q->y1;

					q=iTexture[n]->LQ.GetNext();
				}

				DirtyRect.top=s.y1;
				DirtyRect.left=s.x1;
				DirtyRect.right=s.x2;
				DirtyRect.bottom=s.y2;

				Texture[n]->AddDirtyRect(&DirtyRect);

				iTexture[n]->LQ.Free();

			}
		}
	}

#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	for (n=0;n<NBRE_MAX_TEXTURES;n++)
	{
		if (cLightmap[n])
		{
			if (iLightmap[n]->LQ.Length()>0)
			{
				q=iLightmap[n]->LQ.GetFirst();
				s=*q;
				q=iLightmap[n]->LQ.GetNext();
				while (q)
				{
					if (q->x2>s.x2) s.x2=q->x2;
					if (q->y2>s.y2) s.y2=q->y2;
					if (q->x1<s.x1) s.x1=q->x1;
					if (q->y1<s.y1) s.y1=q->y1;
					q=iLightmap[n]->LQ.GetNext();
				}
				DirtyRect.top=s.y1;
				DirtyRect.left=s.x1;
				DirtyRect.right=s.x2;
				DirtyRect.bottom=s.y2;
				Lightmap[n]->AddDirtyRect(&DirtyRect);
				iLightmap[n]->LQ.Free();
			}
		}
	}
#endif

	D3DDevice->EndScene();
#endif
#endif
#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)

	Flush();

	if (SelectedRenderTarget>=0)
	{
#ifdef OPENGL_PBUFFERS
		if (SecondarySurface)
		{
			if ((aT<0)&&(SelectedRenderTarget==-(aT+1))) pbufferRelease(-(aT+1));
			pbufferDisable(SelectedRenderTarget);
		}
#endif
		SelectedRenderTarget=-1;

		float w=(float)SCREEN_X;
		float h=(float)SCREEN_Y;

		//TODO
		VIEWPORT.Id();

		VIEWPORT.a[0][0]=(float) (w/2);
		VIEWPORT.a[3][0]=(float) (0+w/2);

		VIEWPORT.a[1][1]=((float) (h/2));
		VIEWPORT.a[3][1]=(float) (0+h/2);

		VIEWPORT.a[2][2]=(float) (1.0f);
		VIEWPORT.a[3][2]=(float) (0.0f);
	}
#endif

#if defined(API3D_METAL)

	Flush();

	if (SelectedRenderTarget>=0)
	{
		SelectedRenderTarget=-1;

		float w=(float)SCREEN_X;
		float h=(float)SCREEN_Y;

		//TODO
		VIEWPORT.Id();

		VIEWPORT.a[0][0]=(float) (w/2);
		VIEWPORT.a[3][0]=(float) (0+w/2);

		VIEWPORT.a[1][1]=((float) (h/2));
		VIEWPORT.a[3][1]=(float) (0+h/2);

		VIEWPORT.a[2][2]=(float) (1.0f);
		VIEWPORT.a[3][2]=(float) (0.0f);
	}

	MTLEnd();

#endif

}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Flip back buffer surface
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#if defined(_DEFINES_OPENGL_NO_SDL_INIT_)&&!defined(WIN32)&&!defined(ANDROID)&&!defined(LINUX)
void SwapBuffers();
#endif

#ifdef WINDOWS_STORE	
void WindowsStoreFlipSurfaces();
#endif

#ifdef API3D_SDL2
void SwapBuffers();
#endif


void C3DAPIBASE::FlipDoubleBuffer()
{

#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -------------
	MTLFlipDoubleBuffer();
#endif

#ifdef API3D_SDL2
	SwapBuffers();
#else

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
#if !defined(GLES)&&!defined(GLES20)&&!defined(GLESFULL)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
#ifdef _DEFINES_OPENGL_NO_SDL_INIT_
#ifdef WIN32
#ifndef API3D_VR
	SwapBuffers(hGLDC);
#endif
#else
#ifndef LINUX
    SwapBuffers();
#endif
#endif
#else
    SDL_GL_SwapBuffers();
#endif
#endif
#endif
#endif

#ifdef API3D_DIRECT3D
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	HRESULT h;
	h=D3DDevice->Present( NULL, NULL, NULL, NULL );

#endif

#ifdef API3D_DIRECT3D9
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	HRESULT h;
	h=D3DDevice->Present( NULL, NULL, NULL, NULL );

#endif

#ifdef API3D_DIRECT3D10
	if (states(VERTICAL_RETRACE)!=0) swapChain->Present(1, 0);
	else swapChain->Present(0, 0);
#endif

#ifdef API3D_DIRECT3D11
#ifndef WINDOWS_PHONE
	if (states(VERTICAL_RETRACE)!=0) swapChain->Present(1, 0);
	else swapChain->Present(0, 0);
#endif
#ifdef WINDOWS_STORE	
	WindowsStoreFlipSurfaces();
#endif
#endif
    
#ifdef API3D_DIRECT3D12

	if (commandList)
	{
		commandList->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(renderTargets[frameIndex], D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));
		CloseAndExecuteCommandList(commandList);
		commandList=NULL;
	}
	else
	{
		ID3D12GraphicsCommandList*cmd;
		device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, nullptr, IID_PPV_ARGS(&cmd));
		cmd->ResourceBarrier(1, &CD3DX12_RESOURCE_BARRIER::Transition(renderTargets[frameIndex], D3D12_RESOURCE_STATE_RENDER_TARGET, D3D12_RESOURCE_STATE_PRESENT));
		CloseAndExecuteCommandList(cmd);
	}

	commandQueue->Signal(fence[frameIndex], fenceValue[frameIndex]);
    
	swapChain->Present(1, 0);

    fence[frameIndex]->SetEventOnCompletion(fenceValue[frameIndex], fenceEvent[frameIndex]);
    WaitForSingleObjectEx(fenceEvent[frameIndex], INFINITE, FALSE);

	fenceValue[frameIndex]++;

	ID3D12Resource **res=TexturesFreeing.GetFirst();
	while (res)
	{
		(*res)->Release();
		res=TexturesFreeing.DeleteAndGetNext();
	}

	oldframeIndex=frameIndex;
	frameIndex = swapChain->GetCurrentBackBufferIndex();
#endif

	float fps = 1000.0f / TimeGetFPS();
	FPS = fps;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Create bump map

		void C3DAPIBASE::CreateBumpMap(int nt,char * ptr,int sizex,int sizey,float scale)

		nt : number in array of the texture to be created
		sizex : width in pixels of the texture to be created
		sizey : height in pixels of the texture to be created
		ptr : array of grayscale (height map) 
		scale : multiplier of differentiate
		
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::CreateBumpMap(int nt,char * ptr,int size,float scale)
{
	CreateBumpMap(nt,ptr,size,size,scale);
}


void C3DAPIBASE::CreateBumpMap(int nt,char * ptr,int sizex,int sizey,float scale)
{
	char * raw;
	int n1,n2;
	float dx,dy,i,ix,iy;
	int vr,vg,vb;
	CVector uub;

	raw=(char *) malloc(sizex*sizey*4);

	for (n1=0;n1<sizex;n1++)
		for (n2=0;n2<sizey;n2++)
		{
			i=(float)(ptr[n1+ n2*sizex]&255);
			ix=(float)(ptr[(n1+1)%sizex+ n2*sizex]&255);
			iy=(float)(ptr[n1+ ((n2+1)%sizey)*sizex]&255);

			dx=(ix-i)/255;
			dy=(iy-i)/255;

			uub.x=scale*dx;
			uub.y=scale*dy;
			uub.z=1;

			uub.Normalise();

			vr=(int)(128+uub.x*127);
			vg=(int)(128+uub.y*127);
			vb=(int)(128+uub.z*127);

			raw[4*(n1+n2*sizex)+0]=vr;
			raw[4*(n1+n2*sizex)+1]=vg;
			raw[4*(n1+n2*sizex)+2]=vb;

			raw[4*(n1+n2*sizex)+3]=(char)255;
		}

	int Tilex=sizex;	
	if (Tilex>(int)states(TEXTURE_MAX_WIDTH)) Tilex=states(TEXTURE_MAX_WIDTH);
	int Tiley=sizey;	
	if (Tiley>(int)states(TEXTURE_MAX_WIDTH)) Tiley=states(TEXTURE_MAX_WIDTH);

	CreateTexture(nt,sizex,sizey,raw,sizex,sizey,NO_ALPHA);
	
	free(raw);

}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Create bump map

		int C3DAPIBASE::AddBumpMap(char * ptr,int sizex,int sizey,float scale)

		
		sizex : width in pixels of the texture to be created
		sizey : height in pixels of the texture to be created
		ptr : array of grayscale (height map) 
		scale : multiplier of differentiate
		
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

int C3DAPIBASE::AddBumpMap(char * ptr,int size,float scale)
{
	return AddBumpMap(ptr,size,size,scale);
}

int C3DAPIBASE::AddBumpMap(char * ptr,int sizex,int sizey,float scale)
{
	int res;
	char * raw;
	int n1,n2;
	float dx,dy,i,ix,iy;
	int vr,vg,vb;
	CVector uub;

	raw=(char *) malloc(sizex*sizey*4);

	for (n1=0;n1<sizex;n1++)
		for (n2=0;n2<sizey;n2++)
		{
			i=(float)(ptr[n1+ n2*sizex]&255);
			ix=(float)(ptr[(n1+1)%sizex+ n2*sizex]&255);
			iy=(float)(ptr[n1+ ((n2+1)%sizey)*sizex]&255);

			dx=(ix-i)/255;
			dy=(iy-i)/255;

			uub.x=scale*dx;
			uub.y=scale*dy;
			uub.z=1;

			uub.Normalise();

			vr=(int)(128+uub.x*127);
			vg=(int)(128+uub.y*127);
			vb=(int)(128+uub.z*127);

			raw[4*(n1+n2*sizex)+0]=vr;
			raw[4*(n1+n2*sizex)+1]=vg;
#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
			raw[4*(n1+n2*sizex)+2]=vb;
#else
			raw[4*(n1+n2*sizex)+2]=-vb;
#endif
			raw[4*(n1+n2*sizex)+3]=(char)255;
		}

	res=AddTexture(sizex,raw,sizex,NO_ALPHA);
	
	free(raw);

	return res;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Create textures

		void C3DAPIBASE::CreateTexture(int n,int Size,char * ptrRGBA,int Sizeptr,int Alpha)

		n : number in array of the texture to be created
		Size : length in pixels of the texture to be created
		ptrRGBA : array of (r,g,b,a) 
		SizePtr : lenght in pixels of the buffer ptrRGBA
		Alpha : ALPHA or NO_ALPHA
		
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::CreateTexture(int n,int Sizex,int Sizey,char * ptrRGBA,int Sizeptrx,int Sizeptry,int Alpha)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	unsigned int flags=Alpha;
	if (states(TEXTURES_MIPMAP_ACTIVE)) flags|=TC_MIPMAP;
	if (states(TEXTURES_CLAMPING)) flags|=TC_CLAMP;

	int Tilex=Sizex;	
	if (Tilex>(int)states(TEXTURE_MAX_WIDTH)) Tilex=states(TEXTURE_MAX_WIDTH);
	int Tiley=Sizey;	
	if (Tiley>(int)states(TEXTURE_MAX_WIDTH)) Tiley=states(TEXTURE_MAX_WIDTH);

	if (LIB3D_GL_VERSION_EXPOSANT)
	{
		Tilex=Exposantde2(Tilex);
		Tiley=Exposantde2(Tiley);
	}

	TextureContainer->create(n,Tilex,Tiley,ptrRGBA,Sizeptrx,Sizeptry,flags);
#endif
}


void C3DAPIBASE::CreateTexture(int n,int Size,char * ptrRGBA,int Sizeptr,int Alpha)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	unsigned int flags=Alpha;
	if (states(TEXTURES_MIPMAP_ACTIVE)) flags|=TC_MIPMAP;
	if (states(TEXTURES_CLAMPING)) flags|=TC_CLAMP;

	int Tile=Size;	
	if (Tile>(int)states(TEXTURE_MAX_WIDTH)) Tile=states(TEXTURE_MAX_WIDTH);

	if (LIB3D_GL_VERSION_EXPOSANT) Tile=Exposantde2(Tile);

	TextureContainer->create(n,Tile,Tile,ptrRGBA,Sizeptr,Sizeptr,flags);
#else

	iTexture[n]=new CTexture;
	iTexture[n]->ClampRepeat=states(TEXTURES_CLAMPING);
	iTexture[n]->MipMap=states(TEXTURES_MIPMAP_ACTIVE);
	iTexture[n]->Tile=Size;
	iTexture[n]->Format=0;
	iTexture[n]->Group=NameGroup;
	iTexture[n]->Material=NULL;

	cTexture[n]=1;
    
#ifdef API3D_OPENGL
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	int BASE_TILE;
	int Tile;
	char * ptrtex;
	int x,y,n1,n2,adr,adr2;
	int xx,incxx;
	int nn;


	nn=0;

	BASE_TILE=Sizeptr;
	Tile=Size;

	glPixelStorei(GL_UNPACK_ALIGNMENT,1);
	glPixelStorei(GL_UNPACK_ROW_LENGTH,0);
	glPixelStorei(GL_UNPACK_SKIP_ROWS,0);
	glPixelStorei(GL_UNPACK_SKIP_PIXELS,0);

	if (Alpha==1)
	{

		ptrtex=(char*) malloc(Tile*Tile*4);

		adr2=0;
		for (n2=0;n2<Tile;n2++)
		{
			y=(BASE_TILE*n2)/Tile;
			adr=y*BASE_TILE;
			xx=0;
			incxx=(BASE_TILE*256)/Tile;
			for (n1=0;n1<Tile;n1++)
			{
				x=(xx>>8);
				ptrtex[adr2+ 0]=ptrRGBA[((x+adr)<<2) + 0]&255;
				ptrtex[adr2+ 1]=ptrRGBA[((x+adr)<<2) + 1]&255;
				ptrtex[adr2+ 2]=ptrRGBA[((x+adr)<<2) + 2]&255;
				ptrtex[adr2+ 3]=ptrRGBA[((x+adr)<<2) + 3]&255;
				xx+=incxx;
				adr2+=4;
			}
		}

		Texture[n]=0;

		glEnable(GL_TEXTURE_2D);
		glGenTextures(1,(GLuint*)&Texture[n]);			
		glBindTexture(GL_TEXTURE_2D,Texture[n]);

		if (states(TEXTURES_MIPMAP_ACTIVE)==1)
		{
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
		}
		else
		{
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
		}


		if (states(TEXTURES_CLAMPING)==1)
		{
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
		}
		else
		{
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
		}

		if (states(TEXTURES_MIPMAP_ACTIVE)==0)
			glTexImage2D(GL_TEXTURE_2D,0,GL_RGBA,Tile,Tile,0,GL_RGBA,GL_UNSIGNED_BYTE,ptrtex);
		else
		{
			gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGBA,Tile,Tile,GL_RGBA,GL_UNSIGNED_BYTE,ptrtex);
		}

	}
	else
	{
		ptrtex=(char*) malloc(Tile*Tile*3);
	

		adr2=0;
		for (n2=0;n2<Tile;n2++)
		{
			y=(BASE_TILE*n2)/Tile;
			adr=y*BASE_TILE;
			xx=0;
			incxx=(BASE_TILE*256)/Tile;
			for (n1=0;n1<Tile;n1++)
			{
				x=(xx>>8);
				ptrtex[adr2+ 0]=ptrRGBA[((x+adr)<<2) + 0]&255;
				ptrtex[adr2+ 1]=ptrRGBA[((x+adr)<<2) + 1]&255;
				ptrtex[adr2+ 2]=ptrRGBA[((x+adr)<<2) + 2]&255;
				xx+=incxx;
				adr2+=3;
			}
		}

		glEnable(GL_TEXTURE_2D);
		glGenTextures(1,(GLuint*) &Texture[n]);			
		glBindTexture(GL_TEXTURE_2D,Texture[n]);
		if (states(TEXTURES_MIPMAP_ACTIVE)==1)
		{
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
			
		}
		else
		{
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
		}

		if (states(TEXTURES_CLAMPING)==1)
		{
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
		}
		else
		{
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
		}


		if (states(TEXTURES_MIPMAP_ACTIVE)==0)
			glTexImage2D(GL_TEXTURE_2D,0,GL_RGB,Tile,Tile,0,GL_RGB,GL_UNSIGNED_BYTE,ptrtex);
		else
		{
			gluBuild2DMipmaps(GL_TEXTURE_2D,GL_RGB,Tile,Tile,GL_RGB,GL_UNSIGNED_BYTE,ptrtex);
		}

	}

	free(ptrtex);
#endif


#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	int LEVELS;
	
//	LPDIRECT3DTEXTURE8 Tex; 
	D3DLOCKED_RECT Locked;
	int lvl,nn;
	unsigned int adr0,pitch;
	WORD * ptrdest;
//	BYTE * ptrdest2;
	WORD cc;
	int r,g,b,a;

	D3DFORMAT Formats[3]={
					    D3DFMT_R5G6B5,      
						D3DFMT_X1R5G5B5,    
						D3DFMT_A4R4G4B4
						};
	D3DFORMAT Formats2[6]={
						D3DFMT_R8G8B8,    
						D3DFMT_X8R8G8B8,
					    D3DFMT_R5G6B5,      
						D3DFMT_X1R5G5B5,    
						D3DFMT_A8R8G8B8,    
						D3DFMT_A4R4G4B4
						};
	int BASE_TILE;
	int Tile;
	char * ptrtex;
	int x,y,n1,n2,adr,adr2;
	int xx,incxx;
	int r0,g0,b0;
	char * Ptr2;
	char * Ptr3;
	int Tile2;

	BASE_TILE=Sizeptr;
	Tile=Size;
	if (Tile>(int)states(TEXTURE_MAX_WIDTH)) Tile=states(TEXTURE_MAX_WIDTH);

	if (states(TEXTURES_MIPMAP_ACTIVE)==0) LEVELS=1;
	else
	{
		LEVELS=1;
		while (!((Tile>>LEVELS)&1)) LEVELS++;
		LEVELS++;
	}

	ptrtex=(char*) malloc(Tile*Tile*4);

	adr2=0;
	for (n2=0;n2<Tile;n2++)
	{
		y=(BASE_TILE*n2)/Tile;
		adr=y*BASE_TILE;
		xx=0;
		incxx=(BASE_TILE*256)/Tile;
		for (n1=0;n1<Tile;n1++)
		{
			x=(xx>>8);

			r=ptrRGBA[((x+adr)<<2) + 0]&255;
			g=ptrRGBA[((x+adr)<<2) + 1]&255;
			b=ptrRGBA[((x+adr)<<2) + 2]&255;
			a=ptrRGBA[((x+adr)<<2) + 3]&255;

			if (*states[TEXTURES_DITHERING]==1)
			{
				r0=r&7;
				if (r0>4) r0=4;
				r0=dither[4-r0][x&1][y&1];
				r=((r>>3)+r0)<<3;

				if (r>255) r=255;


				g0=g&3;
				g0=dither[4-g0][x&1][y&1];
				g=((g>>2)+g0)<<2;

				if (g>255) g=255;

				b0=b&7;
				if (b0>4) b0=4;
				b0=dither[4-b0][x&1][y&1];
				b=((b>>3)+b0)<<3;
				if (b>255) b=255;
			}
			ptrtex[adr2+ 0]=r;
			ptrtex[adr2+ 1]=g;
			ptrtex[adr2+ 2]=b;
			ptrtex[adr2+ 3]=a;
			xx+=incxx;
			adr2+=4;
		}
	}

	if (Alpha==0) nn=0;
	else nn=2;

	while ((nn<3)&&(FAILED(D3DDevice->CreateTexture(Tile,Tile,LEVELS,0,Formats[nn],D3DPOOL_MANAGED,&Texture[n])))) nn++;

	if (nn<3)
	{

		Texture[n]->LockRect(0,&Locked,NULL,0);	// level 0
		ptrdest=(WORD *) Locked.pBits;
		pitch=Locked.Pitch/2;
		
		for (n2=0;n2<Tile;n2++)
		{
			adr=n2*pitch;
			adr0=n2*Tile;
			for (n1=0;n1<Tile;n1++)
			{
				r=ptrtex[((n1+adr0)<<2)+0]&255;
				g=ptrtex[((n1+adr0)<<2)+1]&255;
				b=ptrtex[((n1+adr0)<<2)+2]&255;
				a=ptrtex[((n1+adr0)<<2)+3]&255;

				switch (nn)
				{
				case 0:	//565
					cc=((r>>3)<<11) +((g>>2)<<5) + (b>>3);
					break;
				case 1:	//555
					cc=((r>>3)<<10) +((g>>3)<<5) + (b>>3);
					break;
				case 2:	//4444
					cc=((a>>4)<<12) + ((r>>4)<<8) +((g>>4)<<4) + (b>>4);
					break;
				}
				
				ptrdest[n1+adr]=cc;
			}
		}

		Texture[n]->UnlockRect(0);

		if (states(TEXTURES_MIPMAP_ACTIVE)==1)
		{
			Ptr2=CreateMipMap(ptrtex,Tile,4);

			for (lvl=1;lvl<LEVELS;lvl++)
			{
				Texture[n]->LockRect(lvl,&Locked,NULL,0);
				ptrdest=(WORD *) Locked.pBits;
				pitch=Locked.Pitch/2;
				Tile2=Tile/2;

				adr=0;
				for (n2=0;n2<Tile2;n2++)
				{
					adr0=n2*pitch;
					for (n1=0;n1<Tile2;n1++)
					{
						r=Ptr2[adr+0]&255;
						g=Ptr2[adr+1]&255;
						b=Ptr2[adr+2]&255;
						a=Ptr2[adr+3]&255;

						switch (nn)
						{
						case 0:	//565
							cc=((r>>3)<<11) +((g>>2)<<5) + (b>>3);
							break;
						case 1:	//555
							cc=((r>>3)<<10) +((g>>3)<<5) + (b>>3);
							break;
						case 2:	//4444
							cc=((a>>4)<<12) + ((r>>4)<<8) +((g>>4)<<4) + (b>>4);
							break;
						};
						
						ptrdest[n1+adr0]=cc;
						adr+=4;
					}
				}

				Texture[n]->UnlockRect(lvl);
				Ptr3=CreateMipMap(Ptr2,Tile/2,4);
				free(Ptr2);
				Ptr2=Ptr3;
				Tile=Tile/2;
			}
			free(Ptr2);
		}
	}
	free(ptrtex);

	iTexture[n]->Format=nn;
#endif
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Material
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

CMaterial * C3DAPIBASE::Material(int nt)
{
	if (iTexture[nt])
	{
		if (!iTexture[nt]->Material)
		{
			iTexture[nt]->Material=new CMaterial;
		}

		return iTexture[nt]->Material;
	}
	else return NULL;
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function:

		Free all textures
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::FreeAllTextures()
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_

	TextureContainer->delAll();
#else
	int n;

	for (n=0;n<NBRE_MAX_TEXTURES;n++)
	{
		if (cTexture[n]==1)
		{
			if (NameGroup)
			{
				if (iTexture[n]->Group)
				if (strcmp(NameGroup,iTexture[n]->Group)==0) 
				{
					FreeTexture(n);
				}
			}
			else
			{
				FreeTexture(n);
			}
		}
	}
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Create textures

		int C3DAPIBASE::AddTexture(int Size,char * ptrRGBA,int Sizeptr,int Alpha)

		Size : length in pixels of the texture to be created
		ptrRGBA : array of (r,g,b,a) 
		SizePtr : lenght in pixels of the buffer ptrRGBA
		Alpha : ALPHA or NO_ALPHA
		
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

int C3DAPIBASE::AddTexture(int Sizex,int Sizey,char * ptrRGBA,int Sizeptrx,int Sizeptry,int Alpha)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_

	unsigned int flags=Alpha;
	if (states(TEXTURES_MIPMAP_ACTIVE)) flags|=TC_MIPMAP;
	if (states(TEXTURES_CLAMPING)) flags|=TC_CLAMP;

	int Tilex=Sizex;	
	if (Tilex>(int)states(TEXTURE_MAX_WIDTH)) Tilex=states(TEXTURE_MAX_WIDTH);
	int Tiley=Sizey;	
	if (Tiley>(int)states(TEXTURE_MAX_WIDTH)) Tiley=states(TEXTURE_MAX_WIDTH);

	return TextureContainer->add(Tilex,Tiley,ptrRGBA,Sizeptrx,Sizeptry,flags);

#endif

	return 0;
}

int C3DAPIBASE::AddTexture(int Size,char * ptrRGBA,int Sizeptr,int Alpha)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_

	unsigned int flags=Alpha;
	if (states(TEXTURES_MIPMAP_ACTIVE)) flags|=TC_MIPMAP;
	if (states(TEXTURES_CLAMPING)) flags|=TC_CLAMP;
	int Tile=Size;	
	if (Tile>(int)states(TEXTURE_MAX_WIDTH)) Tile=states(TEXTURE_MAX_WIDTH);

	return TextureContainer->add(Tile,Tile,ptrRGBA,Sizeptr,Sizeptr,flags);

#else
	int n;

	n=0;
	while ((cTexture[n]==1)&&(n<NBRE_MAX_TEXTURES)) n++;

	if (n==NBRE_MAX_TEXTURES) return -1;

	CreateTexture(n,Size,ptrRGBA,Sizeptr,Alpha);

	return n;

#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Clone texture
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::DuplicateTexture(int n,int nt)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_

	TextureContainer->clone(n,nt);

#else

	Texture[n]=Texture[nt];

	iTexture[n]=new CTexture;
	iTexture[n]->ClampRepeat=iTexture[nt]->ClampRepeat;
	iTexture[n]->MipMap=iTexture[nt]->MipMap;
	iTexture[n]->Format=iTexture[nt]->Format;
	iTexture[n]->Tile=iTexture[nt]->Tile;
	iTexture[n]->Material=NULL;
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Clone texture
		
		int C3DAPIBASE::CloneTexture(int nt)

		nt : index in texture array

	Usage:	usefull to assign different materials to a "same texture"

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


int C3DAPIBASE::CloneTexture(int nt)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_

	return TextureContainer->addclone(nt);

#else

	int n;

	n=0;
	while ((cTexture[n]==1)&&(n<NBRE_MAX_TEXTURES)) n++;

	if (n==NBRE_MAX_TEXTURES) return -1;

	Texture[n]=Texture[nt];

	iTexture[n]=new CTexture;
	iTexture[n]->ClampRepeat=iTexture[nt]->ClampRepeat;
	iTexture[n]->MipMap=iTexture[nt]->MipMap;
	iTexture[n]->Format=iTexture[nt]->Format;
	iTexture[n]->Tile=iTexture[nt]->Tile;
	iTexture[n]->Material=NULL;

	return n;
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		void C3DAPIBASE::IsActiveTexture(int n)

		n : index in texture array

	Usage:	

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

bool C3DAPIBASE::IsActiveTexture(int n)
{
	if (n>=0)
	{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	return TextureContainer->is(n);
#else
	return (cTexture[n]!=0);
#endif
	}
	else return false;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Free texture
		
		void C3DAPIBASE::FreeTexture(int n)

		n : index in texture array

	Usage:	

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::FreeTexture(int n)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_

	TextureContainer->del(n);

#else

	if (cTexture[n])
	{

#ifdef API3D_OPENGL
//------------------------------------------------------------------------------------------------ OPEN GL -----------	
		glDeleteTextures(1,(GLuint*) &Texture[n]);
		Texture[n]=((unsigned int) -1);
#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------	
		if (Texture[n]!=NULL) Texture[n]->Release();
		Texture[n]=NULL;
#endif

		if (iTexture[n])
		{
			if (iTexture[n]->Material) delete iTexture[n]->Material;
			delete iTexture[n];
		}
		iTexture[n]=NULL;

		cTexture[n]=0;
	}
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Set texture : level 0
		
		int C3DAPIBASE::GetWidthTexture(int n)	
		int C3DAPIBASE::GetHeightTexture(int n)	

		n : index in texture array

	Usage:	

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

int C3DAPIBASE::GetWidthTexture(int n)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	if (TextureContainer->get(n))
	{		
		return TextureContainer->get(n)->data.Tilex;
	}
	else return 0;
#endif
}


int C3DAPIBASE::GetHeightTexture(int n)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	if (TextureContainer->get(n))
	{		
		return TextureContainer->get(n)->data.Tiley;
	}
	else return 0;
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Set texture : level 0
		
		
		void C3DAPIBASE::SetTexture(int n)

		n : index in texture array

	Usage:	

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTexture(int n)
{

#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
//------------------------------------------------------------------------------------------------ METAL -------------
	if (aT!=n) Flush();
	lT=-666;
	aT=n;
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
#ifdef OPENGL_PBUFFERS
	if (aT>-16)
	if (aT<0) pbufferRelease(-(aT+1));
#endif

	if (aT!=n) Flush();

	if (n>=0)
	{
#ifndef API3D_OPENGL20
		if (MultiTexture) glActiveTextureARB(GL_TEXTURE0_ARB);
		glEnable(GL_TEXTURE_2D);
		glBindTexture(GL_TEXTURE_2D,Texture[n]);
		glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
#if !defined(GLES)&&!defined(GLES20)
		glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE_ARB,1);
#endif
#endif

#ifdef API3D_OPENGL20
		lT=-666;
#endif
		aT=n;
	}
	else
	{
		if (SecondarySurface)
		{
#ifndef API3D_OPENGL20
			if (MultiTexture) glActiveTextureARB(GL_TEXTURE0_ARB);
			glEnable(GL_TEXTURE_2D);
#ifdef OPENGL_PBUFFERS
			pbufferBind(-(n+1));
#endif

#ifdef OPENGL_FRAMEBUFFERS
			glBindTexture(GL_TEXTURE_2D,renderedTexture[-(n+1)]);
#endif

			glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
#if !defined(GLES)&&!defined(GLES20)
			glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE_ARB,1);
#endif
#endif
		}

#ifdef API3D_OPENGL20
		lT=-666;
#endif
		aT=n;
	}
#endif

#ifdef API3D_DIRECT3D
//------------------------------------------------------------------------------------------------ DIRECT3D ----------

	if (aT!=n) Flush();

	if (n>=0) 
	{
		if (cTexture[n])
		{
			D3DDevice->SetTexture(0,Texture[n]);
			
			if (iTexture[n]->ClampRepeat==0)
			{
				D3DDevice->SetTextureStageState(0,D3DTSS_ADDRESSU,D3DTADDRESS_WRAP);
				D3DDevice->SetTextureStageState(0,D3DTSS_ADDRESSV,D3DTADDRESS_WRAP);
			}
			else
			{
				D3DDevice->SetTextureStageState(0,D3DTSS_ADDRESSU,D3DTADDRESS_CLAMP);
				D3DDevice->SetTextureStageState(0,D3DTSS_ADDRESSV,D3DTADDRESS_CLAMP);
			}

			if ((iTexture[n]->MipMap==1)&&(states(MIPMAP_ACTIVE))) D3DDevice->SetTextureStageState(0,D3DTSS_MIPFILTER,D3DTEXF_LINEAR);
			else D3DDevice->SetTextureStageState(0,D3DTSS_MIPFILTER,D3DTEXF_NONE);

		}
		else
		{
			D3DDevice->SetTexture(0,NULL);
		}

		aT=n;
	}
	else
	{
//		Texture0=D3DTextureSecondary[-(n+1)];
		D3DDevice->SetTexture(0,D3DTextureSecondary[-(n+1)]);
		D3DDevice->SetTextureStageState(0,D3DTSS_ADDRESSU,D3DTADDRESS_CLAMP);
		D3DDevice->SetTextureStageState(0,D3DTSS_ADDRESSV,D3DTADDRESS_CLAMP);
		D3DDevice->SetTextureStageState(0,D3DTSS_MIPFILTER,D3DTEXF_NONE);
		D3DDevice->SetTextureStageState(0,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
		D3DDevice->SetTextureStageState(0,D3DTSS_MINFILTER,D3DTEXF_LINEAR);

		aT=n;
	}

#endif

#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)
	if (aT!=n) Flush();

	if (n>=0) 
	{
		if (cTexture[n]) Texture0=Texture[n];
	}
	else Texture0=shaderResourceView[-(n+1)];

	lT=-666;
	aT=n;
#endif

#ifdef API3D_DIRECT3D9
//------------------------------------------------------------------------------------------------ DIRECT3D ----------

	if (aT!=n) Flush();

	if (n>=0) 
	{
		if (cTexture[n])
		{
			D3DDevice->SetTexture(0,Texture[n]);
			
			if (iTexture[n]->ClampRepeat==0)
			{
				D3DDevice->SetSamplerState(0,D3DSAMP_ADDRESSU,D3DTADDRESS_WRAP);
				D3DDevice->SetSamplerState(0,D3DSAMP_ADDRESSV,D3DTADDRESS_WRAP);
			}
			else
			{
				D3DDevice->SetSamplerState(0,D3DSAMP_ADDRESSU,D3DTADDRESS_CLAMP);
				D3DDevice->SetSamplerState(0,D3DSAMP_ADDRESSV,D3DTADDRESS_CLAMP);
			}

			if ((iTexture[n]->MipMap==1)&&(states(MIPMAP_ACTIVE))) D3DDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_LINEAR);
			else D3DDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_NONE);

		}
		else
		{
			D3DDevice->SetTexture(0,NULL);
		}

		aT=n;
	}
	else
	{
		D3DDevice->SetTexture(0,D3DTextureSecondary[-(n+1)]);
		D3DDevice->SetSamplerState(0,D3DSAMP_ADDRESSU,D3DTADDRESS_CLAMP);
		D3DDevice->SetSamplerState(0,D3DSAMP_ADDRESSV,D3DTADDRESS_CLAMP);
		D3DDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
		D3DDevice->SetSamplerState(0,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
		D3DDevice->SetSamplerState(0,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);

		aT=n;
	}
#endif

}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Set texture : level 1
		
		
		void C3DAPIBASE::SetTexture(int n)

		n : index in texture array

	Usage:	

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTexture2(int n)
{

#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)
//------------------------------------------------------------------------------------------------ METAL -------------
	if (aT2!=n) Flush();
	lT2=-666;
	aT2=n;
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	if (MultiTexture) 
	{
#ifdef OPENGL_PBUFFERS
		if (aT2>-16)
		if (aT2<0) pbufferRelease(-(aT2+1));
#endif
		if (aT2!=n) Flush();

		if (n>=0)
		{
#ifndef API3D_OPENGL20
			glActiveTextureARB(GL_TEXTURE1_ARB);
			glEnable(GL_TEXTURE_2D);
			glBindTexture(GL_TEXTURE_2D,Texture[n]);
			glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
#if !defined(GLES)&&!defined(GLES20)
			glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE_ARB,1);
#endif
#endif
#ifdef API3D_OPENGL20
			lT2=-666;
#endif
			aT2=n;
		}
		else
		if (SecondarySurface)
		{
#ifndef API3D_OPENGL20
			glActiveTextureARB(GL_TEXTURE1_ARB);
			glEnable(GL_TEXTURE_2D);
#ifdef OPENGL_PBUFFERS
			pbufferBind(-(n+1));
#endif

#ifdef OPENGL_FRAMEBUFFERS
			glBindTexture(GL_TEXTURE_2D,renderedTexture[-(n+1)]);
#endif

			glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
#if !defined(GLES)&&!defined(GLES20)
			glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE_ARB,1);
#endif
#endif
#ifdef API3D_OPENGL20
			lT2=-666;
#endif
			aT2=n;
		}
	}
	aT2=n;
#endif

#ifdef API3D_DIRECT3D
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	if (n>=0) 
	{
		if (cTexture[n])
		{
			D3DDevice->SetTexture(1,Texture[n]);
		
			if (iTexture[n]->ClampRepeat==0)
			{
				D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSU,D3DTADDRESS_WRAP);
				D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSV,D3DTADDRESS_WRAP);
			}
			else
			{
				D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSU,D3DTADDRESS_CLAMP);
				D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSV,D3DTADDRESS_CLAMP);
			}

			if ((iTexture[n]->MipMap==1)&&(states(MIPMAP_ACTIVE))) D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_LINEAR);
			else D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);
		}
		else D3DDevice->SetTexture(1,NULL);
	}		
	else
	{
		D3DDevice->SetTexture(1,D3DTextureSecondary[-(n+1)]);
		D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSU,D3DTADDRESS_CLAMP);
		D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSV,D3DTADDRESS_CLAMP);
		D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);
		D3DDevice->SetTextureStageState(1,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
		D3DDevice->SetTextureStageState(1,D3DTSS_MINFILTER,D3DTEXF_LINEAR);
	}

	aT2=n;
#endif

#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)

	if (n>=0) 
	{
		if (cTexture[n]) Texture1=Texture[n];
	}
	else Texture1=shaderResourceView[-(n+1)];
	lT2=-666;
	aT2=n;
#endif

#ifdef API3D_DIRECT3D9
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	if (n>=0) 
	{
		if (cTexture[n])
		{
			D3DDevice->SetTexture(1,Texture[n]);
		
			if (iTexture[n]->ClampRepeat==0)
			{
				D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSU,D3DTADDRESS_WRAP);
				D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSV,D3DTADDRESS_WRAP);
			}
			else
			{
				D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSU,D3DTADDRESS_CLAMP);
				D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSV,D3DTADDRESS_CLAMP);
			}

			if ((iTexture[n]->MipMap==1)&&(states(MIPMAP_ACTIVE))) D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_LINEAR);
			else D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
		}
		else D3DDevice->SetTexture(1,NULL);
	}
	else
	{
		D3DDevice->SetTexture(1,D3DTextureSecondary[-(n+1)]);
		D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSU,D3DTADDRESS_CLAMP);
		D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSV,D3DTADDRESS_CLAMP);
		D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
		D3DDevice->SetSamplerState(1,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
		D3DDevice->SetSamplerState(1,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);
	}

	aT2=n;
#endif

}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Set texture : level 2
		
		
		void C3DAPIBASE::SetTexture(int n)

		n : index in texture array

	Usage:	

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTexture3(int n)
{
	SetTexture(2,n);
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Set texture : level 3
		
		
		void C3DAPIBASE::SetTexture(int n)

		n : index in texture array

	Usage:	

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTexture4(int n)
{
	SetTexture(3,n);
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Set texture : level 4
		
		
		void C3DAPIBASE::SetTexture(int n)

		n : index in texture array

	Usage:	

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTexture5(int n)
{
	SetTexture(4,n);
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Set texture : level 5
		
		
		void C3DAPIBASE::SetTexture(int n)

		n : index in texture array

	Usage:	

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTexture6(int n)
{
	SetTexture(5,n);
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Set texture : level 6
		
		
		void C3DAPIBASE::SetTexture(int n)

		n : index in texture array

	Usage:	

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTexture7(int n)
{
	SetTexture(6,n);
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Set texture : level 7
		
		
		void C3DAPIBASE::SetTexture(int n)

		n : index in texture array

	Usage:	

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTexture8(int n)
{
	SetTexture(7,n);
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Set texture : level lvl
		
		
		void C3DAPIBASE::SetTexture(int n)

		n : index in texture array

	Usage:	

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTexture(int lvl,int n)
{
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)
//------------------------------------------------------------------------------------------------ METAL -------------
    int* texs[8]={ &aT,&aT2,&aT3,&aT4,&aT5,&aT6,&aT7,&aT8 };
	if (*texs[lvl]!=n) Flush();
	*texs[lvl]=n;
#else

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
#if !defined(GLES)&&!defined(GLES20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	if (MultiTexture) 
	{
		if (n>=0)
		{
#ifndef API3D_OPENGL20
			glActiveTextureARB(GL_TEXTURE0_ARB+lvl);
			glEnable(GL_TEXTURE_2D);
			glBindTexture(GL_TEXTURE_2D,Texture[n]);
			glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
			glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE_ARB,1);
#endif
		}
		else
		if (SecondarySurface)
		{
#ifndef API3D_OPENGL20
			glActiveTextureARB(GL_TEXTURE0_ARB+lvl);
			glEnable(GL_TEXTURE_2D);

#ifdef OPENGL_FRAMEBUFFERS
			glBindTexture(GL_TEXTURE_2D,renderedTexture[-(n+1)]);
#endif

			glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
			glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE_ARB,1);
#endif
		}
	}

#endif
#endif

#ifdef API3D_DIRECT3D
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	if (n>=0) 
	{
		if (cTexture[n])
		{
			D3DDevice->SetTexture(lvl,Texture[n]);
		
			if (iTexture[n]->ClampRepeat==0)
			{
				D3DDevice->SetTextureStageState(lvl,D3DTSS_ADDRESSU,D3DTADDRESS_WRAP);
				D3DDevice->SetTextureStageState(lvl,D3DTSS_ADDRESSV,D3DTADDRESS_WRAP);
			}
			else
			{
				D3DDevice->SetTextureStageState(lvl,D3DTSS_ADDRESSU,D3DTADDRESS_CLAMP);
				D3DDevice->SetTextureStageState(lvl,D3DTSS_ADDRESSV,D3DTADDRESS_CLAMP);
			}

			if ((iTexture[n]->MipMap==1)&&(states(MIPMAP_ACTIVE))) D3DDevice->SetTextureStageState(lvl,D3DTSS_MIPFILTER,D3DTEXF_LINEAR);
			else D3DDevice->SetTextureStageState(lvl,D3DTSS_MIPFILTER,D3DTEXF_NONE);
		}
		else D3DDevice->SetTexture(lvl,NULL);
	}		
	else
	{
		D3DDevice->SetTexture(lvl,D3DTextureSecondary[-(n+1)]);
		D3DDevice->SetTextureStageState(lvl,D3DTSS_MIPFILTER,D3DTEXF_NONE);
		D3DDevice->SetTextureStageState(lvl,D3DTSS_ADDRESSU,D3DTADDRESS_CLAMP);
		D3DDevice->SetTextureStageState(lvl,D3DTSS_ADDRESSV,D3DTADDRESS_CLAMP);
		D3DDevice->SetTextureStageState(lvl,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
		D3DDevice->SetTextureStageState(lvl,D3DTSS_MINFILTER,D3DTEXF_LINEAR);
	}
#endif

#if defined(API3D_DIRECT3D10)
	ID3D10ShaderResourceView** texs[8]={ &Texture0,&Texture1,&Texture2,&Texture3,&Texture4,&Texture5,&Texture6,&Texture7 };

	if (n>=0) 
	{
		if (cTexture[n]) *texs[lvl]=Texture[n];
	}
	else *texs[lvl]=shaderResourceView[-(n+1)];

#endif

#if defined(API3D_DIRECT3D11)

	ID3D11ShaderResourceView** texs[8]={ &Texture0,&Texture1,&Texture2,&Texture3,&Texture4,&Texture5,&Texture6,&Texture7 };

	if (n>=0) 
	{
		if (cTexture[n]) *texs[lvl]=Texture[n];
	}
	else *texs[lvl]=shaderResourceView[-(n+1)];

#endif

#ifdef API3D_DIRECT3D9
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	if (n>=0) 
	{
		if (cTexture[n])
		{
			D3DDevice->SetTexture(lvl,Texture[n]);
		
			if (iTexture[n]->ClampRepeat==0)
			{
				D3DDevice->SetSamplerState(lvl,D3DSAMP_ADDRESSU,D3DTADDRESS_WRAP);
				D3DDevice->SetSamplerState(lvl,D3DSAMP_ADDRESSV,D3DTADDRESS_WRAP);
			}
			else
			{
				D3DDevice->SetSamplerState(lvl,D3DSAMP_ADDRESSU,D3DTADDRESS_CLAMP);
				D3DDevice->SetSamplerState(lvl,D3DSAMP_ADDRESSV,D3DTADDRESS_CLAMP);
			}

			if ((iTexture[n]->MipMap==1)&&(states(MIPMAP_ACTIVE))) D3DDevice->SetSamplerState(lvl,D3DSAMP_MIPFILTER,D3DTEXF_LINEAR);
			else D3DDevice->SetSamplerState(lvl,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
		}
		else D3DDevice->SetTexture(lvl,NULL);
	}		
	else
	{
		D3DDevice->SetTexture(lvl,D3DTextureSecondary[-(n+1)]);

		D3DDevice->SetSamplerState(lvl,D3DSAMP_ADDRESSU,D3DTADDRESS_CLAMP);
		D3DDevice->SetSamplerState(lvl,D3DSAMP_ADDRESSV,D3DTADDRESS_CLAMP);

		D3DDevice->SetSamplerState(lvl,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
		D3DDevice->SetSamplerState(lvl,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
		D3DDevice->SetSamplerState(lvl,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);
	}
#endif

	int * mapaT[8]={ &aT,&aT2,&aT3,&aT4,&aT5,&aT6,&aT7,&aT8 };
	*mapaT[lvl]=n;

#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		patch de texture
		
		void C3DAPIBASE::ModifyTextureFromMem_RGB(int n,int x,int y,int sizex,int sizey,char * ptr)
		

		n : index in texture array
		x,y : coord in pixel of dest patch
		sizex,sizey : lengths of ptr
		ptr : (r,g,b) pixel values
			

	Note: all pixels from ptr are patched although lengths diferences with texture pixel array

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::ModifyTextureFromMem_RGB(int n,int x,int y,int sizex,int sizey,char * ptr)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_

	TextureContainer->modifyRGB(n,x,y,sizex,sizey,ptr);

#else

#ifdef API3D_OPENGL
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	glPixelStorei(GL_UNPACK_ALIGNMENT,1);
	SetTexture(n);
	glTexSubImage2D(GL_TEXTURE_2D,0,x,y,sizex,sizey,GL_RGB,GL_UNSIGNED_BYTE,ptr);

#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	int r,g,b,a;
	int n1,n2;
	unsigned int adr,adr0,pitch;
	WORD * ptrdest;
//	BYTE * ptrdest2;
	D3DLOCKED_RECT Locked;
	RECT DirtyRect;
	CQuad q;

	DirtyRect.top=y;
	DirtyRect.left=x;
	DirtyRect.right=x+sizex;
	DirtyRect.bottom=y+sizey;

	q.x1=x;
	q.y1=y;
	q.x2=x+sizex;
	q.y2=y+sizey;

	iTexture[n]->LQ.Add(q);


	if (iTexture[n]->Format==0) // 565
	{

		Texture[n]->LockRect(0,&Locked,&DirtyRect,D3DLOCK_NO_DIRTY_UPDATE);	// level 0

		ptrdest=(WORD *) Locked.pBits;

		pitch=Locked.Pitch/2;

		for (n2=0;n2<sizey;n2++)
		{
			adr0=3*(n2*sizex);
			adr=(n2)*pitch;
			for (n1=0;n1<sizex;n1++)
			{
				r=ptr[adr0+0]&255;
				g=ptr[adr0+1]&255;
				b=ptr[adr0+2]&255;

				ptrdest[adr]=((r>>3)<<11) +((g>>2)<<5) + (b>>3);
				adr0+=3;
				adr++;
			}
		}
		Texture[n]->UnlockRect(0);
		//D3DDevice->UpdateTexture(TextureSYSTEMMEM[n],Texture[n]);
	}


	if (iTexture[n]->Format==1) // 1555
	{
		Texture[n]->LockRect(0,&Locked,&DirtyRect,D3DLOCK_NO_DIRTY_UPDATE);	// level 0
		ptrdest=(WORD *) Locked.pBits;

		pitch=Locked.Pitch/2;

		for (n2=0;n2<sizey;n2++)
		{
			adr0=3*(n2*sizex);
			adr=(n2)*pitch;
			for (n1=0;n1<sizex;n1++)
			{
				r=ptr[adr0+0]&255;
				g=ptr[adr0+1]&255;
				b=ptr[adr0+2]&255;

				ptrdest[adr]=((r>>3)<<10) +((g>>3)<<5) + (b>>3);
				adr0+=3;
				adr++;
			}
		}
		Texture[n]->UnlockRect(0);
		//D3DDevice->UpdateTexture(TextureSYSTEMMEM[n],Texture[n]);

	}

	if (iTexture[n]->Format==2) // 4444
	{
		Texture[n]->LockRect(0,&Locked,&DirtyRect,D3DLOCK_NO_DIRTY_UPDATE);	// level 0
		ptrdest=(WORD *) Locked.pBits;

		pitch=Locked.Pitch/2;

		for (n2=0;n2<sizey;n2++)
		{
			adr0=3*(n2*sizex);
			adr=(n2)*pitch;
			for (n1=0;n1<sizex;n1++)
			{
				r=ptr[adr0+0]&255;
				g=ptr[adr0+1]&255;
				b=ptr[adr0+2]&255;
				a=255;

				ptrdest[adr]=((a>>4)<<12) + ((r>>4)<<8) +((g>>4)<<4) + (b>>4);
				adr0+=3;
				adr++;
			}
		}
		Texture[n]->UnlockRect(0);
		//D3DDevice->UpdateTexture(TextureSYSTEMMEM[n],Texture[n]);

	}
#endif  

#endif
}

/*

void C3DAPIBASE::ModifyTextureFromMem_RGB_w(int n,int x,int y,int sizex,int sizey,char * ptr)
{
#ifdef API3D_DIRECT3D
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	int r,g,b,a;
	int n1,n2;
	unsigned int adr,adr0,pitch;
	WORD * ptrdest;
//	BYTE * ptrdest2;
	D3DLOCKED_RECT Locked;
	RECT DirtyRect;
	CQuad q;

	DirtyRect.top=y;
	DirtyRect.left=x;
	DirtyRect.right=x+sizex;
	DirtyRect.bottom=y+sizey;

	
	q.x1=x;
	q.y1=y;
	q.x2=x+sizex;
	q.y2=y+sizey;

	iTexture[n]->LQ.Add(q);


	Texture[n]->LockRect(0,&Locked,&DirtyRect,D3DLOCK_NO_DIRTY_UPDATE);	// level 0

	ptrdest=(WORD *) Locked.pBits;

	pitch=Locked.Pitch/2;

	adr=0;
	adr0=0;
	for (n2=0;n2<sizey;n2++)
	{

		memcpy(&ptrdest[adr],&ptr[adr0],sizex*2);
		adr0+=3*(sizex);
		adr+=pitch;
	}
	Texture[n]->UnlockRect(0);

#endif
}

char * C3DAPIBASE::PrepareBuffer_RGB(int format,int sizex,int sizey,char * ptr)
{
	int adr,adr0;
	int r,g,b,a;
	int n1,n2;
	unsigned short int * ptrdest;

	ptrdest=(unsigned short int*) malloc(sizex*sizey*2);

	if (format==0) // 565
	{
		adr=0;
		adr0=0;

		for (n2=0;n2<sizey;n2++)
		{
			for (n1=0;n1<sizex;n1++)
			{
				r=ptr[adr0+0]&255;
				g=ptr[adr0+1]&255;
				b=ptr[adr0+2]&255;

				ptrdest[adr]=((r>>3)<<11) +((g>>2)<<5) + (b>>3);
				adr0+=3;
				adr++;
			}
		}
	}


	if (format==1) // 1555
	{
		adr=0;
		adr0=0;

		for (n2=0;n2<sizey;n2++)
		{
			for (n1=0;n1<sizex;n1++)
			{
				r=ptr[adr0+0]&255;
				g=ptr[adr0+1]&255;
				b=ptr[adr0+2]&255;

				ptrdest[adr]=((r>>3)<<10) +((g>>3)<<5) + (b>>3);
				adr0+=3;
				adr++;
			}
		}
	}

	if (format==2) // 4444
	{
		adr=0;
		adr0=0;

		for (n2=0;n2<sizey;n2++)
		{
			for (n1=0;n1<sizex;n1++)
			{
				r=ptr[adr0+0]&255;
				g=ptr[adr0+1]&255;
				b=ptr[adr0+2]&255;
				a=255;

				ptrdest[adr]=((a>>4)<<12) + ((r>>4)<<8) +((g>>4)<<4) + (b>>4);
				adr0+=3;
				adr++;
			}
		}
	}

	return (char*)ptrdest;
}

*/

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		patch de texture
		
		void C3DAPIBASE::ModifyTextureFromMem4_RGB(int n,int x,int y,int sizex,int sizey,char * ptr)
		

		n : index in texture array
		x,y : coord in pixel of dest patch
		sizex,sizey : lengths of ptr
		ptr : (r,g,b,a) pixel values
			

	Note: all pixels from ptr are patched although lengths diferences with texture pixel array

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::ModifyTextureFromMem4_RGB(int n,int x,int y,int sizex,int sizey,char * ptr)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_

	TextureContainer->modifyRGBA(n,x,y,sizex,sizey,ptr);

#else

#ifdef API3D_OPENGL
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	glPixelStorei(GL_UNPACK_ALIGNMENT,1);
	SetTexture(n);
	glTexSubImage2D(GL_TEXTURE_2D,0,x,y,sizex,sizey,GL_RGBA,GL_UNSIGNED_BYTE,ptr);

#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	int r,g,b,a;
	int n1,n2;
	unsigned int adr,adr0,pitch;
	WORD * ptrdest;
//	BYTE * ptrdest2;
	D3DLOCKED_RECT Locked;
	RECT DirtyRect;
	CQuad q;

	DirtyRect.top=y;
	DirtyRect.left=x;
	DirtyRect.right=x+sizex;
	DirtyRect.bottom=y+sizey;

	q.x1=x;
	q.y1=y;
	q.x2=x+sizex;
	q.y2=y+sizey;

	iTexture[n]->LQ.Add(q);


	if (iTexture[n]->Format==0) // 565
	{

		Texture[n]->LockRect(0,&Locked,&DirtyRect,D3DLOCK_NO_DIRTY_UPDATE);	// level 0

		ptrdest=(WORD *) Locked.pBits;

		pitch=Locked.Pitch/2;

		for (n2=0;n2<sizey;n2++)
		{
			adr0=4*(n2*sizex);
			adr=(n2)*pitch;
			for (n1=0;n1<sizex;n1++)
			{
				r=ptr[adr0+0]&255;
				g=ptr[adr0+1]&255;
				b=ptr[adr0+2]&255;

				ptrdest[adr]=((r>>3)<<11) +((g>>2)<<5) + (b>>3);
				adr0+=4;
				adr++;
			}
		}
		Texture[n]->UnlockRect(0);
	}


	if (iTexture[n]->Format==1) // 1555
	{
		Texture[n]->LockRect(0,&Locked,&DirtyRect,D3DLOCK_NO_DIRTY_UPDATE);	// level 0
		ptrdest=(WORD *) Locked.pBits;

		pitch=Locked.Pitch/2;

		for (n2=0;n2<sizey;n2++)
		{
			adr0=4*(n2*sizex);
			adr=(n2)*pitch;
			for (n1=0;n1<sizex;n1++)
			{
				r=ptr[adr0+0]&255;
				g=ptr[adr0+1]&255;
				b=ptr[adr0+2]&255;

				ptrdest[adr]=((r>>3)<<10) +((g>>3)<<5) + (b>>3);
				adr0+=4;
				adr++;
			}
		}
		Texture[n]->UnlockRect(0);
	}

	if (iTexture[n]->Format==2) // 4444
	{
		Texture[n]->LockRect(0,&Locked,&DirtyRect,D3DLOCK_NO_DIRTY_UPDATE);	// level 0
		ptrdest=(WORD *) Locked.pBits;

		pitch=Locked.Pitch/2;

		for (n2=0;n2<sizey;n2++)
		{
			adr0=4*(n2*sizex);
			adr=(n2)*pitch;
			for (n1=0;n1<sizex;n1++)
			{
				r=ptr[adr0+0]&255;
				g=ptr[adr0+1]&255;
				b=ptr[adr0+2]&255;
				a=ptr[adr0+3]&255;

				ptrdest[adr]=((a>>4)<<12) + ((r>>4)<<8) +((g>>4)<<4) + (b>>4);
				adr0+=4;
				adr++;
			}
		}
		Texture[n]->UnlockRect(0);

	}
#endif  
#endif  

}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		clear Stencil buffer

		void C3DAPIBASE::ClearStencilBuffer()
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::ClearStencilBuffer()
{
	if (StencilClear) { StencilClear=false; }

	if (StencilBuffer)
	{

#ifdef API3D_METAL
		MTLClearStencil();
        
        if (states(RENDER_TARGET)==PRIMARY)
            SetViewport(0,0,projSCREENX,projSCREENY);
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)		
		glClearStencil(0);
		glClear(GL_STENCIL_BUFFER_BIT);
		glStencilMask(0xffffffff);
#endif

#ifdef API3D_DIRECT3D
		D3DDevice->Clear(0L, NULL,D3DCLEAR_STENCIL,0, 1.0f, 0L );
#endif

#ifdef API3D_DIRECT3D9
		D3DDevice->Clear(0L, NULL,D3DCLEAR_STENCIL,0, 1.0f, 0L );
#endif

#ifdef API3D_DIRECT3D10
	device->ClearDepthStencilView(depthstencil, D3D10_CLEAR_STENCIL, 1.0f, 0);	
#endif

#ifdef API3D_DIRECT3D11
	devicecontext->ClearDepthStencilView(depthstencil, D3D11_CLEAR_STENCIL, 1.0f, 0);	
#endif
        
#ifdef API3D_DIRECT3D12
        ID3D12GraphicsCommandList* cmd=commandList;
		if (cmd==NULL)
		{
			device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator, nullptr, IID_PPV_ARGS(&cmd));

			cmd->ClearDepthStencilView(dsvDepthStencil,D3D12_CLEAR_FLAG_STENCIL,1.0f,0,0,nullptr);
			//CloseAndExecuteCommandList(cmd);
			cmd->SetDescriptorHeaps(1,&HandleContainer.DescriptorHeap);
			commandList=cmd;
			previouspipe=NULL;
			prevEffect=NULL;
		}
		else
		{
			cmd->ClearDepthStencilView(dsvDepthStencil,D3D12_CLEAR_FLAG_STENCIL,1.0f,0,0,nullptr);
		}
#endif
	}
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		paramï¿½tres d'affichage

		void C3DAPIBASE::SetParams(int Quoi,int Comment)

	Usage:


	Quoi:					Def:								Comment:
  	API3D_NONE				...
	API3D_ZBUFFER			ZBuffer								(ON,OFF,WRITEOFF)
	API3D_SHADING			Shading								(ON,OFF)
	API3D_CULL				Culling								(ON,OFF,CW,CCW)
	API3D_TEXTURING			Texture Stage 0						(ON,OFF,T_MODULATE,T_ADD,T_BLEND)
	API3D_BLEND				Blending : Automatic set of Src,Dst	(ON,OFF,BLEND_GOURAUD,BLEND_COLOR)
	API3D_CREATETEXTURE		Options when creating texture		(CLAMP,REPEAT,DITHERING,NODITHERING,NO_MIPMAP,MIPMAP)
	API3D_SECONDARYSURFACE	Options used at InitVideo			(ON,OFF,SECONDARYx,NO_SCALE,SCALE)
	API3D_RENDERTARGET		Render target and Stencil Buffer	(PRIMARY,SECONDARYx,STENCIL_NO_ZTEST,STENCIL,
																 ZBUFFER,RENDER,BOTH)	
	API3D_LIGHTING			Transform & Lighting				(ON,OFF)	
	API3D_ZBIAS				ZBias								( x,0 )
	API3D_STENCIL			Stencil buffer test and render		(EQUAL_ONE,ALWAYS,NOT_ONE,NOT_ZERO,LESSEQUAL_ONE,
																 GREATEREQUAL_ONE,EQUAL_ZERO,INCREMENT,INCREMENTSAT,
																 SET_ONE,DECREMENT,DECREMENTSAT)		
	API3D_DITHERING
	API3D_TEXTURING2		Texture Stage 1						(ON,OFF,T_MODULATE,T_ADD,T_BLEND)
	API3D_SPECULAR			TnL Specular						(ON,OFF)
	API3D_SHADERS			Set EnvMapping method				(DYNAMIC_ENV,FIXED_ENV)
	API3D_SHADOWING			Set api shadowing param				(DRAW,DONT_DRAW)
	API3D_ALPHAMULTIGROUP	Set multi group alpha ref drawing	(DRAW,DONT_DRAW,ONLY)
	API3D_ENVMULTIGROUP		Set multi group envmap drawing		(EXTERN,INTERN)

	API3D_HARDWAREVERTEXPROCESSING	Set HardwareVP				(ON,OFF) before InitVideo..()
	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetParams(int Quoi,int Comment)
{

#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    if (!vbdraw_line) UpdateLines();
#endif


#if defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ METAL -------------
 
	switch (Quoi)
	{

	case API3D_TEXTUREMIPMAP:
		if (Comment==ENABLE) *states[MIPMAP_ACTIVE]=1;
		if (Comment==DISABLE) *states[MIPMAP_ACTIVE]=0;
		break;

	case API3D_LIGHTMAPLAYERS:
		if (Comment==OFF) *states[LIGHTMAP_LAYERS]=1;
		else 
		{
			if ((Comment>=1)&&(Comment<16)) *states[LIGHTMAP_LAYERS]=Comment;
			else *states[LIGHTMAP_LAYERS]=1;
		}
		break;

	case API3D_MULTILAYEREFFECTS:
		if (Comment==FIT_RENDERER_DIMENSION) *states[LAYER_DIMENSION]=1;
		if (Comment==FULL_RENDERING) *states[LAYER_DIMENSION]=0;
		break;

	case API3D_MISC:
		if (Comment==VBL_SYNCHRO) *states[VERTICAL_RETRACE]=1;
		if (Comment==VBL_NOSYNCHRO) *states[VERTICAL_RETRACE]=0;

		if (Comment==VBL_INTERVAL_TWO) *states[VERTICAL_RETRACE]=2;
		if (Comment==VBL_INTERVAL_THREE) *states[VERTICAL_RETRACE]=3;

		break;

	case API3D_HARDWAREVERTEXPROCESSING:
		if (Comment==ON) *states[HARDWARE_VERTEX_PROCESSING_E]=1;
		if (Comment==OFF) *states[HARDWARE_VERTEX_PROCESSING_E]=0;
		break;

	case API3D_ALPHATEST:
		if (Comment==ENABLE) set_alphatest=1;
		if (Comment==DISABLE) { set_alphatest=0; val_alphatest=0.0f; }
		if (Comment<=255)
		{
			val_alphatest=((float)Comment)/255.0f;
		}
		break;

	case API3D_BUMP_SETTEXTURE:
		bumpmap_settexture=Comment;
		break;

	case API3D_SHADOWING:
		if (Comment==DONT_DRAW) *states[SHADOW_BUFFERING]=0;
		if (Comment==DRAW) *states[SHADOW_BUFFERING]=1;
		break;
		
	case API3D_STENCILSHADOWVOLUME:
		if (Comment==REVERSE)
        {
            MTLSetAlgo(ALGO_REVERSE);
            *states[ALGO_STENCIL_SHADOWING]=ALGO_REVERSE;
        }
            
		if (Comment==SIMPLE) *states[ALGO_STENCIL_SHADOWING]=ALGO_SIMPLE;
		if (Comment==ALTERNATIVE)
		{
            MTLSetAlgo(ALGO_ALTERNATIVE);
			*states[ALGO_STENCIL_SHADOWING]=ALGO_ALTERNATIVE;
			G_VertexProgram_ShadowVolume=false;
		}
		if (Comment==ALTERNATIVE_GPU)
		{
			*states[ALGO_STENCIL_SHADOWING]=ALGO_ALTERNATIVE;
			G_VertexProgram_ShadowVolume=true;
		}
		if (Comment==TRIVIAL_ELIMINATION_ON) *states[TRIVIAL_ELIMINATION_STENCIL]=1;
		if (Comment==TRIVIAL_ELIMINATION_OFF) *states[TRIVIAL_ELIMINATION_STENCIL]=0;

		break;

	case API3D_ALPHAMULTIGROUP:
		if (Comment==DONT_DRAW) *states[ALPHA_MULTI_GROUP_DRAW]=0;
		if (Comment==DRAW) *states[ALPHA_MULTI_GROUP_DRAW]=1;
		if (Comment==ONLY) *states[ALPHA_MULTI_GROUP_DRAW]=2;
		break;

	case API3D_ENVMULTIGROUP:
		if (Comment==EXTERN) *states[ENV_SHADERS]=1;
		else *states[ENV_SHADERS]=0;
		break;

	case API3D_ZBIAS:
		if (Comment!=ZBiasComment)
		{
			ZBiasComment=Comment;
			MTLZBias(Comment);
		}
		break;

	case API3D_BLEND:
		{
			if (Comment==BLEND_NO_ALPHA)
			{
				Flush();
				*states[RENDER_BLEND_NO_ALPHA]=((*states[RENDER_BLEND_NO_ALPHA])+1)&1;
			}

			if (Comment==OFF)
			{
				if (states(BLENDING)!=0)
				{
					Flush();
					BLEND_GL=0;
					MTLSetAlphaBlending(false,0,0);
					*states[BLENDING]=0;
				}
			}

			if (Comment==ON)
			{
				if (states(BLENDING)!=1)
				{
					Flush();
					BLEND_GL=1;
					MTLSetAlphaBlending(true,METAL_SRC_ALPHA,METAL_ONE_MINUS_SRC_ALPHA);
					*states[BLENDING]=1;
				}
			}

			if (Comment==BLEND_GOURAUD)
			{
				if (states(BLENDING)!=2)
				{
					Flush();
					BLEND_GL=2;
					MTLSetAlphaBlending(true,METAL_SRC_ALPHA,METAL_ONE);
					*states[BLENDING]=2;
				}
			}

			if (Comment==BLEND_INVERSE)
			{
				if (states(BLENDING)!=3)
				{
					Flush();
					BLEND_GL=8;
					MTLSetAlphaBlending(true,METAL_ONE_MINUS_SRC_ALPHA,METAL_SRC_ALPHA);
					*states[BLENDING]=3;
				}
			}

			if (Comment==BLEND_COLOR)
			{
				if (states(BLENDING)!=4)
				{
					Flush();
					BLEND_GL=4;
					MTLSetAlphaBlending(true,METAL_DST_COLOR,METAL_ZERO);
					*states[BLENDING]=4;
				}
			}
			
			if (Comment==BLEND_ADD)
			{
				if (states(BLENDING)!=5)
				{
					Flush();
					MTLSetAlphaBlending(true,METAL_ONE,METAL_ONE);
					BLEND_GL=5;
					*states[BLENDING]=5;
				}
			}

		}
		break;

	case API3D_SECONDARYSURFACE:
		{
			if (Comment==ON) 
			{
				SecondarySurface=true; 
				nSecondaries=1;
			}
			if (Comment==OFF) SecondarySurface=false;
			if (Comment==SCALE) *states[SCALE_SCREEN]=1;
			if (Comment==NO_SCALE) *states[SCALE_SCREEN]=0;

			switch (Comment)
			{
			case SECONDARY1:
				nSecondaries=1;
				SecondarySurface=true; 
				break;
			case SECONDARY2:
				nSecondaries=2;
				SecondarySurface=true; 
				break;
			case SECONDARY3:
				nSecondaries=3;
				SecondarySurface=true; 
				break;
			case SECONDARY4:
				nSecondaries=4;
				SecondarySurface=true; 
				break;
			case SECONDARY5:
				nSecondaries=5;
				SecondarySurface=true; 
				break;
			case SECONDARY6:
				nSecondaries=6;
				SecondarySurface=true; 
				break;
			case SECONDARY7:
				nSecondaries=7;
				SecondarySurface=true; 
				break;
			case SECONDARY8:
				nSecondaries=8;
				SecondarySurface=true; 
				break;
			case SECONDARY9:
				nSecondaries=9;
				SecondarySurface=true; 
				break;
			case SECONDARY10:
				nSecondaries=10;
				SecondarySurface=true; 
				break;
			case SECONDARY11:
				nSecondaries=11;
				SecondarySurface=true; 
				break;
			case SECONDARY12:
				nSecondaries=12;
				SecondarySurface=true; 
				break;
			case SECONDARY13:
				nSecondaries=13;
				SecondarySurface=true; 
				break;
			case SECONDARY14:
				nSecondaries=14;
				SecondarySurface=true; 
				break;
			case SECONDARY15:
				nSecondaries=15;
				SecondarySurface=true; 
				break;
			case SECONDARY16:
				nSecondaries=16;
				SecondarySurface=true; 
				break;
			case SECONDARY17:
				nSecondaries=17;
				SecondarySurface=true; 
				break;
			case SECONDARY18:
				nSecondaries=18;
				SecondarySurface=true; 
				break;
			case SECONDARY19:
				nSecondaries=19;
				SecondarySurface=true; 
				break;
			case SECONDARY20:
				nSecondaries=20;
				SecondarySurface=true; 
				break;
			case SECONDARY21:
				nSecondaries=21;
				SecondarySurface=true; 
				break;
			case SECONDARY22:
				nSecondaries=22;
				SecondarySurface=true; 
				break;
			case SECONDARY23:
				nSecondaries=23;
				SecondarySurface=true; 
				break;
			case SECONDARY24:
				nSecondaries=24;
				SecondarySurface=true; 
				break;
			};

		}
		break;
		
	case API3D_CREATETEXTURE:
		{

			if (Comment==TEXTURE16BITS) *states[TEXTURES_32BITS]=0;
			if (Comment==TEXTURE32BITS) *states[TEXTURES_32BITS]=1;


			if (Comment==CLAMP)
			{
				*states[TEXTURES_CLAMPING]=1;
			}
			if (Comment==REPEAT)
			{
				*states[TEXTURES_CLAMPING]=0;
			}

			if (Comment==DITHERING)
			{
				*states[TEXTURES_DITHERING]=1;
			}
			if (Comment==NODITHERING)
			{
				*states[TEXTURES_DITHERING]=0;
			}

			if (Comment==MIPMAP)
			{
				*states[TEXTURES_MIPMAP_ACTIVE]=1;
			}

			if (Comment==NO_MIPMAP)
			{
				*states[TEXTURES_MIPMAP_ACTIVE]=0;
			}


		}
		break;

	case API3D_ZBUFFER:
		{
			Flush();
			*states[ZBUFFERING]=Comment;
			MTLSetZBufferStencil(API3D_ZBUFFER,Comment);			
		}
		break;

	case API3D_LIGHTMAPS:
		{
			if (Comment==BACKUP) *states[LIGHTMAP_BACKUPS]=1;
			if (Comment==NO_BACKUP) *states[LIGHTMAP_BACKUPS]=0;
		}

	case API3D_SHADING:
		break;

	case API3D_SHADERS:
		if (Comment==DYNAMIC_ENV) *states[SHADERS]=1;
		if (Comment==FIXED_ENV) *states[SHADERS]=0;
		break;

	case API3D_CULL:
		{
			Flush();
			switch (Comment)
			{
			case ON:
				MTLSetCull(ON);
				*states[CULLING]=-1;
				break;
			case OFF:
				MTLSetCull(OFF);
				*states[CULLING]=-1;
				break;
			case CW:
				if (states(CULLING)!=0)
				{
					Flush();
					*states[CULLING]=0;
					MTLSetCull(CCW);
				}
				break;
			case CCW:
				if (states(CULLING)!=1)
				{
					Flush();
					*states[CULLING]=1;
					MTLSetCull(CW);
				}
				break;
			}
		}
		break;

	case API3D_LIGHTING:
		{
			if (Comment==ON)
			{
				Lighting=true;
			}
			else Lighting=false;
		}
		break;

	case API3D_SPECULAR:

		if (Comment==ON)
		{
			Specular=true;
		}
		
		if (Comment==OFF)
		{
			Specular=false;
		}

		if (Comment==ONLY)
		{
			Lighting=Specular=true;
		}

		break;

	case API3D_TEXTURING:
		{
			switch (Comment)
			{
			case T_MODULATE:
				LevelTexture0=0;
				break;
			case T_ADD:
				LevelTexture0=1;
				break;
			};
		}
		break;	

	case API3D_REPLACE_STENCIL:
		if (Comment==ON) *states[REPLACE_ACTIVE]=1;
		if (Comment==OFF) *states[REPLACE_ACTIVE]=0;
		break;

	case API3D_TEXTURING2:
		{
			switch (Comment)
			{
			case T_MODULATE:
				LevelTexture1=0;
				break;
			case T_ADD:
				LevelTexture1=1;
				break;
			};
		}
		break;	

	case API3D_RENDERTARGET:
		{
			Flush();

			if (Comment==PRIMARY)
			{
				MTLSetZBufferStencil(API3D_ZBUFFER,ON);
				zb=zbw=1;

				*states[RENDER_TARGET]=Comment;
                
				if (SelectedRenderTarget>=0)
				{
					SelectedRenderTarget=-1;

					MTLSetRenderTarget(PRIMARY);

					float w=(float)SCREEN_X;
					float h=(float)SCREEN_Y;

					MatrixOrthoLHS( &ProjOrtho, w,h, 0.0f, 1.0f );

					VIEWPORT.Id();

					VIEWPORT.a[0][0]=(float) (w/2);
					VIEWPORT.a[3][0]=(float) (0+w/2);

					VIEWPORT.a[1][1]=((float) (h/2));
					VIEWPORT.a[3][1]=(float) (0+h/2);

					VIEWPORT.a[2][2]=(float) (1.0f);
					VIEWPORT.a[3][2]=(float) (0.0f);
                    
                    Viewport.Width =(float) w;
                    Viewport.Height =(float) h;
                    Viewport.MinDepth = 0.0f;
                    Viewport.MaxDepth = 1.0f;
                    Viewport.TopLeftX = (float)0;
                    Viewport.TopLeftY = (float)0;
                
                    MTLSetViewport(Viewport.TopLeftX,Viewport.TopLeftY,Viewport.TopLeftX+Viewport.Width,Viewport.TopLeftY+Viewport.Height);
				}
				else
				{
					SelectedRenderTarget=-1;
				
					float w=(float)SCREEN_X;
					float h=(float)SCREEN_Y;
								
					VIEWPORT.Id();
				
					VIEWPORT.a[0][0]=(float) (w/2);
					VIEWPORT.a[3][0]=(float) (0+w/2);
				
					VIEWPORT.a[1][1]=((float) (h/2));
					VIEWPORT.a[3][1]=(float) (0+h/2);
				
					VIEWPORT.a[2][2]=(float) (1.0f);
					VIEWPORT.a[3][2]=(float) (0.0f);

					MatrixOrthoLHS( &ProjOrtho, w,h, 0.0f, 1.0f );

                    MTLSetViewport(Viewport.TopLeftX,Viewport.TopLeftY,Viewport.TopLeftX+Viewport.Width,Viewport.TopLeftY+Viewport.Height);
				}
			}

			if ((Comment>=SECONDARY1)&&(Comment<=SECONDARY24))
			{
				MTLSetZBufferStencil(API3D_ZBUFFER,ON);
				zb=zbw=1;

				*states[RENDER_TARGET]=Comment;
                
				int ns=SelectedRenderTarget=Comment - SECONDARY1;

				MTLSetRenderTarget(Comment);

				float w=(float) tile_secondarysurfacesW[SelectedRenderTarget];
				float h=(float) tile_secondarysurfacesH[SelectedRenderTarget];

				VIEWPORT.Id();

				VIEWPORT.a[0][0]=(float) (w/2);
				VIEWPORT.a[3][0]=(float) (0+w/2);

				VIEWPORT.a[1][1]=((float) (h/2));
				VIEWPORT.a[3][1]=(float) (0+h/2);

				VIEWPORT.a[2][2]=(float) (1.0f);
				VIEWPORT.a[3][2]=(float) (0.0f);

				MatrixOrthoLHS( &ProjOrtho, w,h, 0.0f, 1.0f );

                MTLSetViewport(SndViewport[ns].TopLeftX,SndViewport[ns].TopLeftY,SndViewport[ns].TopLeftX+SndViewport[ns].Width,SndViewport[ns].TopLeftY+SndViewport[ns].Height);
			}
			
			switch(Comment)
			{
			case STENCIL_NO_ZTEST:
                MTLColorMask(false,false,false,false);
				if (StencilBuffer)
				{
					*states[RENDER_TARGET_OPTIONS]=STENCIL_NO_ZTEST;
					*states[ZBUFFER_TEST_STENCIL]=1;
                    C3DAPIBASE_ZBUFFER_TEST_STENCIL=1;
					MTLSetZBufferStencil(API3D_ZBUFFER,OFF);
				}
				MTLSetAlphaBlending(true,METAL_ZERO,METAL_ONE);
				break;

			case STENCIL:		
				if (StencilBuffer)
				{
					*states[RENDER_TARGET_OPTIONS]=STENCIL;
					*states[ZBUFFER_TEST_STENCIL]=0;
                    C3DAPIBASE_ZBUFFER_TEST_STENCIL=0;
					MTLSetZBufferStencil(API3D_ZBUFFER,ON);
					MTLSetZBufferStencil(API3D_STENCIL,ALWAYS);
				}
				MTLSetAlphaBlending(true,METAL_ZERO,METAL_ONE);
                MTLColorMask(false,false,false,false);
				break;

			case ZBUFFER:
				*states[RENDER_TARGET_OPTIONS]=ZBUFFER;
				MTLSetAlphaBlending(true,METAL_ZERO,METAL_ONE);
				MTLSetZBufferStencil(API3D_STENCIL,ALWAYS);
				MTLSetZBufferStencil(API3D_ZBUFFER,ON);
                MTLColorMask(false,false,false,false);
				break;
		
			case RENDER:
				BLEND_GL=0;
				*states[BLENDING]=0;
				MTLSetAlphaBlending(false,0,0);
				MTLSetZBufferStencil(API3D_ZBUFFER,ON);
                MTLSetZBufferStencil(API3D_STENCIL,ALWAYS);
                MTLSetZBufferStencil(API3D_STENCIL,DISABLE);
                MTLColorMask(true,true,true,true);
				*states[RENDER_TARGET_OPTIONS]=RENDER;
				break;

			case BOTH:
				*states[RENDER_TARGET_OPTIONS]=BOTH;
                MTLColorMask(true,true,true,true);
				MTLSetAlphaBlending(false,0,0);
				MTLSetZBufferStencil(API3D_ZBUFFER,ON);
				MTLSetZBufferStencil(API3D_ZBUFFER,WRITEOFF);
				MTLSetZBufferStencil(API3D_STENCIL,ALWAYS);
				if (!StencilBuffer) MTLSetAlphaBlending(true,METAL_ZERO,METAL_ONE);
				break;

			case BOTH_WRITE_Z:
				*states[RENDER_TARGET_OPTIONS]=BOTH_WRITE_Z;
                MTLColorMask(false,false,false,false);
				MTLSetAlphaBlending(false,0,0);
				MTLSetZBufferStencil(API3D_ZBUFFER,ON);
				MTLSetZBufferStencil(API3D_STENCIL,ALWAYS);
				if (!StencilBuffer) MTLSetAlphaBlending(true,METAL_ZERO,METAL_ONE);
				break;				
			};
		}
		break;

	case API3D_STENCIL:
		if (StencilBuffer)
		{
			MTLSetZBufferStencil(API3D_STENCIL,Comment);			
		}
		break;

	};

#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	switch (Quoi)
	{
#ifdef VR_SCREENPROJ
	case API3D_VIRTUALSCREEN:
		if (Comment==ON)
		{
			defaultFBO=FramebufferNameSPVR;

            glDisable(GL_SCISSOR_TEST);
            SelectedRenderTarget=PRIMARY;
            *states[RENDER_TARGET]=PRIMARY;

            glBindFramebuffer(GL_FRAMEBUFFER, FramebufferNameSPVR);
            glViewport(0,0,SPVRw,SPVRh);

            float w=(float) SPVRw;
            float h=(float) SPVRh;

            X1base=0;
            Y1base=0;
            X2base=(int)w;
            Y2base=(int)h;

            VIEWPORT.Id();

            VIEWPORT.a[0][0]=(float) (w/2);
            VIEWPORT.a[3][0]=(float) (0+w/2);

            VIEWPORT.a[1][1]=((float) (h/2));
            VIEWPORT.a[3][1]=(float) (0+h/2);

            VIEWPORT.a[2][2]=(float) (1.0f);
            VIEWPORT.a[3][2]=(float) (0.0f);

            setPO(&ProjOrtho,w,h);

			glEnable(GL_DEPTH_TEST);
			glDepthMask(GL_TRUE);
			zb=zbw=1;
		}

		if (Comment==OFF) defaultFBO=defaultFBOPrimary;
		break;
#endif
	case API3D_TEXTUREMIPMAP:
		if (Comment==ENABLE) *states[MIPMAP_ACTIVE]=1;
		if (Comment==DISABLE) *states[MIPMAP_ACTIVE]=0;
		break;

	case API3D_LIGHTMAPLAYERS:
		if (Comment==OFF) *states[LIGHTMAP_LAYERS]=1;
		else 
		{
			if ((Comment>=1)&&(Comment<16)) *states[LIGHTMAP_LAYERS]=Comment;
			else *states[LIGHTMAP_LAYERS]=1;
		}
		break;

	case API3D_MULTILAYEREFFECTS:
		if (Comment==FIT_RENDERER_DIMENSION) *states[LAYER_DIMENSION]=1;
		if (Comment==FULL_RENDERING) *states[LAYER_DIMENSION]=0;
		break;

	case API3D_MISC:
		if (Comment==VBL_SYNCHRO) *states[VERTICAL_RETRACE]=1;
		if (Comment==VBL_NOSYNCHRO) *states[VERTICAL_RETRACE]=0;

		if (Comment==VBL_INTERVAL_TWO) *states[VERTICAL_RETRACE]=2;
		if (Comment==VBL_INTERVAL_THREE) *states[VERTICAL_RETRACE]=3;

		break;

	case API3D_HARDWAREVERTEXPROCESSING:
		if (Comment==ON) *states[HARDWARE_VERTEX_PROCESSING_E]=1;
		if (Comment==OFF) *states[HARDWARE_VERTEX_PROCESSING_E]=0;
		break;

	case API3D_ALPHATEST:
#ifndef API3D_OPENGL20
		if (Comment>255)
		{
			switch (Comment)
			{
			case LESS:
				glEnable(GL_ALPHA_TEST);
				value_alpha=GL_LESS;
				break;
			case GREATER:
				glEnable(GL_ALPHA_TEST);
				value_alpha=GL_GREATER;
				break;
			case ALWAYS:
				glEnable(GL_ALPHA_TEST);
				value_alpha=GL_ALWAYS;
				break;
			case LESSEQUAL:
				glEnable(GL_ALPHA_TEST);
				value_alpha=GL_LEQUAL;
				break;
			case GREATEREQUAL:
				glEnable(GL_ALPHA_TEST);
				value_alpha=GL_GEQUAL;
				break;
			case EQUAL:
				glEnable(GL_ALPHA_TEST);
				value_alpha=GL_EQUAL;
				break;
			case NOTEQUAL:
				glEnable(GL_ALPHA_TEST);
				value_alpha=GL_NOTEQUAL;
				break;
			case NEVER:
				glEnable(GL_ALPHA_TEST);
				value_alpha=GL_NEVER;
				break;
			case ENABLE:
				glEnable(GL_ALPHA_TEST);
				value_alpha=GL_ALWAYS;
				break;
			case DISABLE:
				glDisable(GL_ALPHA_TEST);
				break;
			};

			glAlphaFunc(value_alpha,alpha_value);
		}
		else
		{
			alpha_value=(GLclampf) Comment/255.0f;
			glAlphaFunc(value_alpha,alpha_value);
		}
#else
		if (Comment==ENABLE) set_alphatest=1;
		if (Comment==DISABLE) { set_alphatest=0; val_alphatest=0.0f; }
		if (Comment<=255)
		{
			val_alphatest=((float)Comment)/255.0f;
		}
#endif
		break;

	case API3D_BUMP_SETTEXTURE:
		bumpmap_settexture=Comment;
		break;

	case API3D_SHADOWING:
		if (Comment==DONT_DRAW) *states[SHADOW_BUFFERING]=0;
		if (Comment==DRAW) *states[SHADOW_BUFFERING]=1;
		break;
		
	case API3D_STENCILSHADOWVOLUME:
		if (Comment==REVERSE) *states[ALGO_STENCIL_SHADOWING]=ALGO_REVERSE;
		if (Comment==SIMPLE) *states[ALGO_STENCIL_SHADOWING]=ALGO_SIMPLE;
		if (Comment==ALTERNATIVE)
		{
			*states[ALGO_STENCIL_SHADOWING]=ALGO_ALTERNATIVE;
			G_VertexProgram_ShadowVolume=false;
		}
		if (Comment==ALTERNATIVE_GPU)
		{
			*states[ALGO_STENCIL_SHADOWING]=ALGO_ALTERNATIVE;
			G_VertexProgram_ShadowVolume=true;
		}
		if (Comment==TRIVIAL_ELIMINATION_ON) *states[TRIVIAL_ELIMINATION_STENCIL]=1;
		if (Comment==TRIVIAL_ELIMINATION_OFF) *states[TRIVIAL_ELIMINATION_STENCIL]=0;

		break;

	case API3D_ALPHAMULTIGROUP:
		if (Comment==DONT_DRAW) *states[ALPHA_MULTI_GROUP_DRAW]=0;
		if (Comment==DRAW) *states[ALPHA_MULTI_GROUP_DRAW]=1;
		if (Comment==ONLY) *states[ALPHA_MULTI_GROUP_DRAW]=2;
		break;

	case API3D_ENVMULTIGROUP:
		if (Comment==EXTERN) *states[ENV_SHADERS]=1;
		else *states[ENV_SHADERS]=0;
		break;

	case API3D_ZBIAS:
		if (Comment!=ZBiasComment)
		{
			ZBiasComment=Comment;

			if (Comment!=0)
			{
				glEnable(GL_POLYGON_OFFSET_FILL);
				glPolygonOffset(-0.2f*((GLfloat)Comment),-0.2f*((GLfloat)Comment));
			}
			else 
			{
				glDisable(GL_POLYGON_OFFSET_FILL);
			}
		}
		break;

	case API3D_BLEND:
		{
			if (Comment==BLEND_NO_ALPHA)
			{
				Flush();
				*states[RENDER_BLEND_NO_ALPHA]=((*states[RENDER_BLEND_NO_ALPHA])+1)&1;
			}
			
			if (Comment==OFF)
			{
				if (states(BLENDING)!=0)
				{
					Flush();
					BLEND_GL=0;
					glDisable(GL_BLEND);
					*states[BLENDING]=0;
				}
			}

			if (Comment==ON)
			{
				if (states(BLENDING)!=1)
				{
					Flush();
					BLEND_GL=1;
					glEnable(GL_BLEND);
					glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
					*states[BLENDING]=1;
				}
			}

			if (Comment==BLEND_GOURAUD)
			{
				if (states(BLENDING)!=2)
				{
					Flush();
					BLEND_GL=2;
					glEnable(GL_BLEND);
					glBlendFunc(GL_SRC_ALPHA,GL_ONE);
					*states[BLENDING]=2;
				}
			}

			if (Comment==BLEND_INVERSE)
			{
				if (states(BLENDING)!=3)
				{
					Flush();
					BLEND_GL=8;
					glEnable(GL_BLEND);
					glBlendFunc(GL_ONE_MINUS_SRC_ALPHA,GL_SRC_ALPHA);
					*states[BLENDING]=3;
				}
			}

			if (Comment==BLEND_COLOR)
			{
				if (states(BLENDING)!=4)
				{
					Flush();
					BLEND_GL=4;
					glEnable(GL_BLEND);
					glBlendFunc(GL_DST_COLOR,GL_ZERO);
					*states[BLENDING]=4;
				}
			}
			
			if (Comment==BLEND_ADD)
			{
				if (states(BLENDING)!=5)
				{
					Flush();
					glEnable(GL_BLEND);
					glBlendFunc(GL_ONE,GL_ONE);
					BLEND_GL=5;
					*states[BLENDING]=5;
				}
			}

		}
		break;

	case API3D_SECONDARYSURFACE:
		{
			if (Comment==ON) 
			{
				SecondarySurface=true; 
				nSecondaries=1;
			}
			if (Comment==OFF) SecondarySurface=false;
			if (Comment==SCALE) *states[SCALE_SCREEN]=1;
			if (Comment==NO_SCALE) *states[SCALE_SCREEN]=0;


			switch (Comment)
			{
			case SECONDARY1:
				nSecondaries=1;
				SecondarySurface=true; 
				break;
			case SECONDARY2:
				nSecondaries=2;
				SecondarySurface=true; 
				break;
			case SECONDARY3:
				nSecondaries=3;
				SecondarySurface=true; 
				break;
			case SECONDARY4:
				nSecondaries=4;
				SecondarySurface=true; 
				break;
			case SECONDARY5:
				nSecondaries=5;
				SecondarySurface=true; 
				break;
			case SECONDARY6:
				nSecondaries=6;
				SecondarySurface=true; 
				break;
			case SECONDARY7:
				nSecondaries=7;
				SecondarySurface=true; 
				break;
			case SECONDARY8:
				nSecondaries=8;
				SecondarySurface=true; 
				break;
			case SECONDARY9:
				nSecondaries=9;
				SecondarySurface=true; 
				break;
			case SECONDARY10:
				nSecondaries=10;
				SecondarySurface=true; 
				break;
			case SECONDARY11:
				nSecondaries=11;
				SecondarySurface=true; 
				break;
			case SECONDARY12:
				nSecondaries=12;
				SecondarySurface=true; 
				break;
			case SECONDARY13:
				nSecondaries=13;
				SecondarySurface=true; 
				break;
			case SECONDARY14:
				nSecondaries=14;
				SecondarySurface=true; 
				break;
			case SECONDARY15:
				nSecondaries=15;
				SecondarySurface=true; 
				break;
			case SECONDARY16:
				nSecondaries=16;
				SecondarySurface=true; 
				break;
			case SECONDARY17:
				nSecondaries=17;
				SecondarySurface=true; 
				break;
			case SECONDARY18:
				nSecondaries=18;
				SecondarySurface=true; 
				break;
			case SECONDARY19:
				nSecondaries=19;
				SecondarySurface=true; 
				break;
			case SECONDARY20:
				nSecondaries=20;
				SecondarySurface=true; 
				break;
			case SECONDARY21:
				nSecondaries=21;
				SecondarySurface=true; 
				break;
			case SECONDARY22:
				nSecondaries=22;
				SecondarySurface=true; 
				break;
			case SECONDARY23:
				nSecondaries=23;
				SecondarySurface=true; 
				break;
			case SECONDARY24:
				nSecondaries=24;
				SecondarySurface=true; 
				break;
			};

		}
		break;
		
	case API3D_CREATETEXTURE:
		{

			if (Comment==TEXTURE16BITS) *states[TEXTURES_32BITS]=0;
			if (Comment==TEXTURE32BITS) *states[TEXTURES_32BITS]=1;


			if (Comment==CLAMP)
			{
				*states[TEXTURES_CLAMPING]=1;
			}
			if (Comment==REPEAT)
			{
				*states[TEXTURES_CLAMPING]=0;
			}

			if (Comment==DITHERING)
			{
				*states[TEXTURES_DITHERING]=1;
			}
			if (Comment==NODITHERING)
			{
				*states[TEXTURES_DITHERING]=0;
			}

			if (Comment==MIPMAP)
			{
				*states[TEXTURES_MIPMAP_ACTIVE]=1;
			}

			if (Comment==NO_MIPMAP)
			{
				*states[TEXTURES_MIPMAP_ACTIVE]=0;
			}


		}
		break;

	case API3D_ZBUFFER:
		{
			Flush();
			*states[ZBUFFERING]=Comment;
			switch (Comment)
			{
			case WRITEOFF:
				if (zbw)
				{	
					glDepthMask(GL_FALSE);
					zbw=0;
				}
				break;
			case ALWAYS:
				glDepthFunc(GL_ALWAYS);
				break;

			case LESS:
				glDepthFunc(GL_LESS);
				break;
			case GREATER:
				glDepthFunc(GL_GREATER);
				break;
			case REINIT:
			case LESSEQUAL:
				glDepthFunc(GL_LEQUAL);
				break;
			case GREATEREQUAL:
				glDepthFunc(GL_GEQUAL);
				break;
			case EQUAL:
				glDepthFunc(GL_EQUAL);
				break;
			case NOTEQUAL:
				glDepthFunc(GL_NOTEQUAL);
				break;
			case ON:
			case ENABLE:
				if ((zb==0)||(zbw==0))
				{
					glEnable(GL_DEPTH_TEST);
					glDepthMask(GL_TRUE);
					zb=zbw=1;
				}
				break;
			case OFF:
			case DISABLE:
				if (zb)
				{
					zb=zbw=0;
					glDepthMask(GL_FALSE);
					glDisable(GL_DEPTH_TEST);
				}
				break;
			};
		}
		break;

	case API3D_LIGHTMAPS:
		{
			if (Comment==BACKUP) *states[LIGHTMAP_BACKUPS]=1;
			if (Comment==NO_BACKUP) *states[LIGHTMAP_BACKUPS]=0;
		}

	case API3D_SHADING:
		{
#ifndef API3D_OPENGL20
			if (Comment==ON)
				glShadeModel(GL_SMOOTH);

			if (Comment==OFF)
				glShadeModel(GL_FLAT);
#endif
		}
		break;

	case API3D_SHADERS:
		if (Comment==DYNAMIC_ENV) *states[SHADERS]=1;
		if (Comment==FIXED_ENV) *states[SHADERS]=0;
		break;

	case API3D_CULL:
		{
			Flush();
			switch (Comment)
			{
			case ON:
				glEnable(GL_CULL_FACE);
				*states[CULLING]=-1;
				break;
			case OFF:
				glDisable(GL_CULL_FACE);
				*states[CULLING]=-1;
				break;
			case CW:
				if (states(CULLING)!=0)
				{
					Flush();
					*states[CULLING]=0;
					glFrontFace(GL_CCW);
				}
				break;
			case CCW:
				if (states(CULLING)!=1)
				{
					Flush();
					*states[CULLING]=1;
					glFrontFace(GL_CW);
				}
				break;
			}
		}
		break;

	case API3D_LIGHTING:
		{
			if (Comment==ON)
			{
				Lighting=true;
			}
			else Lighting=false;
		}
		break;

	case API3D_SPECULAR:

		if (Comment==ON)
		{
			Specular=true;
		}
		
		if (Comment==OFF)
		{
			Specular=false;
		}

		if (Comment==ONLY)
		{
			Lighting=Specular=true;
		}

		break;


	case API3D_TEXTURING:
		{

			switch (Comment)
			{
			case ON:
#ifndef GLES20
				if (MultiTexture) glActiveTextureARB(GL_TEXTURE0_ARB);
				glEnable(GL_TEXTURE_2D);
#endif
				break;
			
			case OFF:
#ifndef GLES20						
				if (MultiTexture) glActiveTextureARB(GL_TEXTURE0_ARB);
				glDisable(GL_TEXTURE_2D);
				if (MultiTexture)
				{	
					glActiveTextureARB(GL_TEXTURE1_ARB);
					glDisable(GL_TEXTURE_2D);
#ifndef GLES
					for(int n=2;n<ntmax;n++)
					{
						glActiveTextureARB(GL_TEXTURE0_ARB+n);
						glDisable(GL_TEXTURE_2D);
					}
					ntmax=0;
#endif
				}
#endif
				break;
			case T_MODULATE:
				LevelTexture0=GL_MODULATE;
#ifndef GLES20
				glDisable(GL_BLEND);
				if (MultiTexture) glActiveTextureARB(GL_TEXTURE0_ARB);
				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
#endif
				break;
			case T_ADD:
				LevelTexture0=GL_ADD;
#ifndef GLES20
				glDisable(GL_BLEND);
				if (MultiTexture) glActiveTextureARB(GL_TEXTURE0_ARB);
				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_ADD);
#endif
				break;
			case T_BLEND:
#ifndef GLES20
				glEnable(GL_BLEND);
				if (MultiTexture) glActiveTextureARB(GL_TEXTURE0_ARB);
				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_BLEND);
				glTexEnvfv(GL_TEXTURE_ENV,GL_TEXTURE_ENV_COLOR,RGBA);
#endif
				break;

			}
		}
		break;	

	case API3D_REPLACE_STENCIL:
		if (Comment==ON) *states[REPLACE_ACTIVE]=1;
		if (Comment==OFF) *states[REPLACE_ACTIVE]=0;
		break;

	case API3D_TEXTURING2:
		{

			switch (Comment)
			{
			case ON:
#ifndef GLES20
				if (MultiTexture) glActiveTextureARB(GL_TEXTURE1_ARB);
				glEnable(GL_TEXTURE_2D);
#endif
				break;
			
			case OFF:
#ifndef GLES20
				if (MultiTexture) glActiveTextureARB(GL_TEXTURE1_ARB);
				glDisable(GL_TEXTURE_2D);
#endif
				break;
			case T_MODULATE:
				LevelTexture1=GL_MODULATE;
#ifndef GLES20
				glDisable(GL_BLEND);
				if (MultiTexture) glActiveTextureARB(GL_TEXTURE1_ARB);
				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
#endif
				break;
			case T_ADD:
				LevelTexture1=GL_ADD;
#ifndef GLES20
				glDisable(GL_BLEND);
				if (MultiTexture) glActiveTextureARB(GL_TEXTURE1_ARB);
				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_ADD);
#endif
				break;

			}
		}
		break;	

	case API3D_RENDERTARGET:
		{
			Flush();
			//glFlush();

#if defined(GOOGLEVR)||defined(API3D_VR)
            if (catseyes)
            {
                if (Comment==PRIMARY)
                {
#if defined(GOOGLEVR)
                    glEnable(GL_SCISSOR_TEST);
#endif
                    *states[RENDER_TARGET]=Comment;

                    if (SelectedRenderTarget>=0)
                    {
                        glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO);
                        glViewport(viewportVR[0],viewportVR[1],viewportVR[2],viewportVR[3]);
                    }

                    X1base=0;
                    Y1base=0;
                    X2base=viewportVR[2];
                    Y2base=viewportVR[3];

                    SelectedRenderTarget=-1;

                    float w=(float)viewportVR[2];
                    float h=(float)viewportVR[3];

                    ProjOrtho.a[0][0] = 2.0f/w;
                    ProjOrtho.a[1][0] = 0.0f;
                    ProjOrtho.a[2][0] = 0.0f;
                    ProjOrtho.a[3][0] = 0.0f;

                    ProjOrtho.a[0][1] = 0.0f;

                    ProjOrtho.a[1][1] = -2.0f/h;

                    ProjOrtho.a[2][1] = 0.0f;
                    ProjOrtho.a[3][1] = 0.0f;

                    ProjOrtho.a[0][2] = 0.0f;
                    ProjOrtho.a[1][2] = 0.0f;
                    ProjOrtho.a[2][2] = 2.0f;
                    ProjOrtho.a[3][2] = -1.0f;

                    ProjOrtho.a[0][3] = 0.0f;
                    ProjOrtho.a[1][3] = 0.0f;
                    ProjOrtho.a[2][3] = 0.0f;
                    ProjOrtho.a[3][3] = 1.0f;

                    VIEWPORT.Id();

                    VIEWPORT.a[0][0]=(float) (w/2);
                    VIEWPORT.a[3][0]=(float) (0+w/2);

                    VIEWPORT.a[1][1]=((float) (h/2));
                    VIEWPORT.a[3][1]=(float) (0+h/2);

                    VIEWPORT.a[2][2]=(float) (1.0f);
                    VIEWPORT.a[3][2]=(float) (0.0f);

					glEnable(GL_DEPTH_TEST);
					glDepthMask(GL_TRUE);
					zb=zbw=1;

                    return;
                }

                if ((Comment>=SECONDARY1)&&(Comment<=SECONDARY24))
                {
                    glDisable(GL_SCISSOR_TEST);
                    SelectedRenderTarget=Comment - SECONDARY1;
                    *states[RENDER_TARGET]=Comment;
                    glBindFramebuffer(GL_FRAMEBUFFER, FramebufferName[SelectedRenderTarget]);
                    glViewport(0,0,tile_secondarysurfacesW[SelectedRenderTarget],tile_secondarysurfacesH[SelectedRenderTarget]);

                    float w=(float) tile_secondarysurfacesW[SelectedRenderTarget];
                    float h=(float) tile_secondarysurfacesH[SelectedRenderTarget];

                    X1base=0;
                    Y1base=0;
                    X2base=(int)w;
                    Y2base=(int)h;

                    VIEWPORT.Id();

                    VIEWPORT.a[0][0]=(float) (w/2);
                    VIEWPORT.a[3][0]=(float) (0+w/2);

                    VIEWPORT.a[1][1]=((float) (h/2));
                    VIEWPORT.a[3][1]=(float) (0+h/2);

                    VIEWPORT.a[2][2]=(float) (1.0f);
                    VIEWPORT.a[3][2]=(float) (0.0f);

                    setPO(&ProjOrtho,w,h);

					glEnable(GL_DEPTH_TEST);
					glDepthMask(GL_TRUE);
					zb=zbw=1;

                    return;
                }
            }
#else
// ! GOOGLEVR
			if (Comment==PRIMARY)
			{
				*states[RENDER_TARGET]=Comment;
#ifdef OPENGL_PBUFFERS
				if ((aT<0)&&(SelectedRenderTarget==-(aT+1))) pbufferRelease(-(aT+1));
#endif
				if (SelectedRenderTarget>=0)
				{
#ifdef OPENGL_PBUFFERS
					if (SecondarySurface)
					{
						pbufferDisable(SelectedRenderTarget);
					}
#endif

#ifdef OPENGL_FRAMEBUFFERS
					if (SecondarySurface)
					{
#if defined(IOS)||defined(GOOGLEVR)||defined(API3D_VR)||defined(WEBASM)
                        glBindFramebuffer(GL_FRAMEBUFFER, defaultFBO);
#else
                        glBindFramebuffer(GL_FRAMEBUFFER, 0);
#endif
						glViewport(0,0,SCREEN_X,SCREEN_Y);
                        glScissor(0,0,SCREEN_X,SCREEN_Y);
					}
#endif
					SelectedRenderTarget=-1;

					float w=(float)SCREEN_X;
					float h=(float)SCREEN_Y;

					//TODO
					VIEWPORT.Id();

					VIEWPORT.a[0][0]=(float) (w/2);
					VIEWPORT.a[3][0]=(float) (0+w/2);

					VIEWPORT.a[1][1]=((float) (h/2));
					VIEWPORT.a[3][1]=(float) (0+h/2);

					VIEWPORT.a[2][2]=(float) (1.0f);
					VIEWPORT.a[3][2]=(float) (0.0f);

#if defined(API3D_OPENGL20)
					setPO(&ProjOrtho,w,h);
#endif
				}
				else 
				{
					glViewport(0,0,SCREEN_X,SCREEN_Y);
                    glScissor(0,0,SCREEN_X,SCREEN_Y);
				
					SelectedRenderTarget=-1;
				
					float w=(float)SCREEN_X;
					float h=(float)SCREEN_Y;
								
					VIEWPORT.Id();
				
					VIEWPORT.a[0][0]=(float) (w/2);
					VIEWPORT.a[3][0]=(float) (0+w/2);
				
					VIEWPORT.a[1][1]=((float) (h/2));
					VIEWPORT.a[3][1]=(float) (0+h/2);
				
					VIEWPORT.a[2][2]=(float) (1.0f);
					VIEWPORT.a[3][2]=(float) (0.0f);

#if defined(API3D_OPENGL20)
					setPO(&ProjOrtho,w,h);
#endif
				}

				glEnable(GL_DEPTH_TEST);
				glDepthMask(GL_TRUE);
				zb=zbw=1;
			}

			if ((Comment>=SECONDARY1)&&(Comment<=SECONDARY24))
			{
				*states[RENDER_TARGET]=Comment;
#ifdef OPENGL_PBUFFERS
				if ((aT<0)&&(SelectedRenderTarget==-(aT+1))) pbufferRelease(-(aT+1));
				
				if ((SelectedRenderTarget>=0)&&(SecondarySurface)) 
				{
					pbufferDisable(SelectedRenderTarget);
				}
#endif
				SelectedRenderTarget=Comment - SECONDARY1;

#ifdef OPENGL_PBUFFERS
				if (SecondarySurface)
				{
					pbufferEnable(SelectedRenderTarget);
				}
#endif

#ifdef OPENGL_FRAMEBUFFERS
				if (SecondarySurface)
				{
					glBindFramebuffer(GL_FRAMEBUFFER, FramebufferName[SelectedRenderTarget]);
					glViewport(0,0,tile_secondarysurfacesW[SelectedRenderTarget],tile_secondarysurfacesH[SelectedRenderTarget]);
				}
#endif
                glDisable(GL_SCISSOR_TEST);

				float w=(float) tile_secondarysurfacesW[SelectedRenderTarget];
				float h=(float) tile_secondarysurfacesH[SelectedRenderTarget];

				VIEWPORT.Id();

				VIEWPORT.a[0][0]=(float) (w/2);
				VIEWPORT.a[3][0]=(float) (0+w/2);

				VIEWPORT.a[1][1]=((float) (h/2));
				VIEWPORT.a[3][1]=(float) (0+h/2);

				VIEWPORT.a[2][2]=(float) (1.0f);
				VIEWPORT.a[3][2]=(float) (0.0f);

#if defined(API3D_OPENGL20)
				setPO(&ProjOrtho,w,h);
#endif
				glEnable(GL_DEPTH_TEST);
				glDepthMask(GL_TRUE);
				zb=zbw=1;
			}
#endif

			switch(Comment)
			{
			case STENCIL_NO_ZTEST:
		
				if (StencilBuffer)
				{
				*states[RENDER_TARGET_OPTIONS]=STENCIL_NO_ZTEST;

				glDepthMask(GL_FALSE);
				glColorMask(GL_FALSE,GL_FALSE,GL_FALSE,GL_FALSE);
				glEnable(GL_STENCIL_TEST);
#ifndef GLES20
				glShadeModel(GL_FLAT);
#endif
				*states[ZBUFFER_TEST_STENCIL]=1;
				glStencilOp(GL_KEEP,GL_REPLACE,GL_REPLACE);
				glStencilFunc(GL_ALWAYS,1,1);
				}
				break;

			case STENCIL:
		
				if (StencilBuffer)
				{
					*states[RENDER_TARGET_OPTIONS]=STENCIL;
					glStencilMask(0xffffffff);
					glEnable(GL_DEPTH_TEST);
					glColorMask(GL_FALSE,GL_FALSE,GL_FALSE,GL_FALSE);
					glDepthMask(GL_FALSE);
					glEnable(GL_STENCIL_TEST);
#ifndef GLES20
					glShadeModel(GL_FLAT);
#endif
					*states[ZBUFFER_TEST_STENCIL]=0;
					glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
					glStencilFunc(GL_ALWAYS,1,0xffffffff);
				}
				break;

			case ZBUFFER:
				*states[RENDER_TARGET_OPTIONS]=ZBUFFER;
				glColorMask(GL_FALSE,GL_FALSE,GL_FALSE,GL_FALSE);
				glEnable(GL_DEPTH_TEST);
				glDepthMask(GL_TRUE);
				if (StencilBuffer) glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);
				break;
		
			case RENDER:

				BLEND_GL=0;
				glDisable(GL_BLEND);
				*states[BLENDING]=0;

				*states[RENDER_TARGET_OPTIONS]=RENDER;
				glStencilFunc(GL_ALWAYS,1,0xffffffff);

				glColorMask(GL_TRUE,GL_TRUE,GL_TRUE,GL_TRUE);
				glDisable(GL_STENCIL_TEST);
#ifndef GLES20
				glShadeModel(GL_SMOOTH);
#endif
				glEnable(GL_DEPTH_TEST);
				if (StencilBuffer) glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);
				glDepthMask(GL_TRUE);				
				break;

			case BOTH:
				*states[RENDER_TARGET_OPTIONS]=BOTH;
				if (StencilBuffer)
				{
					glColorMask(GL_TRUE,GL_TRUE,GL_TRUE,GL_TRUE);					
					glEnable(GL_STENCIL_TEST);
#ifndef GLES20
					glShadeModel(GL_SMOOTH);
#endif
					glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);					
					glEnable(GL_DEPTH_TEST);
					glDepthMask(GL_FALSE);
				}
				else
				{
					glColorMask(GL_FALSE,GL_FALSE,GL_FALSE,GL_FALSE);
				}
				break;

			case BOTH_WRITE_Z:
				*states[RENDER_TARGET_OPTIONS]=BOTH_WRITE_Z;
				if (StencilBuffer)
				{
					glColorMask(GL_TRUE,GL_TRUE,GL_TRUE,GL_TRUE);
					glEnable(GL_STENCIL_TEST);
#ifndef GLES20
					glShadeModel(GL_SMOOTH);
#endif
					glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
					glEnable(GL_DEPTH_TEST);
					glDepthMask(GL_TRUE);
				}
				else
				{
					glColorMask(GL_FALSE,GL_FALSE,GL_FALSE,GL_FALSE);
				}
				break;				
			};
		}
		break;

	case API3D_STENCIL:
		if (StencilBuffer)
		{
			if ((Comment>=STENCIL_SET)&&(Comment<=STENCIL_EQUAL))
			{
				glEnable(GL_STENCIL_TEST);
				glStencilFunc(GL_ALWAYS,Comment-STENCIL_SET,0xffffffff);
				
				if (*states[ZBUFFER_TEST_STENCIL]==0)
					glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
				else
					glStencilOp(GL_KEEP,GL_REPLACE,GL_REPLACE);
			}
			else
			if (Comment>=STENCIL_EQUAL)
			{
				glEnable(GL_STENCIL_TEST);
				glStencilFunc(GL_EQUAL,Comment-STENCIL_EQUAL,0xffffffff);
			}
			else
			{

				switch (Comment)
				{
				case EQUAL_ONE:
					glEnable(GL_STENCIL_TEST);
					glStencilFunc(GL_EQUAL,1,0xffffffff);
					break;
				case ALWAYS:
					glDisable(GL_STENCIL_TEST);
					glStencilFunc(GL_ALWAYS,1,0xffffffff);
					break;
				case NOT_ONE:
					glEnable(GL_STENCIL_TEST);
					glStencilFunc(GL_NOTEQUAL,1,0xffffffff);
					break;

				case NOT_ZERO:
					glEnable(GL_STENCIL_TEST);
					glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);
					glStencilFunc(GL_NOTEQUAL,0,0xffffffff);
					break;

				case NOT_ZERO_REPLACE:
					glEnable(GL_STENCIL_TEST);
					glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
					glStencilFunc(GL_NOTEQUAL,0,0xffffffff);
					break;

				case LESSEQUAL_ONE:
					glEnable(GL_STENCIL_TEST);
					glStencilFunc(GL_LEQUAL,1,0xffffffff);
					break;
				case GREATEREQUAL_ONE:
					glEnable(GL_STENCIL_TEST);
					glStencilFunc(GL_GEQUAL,1,0xffffffff);
					break;
				case EQUAL_ZERO:
					glEnable(GL_STENCIL_TEST);
					glStencilFunc(GL_EQUAL,0,0xffffffff);
					break;

				case EQUAL_ZERO_REPLACE:
					glEnable(GL_STENCIL_TEST);
					glStencilFunc(GL_EQUAL,0,0xffffffff);
					glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
					break;

				case INCREMENT:
					glEnable(GL_STENCIL_TEST);
#ifndef GLES
					glStencilFunc(GL_ALWAYS,1,0xffffffff);
					if (*states[ZBUFFER_TEST_STENCIL]==0)
						glStencilOp(GL_KEEP,GL_KEEP,GL_INCR_WRAP);
					else
						glStencilOp(GL_KEEP,GL_REPLACE,GL_INCR_WRAP);

					break;
#endif
				case INCREMENTSAT:
					glEnable(GL_STENCIL_TEST);
					glStencilFunc(GL_ALWAYS,1,0xffffffff);
					
					if (*states[ZBUFFER_TEST_STENCIL]==0)
						glStencilOp(GL_KEEP,GL_KEEP,GL_INCR);
					else
						glStencilOp(GL_KEEP,GL_REPLACE,GL_INCR);
					break;

				case SET_ONE:
					glEnable(GL_STENCIL_TEST);
					glStencilFunc(GL_ALWAYS,1,1);
					
					if (*states[ZBUFFER_TEST_STENCIL]==0)
						glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
					else
						glStencilOp(GL_KEEP,GL_REPLACE,GL_REPLACE);
			
					break;

				case SET_ZERO:
					glEnable(GL_STENCIL_TEST);
					glStencilFunc(GL_ALWAYS,1,1); //TODO
					
					if (*states[ZBUFFER_TEST_STENCIL]==0)
						glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
					else
						glStencilOp(GL_KEEP,GL_REPLACE,GL_REPLACE);
			
					break;

				case DECREMENT:
					glEnable(GL_STENCIL_TEST);
#ifndef GLES
					glStencilFunc(GL_ALWAYS,1,0xffffffff);
					if (*states[ZBUFFER_TEST_STENCIL]==0)
						glStencilOp(GL_KEEP,GL_KEEP,GL_DECR_WRAP);
					else
						glStencilOp(GL_KEEP,GL_REPLACE,GL_DECR_WRAP);
					break;
#endif
				case DECREMENTSAT:
					glEnable(GL_STENCIL_TEST);
					glStencilFunc(GL_ALWAYS,1,0xffffffff);
					if (*states[ZBUFFER_TEST_STENCIL]==0)
						glStencilOp(GL_KEEP,GL_KEEP,GL_DECR);
					else
						glStencilOp(GL_KEEP,GL_REPLACE,GL_DECR);
			
					break;
				};
			}
		}
		break;

	};

#endif

#ifdef API3D_DIRECT3D12

    float depth=0.0f;
    float slope=0.0f;

//------------------------------------------------------------------------------------------------ DIRECT3D ----------

    int ns;

    int basic=Comment&1023;
    int enhanced=Comment-basic;

    switch (Quoi)
    {

    case API3D_TEXTUREMIPMAP:
        if (Comment==ENABLE) *states[MIPMAP_ACTIVE]=1;
        if (Comment==DISABLE) *states[MIPMAP_ACTIVE]=0;
        break;

    case API3D_LIGHTMAPLAYERS:
        if (Comment==OFF) *states[LIGHTMAP_LAYERS]=1;
        else
        {
            if ((Comment>=1)&&(Comment<16)) *states[LIGHTMAP_LAYERS]=Comment;
            else *states[LIGHTMAP_LAYERS]=1;
        }
        break;

    case API3D_MULTILAYEREFFECTS:
        if (Comment==FIT_RENDERER_DIMENSION) *states[LAYER_DIMENSION]=1;
        if (Comment==FULL_RENDERING) *states[LAYER_DIMENSION]=0;
        break;

    case API3D_CLIPPING:
            break;

    case API3D_MISC:
        if (Comment==VBL_SYNCHRO) *states[VERTICAL_RETRACE]=1;
        if (Comment==VBL_NOSYNCHRO) *states[VERTICAL_RETRACE]=0;
        if (Comment==VBL_INTERVAL_TWO) *states[VERTICAL_RETRACE]=2;
        if (Comment==VBL_INTERVAL_THREE) *states[VERTICAL_RETRACE]=3;
        break;

    case API3D_ANTIALIASING:
        break;

    case API3D_LIGHTMAPS:
        {
            if (Comment==BACKUP) *states[LIGHTMAP_BACKUPS]=1;
            if (Comment==NO_BACKUP) *states[LIGHTMAP_BACKUPS]=0;
        }

    case API3D_MULTIQUADS:
        if (Comment==TOGGLE) Flush();
        break;

    case API3D_BUMP_DISPLACE_SETTEXTURE:
        bump_displace=Comment;
        break;

    case API3D_HORIZON_MAPS_SETTEXTURE:
        bump_horizon=Comment;
        break;

    case API3D_STENCILSHADOWVOLUME:
        if (Comment==REVERSE) *states[ALGO_STENCIL_SHADOWING]=1;
        if (Comment==SIMPLE) *states[ALGO_STENCIL_SHADOWING]=2;
        if (Comment==ALTERNATIVE) *states[ALGO_STENCIL_SHADOWING]=0;
        if (Comment==TRIVIAL_ELIMINATION_ON) *states[TRIVIAL_ELIMINATION_STENCIL]=1;
        if (Comment==TRIVIAL_ELIMINATION_OFF) *states[TRIVIAL_ELIMINATION_STENCIL]=0;
        break;

    case API3D_HARDWAREVERTEXPROCESSING:
        if (Comment==ON) *states[HARDWARE_VERTEX_PROCESSING_E]=1;
        if (Comment==OFF) *states[HARDWARE_VERTEX_PROCESSING_E]=0;
        break;

    case API3D_ALPHATEST:
        dirtyCRCState=true;
        if (Comment==ENABLE) set_alphatest=1;
        if (Comment==DISABLE) { set_alphatest=0; val_alphatest=0.0f; }

        if (Comment<=255)
        {
            val_alphatest=((float)Comment)/255.0f;
        }
        break;
                
    case API3D_BUMP_SETTEXTURE:
        bumpmap_settexture=Comment;
        break;
        
    case API3D_ALPHAMULTIGROUP:
        if (Comment==DONT_DRAW) *states[ALPHA_MULTI_GROUP_DRAW]=0;
        if (Comment==DRAW) *states[ALPHA_MULTI_GROUP_DRAW]=1;
        if (Comment==ONLY) *states[ALPHA_MULTI_GROUP_DRAW]=2;
        break;

    case API3D_SHADOWING:
        if (Comment==DONT_DRAW) *states[SHADOW_BUFFERING]=0;
        if (Comment==DRAW) *states[SHADOW_BUFFERING]=1;
        break;

    case API3D_ENVMULTIGROUP:
        if (Comment==EXTERN) *states[ENV_SHADERS]=1;
        else *states[ENV_SHADERS]=0;
        break;

    case API3D_BUMPMAPPINGSH:

        if (basic==ANIMATED) *states[SPECIAL_ANIMATED]=1;
        else
        if (basic==STATIC_LIGHTING) *states[SPECIAL_ANIMATED]=0;
        else
        if (basic==FASTDRAW) *states[SPECIAL_FASTDRAW]=1;
        else
        if (basic==DIRTYDRAW) *states[SPECIAL_FASTDRAW]=2;
        else
        if (basic==FULLDRAW) *states[SPECIAL_FASTDRAW]=0;
        else
        {
            if (enhanced==SH_BUMPY+SH_DISPLACE+SH_SELFSHADOWED+SH_CARTOON) { *states[SPECIAL_ENHANCED]=0; *states[SPECIAL_FASTDRAW]=0; }
            if (enhanced==SH_BUMPY+SH_DISPLACE+SH_SELFSHADOWED) { *states[SPECIAL_ENHANCED]=0; *states[SPECIAL_FASTDRAW]=0; }
            if (enhanced==SH_BUMPY+SH_DISPLACE) { *states[SPECIAL_ENHANCED]=2; *states[SPECIAL_FASTDRAW]=0; }
            if (enhanced==SH_BUMPY) *states[SPECIAL_ENHANCED]=3;
            if (enhanced&SH_NORMAL) *states[SPECIAL_ENHANCED]=3;
        }

        BumpMappingStates();

        break;

    case API3D_TEXTUREFILTERS:
        break;


    case API3D_DITHERING:
        {
        }
        break;

    case API3D_ZBIAS:
        {
            if (Comment==0) slope=0.0f;
            else slope=(float) Comment;
            
            if (Comment!=ZBiasComment)
            {
                dirtyCRCState=true;
                
                ZBiasComment=Comment;

				prevEffect=NULL;
                
                rasterDesc.DepthBias = 0;
                rasterDesc.DepthBiasClamp = 0.0f;
                rasterDesc.SlopeScaledDepthBias = -slope*0.3f;
            }
        }
        break;

    case API3D_SPECULAR:
        {
            if (Comment==ON) Specular=true;
            else Specular=false;
        }
        break;

    case API3D_LIGHTING:
        {
            Flush();
            if (Comment==ON) Lighting=true;
            if (Comment==OFF) Lighting=false;
        }
        break;

    case API3D_REPLACE_STENCIL:
        if (Comment==ON) *states[REPLACE_ACTIVE]=1;
        if (Comment==OFF) *states[REPLACE_ACTIVE]=0;
        break;

    case API3D_RENDERTARGET:
    {
        Flush();
        dirtyCRCState=true;
        
        if ((Comment==PRIMARY))
        {
            *states[RENDER_TARGET]=Comment;

            MatrixOrthoLHS( &ProjOrtho, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );

			prevEffect=NULL;
			previouspipe=NULL;

            if (SelectedRenderTarget!=PRIMARY)
			{			
				if (commandList) CloseAndExecuteCommandList(commandList);
				commandList=NULL;

				if (SelectedRenderTarget==SECONDARY) ns=0;
				else ns=SelectedRenderTarget-SECONDARY1;

				SelectedRenderTarget=PRIMARY;
                rtvSurface=rtv_rendertargets[frameIndex];
                dsvDepthStencil=dsv_depthstencil[frameIndex];
            }

            rtvSurface=rtv_rendertargets[frameIndex];
            dsvDepthStencil=dsv_depthstencil[frameIndex];
			resTarget=renderTargets[frameIndex];
			resDepth=depthstencil[frameIndex];

            ViewportActual=Viewport;
            ScissorRectActual=ScissorRect;

            VIEWPORT.Id();
            VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
            VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);
            VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
            VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);
            VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
            VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);
        }
        else
        if (((Comment>=SECONDARY1)&&(Comment<=SECONDARY24))||(Comment==SECONDARY))
        {
            *states[RENDER_TARGET]=Comment;

            if (Comment==SECONDARY) ns=0;
            else ns=Comment-SECONDARY1;

			prevEffect=NULL;
			previouspipe=NULL;

			if (commandList) CloseAndExecuteCommandList(commandList);
			commandList=NULL;

            SelectedRenderTarget=Comment;

            rtvSurface=renderSndTargetView[ns];
            dsvDepthStencil=renderDepthStencilView[ns];

			ViewportActual=SndViewport[ns];
            ScissorRectActual=SndScissorRect[ns];

			resTarget=renderTargetTexture[ns];
			resDepth=renderDepthStencilBuffer[ns];
            
            VIEWPORT.Id();
            VIEWPORT.a[0][0]=(float) (SndViewport[ns].Width/2);
            VIEWPORT.a[3][0]=(float) (SndViewport[ns].TopLeftX+SndViewport[ns].Width/2);
            VIEWPORT.a[1][1]=((float) (SndViewport[ns].Height/2));
            VIEWPORT.a[3][1]=(float) (SndViewport[ns].TopLeftY+SndViewport[ns].Height/2);
            VIEWPORT.a[2][2]=(float) (SndViewport[ns].MaxDepth-SndViewport[ns].MinDepth);
            VIEWPORT.a[3][2]=(float) (SndViewport[ns].MinDepth);

            MatrixOrthoLHS( &ProjOrtho, (float)SndViewport[ns].Width, (float)SndViewport[ns].Height, 0.0f, 1.0f );
        }

        switch(Comment)
        {
        case STENCIL:
            if (StencilBuffer)
            {
                *states[RENDER_TARGET_OPTIONS]=STENCIL;
                *states[ZBUFFER_TEST_STENCIL]=0;

                blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_ZERO;
                blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ONE;
                blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
                blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
                blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_ZERO;
                blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ONE;

                depthStencilDesc.DepthEnable = true;
                depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
                depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;

                depthStencilDesc.StencilEnable = true;
                depthStencilDesc.StencilReadMask = 0xFF;
                depthStencilDesc.StencilWriteMask = 0xFF;

                depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

                depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

				prevEffect=NULL;
            }
            break;

        case STENCIL_NO_ZTEST:
            if (StencilBuffer)
            {
                *states[RENDER_TARGET_OPTIONS]=STENCIL_NO_ZTEST;
                *states[ZBUFFER_TEST_STENCIL]=1;

                blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_ZERO;
                blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ONE;
                blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
                blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
                blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_ZERO;
                blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ONE;

                depthStencilDesc.DepthEnable = false;
                depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
                depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;

                depthStencilDesc.StencilEnable = true;
                depthStencilDesc.StencilReadMask = 0xFF;
                depthStencilDesc.StencilWriteMask = 0xFF;

                depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_REPLACE;
                depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

                depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

				prevEffect=NULL;
            }
            break;

        case ZBUFFER:
            *states[RENDER_TARGET_OPTIONS]=ZBUFFER;

            blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_ZERO;
            blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ONE;
            blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
            blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_ZERO;
            blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ONE;
            blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;

			prevEffect=NULL;
            break;

        case RENDER:
            *states[RENDER_TARGET_OPTIONS]=RENDER;
                
            blendStateDesc.RenderTarget[0].BlendEnable=false;

            *states[BLENDING]=0;

            depthStencilDesc.DepthEnable = true;
            depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
            depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;

            depthStencilDesc.StencilEnable = false;
            depthStencilDesc.StencilReadMask = 0xFF;
            depthStencilDesc.StencilWriteMask = 0xFF;

            depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
            depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
            depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
            depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

            depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
            depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
            depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
            depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

			prevEffect=NULL;
            break;

        case BOTH:
            *states[RENDER_TARGET_OPTIONS]=BOTH;
            if (StencilBuffer)
            {
                blendStateDesc.RenderTarget[0].BlendEnable=false;

                depthStencilDesc.DepthEnable = true;
                depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
                depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;

                depthStencilDesc.StencilEnable = true;
                depthStencilDesc.StencilReadMask = 0xFF;
                depthStencilDesc.StencilWriteMask = 0xFF;

                depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

                depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

				prevEffect=NULL;
            }
            break;

        case BOTH_WRITE_Z:
            *states[RENDER_TARGET_OPTIONS]=BOTH_WRITE_Z;
            if (StencilBuffer)
            {
                blendStateDesc.RenderTarget[0].BlendEnable=false;

                depthStencilDesc.DepthEnable = true;
                depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
                //depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;

                depthStencilDesc.StencilEnable = true;
                depthStencilDesc.StencilReadMask = 0xFF;
                depthStencilDesc.StencilWriteMask = 0xFF;

                depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

                depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

				prevEffect=NULL;
            }
            break;
        };

    }

    break;
            
    case API3D_STENCIL:
        if (StencilBuffer)
        {
            Flush();
            dirtyCRCState=true;

			if (!depthStencilDesc.StencilEnable) prevEffect=NULL;

            if ((Comment>=STENCIL_SET)&&(Comment<=STENCIL_EQUAL))
            {
                StencilREF=Comment-STENCIL_SET;

                depthStencilDesc.StencilEnable = true;
                depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_REPLACE;
                depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;
            }
            else
            if (Comment>=STENCIL_EQUAL)
            {
                StencilREF=Comment-STENCIL_EQUAL;
                depthStencilDesc.StencilEnable = true;
                depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_REPLACE;
                depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_EQUAL;
            }
            else
            {
                switch (Comment)
                {
                case EQUAL_ONE:
                    StencilREF=0x1;
                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_EQUAL;

                    depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_EQUAL;
                    break;

                case ALWAYS:
                    StencilREF=0x1;
                    depthStencilDesc.StencilEnable = false;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

                    depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;
                    break;

                case NOT_ONE:
                    StencilREF=0x1;
                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_NOT_EQUAL;

                    depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_NOT_EQUAL;
                    break;

                case NOT_ZERO:
                    StencilREF=0x0;
                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_NOT_EQUAL;

                    depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_NOT_EQUAL;
                    break;

                case NOT_ZERO_REPLACE:
                    StencilREF=0x0;
                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_REPLACE;
                    depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_NOT_EQUAL;

                    depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_REPLACE;
                    depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_NOT_EQUAL;
                    break;

                case LESSEQUAL_ONE:
                    StencilREF=0x1;
                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;

                    depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
                    break;

                case GREATEREQUAL_ONE:
                    StencilREF=0x1;
                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_GREATER_EQUAL;

                    depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_GREATER_EQUAL;
                    break;

                case EQUAL_ZERO:
                    StencilREF=0x0;
                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_EQUAL;

                    depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_EQUAL;
                    break;

                case EQUAL_ZERO_REPLACE:
                    StencilREF=0x0;
                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_REPLACE;
                    depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_EQUAL;

                    depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_REPLACE;
                    depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_EQUAL;
                    break;

                case INCREMENT:
                    StencilREF=0x1;
                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    if (states(ZBUFFER_TEST_STENCIL)==1) depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_INCR;
                    else depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_INCR;
                    break;

                case INCREMENTSAT:
                    StencilREF=0x1;
                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    if (states(ZBUFFER_TEST_STENCIL)==1) depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_INCR_SAT;
                    else depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_INCR_SAT;
                    break;

                case SET_ONE:
                    StencilREF=0x1;

                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_REPLACE;
                    depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

                    depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_REPLACE;
                    depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;
                    break;

                case SET_ZERO:
                    StencilREF=0x0;
                    depthStencilDesc.StencilEnable = true;

                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_REPLACE;
                    depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

                    depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_REPLACE;
                    depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;
                    break;

                case DECREMENT:
                    StencilREF=0x1;
                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    if (states(ZBUFFER_TEST_STENCIL)==1) depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_DECR;
                    else depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_DECR;
                    break;

                case DECREMENTSAT:
                    StencilREF=0x1;
                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                    if (states(ZBUFFER_TEST_STENCIL)==1) depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_DECR_SAT;
                    else depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_DECR_SAT;
                    break;

                case INVERT:
                    StencilREF=0x0;
                    depthStencilDesc.StencilEnable = true;
                    depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_INCR;
                    depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_INCR;
                    depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_ZERO;
                    depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_NOT_EQUAL;

                    depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_INCR;
                    depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_INCR;
                    depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_ZERO;
                    depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_NOT_EQUAL;
                    break;
                };
            }
        }
        break;

    case API3D_SECONDARYSURFACE:
        {
            if (Comment==ON)
            {
                SecondarySurface=true;
                nSecondaries=1;
            }
            if (Comment==OFF) SecondarySurface=false;
            if (Comment==SCALE) *states[SCALE_SCREEN]=1;
            if (Comment==NO_SCALE) *states[SCALE_SCREEN]=0;

            switch (Comment)
            {
            case SECONDARY1:
                nSecondaries=1;
                SecondarySurface=true;
                break;
            case SECONDARY2:
                nSecondaries=2;
                SecondarySurface=true;
                break;
            case SECONDARY3:
                nSecondaries=3;
                SecondarySurface=true;
                break;
            case SECONDARY4:
                nSecondaries=4;
                SecondarySurface=true;
                break;
            case SECONDARY5:
                nSecondaries=5;
                SecondarySurface=true;
                break;
            case SECONDARY6:
                nSecondaries=6;
                SecondarySurface=true;
                break;
            case SECONDARY7:
                nSecondaries=7;
                SecondarySurface=true;
                break;
            case SECONDARY8:
                nSecondaries=8;
                SecondarySurface=true;
                break;
            case SECONDARY9:
                nSecondaries=9;
                SecondarySurface=true;
                break;
            case SECONDARY10:
                nSecondaries=10;
                SecondarySurface=true;
                break;
            case SECONDARY11:
                nSecondaries=11;
                SecondarySurface=true;
                break;
            case SECONDARY12:
                nSecondaries=12;
                SecondarySurface=true;
                break;
            case SECONDARY13:
                nSecondaries=13;
                SecondarySurface=true;
                break;
            case SECONDARY14:
                nSecondaries=14;
                SecondarySurface=true;
                break;
            case SECONDARY15:
                nSecondaries=15;
                SecondarySurface=true;
                break;
            case SECONDARY16:
                nSecondaries=16;
                SecondarySurface=true;
                break;
            case SECONDARY17:
                nSecondaries=17;
                SecondarySurface=true;
                break;
            case SECONDARY18:
                nSecondaries=18;
                SecondarySurface=true;
                break;
            case SECONDARY19:
                nSecondaries=19;
                SecondarySurface=true;
                break;
            case SECONDARY20:
                nSecondaries=20;
                SecondarySurface=true;
                break;
            case SECONDARY21:
                nSecondaries=21;
                SecondarySurface=true;
                break;
            case SECONDARY22:
                nSecondaries=22;
                SecondarySurface=true;
                break;
            case SECONDARY23:
                nSecondaries=23;
                SecondarySurface=true;
                break;
            case SECONDARY24:
                nSecondaries=24;
                SecondarySurface=true;
                break;
            };

        }
        break;

        case API3D_BLEND:
        {
			prevEffect=NULL;

            switch (Comment)
            {

            case BLEND_NO_ALPHA:
                Flush();
                *states[RENDER_BLEND_NO_ALPHA]=((*states[RENDER_BLEND_NO_ALPHA])+1)&1;
                dirtyCRCState=true;
                break;
                    
            case OFF:
                if (states(BLENDING)!=0)
                {
                    Flush();
                    dirtyCRCState=true;
                    blendStateDesc.RenderTarget[0].BlendEnable=false;
                    blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_ONE;
                    blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ZERO;
                    blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_ONE;
                    blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ZERO;
                    *states[BLENDING]=0;					
                }
                break;

            case ON:
                if (states(BLENDING)!=1)
                {
                    Flush();
                    dirtyCRCState=true;
                    blendStateDesc.RenderTarget[0].BlendEnable=true;
                    blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_SRC_ALPHA;
                    blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_INV_SRC_ALPHA;
                    blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
                    blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_SRC_ALPHA;
                    blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_INV_SRC_ALPHA;
                    blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;

                    *states[BLENDING]=1;
                }
                break;

            case BLEND_GOURAUD:
                if (states(BLENDING)!=2)
                {
                    Flush();
                    dirtyCRCState=true;
                    blendStateDesc.RenderTarget[0].BlendEnable=true;
                    blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_SRC_ALPHA;
                    blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ONE;
                    blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
                    blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_SRC_ALPHA;
                    blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ONE;
                    blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;

                    *states[BLENDING]=2;					
                }
                break;

            case BLEND_COLOR:
                if (states(BLENDING)!=3)
                {
                    Flush();
                    dirtyCRCState=true;
                    blendStateDesc.RenderTarget[0].BlendEnable=true;
                    blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_DEST_COLOR;
                    blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ZERO;
                    blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
                    blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_DEST_ALPHA;
                    blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ZERO;
                    blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
                    *states[BLENDING]=3;
                }
                break;

            case BLEND_INVERSE:
                if (states(BLENDING)!=4)
                {
                    Flush();
                    dirtyCRCState=true;
                    blendStateDesc.RenderTarget[0].BlendEnable=true;
                    blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_INV_SRC_ALPHA;
                    blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_SRC_ALPHA;
                    blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
                    blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_INV_SRC_ALPHA;
                    blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_SRC_ALPHA;
                    blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;

                    *states[BLENDING]=4;
                }
                break;

            case BLEND_ADD:
                if (states(BLENDING)!=5)
                {
                    Flush();
                    dirtyCRCState=true;
                    blendStateDesc.RenderTarget[0].BlendEnable=true;
                    blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_ONE;
                    blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ONE;
                    blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
                    blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_ONE;
                    blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ONE;
                    blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;

                    *states[BLENDING]=5;
                }
                break;
            };

        }
        break;

    case API3D_CREATETEXTURE:
        {
            switch (Comment)
            {
            case CLAMP:
                *states[TEXTURES_CLAMPING]=1;
                break;
            case REPEAT:
                *states[TEXTURES_CLAMPING]=0;
                break;
            case MIPMAP:
                *states[TEXTURES_MIPMAP_ACTIVE]=1;
                break;
            case NO_MIPMAP:
                *states[TEXTURES_MIPMAP_ACTIVE]=0;
                break;
            };
        }
        break;

    case API3D_ZBUFFER:
        {
            Flush();
            dirtyCRCState=true;
            
            *states[ZBUFFERING]=Comment;
            switch (Comment)
            {
            case WRITEOFF:
				//if (depthStencilDesc.DepthWriteMask != D3D12_DEPTH_WRITE_MASK_ZERO) prevEffect=NULL;
                depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
                break;
            case LESS:
                depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS;
                break;
            case ALWAYS:
                depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_ALWAYS;
                break;
            case GREATER:
                depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_GREATER;
                break;

            case REINIT:
            case LESSEQUAL:
                depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
                break;
            case GREATEREQUAL:
                depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_GREATER_EQUAL;
                break;
            case EQUAL:
                depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_EQUAL;
                break;
            case NOTEQUAL:
                depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_NOT_EQUAL;
                break;
            case ON:
            case ENABLE:
				if (!depthStencilDesc.DepthEnable) prevEffect=NULL;
                depthStencilDesc.DepthEnable = true;
                depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
                break;
            case OFF:
            case DISABLE:
				if (depthStencilDesc.DepthEnable) prevEffect=NULL;
                depthStencilDesc.DepthEnable = false;
                depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
                break;
            };
        }
        break;

    case API3D_SHADING:
        {
        }
        break;

    case API3D_CULL:
        {            
            switch (Comment)
            {
            case ON:
                *states[CULLING]=-1;
                dirtyCRCState=true;
                break;
            case OFF:
                Flush();
                dirtyCRCState=true;
                *states[CULLING]=-1;
                rasterDesc.CullMode = D3D12_CULL_MODE_NONE;
				prevEffect=NULL;
                break;
            case CW:
                if (states(CULLING)!=0)
                {
                    Flush();
                    dirtyCRCState=true;
                    *states[CULLING]=0;
                    rasterDesc.CullMode = D3D12_CULL_MODE_FRONT;
					prevEffect=NULL;
                }
                break;
            case CCW:
                if (states(CULLING)!=1)
                {
                    Flush();
                    dirtyCRCState=true;
                    *states[CULLING]=1;
                    rasterDesc.CullMode = D3D12_CULL_MODE_BACK;
					prevEffect=NULL;
                }
                break;
            };
        }
        break;

    case API3D_SHADERS:
        if (Comment==DYNAMIC_ENV) *states[SHADERS]=1;
        if (Comment==FIXED_ENV) *states[SHADERS]=0;
        break;

    case API3D_TEXTURING:
        {
            Flush();

            switch (Comment)
            {
            case T_MODULATE:
                LevelTexture0=0;
                break;
            case T_ADD:
                LevelTexture0=1;
                break;
            };
        }
        break;
            
    case API3D_FILL:
        if (Comment==WIREFRAME)
        {
            rasterDesc.FillMode = D3D12_FILL_MODE_WIREFRAME;
        }

        if (Comment==SOLID)
        {
            rasterDesc.FillMode = D3D12_FILL_MODE_SOLID;
        }
        break;
            
    case API3D_TEXTURING2:
        {
            switch (Comment)
            {
            case T_MODULATE:
                LevelTexture1=0;
                break;
            case T_ADD:
                LevelTexture1=1;
                break;
            };
        }
        break;
    };
    
#endif
    
    
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL) && !defined(API3D_DIRECT3D12)

	float depth=0.0f;
	float slope=0.0f;

//------------------------------------------------------------------------------------------------ DIRECT3D ----------

	int ns;

	int basic=Comment&1023;
	int enhanced=Comment-basic;

	switch (Quoi)
	{

	case API3D_TEXTUREMIPMAP:
		if (Comment==ENABLE) *states[MIPMAP_ACTIVE]=1;
		if (Comment==DISABLE) *states[MIPMAP_ACTIVE]=0;
		break;

	case API3D_LIGHTMAPLAYERS:
		if (Comment==OFF) *states[LIGHTMAP_LAYERS]=1;
		else 
		{
			if ((Comment>=1)&&(Comment<16)) *states[LIGHTMAP_LAYERS]=Comment;
			else *states[LIGHTMAP_LAYERS]=1;
		}
		break;

	case API3D_MULTILAYEREFFECTS:
		if (Comment==FIT_RENDERER_DIMENSION) *states[LAYER_DIMENSION]=1;
		if (Comment==FULL_RENDERING) *states[LAYER_DIMENSION]=0;
		break;

	case API3D_CLIPPING:
#ifndef API3D_DIRECT3D10
#ifndef API3D_DIRECT3D11
		if (Comment==ON) D3DDevice->SetRenderState( D3DRS_CLIPPING, TRUE );
		if (Comment==OFF) D3DDevice->SetRenderState( D3DRS_CLIPPING, FALSE );
#endif
#endif
		break;

	case API3D_MISC:
		if (Comment==VBL_SYNCHRO) *states[VERTICAL_RETRACE]=1;
		if (Comment==VBL_NOSYNCHRO) *states[VERTICAL_RETRACE]=0;
		if (Comment==VBL_INTERVAL_TWO) *states[VERTICAL_RETRACE]=2;
		if (Comment==VBL_INTERVAL_THREE) *states[VERTICAL_RETRACE]=3;
		break;

	case API3D_ANTIALIASING:
#ifndef API3D_DIRECT3D10
#ifndef API3D_DIRECT3D11
#ifdef API3D_DIRECT3D
		if (Comment==ON) 
		{
			D3DDevice->SetRenderState(D3DRS_EDGEANTIALIAS,TRUE);			
		}

		if (Comment==OFF) 
		{
			D3DDevice->SetRenderState(D3DRS_EDGEANTIALIAS,FALSE);			
		}
#else
		if (Comment==ON) 
		{			
			D3DDevice->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE,TRUE);
		}

		if (Comment==OFF) 
		{			
			D3DDevice->SetRenderState(D3DRS_ANTIALIASEDLINEENABLE,FALSE);
		}
#endif
#endif
#endif
		break;

	case API3D_LIGHTMAPS:
		{
			if (Comment==BACKUP) *states[LIGHTMAP_BACKUPS]=1;
			if (Comment==NO_BACKUP) *states[LIGHTMAP_BACKUPS]=0;
		}

	case API3D_MULTIQUADS:
		if (Comment==TOGGLE) Flush();
		break;

	case API3D_BUMP_DISPLACE_SETTEXTURE:
		bump_displace=Comment;
		break;

	case API3D_HORIZON_MAPS_SETTEXTURE:
		bump_horizon=Comment;
		break;

	case API3D_STENCILSHADOWVOLUME:
		if (Comment==REVERSE) *states[ALGO_STENCIL_SHADOWING]=1;
		if (Comment==SIMPLE) *states[ALGO_STENCIL_SHADOWING]=2;
		if (Comment==ALTERNATIVE) *states[ALGO_STENCIL_SHADOWING]=0;
		if (Comment==TRIVIAL_ELIMINATION_ON) *states[TRIVIAL_ELIMINATION_STENCIL]=1;
		if (Comment==TRIVIAL_ELIMINATION_OFF) *states[TRIVIAL_ELIMINATION_STENCIL]=0;
		break;

	case API3D_HARDWAREVERTEXPROCESSING:
		if (Comment==ON) *states[HARDWARE_VERTEX_PROCESSING_E]=1;
		if (Comment==OFF) *states[HARDWARE_VERTEX_PROCESSING_E]=0;
		break;

	case API3D_ALPHATEST:

#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)
		if (Comment==ENABLE) set_alphatest=1;
		if (Comment==DISABLE) { set_alphatest=0; val_alphatest=0.0f; }

		if (Comment<=255)
		{
			val_alphatest=((float)Comment)/255.0f;
		}
#else
		if (Comment==ENABLE) set_alphatest=1;
		if (Comment==DISABLE) { set_alphatest=0; val_alphatest=0.0f; }

		if (Comment<=255)
		{
			val_alphatest=((float)Comment)/255.0f;
		}

		if (Comment>255)
		{
			switch (Comment)
			{
			case LESS:
				D3DDevice->SetRenderState(D3DRS_ALPHAFUNC,D3DCMP_LESS);
				break;
			case GREATER:
				D3DDevice->SetRenderState(D3DRS_ALPHAFUNC,D3DCMP_GREATER);
				break;
			case ALWAYS:
				D3DDevice->SetRenderState(D3DRS_ALPHAFUNC,D3DCMP_ALWAYS);
				break;
			case LESSEQUAL:
				D3DDevice->SetRenderState(D3DRS_ALPHAFUNC,D3DCMP_LESSEQUAL);
				break;
			case GREATEREQUAL:
				D3DDevice->SetRenderState(D3DRS_ALPHAFUNC,D3DCMP_GREATEREQUAL);
				break;
			case EQUAL:
				D3DDevice->SetRenderState(D3DRS_ALPHAFUNC,D3DCMP_EQUAL);
				break;
			case NOTEQUAL:
				D3DDevice->SetRenderState(D3DRS_ALPHAFUNC,D3DCMP_NOTEQUAL);
				break;
			case NEVER:
				D3DDevice->SetRenderState(D3DRS_ALPHAFUNC,D3DCMP_NEVER);
				break;
			case ENABLE:
				D3DDevice->SetRenderState(D3DRS_ALPHATESTENABLE,TRUE);
				break;
			case DISABLE:
				D3DDevice->SetRenderState(D3DRS_ALPHATESTENABLE,FALSE);
				break;
			};
		}
		else
		{
			D3DDevice->SetRenderState(D3DRS_ALPHAREF,Comment);
		}
#endif
		break;
	
	
	case API3D_BUMP_SETTEXTURE:
		bumpmap_settexture=Comment;
		break;
	
	case API3D_ALPHAMULTIGROUP:
		if (Comment==DONT_DRAW) *states[ALPHA_MULTI_GROUP_DRAW]=0;
		if (Comment==DRAW) *states[ALPHA_MULTI_GROUP_DRAW]=1;
		if (Comment==ONLY) *states[ALPHA_MULTI_GROUP_DRAW]=2;
		break;

	case API3D_SHADOWING:
		if (Comment==DONT_DRAW) *states[SHADOW_BUFFERING]=0;
		if (Comment==DRAW) *states[SHADOW_BUFFERING]=1;
		break;

	case API3D_ENVMULTIGROUP:
		if (Comment==EXTERN) *states[ENV_SHADERS]=1;
		else *states[ENV_SHADERS]=0;
		break;

	case API3D_BUMPMAPPINGSH:

		if (basic==ANIMATED) *states[SPECIAL_ANIMATED]=1;
		else
		if (basic==STATIC_LIGHTING) *states[SPECIAL_ANIMATED]=0;
		else
		if (basic==FASTDRAW) *states[SPECIAL_FASTDRAW]=1;
		else
		if (basic==DIRTYDRAW) *states[SPECIAL_FASTDRAW]=2;
		else
		if (basic==FULLDRAW) *states[SPECIAL_FASTDRAW]=0;
		else
		{			
			if (enhanced==SH_BUMPY+SH_DISPLACE+SH_SELFSHADOWED+SH_CARTOON) { *states[SPECIAL_ENHANCED]=0; *states[SPECIAL_FASTDRAW]=0; }
			if (enhanced==SH_BUMPY+SH_DISPLACE+SH_SELFSHADOWED) { *states[SPECIAL_ENHANCED]=0; *states[SPECIAL_FASTDRAW]=0; }
			if (enhanced==SH_BUMPY+SH_DISPLACE) { *states[SPECIAL_ENHANCED]=2; *states[SPECIAL_FASTDRAW]=0; }
			if (enhanced==SH_BUMPY) *states[SPECIAL_ENHANCED]=3;
			if (enhanced&SH_NORMAL) *states[SPECIAL_ENHANCED]=3;
		}

		BumpMappingStates();

		break;

	case API3D_TEXTUREFILTERS:
#if !defined(API3D_DIRECT3D10)&&!defined(API3D_DIRECT3D11)
		{
			switch (Comment)
			{
			case STAGE0_ON:
#ifdef API3D_DIRECT3D
				D3DDevice->SetTextureStageState(0,D3DTSS_MIPFILTER,D3DTEXF_NONE);
				D3DDevice->SetTextureStageState(0,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
				D3DDevice->SetTextureStageState(0,D3DTSS_MINFILTER,D3DTEXF_LINEAR);
#else
				D3DDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
				D3DDevice->SetSamplerState(0,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
				D3DDevice->SetSamplerState(0,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);
#endif
				break;

			case STAGE1_ON:
#ifdef API3D_DIRECT3D
				D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);
				D3DDevice->SetTextureStageState(1,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
				D3DDevice->SetTextureStageState(1,D3DTSS_MINFILTER,D3DTEXF_LINEAR);
#else
				D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
				D3DDevice->SetSamplerState(1,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
				D3DDevice->SetSamplerState(1,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);
#endif
				break;

			case STAGE0_OFF:
#ifdef API3D_DIRECT3D
				D3DDevice->SetTextureStageState(0,D3DTSS_MIPFILTER,D3DTEXF_NONE);
				D3DDevice->SetTextureStageState(0,D3DTSS_MAGFILTER,D3DTEXF_NONE);
				D3DDevice->SetTextureStageState(0,D3DTSS_MINFILTER,D3DTEXF_NONE);
#else
				D3DDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
				D3DDevice->SetSamplerState(0,D3DSAMP_MAGFILTER,D3DTEXF_NONE);
				D3DDevice->SetSamplerState(0,D3DSAMP_MINFILTER,D3DTEXF_NONE);
#endif
				break;

			case STAGE1_OFF:
#ifdef API3D_DIRECT3D
				D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);
				D3DDevice->SetTextureStageState(1,D3DTSS_MAGFILTER,D3DTEXF_NONE);
				D3DDevice->SetTextureStageState(1,D3DTSS_MINFILTER,D3DTEXF_NONE);
#else
				D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
				D3DDevice->SetSamplerState(1,D3DSAMP_MAGFILTER,D3DTEXF_NONE);
				D3DDevice->SetSamplerState(1,D3DSAMP_MINFILTER,D3DTEXF_NONE);
#endif
				break;
			};
		}	
#endif
		break;


	case API3D_DITHERING:
		{
#if !defined(API3D_DIRECT3D10)&&!defined(API3D_DIRECT3D11)
			if (Comment==ON) D3DDevice->SetRenderState(D3DRS_DITHERENABLE,TRUE);
			else D3DDevice->SetRenderState(D3DRS_DITHERENABLE,FALSE);
#endif
		}
		break;

	case API3D_ZBIAS:
		{
#ifdef API3D_DIRECT3D11
			
			if (Comment==0) slope=0.0f;
			else slope=(float) Comment; 
			
			if (Comment!=ZBiasComment)
			{
				ZBiasComment=Comment;

				if (rasterState) rasterState->Release();
				rasterDesc.DepthBias = 0;
				rasterDesc.DepthBiasClamp = 0.0f;
				rasterDesc.SlopeScaledDepthBias = -slope*0.3f;
				device->CreateRasterizerState(&rasterDesc, &rasterState);
				devicecontext->RSSetState(rasterState);
			}
#else
#ifdef API3D_DIRECT3D10
			
			if (Comment==0) slope=0.0f;
			else slope=(float) Comment; 
			
			if (Comment!=ZBiasComment)
			{
				ZBiasComment=Comment;

				rasterState->Release();
				rasterDesc.DepthBias = 0;
				rasterDesc.DepthBiasClamp = 0.0f;
				rasterDesc.SlopeScaledDepthBias = -slope*0.3f;
				device->CreateRasterizerState(&rasterDesc, &rasterState);
				device->RSSetState(rasterState);
			}
#else
#ifdef API3D_DIRECT3D9
			if (Comment==0) slope=0.0f;
			else slope=(float) -0.2f*Comment; 

			if (Comment!=ZBiasComment)
			{
				ZBiasComment=Comment;

				D3DDevice->SetRenderState(D3DRS_DEPTHBIAS,F2DW(depth));
				D3DDevice->SetRenderState(D3DRS_SLOPESCALEDEPTHBIAS,F2DW(slope)); 
#else
				D3DDevice->SetRenderState(D3DRS_ZBIAS,Comment);
#endif
			}
#endif
#endif
		}
		break;

	case API3D_SPECULAR:
		{
#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)
			if (Comment==ON) Specular=true;
			else Specular=false;
#else
			if (Comment==ON)
			{
				Specular=true;
				D3DDevice->SetRenderState( D3DRS_SPECULARENABLE, TRUE);
			}
			else
			{
				Specular=false;
				D3DDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE);
			}

			if (Comment==ONLY)
			{
				D3DDevice->SetRenderState( D3DRS_LIGHTING, TRUE );

#ifdef API3D_DIRECT3D

				D3DMATERIAL8 m;
				ZeroMemory( &m, sizeof(D3DMATERIAL8) );
				m.Diffuse.r = m.Ambient.r = 0.0f;
				m.Diffuse.g = m.Ambient.g = 0.0f;
				m.Diffuse.b = m.Ambient.b = 0.0f;
				m.Diffuse.a = m.Ambient.a = 0.0f;

				m.Specular.r = 1.0f;
				m.Specular.g = 1.0f;
				m.Specular.b = 1.0f;
				m.Specular.a = 1.0f;
				m.Power = 60;
#else
				D3DMATERIAL9 m;
				ZeroMemory( &m, sizeof(D3DMATERIAL9) );
				m.Diffuse.r = m.Ambient.r = 0.0f;
				m.Diffuse.g = m.Ambient.g = 0.0f;
				m.Diffuse.b = m.Ambient.b = 0.0f;
				m.Diffuse.a = m.Ambient.a = 0.0f;

				m.Specular.r = 1.0f;
				m.Specular.g = 1.0f;
				m.Specular.b = 1.0f;
				m.Specular.a = 1.0f;
				m.Power = 60;
#endif
				D3DDevice->SetMaterial( &m );

				Specular=true;
				D3DDevice->SetRenderState( D3DRS_SPECULARENABLE, TRUE);

			}
#endif
		}
		break;


	case API3D_LIGHTING:
		{
			Flush();
#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)
			if (Comment==ON) Lighting=true;
			if (Comment==OFF) Lighting=false;
#endif
#if !defined(API3D_DIRECT3D10)&&!defined(API3D_DIRECT3D11)
			if (Comment==ON)
			{
				D3DDevice->SetRenderState( D3DRS_LIGHTING, TRUE );
#ifdef API3D_DIRECT3D
				D3DMATERIAL8 m;
				ZeroMemory( &m, sizeof(D3DMATERIAL8) );
				m.Diffuse.r = m.Ambient.r = 1.0f;
				m.Diffuse.g = m.Ambient.g = 1.0f;
				m.Diffuse.b = m.Ambient.b = 1.0f;
				m.Diffuse.a = m.Ambient.a = 1.0f;
	
				m.Specular.r = m.Ambient.r = 1.0f;
				m.Specular.g = m.Ambient.g = 1.0f;
				m.Specular.b = m.Ambient.b = 1.0f;
				m.Specular.a = m.Ambient.a = 1.0f;
				m.Power = 20;
#else
				D3DMATERIAL9 m;
				ZeroMemory( &m, sizeof(D3DMATERIAL9) );
				m.Diffuse.r = m.Ambient.r = 1.0f;
				m.Diffuse.g = m.Ambient.g = 1.0f;
				m.Diffuse.b = m.Ambient.b = 1.0f;
				m.Diffuse.a = m.Ambient.a = 1.0f;
	
				m.Specular.r = m.Ambient.r = 1.0f;
				m.Specular.g = m.Ambient.g = 1.0f;
				m.Specular.b = m.Ambient.b = 1.0f;
				m.Specular.a = m.Ambient.a = 1.0f;
				m.Power = 20;
#endif
				D3DDevice->SetMaterial( &m );

				if (Specular)
					D3DDevice->SetRenderState( D3DRS_SPECULARENABLE, TRUE);
				else
					D3DDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE);
			}
			else
			{
				D3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );
				D3DDevice->SetRenderState( D3DRS_SPECULARENABLE, FALSE);
			}
#endif
		}
		break;

	case API3D_REPLACE_STENCIL:
		if (Comment==ON) *states[REPLACE_ACTIVE]=1;
		if (Comment==OFF) *states[REPLACE_ACTIVE]=0;
		break;


	case API3D_RENDERTARGET:
#ifdef API3D_DIRECT3D11

		{
			Flush();
            
			if ((Comment==PRIMARY))
			{
				*states[RENDER_TARGET]=Comment;

				MatrixOrthoLHS( &ProjOrtho, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );

				if (SelectedRenderTarget!=PRIMARY)
				{
					SelectedRenderTarget=PRIMARY;
					devicecontext->OMSetRenderTargets(1, &renderTargetView, depthStencilView);
				
					render=renderTargetView;
					depthstencil=depthStencilView;
				}

                devicecontext->RSSetViewports(1, &Viewport);
                devicecontext->RSSetScissorRects( 1, &scissor);
                
                rasterDesc.ScissorEnable = true;
                
                if (rasterState) rasterState->Release();
                device->CreateRasterizerState(&rasterDesc, &rasterState);
                devicecontext->RSSetState(rasterState);

				VIEWPORT.Id();
				VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
				VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);
				VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
				VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);
				VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
				VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);
			}
			else
			if (((Comment>=SECONDARY1)&&(Comment<=SECONDARY24))||(Comment==SECONDARY))
			{
				*states[RENDER_TARGET]=Comment;

				if (Comment==SECONDARY) ns=0;
				else ns=Comment-SECONDARY1;

				SelectedRenderTarget=Comment;

				devicecontext->OMSetRenderTargets(1, &renderSndTargetView[ns], renderDepthStencilView[ns]);

				render=renderSndTargetView[ns];
				depthstencil=renderDepthStencilView[ns];
				
				devicecontext->RSSetViewports(1, &SndViewport[ns]);
                                
                rasterDesc.ScissorEnable = false;
                
                if (rasterState) rasterState->Release();
                device->CreateRasterizerState(&rasterDesc, &rasterState);
                devicecontext->RSSetState(rasterState);

				VIEWPORT.Id();
				VIEWPORT.a[0][0]=(float) (SndViewport[ns].Width/2);
				VIEWPORT.a[3][0]=(float) (SndViewport[ns].TopLeftX+SndViewport[ns].Width/2);
				VIEWPORT.a[1][1]=((float) (SndViewport[ns].Height/2));
				VIEWPORT.a[3][1]=(float) (SndViewport[ns].TopLeftY+SndViewport[ns].Height/2);
				VIEWPORT.a[2][2]=(float) (SndViewport[ns].MaxDepth-SndViewport[ns].MinDepth);
				VIEWPORT.a[3][2]=(float) (SndViewport[ns].MinDepth);

				MatrixOrthoLHS( &ProjOrtho, (float)SndViewport[ns].Width, (float)SndViewport[ns].Height, 0.0f, 1.0f );
			}

			switch(Comment)
			{
			case STENCIL:
				if (StencilBuffer)
				{
					*states[RENDER_TARGET_OPTIONS]=STENCIL;
					*states[ZBUFFER_TEST_STENCIL]=0;

					if (blendStateTMP) blendStateTMP->Release();
					blendStateDesc.RenderTarget[0].SrcBlend=D3D11_BLEND_ZERO;
					blendStateDesc.RenderTarget[0].DestBlend=D3D11_BLEND_ONE;
					blendStateDesc.RenderTarget[0].BlendOp=D3D11_BLEND_OP_ADD;
					blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D11_BLEND_OP_ADD;
					blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_ZERO;
					blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_ONE;
					device->CreateBlendState(&blendStateDesc,&blendStateTMP);
					devicecontext->OMSetBlendState(blendStateTMP,factors,0xFFFFFFFF);

					if (depthStencilState) depthStencilState->Release();

					depthStencilDesc.DepthEnable = true;
					depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;
					depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;

					depthStencilDesc.StencilEnable = true;
					depthStencilDesc.StencilReadMask = 0xFF;
					depthStencilDesc.StencilWriteMask = 0xFF;

					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, 1);

				}
				break;

			case STENCIL_NO_ZTEST:
				if (StencilBuffer)
				{
					*states[RENDER_TARGET_OPTIONS]=STENCIL_NO_ZTEST;
					*states[ZBUFFER_TEST_STENCIL]=1;

					if (blendStateTMP) blendStateTMP->Release();
					blendStateDesc.RenderTarget[0].SrcBlend=D3D11_BLEND_ZERO;
					blendStateDesc.RenderTarget[0].DestBlend=D3D11_BLEND_ONE;
					blendStateDesc.RenderTarget[0].BlendOp=D3D11_BLEND_OP_ADD;
					blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D11_BLEND_OP_ADD;
					blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_ZERO;
					blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_ONE;
					device->CreateBlendState(&blendStateDesc,&blendStateTMP);
					devicecontext->OMSetBlendState(blendStateTMP,factors,0xFFFFFFFF);

					if (depthStencilState) depthStencilState->Release();

					depthStencilDesc.DepthEnable = false;
					depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;
					depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;

					depthStencilDesc.StencilEnable = true;
					depthStencilDesc.StencilReadMask = 0xFF;
					depthStencilDesc.StencilWriteMask = 0xFF;

					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_REPLACE;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, 1);

				}
				break;

			case ZBUFFER:
				*states[RENDER_TARGET_OPTIONS]=ZBUFFER;
				if (blendStateTMP) blendStateTMP->Release();
				blendStateDesc.RenderTarget[0].SrcBlend=D3D11_BLEND_ZERO;
				blendStateDesc.RenderTarget[0].DestBlend=D3D11_BLEND_ONE;
				blendStateDesc.RenderTarget[0].BlendOp=D3D11_BLEND_OP_ADD;
				blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_ZERO;
				blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_ONE;
				blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D11_BLEND_OP_ADD;
				device->CreateBlendState(&blendStateDesc,&blendStateTMP);
				devicecontext->OMSetBlendState(blendStateTMP,factors,0xFFFFFFFF);
				break;

			case RENDER:
				*states[RENDER_TARGET_OPTIONS]=RENDER;

				devicecontext->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);
				*states[BLENDING]=0;

				if (depthStencilState) depthStencilState->Release();

				depthStencilDesc.DepthEnable = true;
				depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
				depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;

				depthStencilDesc.StencilEnable = false;
				depthStencilDesc.StencilReadMask = 0xFF;
				depthStencilDesc.StencilWriteMask = 0xFF;

				depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

				depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, 1);

				break;

			case BOTH:
				*states[RENDER_TARGET_OPTIONS]=BOTH;
				if (StencilBuffer)
				{
					devicecontext->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.DepthEnable = true;
					depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;
					//depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;

					depthStencilDesc.StencilEnable = true;
					depthStencilDesc.StencilReadMask = 0xFF;
					depthStencilDesc.StencilWriteMask = 0xFF;

					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, 1);
				}
				break;

			case BOTH_WRITE_Z:
				*states[RENDER_TARGET_OPTIONS]=BOTH_WRITE_Z;
				if (StencilBuffer)
				{
					devicecontext->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);

					if (depthStencilState) depthStencilState->Release();

					depthStencilDesc.DepthEnable = true;
					depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
					//depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;

					depthStencilDesc.StencilEnable = true;
					depthStencilDesc.StencilReadMask = 0xFF;
					depthStencilDesc.StencilWriteMask = 0xFF;

					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, 1);
				}
				break;
			};

		}

#else
#ifdef API3D_DIRECT3D10

		{

			Flush();
			
			if ((Comment==PRIMARY))
			{
				*states[RENDER_TARGET]=Comment;

				D3DXMATRIX proj;
				D3DXMatrixOrthoLH( &proj, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );

				ProjOrtho.a[0][0]=proj._11;	ProjOrtho.a[1][0]=proj._21;	ProjOrtho.a[2][0]=proj._31;	ProjOrtho.a[3][0]=proj._41;
				ProjOrtho.a[0][1]=-proj._12; ProjOrtho.a[1][1]=-proj._22; ProjOrtho.a[2][1]=-proj._32; ProjOrtho.a[3][1]=-proj._42;
				ProjOrtho.a[0][2]=proj._13;	ProjOrtho.a[1][2]=proj._23;	ProjOrtho.a[2][2]=proj._33;	ProjOrtho.a[3][2]=proj._43;
				ProjOrtho.a[0][3]=proj._14;	ProjOrtho.a[1][3]=proj._24;	ProjOrtho.a[2][3]=proj._34;	ProjOrtho.a[3][3]=proj._44;

				if (SelectedRenderTarget!=PRIMARY)
				{
					SelectedRenderTarget=PRIMARY;
					device->OMSetRenderTargets(1, &renderTargetView, depthStencilView);
				
					render=renderTargetView;
					depthstencil=depthStencilView;
				}

				device->RSSetViewports(1, &Viewport);
                device->RSSetScissorRects( 1, &scissor);
                
                rasterDesc.ScissorEnable = true;

                if (rasterState) rasterState->Release();
                device->CreateRasterizerState(&rasterDesc, &rasterState);
                device->RSSetState(rasterState);

				VIEWPORT.Id();
				VIEWPORT.a[0][0]=(float) (Viewport.Width/2);
				VIEWPORT.a[3][0]=(float) (Viewport.TopLeftX+Viewport.Width/2);
				VIEWPORT.a[1][1]=((float) (Viewport.Height/2));
				VIEWPORT.a[3][1]=(float) (Viewport.TopLeftY+Viewport.Height/2);
				VIEWPORT.a[2][2]=(float) (Viewport.MaxDepth-Viewport.MinDepth);
				VIEWPORT.a[3][2]=(float) (Viewport.MinDepth);
			}
			else
			if (((Comment>=SECONDARY1)&&(Comment<=SECONDARY24))||(Comment==SECONDARY))
			{
				*states[RENDER_TARGET]=Comment;

				if (Comment==SECONDARY) ns=0;
				else ns=Comment-SECONDARY1;

				SelectedRenderTarget=Comment;

				device->OMSetRenderTargets(1, &renderSndTargetView[ns], renderDepthStencilView[ns]);

				render=renderSndTargetView[ns];
				depthstencil=renderDepthStencilView[ns];

				device->RSSetViewports(1, &SndViewport[ns]);
                                
                rasterDesc.ScissorEnable = false;
                
                if (rasterState) rasterState->Release();
                device->CreateRasterizerState(&rasterDesc, &rasterState);
                device->RSSetState(rasterState);

				VIEWPORT.Id();
				VIEWPORT.a[0][0]=(float) (SndViewport[ns].Width/2);
				VIEWPORT.a[3][0]=(float) (SndViewport[ns].TopLeftX+SndViewport[ns].Width/2);
				VIEWPORT.a[1][1]=((float) (SndViewport[ns].Height/2));
				VIEWPORT.a[3][1]=(float) (SndViewport[ns].TopLeftY+SndViewport[ns].Height/2);
				VIEWPORT.a[2][2]=(float) (SndViewport[ns].MaxDepth-SndViewport[ns].MinDepth);
				VIEWPORT.a[3][2]=(float) (SndViewport[ns].MinDepth);

				D3DXMATRIX proj;
				D3DXMatrixOrthoLH( &proj, (float)SndViewport[ns].Width, (float)SndViewport[ns].Height, 0.0f, 1.0f );

				ProjOrtho.a[0][0]=proj._11;	ProjOrtho.a[1][0]=proj._21;	ProjOrtho.a[2][0]=proj._31;	ProjOrtho.a[3][0]=proj._41;
				ProjOrtho.a[0][1]=-proj._12; ProjOrtho.a[1][1]=-proj._22; ProjOrtho.a[2][1]=-proj._32; ProjOrtho.a[3][1]=-proj._42;
				ProjOrtho.a[0][2]=proj._13;	ProjOrtho.a[1][2]=proj._23;	ProjOrtho.a[2][2]=proj._33;	ProjOrtho.a[3][2]=proj._43;
				ProjOrtho.a[0][3]=proj._14;	ProjOrtho.a[1][3]=proj._24;	ProjOrtho.a[2][3]=proj._34;	ProjOrtho.a[3][3]=proj._44;
			}

			switch(Comment)
			{
			case STENCIL:
				if (StencilBuffer)
				{
					*states[RENDER_TARGET_OPTIONS]=STENCIL;
					*states[ZBUFFER_TEST_STENCIL]=0;

					if (blendStateTMP) blendStateTMP->Release();
					blendStateDesc.SrcBlend=D3D10_BLEND_ZERO;
					blendStateDesc.DestBlend=D3D10_BLEND_ONE;
					blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
					blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
					blendStateDesc.SrcBlendAlpha=D3D10_BLEND_ZERO;
					blendStateDesc.DestBlendAlpha=D3D10_BLEND_ONE;
					device->CreateBlendState(&blendStateDesc,&blendStateTMP);
					device->OMSetBlendState(blendStateTMP,factors,0xFFFFFFFF);

					if (depthStencilState) depthStencilState->Release();

					depthStencilDesc.DepthEnable = true;
					depthStencilDesc.DepthWriteMask = D3D10_DEPTH_WRITE_MASK_ZERO;
					depthStencilDesc.DepthFunc = D3D10_COMPARISON_LESS_EQUAL;

					depthStencilDesc.StencilEnable = true;
					depthStencilDesc.StencilReadMask = 0xFF;
					depthStencilDesc.StencilWriteMask = 0xFF;

					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, 1);

				}
				break;

			case STENCIL_NO_ZTEST:
				if (StencilBuffer)
				{
					*states[RENDER_TARGET_OPTIONS]=STENCIL_NO_ZTEST;
					*states[ZBUFFER_TEST_STENCIL]=1;

					if (blendStateTMP) blendStateTMP->Release();
					blendStateDesc.SrcBlend=D3D10_BLEND_ZERO;
					blendStateDesc.DestBlend=D3D10_BLEND_ONE;
					blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
					blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
					blendStateDesc.SrcBlendAlpha=D3D10_BLEND_ZERO;
					blendStateDesc.DestBlendAlpha=D3D10_BLEND_ONE;
					device->CreateBlendState(&blendStateDesc,&blendStateTMP);
					device->OMSetBlendState(blendStateTMP,factors,0xFFFFFFFF);

					if (depthStencilState) depthStencilState->Release();

					depthStencilDesc.DepthEnable = false;
					depthStencilDesc.DepthWriteMask = D3D10_DEPTH_WRITE_MASK_ZERO;
					depthStencilDesc.DepthFunc = D3D10_COMPARISON_LESS_EQUAL;

					depthStencilDesc.StencilEnable = true;
					depthStencilDesc.StencilReadMask = 0xFF;
					depthStencilDesc.StencilWriteMask = 0xFF;

					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_REPLACE;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, 1);

				}
				break;

			case ZBUFFER:
				*states[RENDER_TARGET_OPTIONS]=ZBUFFER;
				if (blendStateTMP) blendStateTMP->Release();
				blendStateDesc.SrcBlend=D3D10_BLEND_ZERO;
				blendStateDesc.DestBlend=D3D10_BLEND_ONE;
				blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
				blendStateDesc.SrcBlendAlpha=D3D10_BLEND_ZERO;
				blendStateDesc.DestBlendAlpha=D3D10_BLEND_ONE;
				blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
				device->CreateBlendState(&blendStateDesc,&blendStateTMP);
				device->OMSetBlendState(blendStateTMP,factors,0xFFFFFFFF);
				break;

			case RENDER:
				*states[RENDER_TARGET_OPTIONS]=RENDER;
				device->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);
				*states[BLENDING]=0;

				if (depthStencilState) depthStencilState->Release();

				depthStencilDesc.DepthEnable = true;
				depthStencilDesc.DepthWriteMask = D3D10_DEPTH_WRITE_MASK_ALL;
				depthStencilDesc.DepthFunc = D3D10_COMPARISON_LESS_EQUAL;

				depthStencilDesc.StencilEnable = false;
				depthStencilDesc.StencilReadMask = 0xFF;
				depthStencilDesc.StencilWriteMask = 0xFF;

				depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

				depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, 1);

				break;

			case BOTH:
				*states[RENDER_TARGET_OPTIONS]=BOTH;
				if (StencilBuffer)
				{
					device->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);
					*states[BLENDING]=0;

					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.DepthEnable = true;
					depthStencilDesc.DepthWriteMask = D3D10_DEPTH_WRITE_MASK_ZERO;
					//depthStencilDesc.DepthFunc = D3D10_COMPARISON_LESS_EQUAL;

					depthStencilDesc.StencilEnable = true;
					depthStencilDesc.StencilReadMask = 0xFF;
					depthStencilDesc.StencilWriteMask = 0xFF;

					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, 1);
				}
				break;

			case BOTH_WRITE_Z:
				*states[RENDER_TARGET_OPTIONS]=BOTH_WRITE_Z;
				if (StencilBuffer)
				{
					device->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);
					*states[BLENDING]=0;

					if (depthStencilState) depthStencilState->Release();

					depthStencilDesc.DepthEnable = true;
					depthStencilDesc.DepthWriteMask = D3D10_DEPTH_WRITE_MASK_ALL;
					//depthStencilDesc.DepthFunc = D3D10_COMPARISON_LESS_EQUAL;

					depthStencilDesc.StencilEnable = true;
					depthStencilDesc.StencilReadMask = 0xFF;
					depthStencilDesc.StencilWriteMask = 0xFF;

					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, 1);
				}
				break;
			};

		}

#else
		{
			Flush();

			if ((Comment==PRIMARY))
			{
				*states[RENDER_TARGET]=Comment;

				if (SelectedRenderTarget!=PRIMARY)
				{
					SelectedRenderTarget=PRIMARY;
#ifdef API3D_DIRECT3D
					D3DDevice->SetRenderTarget(PreviousRenderTarget,PreviousZbuffer);
#else
					D3DDevice->SetRenderTarget(0,PreviousRenderTarget);
					D3DDevice->SetDepthStencilSurface(PreviousZbuffer);
#endif
					D3DDevice->SetViewport(&PreviousViewport);
                    
                    D3DDevice->SetRenderState(D3DRS_SCISSORTESTENABLE,TRUE);
                    D3DDevice->SetScissorRect(&scissor);

					D3DDevice->GetViewport(&ViewPort);
					VIEWPORT.Id();
					VIEWPORT.a[0][0]=(float) (PreviousViewport.Width/2);
					VIEWPORT.a[3][0]=(float) (PreviousViewport.X+PreviousViewport.Width/2);
					VIEWPORT.a[1][1]=((float) (PreviousViewport.Height/2));
					VIEWPORT.a[3][1]=(float) (PreviousViewport.Y+PreviousViewport.Height/2);
					VIEWPORT.a[2][2]=(float) (PreviousViewport.MaxZ-PreviousViewport.MinZ);
					VIEWPORT.a[3][2]=(float) (PreviousViewport.MinZ);

					PreviousRenderTarget->Release();
					PreviousZbuffer->Release();
				}
				else
				{
					D3DDevice->SetViewport(&ViewPort);
                                        
                    D3DDevice->SetRenderState(D3DRS_SCISSORTESTENABLE,TRUE);
                    D3DDevice->SetScissorRect(&scissor);
                    
					VIEWPORT.Id();
					VIEWPORT.a[0][0]=(float) (ViewPort.Width/2);
					VIEWPORT.a[3][0]=(float) (ViewPort.X+ViewPort.Width/2);
					VIEWPORT.a[1][1]=((float) (ViewPort.Height/2));
					VIEWPORT.a[3][1]=(float) (ViewPort.Y+ViewPort.Height/2);
					VIEWPORT.a[2][2]=(float) (ViewPort.MaxZ-ViewPort.MinZ);
					VIEWPORT.a[3][2]=(float) (ViewPort.MinZ);
				}

				D3DXMATRIX proj;
				D3DXMatrixOrthoLH( &proj, (float)SCREEN_X, (float)SCREEN_Y, 0.0f, 1.0f );

				ProjOrtho.a[0][0]=proj._11;	ProjOrtho.a[1][0]=proj._21;	ProjOrtho.a[2][0]=proj._31;	ProjOrtho.a[3][0]=proj._41;
				ProjOrtho.a[0][1]=-proj._12; ProjOrtho.a[1][1]=-proj._22; ProjOrtho.a[2][1]=-proj._32; ProjOrtho.a[3][1]=-proj._42;
				ProjOrtho.a[0][2]=proj._13;	ProjOrtho.a[1][2]=proj._23;	ProjOrtho.a[2][2]=proj._33;	ProjOrtho.a[3][2]=proj._43;
				ProjOrtho.a[0][3]=proj._14;	ProjOrtho.a[1][3]=proj._24;	ProjOrtho.a[2][3]=proj._34;	ProjOrtho.a[3][3]=proj._44;
			}
			
			if (((Comment>=SECONDARY1)&&(Comment<=SECONDARY24))||(Comment==SECONDARY))
			{
				*states[RENDER_TARGET]=Comment;

				if (Comment==SECONDARY) ns=0;
				else ns=Comment-SECONDARY1;

				if (SelectedRenderTarget==PRIMARY)
				{
#ifdef API3D_DIRECT3D
					D3DDevice->GetRenderTarget(&PreviousRenderTarget);
#else
					D3DDevice->GetRenderTarget(0,&PreviousRenderTarget);
#endif
					D3DDevice->GetDepthStencilSurface(&PreviousZbuffer);
					D3DDevice->GetViewport(&PreviousViewport);
				}

				SelectedRenderTarget=Comment;

#ifdef API3D_DIRECT3D
				D3DDevice->SetRenderTarget(D3DSecondary[ns],D3DSecondaryZbuffer[ns]);
#else
				D3DDevice->SetRenderTarget(0,D3DSecondary[ns]);
				D3DDevice->SetDepthStencilSurface(D3DSecondaryZbuffer[ns]);
#endif
			
				D3DDevice->SetViewport(&SecondaryViewport[ns]);
                D3DDevice->SetRenderState(D3DRS_SCISSORTESTENABLE,FALSE);

				VIEWPORT.Id();
				VIEWPORT.a[0][0]=(float) (SecondaryViewport[ns].Width/2);
				VIEWPORT.a[3][0]=(float) (SecondaryViewport[ns].X+SecondaryViewport[ns].Width/2);

				VIEWPORT.a[1][1]=((float) (SecondaryViewport[ns].Height/2));
				VIEWPORT.a[3][1]=(float) (SecondaryViewport[ns].Y+SecondaryViewport[ns].Height/2);

				VIEWPORT.a[2][2]=(float) (SecondaryViewport[ns].MaxZ-SecondaryViewport[ns].MinZ);
				VIEWPORT.a[3][2]=(float) (SecondaryViewport[ns].MinZ);

				D3DXMATRIX proj;
				D3DXMatrixOrthoLH( &proj, (float)SecondaryViewport[ns].Width, (float)SecondaryViewport[ns].Height, 0.0f, 1.0f );

				ProjOrtho.a[0][0]=proj._11;	ProjOrtho.a[1][0]=proj._21;	ProjOrtho.a[2][0]=proj._31;	ProjOrtho.a[3][0]=proj._41;
				ProjOrtho.a[0][1]=-proj._12; ProjOrtho.a[1][1]=-proj._22; ProjOrtho.a[2][1]=-proj._32; ProjOrtho.a[3][1]=-proj._42;
				ProjOrtho.a[0][2]=proj._13;	ProjOrtho.a[1][2]=proj._23;	ProjOrtho.a[2][2]=proj._33;	ProjOrtho.a[3][2]=proj._43;
				ProjOrtho.a[0][3]=proj._14;	ProjOrtho.a[1][3]=proj._24;	ProjOrtho.a[2][3]=proj._34;	ProjOrtho.a[3][3]=proj._44;

			}

			switch(Comment)
			{
			case STENCIL:
				*states[RENDER_TARGET_OPTIONS]=STENCIL;
				if (StencilBuffer)
				{
					D3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,	TRUE );
					D3DDevice->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_ZERO );
					D3DDevice->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_ONE );
					D3DDevice->SetRenderState( D3DRS_STENCILFUNC,		D3DCMP_ALWAYS );
					D3DDevice->SetRenderState( D3DRS_STENCILZFAIL,		D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,		D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_ZENABLE,			D3DZB_TRUE);
					D3DDevice->SetRenderState( D3DRS_ZWRITEENABLE,		0);
					D3DDevice->SetRenderState( D3DRS_STENCILENABLE,		TRUE );
					D3DDevice->SetRenderState( D3DRS_SHADEMODE,			D3DSHADE_FLAT );
					*states[ZBUFFER_TEST_STENCIL]=0;
				}
				break;

			case STENCIL_NO_ZTEST:
				*states[RENDER_TARGET_OPTIONS]=STENCIL_NO_ZTEST;
				if (StencilBuffer)
				{
					D3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,	TRUE );
					D3DDevice->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_ZERO );
					D3DDevice->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_ONE );
					D3DDevice->SetRenderState( D3DRS_STENCILFUNC,		D3DCMP_ALWAYS );
					D3DDevice->SetRenderState( D3DRS_STENCILZFAIL,		D3DSTENCILOP_REPLACE );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,		D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_ZENABLE,			D3DZB_TRUE);
					D3DDevice->SetRenderState( D3DRS_ZWRITEENABLE,		0);
					D3DDevice->SetRenderState( D3DRS_STENCILENABLE,		TRUE );
					D3DDevice->SetRenderState( D3DRS_SHADEMODE,			D3DSHADE_FLAT );
					*states[ZBUFFER_TEST_STENCIL]=1;
				}
				break;

			case ZBUFFER:
				*states[RENDER_TARGET_OPTIONS]=ZBUFFER;
				D3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE,	TRUE );
				D3DDevice->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_ZERO );
				D3DDevice->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_ONE );
				D3DDevice->SetRenderState( D3DRS_ZWRITEENABLE,		TRUE );
				break;

			case RENDER:
				*states[RENDER_TARGET_OPTIONS]=RENDER;
				*states[BLENDING]=0;
				D3DDevice->SetRenderState( D3DRS_SRCBLEND,			D3DBLEND_ONE );
				D3DDevice->SetRenderState( D3DRS_DESTBLEND,			D3DBLEND_ZERO );
				D3DDevice->SetRenderState( D3DRS_ZENABLE,			D3DZB_TRUE);
				D3DDevice->SetRenderState( D3DRS_ZWRITEENABLE,		1);
				D3DDevice->SetRenderState( D3DRS_STENCILENABLE,		FALSE );
				D3DDevice->SetRenderState( D3DRS_SHADEMODE,			D3DSHADE_GOURAUD );
				break;

			case BOTH:
				*states[RENDER_TARGET_OPTIONS]=BOTH;
				if (StencilBuffer)
				{
					D3DDevice->SetRenderState(D3DRS_ZENABLE,			D3DZB_TRUE);
					D3DDevice->SetRenderState(D3DRS_ZWRITEENABLE,		0);
					D3DDevice->SetRenderState( D3DRS_STENCILENABLE,		TRUE );
					D3DDevice->SetRenderState( D3DRS_STENCILZFAIL,		D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,		D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_SHADEMODE,			D3DSHADE_GOURAUD );
				}
				break;

			case BOTH_WRITE_Z:
				*states[RENDER_TARGET_OPTIONS]=BOTH_WRITE_Z;
				if (StencilBuffer)
				{
					D3DDevice->SetRenderState(D3DRS_ZENABLE,			D3DZB_TRUE);
					D3DDevice->SetRenderState(D3DRS_ZWRITEENABLE,		1);
					D3DDevice->SetRenderState( D3DRS_STENCILENABLE,		TRUE );
					D3DDevice->SetRenderState( D3DRS_STENCILZFAIL,		D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,		D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_SHADEMODE,			D3DSHADE_GOURAUD );
				}
				break;
			};
		}
#endif
#endif
		break;

	case API3D_STENCIL:
#ifdef API3D_DIRECT3D11

		if (StencilBuffer)
		{
			Flush();

			if ((Comment>=STENCIL_SET)&&(Comment<=STENCIL_EQUAL))
			{
				StencilREF=Comment-STENCIL_SET;

				depthStencilState->Release();
				depthStencilDesc.StencilEnable = true;
				depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;
				depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
			}
			else
			if (Comment>=STENCIL_EQUAL)
			{
				StencilREF=Comment-STENCIL_EQUAL;
				depthStencilDesc.StencilEnable = true;
				depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;
				depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_EQUAL;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
			}
			else
			{
				switch (Comment)
				{
				case EQUAL_ONE:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_EQUAL;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case ALWAYS:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = false;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case NOT_ONE:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_NOT_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_NOT_EQUAL;


					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case NOT_ZERO:
					StencilREF=0x0;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_NOT_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_NOT_EQUAL;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case NOT_ZERO_REPLACE:
					StencilREF=0x0;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_NOT_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_NOT_EQUAL;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case LESSEQUAL_ONE:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_LESS_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_LESS_EQUAL;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case GREATEREQUAL_ONE:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_GREATER_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_GREATER_EQUAL;


					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case EQUAL_ZERO:
					StencilREF=0x0;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_EQUAL;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case EQUAL_ZERO_REPLACE:
					StencilREF=0x0;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_EQUAL;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case INCREMENT:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					if (states(ZBUFFER_TEST_STENCIL)==1) depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
					else depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_INCR;
					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case INCREMENTSAT:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					if (states(ZBUFFER_TEST_STENCIL)==1) depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR_SAT;
					else depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_INCR_SAT;
					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case SET_ONE:
					StencilREF=0x1;

					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);

					break;

				case SET_ZERO:
					StencilREF=0x0;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();

					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_REPLACE;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);

					break;

				case DECREMENT:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					if (states(ZBUFFER_TEST_STENCIL)==1) depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
					else depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_DECR;
					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case DECREMENTSAT:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					if (states(ZBUFFER_TEST_STENCIL)==1) depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR_SAT;
					else depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_DECR_SAT;
					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case INVERT:
					StencilREF=0x0;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_INCR;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_ZERO;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_NOT_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_INCR;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_ZERO;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_NOT_EQUAL;
					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;
				};
			}
		}
#else
#ifdef API3D_DIRECT3D10

		if (StencilBuffer)
		{
			Flush();

			if ((Comment>=STENCIL_SET)&&(Comment<=STENCIL_EQUAL))
			{
				StencilREF=Comment-STENCIL_SET;

				depthStencilState->Release();
				depthStencilDesc.StencilEnable = true;
				depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_REPLACE;
				depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, StencilREF);
			}
			else
			if (Comment>=STENCIL_EQUAL)
			{
				StencilREF=Comment-STENCIL_EQUAL;
				depthStencilDesc.StencilEnable = true;
				depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_REPLACE;
				depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_EQUAL;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, StencilREF);
			}
			else
			{
				switch (Comment)
				{
				case EQUAL_ONE:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_EQUAL;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case ALWAYS:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = false;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case NOT_ONE:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_NOT_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_NOT_EQUAL;


					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case NOT_ZERO:
					StencilREF=0x0;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_NOT_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_NOT_EQUAL;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case NOT_ZERO_REPLACE:
					StencilREF=0x0;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_REPLACE;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_NOT_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_REPLACE;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_NOT_EQUAL;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case LESSEQUAL_ONE:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_LESS_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_LESS_EQUAL;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case GREATEREQUAL_ONE:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_GREATER_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_GREATER_EQUAL;


					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case EQUAL_ZERO:
					StencilREF=0x0;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_EQUAL;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case EQUAL_ZERO_REPLACE:
					StencilREF=0x0;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_REPLACE;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_REPLACE;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_EQUAL;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case INCREMENT:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					if (states(ZBUFFER_TEST_STENCIL)==1) depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_INCR;
					else depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_INCR;
					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case INCREMENTSAT:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					if (states(ZBUFFER_TEST_STENCIL)==1) depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_INCR_SAT;
					else depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_INCR_SAT;
					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case SET_ONE:
					StencilREF=0x1;

					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_REPLACE;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_REPLACE;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);

					break;

				case SET_ZERO:
					StencilREF=0x0;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();

					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_REPLACE;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_REPLACE;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);

					break;

				case DECREMENT:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					if (states(ZBUFFER_TEST_STENCIL)==1) depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_DECR;
					else depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_DECR;
					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case DECREMENTSAT:
					StencilREF=0x1;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					if (states(ZBUFFER_TEST_STENCIL)==1) depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_DECR_SAT;
					else depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_DECR_SAT;
					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;

				case INVERT:
					StencilREF=0x0;
					depthStencilDesc.StencilEnable = true;
					if (depthStencilState) depthStencilState->Release();
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_INCR;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_INCR;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_ZERO;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_NOT_EQUAL;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_INCR;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_INCR;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_ZERO;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_NOT_EQUAL;
					device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
					device->OMSetDepthStencilState(depthStencilState, StencilREF);
					break;
				};
			}
		}
#else
		if (StencilBuffer)
		{
			Flush();

			if ((Comment>=STENCIL_SET)&&(Comment<=STENCIL_EQUAL))
			{
				D3DDevice->SetRenderState( D3DRS_STENCILREF,       Comment-STENCIL_SET );
				D3DDevice->SetRenderState( D3DRS_STENCILMASK,      0xffffffff );
				D3DDevice->SetRenderState( D3DRS_STENCILWRITEMASK, 0xffffffff );
				D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_REPLACE );
				D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
			}
			else
			if (Comment>=STENCIL_EQUAL)
			{
				D3DDevice->SetRenderState( D3DRS_STENCILREF,	   Comment-STENCIL_EQUAL );
				D3DDevice->SetRenderState( D3DRS_STENCILFUNC,	   D3DCMP_EQUAL );
				D3DDevice->SetRenderState( D3DRS_STENCILPASS,	   D3DSTENCILOP_REPLACE );
				D3DDevice->SetRenderState( D3DRS_STENCILFAIL,	   D3DSTENCILOP_KEEP );

			}
			else
			{

				switch (Comment)
				{
				case EQUAL_ONE:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x1 );
					D3DDevice->SetRenderState( D3DRS_STENCILFUNC,      D3DCMP_EQUAL );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					break;
				case ALWAYS:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x1 );
					D3DDevice->SetRenderState( D3DRS_STENCILFUNC,      D3DCMP_ALWAYS );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					break;
				case NOT_ONE:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x1 );
					D3DDevice->SetRenderState( D3DRS_STENCILFUNC,      D3DCMP_NOTEQUAL );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					break;

				case NOT_ZERO:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x0 );
					D3DDevice->SetRenderState( D3DRS_STENCILFUNC,      D3DCMP_NOTEQUAL );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );

					break;

				case NOT_ZERO_REPLACE:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x0 );
					D3DDevice->SetRenderState( D3DRS_STENCILFUNC,      D3DCMP_NOTEQUAL );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_REPLACE );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					break;

				case LESSEQUAL_ONE:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x1 );
					D3DDevice->SetRenderState( D3DRS_STENCILFUNC,      D3DCMP_LESSEQUAL );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					break;
				case GREATEREQUAL_ONE:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x1 );
					D3DDevice->SetRenderState( D3DRS_STENCILFUNC,      D3DCMP_GREATEREQUAL );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					break;
				case EQUAL_ZERO:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x0 );
					D3DDevice->SetRenderState( D3DRS_STENCILFUNC,      D3DCMP_EQUAL );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,	   D3DSTENCILOP_KEEP );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					break;

				case EQUAL_ZERO_REPLACE:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x0 );
					D3DDevice->SetRenderState( D3DRS_STENCILFUNC,      D3DCMP_EQUAL );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,	   D3DSTENCILOP_REPLACE );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					break;

				case INCREMENT:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x1 );
					D3DDevice->SetRenderState( D3DRS_STENCILMASK,      0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILWRITEMASK, 0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_INCR );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					if (states(ZBUFFER_TEST_STENCIL)==1) D3DDevice->SetRenderState(D3DRS_STENCILZFAIL,D3DSTENCILOP_INCR);
					break;

				case INCREMENTSAT:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x1 );
					D3DDevice->SetRenderState( D3DRS_STENCILMASK,      0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILWRITEMASK, 0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_INCRSAT );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					break;

				case SET_ONE:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x1 );
					D3DDevice->SetRenderState( D3DRS_STENCILMASK,      0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILWRITEMASK, 0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_REPLACE );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					break;

				case SET_ZERO:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x0 );
					D3DDevice->SetRenderState( D3DRS_STENCILMASK,      0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILWRITEMASK, 0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_REPLACE );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					break;

				case DECREMENT:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x1 );
					D3DDevice->SetRenderState( D3DRS_STENCILMASK,      0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILWRITEMASK, 0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_DECR );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					if (states(ZBUFFER_TEST_STENCIL)==1) D3DDevice->SetRenderState(D3DRS_STENCILZFAIL,D3DSTENCILOP_DECR);
					break;

				case DECREMENTSAT:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x1 );
					D3DDevice->SetRenderState( D3DRS_STENCILMASK,      0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILWRITEMASK, 0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_DECRSAT );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_KEEP );
					break;

				case INVERT:
					D3DDevice->SetRenderState( D3DRS_STENCILREF,       0x0 );
					D3DDevice->SetRenderState( D3DRS_STENCILFUNC,	   D3DCMP_NOTEQUAL );
					D3DDevice->SetRenderState( D3DRS_STENCILMASK,      0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILWRITEMASK, 0xffffffff );
					D3DDevice->SetRenderState( D3DRS_STENCILPASS,      D3DSTENCILOP_ZERO );
					D3DDevice->SetRenderState( D3DRS_STENCILFAIL,      D3DSTENCILOP_INCR );
					D3DDevice->SetRenderState( D3DRS_STENCILZFAIL,     D3DSTENCILOP_INCR );
				
					break;


				};
			}
		}
#endif
#endif
		break;

	case API3D_SECONDARYSURFACE:
		{
			if (Comment==ON) 
			{
				SecondarySurface=true; 
				nSecondaries=1;
			}
			if (Comment==OFF) SecondarySurface=false;
			if (Comment==SCALE) *states[SCALE_SCREEN]=1;
			if (Comment==NO_SCALE) *states[SCALE_SCREEN]=0;

			switch (Comment)
			{
			case SECONDARY1:
				nSecondaries=1;
				SecondarySurface=true; 
				break;
			case SECONDARY2:
				nSecondaries=2;
				SecondarySurface=true; 
				break;
			case SECONDARY3:
				nSecondaries=3;
				SecondarySurface=true; 
				break;
			case SECONDARY4:
				nSecondaries=4;
				SecondarySurface=true; 
				break;
			case SECONDARY5:
				nSecondaries=5;
				SecondarySurface=true; 
				break;
			case SECONDARY6:
				nSecondaries=6;
				SecondarySurface=true; 
				break;
			case SECONDARY7:
				nSecondaries=7;
				SecondarySurface=true; 
				break;
			case SECONDARY8:
				nSecondaries=8;
				SecondarySurface=true; 
				break;
			case SECONDARY9:
				nSecondaries=9;
				SecondarySurface=true; 
				break;
			case SECONDARY10:
				nSecondaries=10;
				SecondarySurface=true; 
				break;
			case SECONDARY11:
				nSecondaries=11;
				SecondarySurface=true; 
				break;
			case SECONDARY12:
				nSecondaries=12;
				SecondarySurface=true; 
				break;
			case SECONDARY13:
				nSecondaries=13;
				SecondarySurface=true; 
				break;
			case SECONDARY14:
				nSecondaries=14;
				SecondarySurface=true; 
				break;
			case SECONDARY15:
				nSecondaries=15;
				SecondarySurface=true; 
				break;
			case SECONDARY16:
				nSecondaries=16;
				SecondarySurface=true; 
				break;
			case SECONDARY17:
				nSecondaries=17;
				SecondarySurface=true; 
				break;
			case SECONDARY18:
				nSecondaries=18;
				SecondarySurface=true; 
				break;
			case SECONDARY19:
				nSecondaries=19;
				SecondarySurface=true; 
				break;
			case SECONDARY20:
				nSecondaries=20;
				SecondarySurface=true; 
				break;
			case SECONDARY21:
				nSecondaries=21;
				SecondarySurface=true; 
				break;
			case SECONDARY22:
				nSecondaries=22;
				SecondarySurface=true; 
				break;
			case SECONDARY23:
				nSecondaries=23;
				SecondarySurface=true; 
				break;
			case SECONDARY24:
				nSecondaries=24;
				SecondarySurface=true; 
				break;
			};

		}
		break;

	case API3D_BLEND:
		{
			
#ifdef API3D_DIRECT3D11
			switch (Comment)
			{

			case BLEND_NO_ALPHA:
				Flush();
				*states[RENDER_BLEND_NO_ALPHA]=((*states[RENDER_BLEND_NO_ALPHA])+1)&1;
				break;

			case OFF:
				if (states(BLENDING)!=0)
				{
					Flush();
					devicecontext->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);
					*states[BLENDING]=0;
				}
				break;

			case ON:
				if (states(BLENDING)!=1)
				{
					Flush();
					devicecontext->OMSetBlendState(blendStateON,factors,0xFFFFFFFF);
					*states[BLENDING]=1;
				}
				break;

			case BLEND_GOURAUD:
				if (states(BLENDING)!=2)
				{
					Flush();
					devicecontext->OMSetBlendState(blendStateGOURAUD,factors,0xFFFFFFFF);
					*states[BLENDING]=2;
				}
				break;

			case BLEND_COLOR:
				if (states(BLENDING)!=3)
				{
					Flush();
					devicecontext->OMSetBlendState(blendStateCOLOR,factors,0xFFFFFFFF);
					*states[BLENDING]=3;
				}
				break;

			case BLEND_INVERSE:
				if (states(BLENDING)!=4)
				{
					Flush();
					devicecontext->OMSetBlendState(blendStateINVERSE,factors,0xFFFFFFFF);
					*states[BLENDING]=4;
				}
				break;

			case BLEND_ADD:
				if (states(BLENDING)!=5)
				{
					Flush();
					devicecontext->OMSetBlendState(blendStateADD,factors,0xFFFFFFFF);
					*states[BLENDING]=5;
				}
				break;
			};

#else
#ifdef API3D_DIRECT3D10
			switch (Comment)
			{

			case BLEND_NO_ALPHA:
				Flush();
				*states[RENDER_BLEND_NO_ALPHA]=((*states[RENDER_BLEND_NO_ALPHA])+1)&1;
				break;

			case OFF:
				if (states(BLENDING)!=0)
				{
					Flush();
					device->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);
					*states[BLENDING]=0;
				}
				break;

			case ON:
				if (states(BLENDING)!=1)
				{
					Flush();
					device->OMSetBlendState(blendStateON,factors,0xFFFFFFFF);
					*states[BLENDING]=1;
				}
				break;

			case BLEND_GOURAUD:
				if (states(BLENDING)!=2)
				{
					Flush();
					device->OMSetBlendState(blendStateGOURAUD,factors,0xFFFFFFFF);
					*states[BLENDING]=2;
				}
				break;

			case BLEND_COLOR:
				if (states(BLENDING)!=3)
				{
					Flush();
					device->OMSetBlendState(blendStateCOLOR,factors,0xFFFFFFFF);
					*states[BLENDING]=3;
				}
				break;

			case BLEND_INVERSE:
				if (states(BLENDING)!=4)
				{
					Flush();
					device->OMSetBlendState(blendStateINVERSE,factors,0xFFFFFFFF);
					*states[BLENDING]=4;
				}
				break;

			case BLEND_ADD:
				if (states(BLENDING)!=5)
				{
					Flush();
					device->OMSetBlendState(blendStateADD,factors,0xFFFFFFFF);
					*states[BLENDING]=5;
				}
				break;
			};

#else
			switch (Comment)
			{
			case BLEND_NO_ALPHA:
				Flush();
				*states[RENDER_BLEND_NO_ALPHA]=((*states[RENDER_BLEND_NO_ALPHA])+1)&1;
				break;
				
			case OFF:
				if (states(BLENDING)!=0)
				{
					Flush();
					D3DDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);
					*states[BLENDING]=0;
				}
				break;
			case ON:
				if (states(BLENDING)!=1)
				{
					Flush();
					D3DDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,TRUE);
					D3DDevice->SetRenderState(D3DRS_SRCBLEND,D3DBLEND_SRCALPHA);
					D3DDevice->SetRenderState(D3DRS_DESTBLEND,D3DBLEND_INVSRCALPHA);
					D3DDevice->SetRenderState(D3DRS_SRCBLENDALPHA,D3DBLEND_SRCALPHA);
					D3DDevice->SetRenderState(D3DRS_DESTBLENDALPHA,D3DBLEND_INVSRCALPHA);
					*states[BLENDING]=1;
				}
				break;
			case BLEND_GOURAUD:
				if (states(BLENDING)!=2)
				{
					Flush();
					D3DDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,TRUE);
					D3DDevice->SetRenderState(D3DRS_SRCBLEND,D3DBLEND_SRCALPHA);
					D3DDevice->SetRenderState(D3DRS_DESTBLEND,D3DBLEND_ONE);
					D3DDevice->SetRenderState(D3DRS_SRCBLENDALPHA,D3DBLEND_SRCALPHA);
					D3DDevice->SetRenderState(D3DRS_DESTBLENDALPHA,D3DBLEND_ONE);
					*states[BLENDING]=2;
				}
				break;

			case BLEND_COLOR:
				if (states(BLENDING)!=3)
				{
					Flush();
					D3DDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,TRUE);
					D3DDevice->SetRenderState(D3DRS_SRCBLEND,D3DBLEND_DESTCOLOR);
					D3DDevice->SetRenderState(D3DRS_DESTBLEND,D3DBLEND_ZERO);
					D3DDevice->SetRenderState(D3DRS_SRCBLENDALPHA,D3DBLEND_DESTCOLOR);
					D3DDevice->SetRenderState(D3DRS_DESTBLENDALPHA,D3DBLEND_ZERO);
					*states[BLENDING]=3;
				}
				break;

			case BLEND_INVERSE:
				if (states(BLENDING)!=4)
				{
					Flush();
					D3DDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,TRUE);
					D3DDevice->SetRenderState(D3DRS_SRCBLEND,D3DBLEND_INVSRCALPHA);
					D3DDevice->SetRenderState(D3DRS_DESTBLEND,D3DBLEND_SRCALPHA);
					D3DDevice->SetRenderState(D3DRS_SRCBLENDALPHA,D3DBLEND_INVSRCALPHA);
					D3DDevice->SetRenderState(D3DRS_DESTBLENDALPHA,D3DBLEND_SRCALPHA);
					*states[BLENDING]=4;
				}
				break;

			case BLEND_ADD:
				if (states(BLENDING)!=5)
				{
					Flush();
					D3DDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,TRUE);
					D3DDevice->SetRenderState(D3DRS_SRCBLEND,D3DBLEND_ONE);
					D3DDevice->SetRenderState(D3DRS_DESTBLEND,D3DBLEND_ONE);
					D3DDevice->SetRenderState(D3DRS_SRCBLENDALPHA,D3DBLEND_ONE);
					D3DDevice->SetRenderState(D3DRS_DESTBLENDALPHA,D3DBLEND_ONE);
					*states[BLENDING]=5;
				}
				break;
			};
#endif
#endif
		}
		break;

	case API3D_CREATETEXTURE:
		{

			switch (Comment)
			{
#if !defined(API3D_DIRECT3D10)&&!defined(API3D_DIRECT3D11)
			case TEXTURE16BITS:
				*states[TEXTURES_32BITS]=0;
				break;
			case TEXTURE32BITS:
				*states[TEXTURES_32BITS]=1;
				break;
#endif
			case CLAMP:
				*states[TEXTURES_CLAMPING]=1;
				break;
			case REPEAT:
				*states[TEXTURES_CLAMPING]=0;
				break;
			case MIPMAP:
				*states[TEXTURES_MIPMAP_ACTIVE]=1;
				break;
			case NO_MIPMAP:
				*states[TEXTURES_MIPMAP_ACTIVE]=0;
				break;
#if !defined(API3D_DIRECT3D10)&&!defined(API3D_DIRECT3D11)
			case DOUBLETEXTURAGE:
				DoubleTexture=(DoubleTexture+1)&1;
				break;
			case DITHERING:
				*states[TEXTURES_DITHERING]=1;
				break;
			case NODITHERING:
				*states[TEXTURES_DITHERING]=0;
				break;
#endif
			};
		}
		break;

	case API3D_ZBUFFER:
		{
			Flush();

			*states[ZBUFFERING]=Comment;
			switch (Comment)
			{
			case WRITEOFF:
#ifdef API3D_DIRECT3D11
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
#ifdef API3D_DIRECT3D10
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthWriteMask = D3D10_DEPTH_WRITE_MASK_ZERO;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
				D3DDevice->SetRenderState(D3DRS_ZWRITEENABLE,0);
#endif
#endif
				break;
			case LESS:
#ifdef API3D_DIRECT3D11
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
#ifdef API3D_DIRECT3D10
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D10_COMPARISON_LESS;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
				D3DDevice->SetRenderState(D3DRS_ZFUNC,D3DCMP_LESS);
#endif
#endif
				break;
			case ALWAYS:
#ifdef API3D_DIRECT3D11
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D11_COMPARISON_ALWAYS;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
#ifdef API3D_DIRECT3D10
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D10_COMPARISON_ALWAYS;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
				D3DDevice->SetRenderState(D3DRS_ZFUNC,D3DCMP_ALWAYS);
#endif
#endif
				break;
			case GREATER:
#ifdef API3D_DIRECT3D11
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D11_COMPARISON_GREATER;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
#ifdef API3D_DIRECT3D10
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D10_COMPARISON_GREATER;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
				D3DDevice->SetRenderState(D3DRS_ZFUNC,D3DCMP_GREATER);
#endif
#endif
				break;

			case REINIT:
			case LESSEQUAL:
#ifdef API3D_DIRECT3D11
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;

				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
#ifdef API3D_DIRECT3D10
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D10_COMPARISON_LESS_EQUAL;

				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
				D3DDevice->SetRenderState(D3DRS_ZFUNC,D3DCMP_LESSEQUAL);
#endif
#endif
				break;
			case GREATEREQUAL:
#ifdef API3D_DIRECT3D11
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D11_COMPARISON_GREATER_EQUAL;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
#ifdef API3D_DIRECT3D10
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D10_COMPARISON_GREATER_EQUAL;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
				D3DDevice->SetRenderState(D3DRS_ZFUNC,D3DCMP_GREATEREQUAL);
#endif
#endif
				break;
			case EQUAL:
#ifdef API3D_DIRECT3D11
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D11_COMPARISON_EQUAL;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
#ifdef API3D_DIRECT3D10
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D10_COMPARISON_EQUAL;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
				D3DDevice->SetRenderState(D3DRS_ZFUNC,D3DCMP_EQUAL);
#endif
#endif
				break;
			case NOTEQUAL:
#ifdef API3D_DIRECT3D11
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D11_COMPARISON_NOT_EQUAL;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
#ifdef API3D_DIRECT3D10
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthFunc = D3D10_COMPARISON_NOT_EQUAL;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
				D3DDevice->SetRenderState(D3DRS_ZFUNC,D3DCMP_NOTEQUAL);
#endif
#endif
				break;
			case ON:
			case ENABLE:
#ifdef API3D_DIRECT3D11
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthEnable = true;
				depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
#ifdef API3D_DIRECT3D10
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthEnable = true;
				depthStencilDesc.DepthWriteMask = D3D10_DEPTH_WRITE_MASK_ALL;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
				D3DDevice->SetRenderState(D3DRS_ZENABLE,D3DZB_TRUE);
				D3DDevice->SetRenderState(D3DRS_ZWRITEENABLE,1);
#endif
#endif
				break;
			case OFF:
			case DISABLE:
#ifdef API3D_DIRECT3D11
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthEnable = false;
				depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
#ifdef API3D_DIRECT3D10
				if (depthStencilState) depthStencilState->Release();
				depthStencilDesc.DepthEnable = false;
				depthStencilDesc.DepthWriteMask = D3D10_DEPTH_WRITE_MASK_ZERO;
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, StencilREF);
#else
				D3DDevice->SetRenderState(D3DRS_ZENABLE,D3DZB_FALSE);
				D3DDevice->SetRenderState(D3DRS_ZWRITEENABLE,0);
#endif
#endif
				break;
			};
		}
		break;

	case API3D_SHADING:
		{
		}
		break;

	case API3D_CULL:
		{
			
			switch (Comment)
			{
			case ON:
				*states[CULLING]=-1;
				break;
			case OFF:
				Flush();
				*states[CULLING]=-1;
#ifdef API3D_DIRECT3D11
				if (rasterState) rasterState->Release();
				rasterDesc.CullMode = D3D11_CULL_NONE;
				device->CreateRasterizerState(&rasterDesc, &rasterState);
				devicecontext->RSSetState(rasterState);
#else
#ifdef API3D_DIRECT3D10
				rasterState->Release();
				rasterDesc.CullMode = D3D10_CULL_NONE;
				device->CreateRasterizerState(&rasterDesc, &rasterState);
				device->RSSetState(rasterState);
#else
				D3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );
#endif
#endif
				break;
			case CW:
				if (states(CULLING)!=0)
				{
					Flush();
					*states[CULLING]=0;
#ifdef API3D_DIRECT3D11
					if (rasterState) rasterState->Release();
					rasterDesc.CullMode = D3D11_CULL_FRONT;
					device->CreateRasterizerState(&rasterDesc, &rasterState);
					devicecontext->RSSetState(rasterState);
#else
#ifdef API3D_DIRECT3D10
					rasterState->Release();
					rasterDesc.CullMode = D3D10_CULL_FRONT;
					device->CreateRasterizerState(&rasterDesc, &rasterState);
					device->RSSetState(rasterState);
#else
					D3DDevice->SetRenderState(D3DRS_CULLMODE,D3DCULL_CW);
#endif
#endif		
				}
				break;
			case CCW:
				if (states(CULLING)!=1)
				{
					Flush();
					*states[CULLING]=1;
#ifdef API3D_DIRECT3D11
					if (rasterState) rasterState->Release();
					rasterDesc.CullMode = D3D11_CULL_BACK;
					device->CreateRasterizerState(&rasterDesc, &rasterState);
					devicecontext->RSSetState(rasterState);
#else
#ifdef API3D_DIRECT3D10
					rasterState->Release();
					rasterDesc.CullMode = D3D10_CULL_BACK;
					device->CreateRasterizerState(&rasterDesc, &rasterState);
					device->RSSetState(rasterState);
#else
					D3DDevice->SetRenderState(D3DRS_CULLMODE,D3DCULL_CCW);
#endif
#endif
				}
				break;
			};
		}
		break;

	case API3D_SHADERS:
		if (Comment==DYNAMIC_ENV) *states[SHADERS]=1;
		if (Comment==FIXED_ENV) *states[SHADERS]=0;
		break;

	case API3D_TEXTURING:
		{
			Flush();
#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)

			switch (Comment)
			{
			case T_MODULATE:
				LevelTexture0=0;
				break;
			case T_ADD:
				LevelTexture0=1;
				break;
			};

#else
			switch (Comment)
			{
			case WRAP:
				D3DDevice->SetRenderState(D3DRS_WRAP0,D3DWRAP_U|D3DWRAP_V);
				D3DDevice->SetRenderState(D3DRS_WRAP1,D3DWRAP_U|D3DWRAP_V);
				break;
			case NO_WRAP:
				D3DDevice->SetRenderState(D3DRS_WRAP0,0);
				D3DDevice->SetRenderState(D3DRS_WRAP1,0);
				break;
			case ON:
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
				break;
			case OFF:
				aT=-555; aT2=-555; aT3=-555; aT4=-555;
				aT5=-555; aT6=-555; aT7=-555; aT8=-555;
				D3DDevice->SetTexture(0,NULL);
				D3DDevice->SetTexture(1,NULL);
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
				break;
			case T_MODULATE:
				LevelTexture0=D3DTOP_MODULATE;
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
				break;
			case T_ADD:
				LevelTexture0=D3DTOP_ADD;
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_ADD );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
				break;

			};
#endif
		}
		break;
	case API3D_FILL:
#ifdef API3D_DIRECT3D11
		if (Comment==WIREFRAME)
		{
			if (rasterState) rasterState->Release();
			rasterDesc.FillMode = D3D11_FILL_WIREFRAME;
			device->CreateRasterizerState(&rasterDesc, &rasterState);
			devicecontext->RSSetState(rasterState);
		}

		if (Comment==SOLID)
		{
			if (rasterState) rasterState->Release();
			rasterDesc.FillMode = D3D11_FILL_SOLID;
			device->CreateRasterizerState(&rasterDesc, &rasterState);
			devicecontext->RSSetState(rasterState);
		}
#else
#ifdef API3D_DIRECT3D10
		if (Comment==WIREFRAME)
		{
			rasterState->Release();
			rasterDesc.FillMode = D3D10_FILL_WIREFRAME;
			device->CreateRasterizerState(&rasterDesc, &rasterState);
			device->RSSetState(rasterState);
		}

		if (Comment==SOLID)
		{
			rasterState->Release();
			rasterDesc.FillMode = D3D10_FILL_SOLID;
			device->CreateRasterizerState(&rasterDesc, &rasterState);
			device->RSSetState(rasterState);
		}
#else
		if (Comment==WIREFRAME)
		{
			D3DDevice->SetRenderState(D3DRS_FILLMODE,D3DFILL_WIREFRAME);
		}

		if (Comment==SOLID)
		{
			D3DDevice->SetRenderState(D3DRS_FILLMODE,D3DFILL_SOLID);
		}
#endif
#endif
		break;
	case API3D_TEXTURING2:
		{

#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)

			switch (Comment)
			{
			case T_MODULATE:
				LevelTexture1=0;
				break;
			case T_ADD:
				LevelTexture1=1;
				break;
			};

#else
			switch (Comment)
			{
			case ON:
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );
				break;
			case OFF:
				D3DDevice->SetTexture(0,NULL);
				D3DDevice->SetTexture(1,NULL);
				aT=-555; aT2=-555; aT3=-555; aT4=-555;
				aT5=-555; aT6=-555; aT7=-555; aT8=-555;
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
				D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
				break;
			case T_MODULATE:
				LevelTexture1=D3DTOP_MODULATE;
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_MODULATE );
				break;
			case T_ADD:
				LevelTexture1=D3DTOP_ADD;
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_ADD );
				break;
			}
#endif
		}
		break;	
	};
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		open gl : color blend

  (obsolete)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::SetColorBlend(float r,float g,float b,float a)
{
//------------------------------------------------------------------------------------------------ OPEN GL -----------
#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
	RGBA[0]=r;
	RGBA[1]=g;
	RGBA[2]=b;
	RGBA[3]=a;
#endif

}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function:

		projection matrix D3D
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#ifdef API3D_DIRECT3D
void ProjectionMatrix(D3DMATRIX * ret,float n,float f,float fov)
{
    float    h, w, Q;
 
    w=(float) ((float) 1/tan(fov*0.5));  
    h=(float) ((float) 1/tan(fov*0.5));  
	Q=f/(f-n);
 
    ret->_12=0;
	ret->_13=0;
	ret->_14=0;

	ret->_21=0;
	ret->_23=0;
	ret->_24=0;

	ret->_31=0;
	ret->_32=0;
	ret->_41=0;
	ret->_42=0;
	ret->_44=0;


	ret->_11=w;
	ret->_22=h;
	ret->_33=Q;
	ret->_43=-Q*n;
	ret->_34=1;

}  
#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		set projection matrix

		void C3DAPIBASE::SetProjection()

	Note: for secondary render target, SCALE,NO_SCALE is used to simulate primary surface aspect
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */
#if defined(GLES)
void gluPerspective(float fFov,float fAspect,float fNear,float fFar)
{
	float xmin, xmax, ymin, ymax;

	ymax = fNear * float(tan( fFov * PI / 360.0 ));
	ymin = -ymax;
	xmin = ymin * fAspect;
	xmax = -xmin;

	glFrustumf( xmin, xmax, ymin, ymax, fNear, fFar );
}
#endif

#if defined(API3D_OPENGL20)
void glProjPerspective(GLfloat *proj,float fov,float aspect,float zn,float zf)
{
	float ymax, xmax;
    ymax = zn * tanf(fov * PI / 360.0f);
    xmax = ymax * aspect;
	float left=-xmax;
	float right=xmax;
	float bottom=-ymax;
	float top=ymax;
    float temp, temp2, temp3, temp4;
    temp = 2.0f * zn;
    temp2 = right - left;
    temp3 = top - bottom;
    temp4 = zf - zn;
    proj[0] = temp / temp2;
    proj[1] = 0.0f;
    proj[2] = 0.0f;
    proj[3] = 0.0f;
    proj[4] = 0.0f;
    proj[5] = temp / temp3;
    proj[6] = 0.0f;
    proj[7] = 0.0f;
    proj[8] = (right + left) / temp2;
    proj[9] = (top + bottom) / temp3;
    proj[10] = (-zf - zn) / temp4;
    proj[11] = -1.0f;
    proj[12] = 0.0f;
    proj[13] = 0.0f;
    proj[14] = (-temp * zf) / temp4;
    proj[15] = 0.0f;
}
#endif

void C3DAPIBASE::SetProjection()
{
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
	UpdateLines();
#endif

	if (states(RENDER_TARGET)==PRIMARY)
	{
		projSCREENX=-1;
		projSCREENY=-1;
	}

#ifdef API3D_VR

	PROJ=BASEPROJ;
	pPROJ=PROJ;

	for (int i=0;i<4;i++)
		for (int j=0;j<4;j++) projection[i+4*j]=PROJ.a[j][i];

	PROJ.a[0][0]=-PROJ.a[0][0];
	PROJ.a[1][1]=-PROJ.a[1][1];
	PROJ.a[2][2]=-PROJ.a[2][2];
	
	PROJ.a[2][1]=-PROJ.a[2][1];

	return;
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	float Fov;
	GLfloat proj[16];
	int i,j;
#ifdef API3D_OPENGL20

    if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN))) Fov=(float) (2*360*atan((float) SCREEN_Y/(2*Distance))/(2*3.14159));
	else Fov=(float) (2*360*atan((float) SCREEN_Y/(2*Distance))/(2*3.14159));

	if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN)))
		glProjPerspective(proj,Fov,(float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y,Front,Back);
	else
		glProjPerspective(proj,Fov,1.0f,Front,Back);

	for (i=0;i<4;i++)
		for (j=0;j<4;j++) 
		{
			projection[i+4*j]=PROJ.a[j][i]=proj[i+4*j];
		}

	pPROJ=PROJ;
	
	PROJ.a[0][0]=-proj[0+4*0]; 
	PROJ.a[1][1]=-proj[1+4*1]; 
	PROJ.a[2][2]=-proj[2+4*2];

#else
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	Fov=(float) (2*360*atan((float) SCREEN_Y/(2*Distance))/(2*3.14159));

	if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN)))
		gluPerspective(Fov,(float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y,Front,Back);
	else
		gluPerspective(Fov,1.0f,Front,Back);
	
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glGetFloatv(GL_PROJECTION_MATRIX, proj);

	for (i=0;i<4;i++)
		for (j=0;j<4;j++) 
		{
			PROJ.a[j][i]=proj[i+4*j];
		}
	
	pPROJ=PROJ;

	PROJ.a[0][0]=-proj[0+4*0]; 
	PROJ.a[1][1]=-proj[1+4*1]; 
	PROJ.a[2][2]=-proj[2+4*2]; 
#endif
#endif


#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -------------
	float Fov=(float) (2*atan((float) SCREEN_Y/(2*Distance)));

	worldMatrix.Id();
	viewMatrix.Id();

	if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN))) MatrixPerspectiveFovLH( &PROJ, Fov, (float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y, Front, Back );
	else MatrixPerspectiveFovLH( &PROJ, Fov, 1.0f, Front, Back );
		
	projectionMatrix=PROJ;
	pPROJ=PROJ;

#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------

#if defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)
	float Fov;

	Fov=(float) (2*atan((float) SCREEN_Y/(2*Distance)));

	worldMatrix.Id();
	viewMatrix.Id();

	if ((SelectedRenderTarget==PRIMARY)||(states(SCALE_SCREEN))) MatrixPerspectiveFovLH( &PROJ, Fov, (float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y, Front, Back );
	else MatrixPerspectiveFovLH( &PROJ, Fov, 1.0f, Front, Back );
		
	projectionMatrix=PROJ;
	pPROJ=PROJ;
#else
#ifdef API3D_DIRECT3D10
	float Fov;
	D3DXMATRIX Id,proj;

	Fov=(float) (2*atan((float) SCREEN_Y/(2*Distance)));
	D3DXMatrixIdentity(&Id);

	worldMatrix=Id;
	viewMatrix=Id;

	if ((SelectedRenderTarget==PRIMARY)||(states(SCALE_SCREEN))) D3DXMatrixPerspectiveFovLH( &proj, Fov, (float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y, Front, Back );
	else D3DXMatrixPerspectiveFovLH( &proj, Fov, 1.0f, Front, Back );
		
	projectionMatrix=proj;

	PROJ.a[0][0]=proj._11;	PROJ.a[1][0]=proj._21;	PROJ.a[2][0]=proj._31;	PROJ.a[3][0]=proj._41;
	PROJ.a[0][1]=proj._12;	PROJ.a[1][1]=proj._22;	PROJ.a[2][1]=proj._32;	PROJ.a[3][1]=proj._42;
	PROJ.a[0][2]=proj._13;	PROJ.a[1][2]=proj._23;	PROJ.a[2][2]=proj._33;	PROJ.a[3][2]=proj._43;
	PROJ.a[0][3]=proj._14;	PROJ.a[1][3]=proj._24;	PROJ.a[2][3]=proj._34;	PROJ.a[3][3]=proj._44;

	pPROJ=PROJ;

#else
	float Fov;
	D3DXMATRIX Id,proj;

	Fov=(float) (2*atan((float) SCREEN_Y/(2*Distance)));
	D3DXMatrixIdentity(&Id);
	D3DDevice->SetTransform(D3DTS_WORLD,&Id);
	D3DDevice->SetTransform(D3DTS_VIEW,&Id);

	if ((SelectedRenderTarget==PRIMARY)||(states(SCALE_SCREEN))) D3DXMatrixPerspectiveFovLH( &proj, Fov, (float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y, Front, Back );
	else D3DXMatrixPerspectiveFovLH( &proj, Fov, 1.0f, Front, Back );
		
	D3DDevice->SetTransform(D3DTS_PROJECTION,&proj);
	PROJ.a[0][0]=proj._11;	PROJ.a[1][0]=proj._21;	PROJ.a[2][0]=proj._31;	PROJ.a[3][0]=proj._41;
	PROJ.a[0][1]=proj._12;	PROJ.a[1][1]=proj._22;	PROJ.a[2][1]=proj._32;	PROJ.a[3][1]=proj._42;
	PROJ.a[0][2]=proj._13;	PROJ.a[1][2]=proj._23;	PROJ.a[2][2]=proj._33;	PROJ.a[3][2]=proj._43;
	PROJ.a[0][3]=proj._14;	PROJ.a[1][3]=proj._24;	PROJ.a[2][3]=proj._34;	PROJ.a[3][3]=proj._44;

	pPROJ=PROJ;
#endif
#endif
#endif
}


void C3DAPIBASE::SetProjectionFov(float Fov)
{
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif

#ifdef API3D_VR

	PROJ=BASEPROJ;
	pPROJ=PROJ;

	for (int i=0;i<4;i++)
		for (int j=0;j<4;j++) projection[i+4*j]=PROJ.a[j][i];

	
	PROJ.a[0][0]=-PROJ.a[0][0];
	PROJ.a[1][1]=-PROJ.a[1][1];
	PROJ.a[2][2]=-PROJ.a[2][2];
	
	PROJ.a[2][1]=-PROJ.a[2][1];
	return;
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	GLfloat proj[16];
	int i,j;
#ifdef API3D_OPENGL20

	if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN)))
		glProjPerspective(proj,Fov,(float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y,Front,Back);
	else
		glProjPerspective(proj,Fov,1.0f,Front,Back);

	for (i=0;i<4;i++)
		for (j=0;j<4;j++) 
		{
			projection[i+4*j]=PROJ.a[j][i]=proj[i+4*j];
		}
	
	pPROJ=PROJ;

	PROJ.a[0][0]=-proj[0+4*0]; 
	PROJ.a[1][1]=-proj[1+4*1]; 
	PROJ.a[2][2]=-proj[2+4*2];

#else
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN)))
		gluPerspective(Fov,(float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y,Front,Back);
	else
		gluPerspective(Fov,1.0f,Front,Back);
	
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glGetFloatv(GL_PROJECTION_MATRIX, proj);

	for (i=0;i<4;i++)
		for (j=0;j<4;j++) 
		{
			PROJ.a[j][i]=proj[i+4*j];
		}
	
	pPROJ=PROJ;

	PROJ.a[0][0]=-proj[0+4*0]; 
	PROJ.a[1][1]=-proj[1+4*1]; 
	PROJ.a[2][2]=-proj[2+4*2]; 
#endif
#endif

#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -------------
	float rFov=(2*PI)*Fov/360.0f;

	worldMatrix.Id();
	viewMatrix.Id();

	if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN))) MatrixPerspectiveFovLH( &PROJ, rFov, (float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y, Front, Back );
	else MatrixPerspectiveFovLH( &PROJ, rFov, 1.0f, Front, Back );
		
	projectionMatrix=PROJ;
	pPROJ=PROJ;
#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	float rFov=(2*PI)*Fov/360.0f;
#if defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)

	worldMatrix.Id();
	viewMatrix.Id();

	if ((SelectedRenderTarget==PRIMARY)||(states(SCALE_SCREEN))) MatrixPerspectiveFovLH( &PROJ, rFov, (float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y, Front, Back );
	else MatrixPerspectiveFovLH( &PROJ, rFov, 1.0f, Front, Back );
		
	projectionMatrix=PROJ;
	pPROJ=PROJ;
#else
#ifdef API3D_DIRECT3D10
	D3DXMATRIX Id,proj;

	D3DXMatrixIdentity(&Id);

	worldMatrix=Id;
	viewMatrix=Id;

	if ((SelectedRenderTarget==PRIMARY)||(states(SCALE_SCREEN))) D3DXMatrixPerspectiveFovLH( &proj, rFov, (float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y, Front, Back );
	else D3DXMatrixPerspectiveFovLH( &proj, rFov, 1.0f, Front, Back );
		
	projectionMatrix=proj;

	PROJ.a[0][0]=proj._11;	PROJ.a[1][0]=proj._21;	PROJ.a[2][0]=proj._31;	PROJ.a[3][0]=proj._41;
	PROJ.a[0][1]=proj._12;	PROJ.a[1][1]=proj._22;	PROJ.a[2][1]=proj._32;	PROJ.a[3][1]=proj._42;
	PROJ.a[0][2]=proj._13;	PROJ.a[1][2]=proj._23;	PROJ.a[2][2]=proj._33;	PROJ.a[3][2]=proj._43;
	PROJ.a[0][3]=proj._14;	PROJ.a[1][3]=proj._24;	PROJ.a[2][3]=proj._34;	PROJ.a[3][3]=proj._44;

	pPROJ=PROJ;
#else
	D3DXMATRIX Id,proj;

	D3DXMatrixIdentity(&Id);
	D3DDevice->SetTransform(D3DTS_WORLD,&Id);
	D3DDevice->SetTransform(D3DTS_VIEW,&Id);

	if ((SelectedRenderTarget==PRIMARY)||(states(SCALE_SCREEN))) D3DXMatrixPerspectiveFovLH( &proj, rFov, (float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y, Front, Back );
	else D3DXMatrixPerspectiveFovLH( &proj, rFov, 1.0f, Front, Back );
		
	D3DDevice->SetTransform(D3DTS_PROJECTION,&proj);
	PROJ.a[0][0]=proj._11;	PROJ.a[1][0]=proj._21;	PROJ.a[2][0]=proj._31;	PROJ.a[3][0]=proj._41;
	PROJ.a[0][1]=proj._12;	PROJ.a[1][1]=proj._22;	PROJ.a[2][1]=proj._32;	PROJ.a[3][1]=proj._42;
	PROJ.a[0][2]=proj._13;	PROJ.a[1][2]=proj._23;	PROJ.a[2][2]=proj._33;	PROJ.a[3][2]=proj._43;
	PROJ.a[0][3]=proj._14;	PROJ.a[1][3]=proj._24;	PROJ.a[2][3]=proj._34;	PROJ.a[3][3]=proj._44;

	pPROJ=PROJ;
#endif
#endif
#endif
}

void C3DAPIBASE::SetProjectionFov(float Fov,float aspect)
{
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif

#ifdef API3D_VR
    
    PROJ=BASEPROJ;
    pPROJ=PROJ;
    
    for (int i=0;i<4;i++)
        for (int j=0;j<4;j++) projection[i+4*j]=PROJ.a[j][i];
    
    
    PROJ.a[0][0]=-PROJ.a[0][0];
    PROJ.a[1][1]=-PROJ.a[1][1];
    PROJ.a[2][2]=-PROJ.a[2][2];
    
    PROJ.a[2][1]=-PROJ.a[2][1];
    return;
#endif
    
#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
    //------------------------------------------------------------------------------------------------ OPEN GL -----------
    GLfloat proj[16];
    int i,j;
#ifdef API3D_OPENGL20
    
    glProjPerspective(proj,Fov,aspect,Front,Back);
    
    for (i=0;i<4;i++)
        for (j=0;j<4;j++)
        {
            projection[i+4*j]=PROJ.a[j][i]=proj[i+4*j];
        }
    
    pPROJ=PROJ;
    
    PROJ.a[0][0]=-proj[0+4*0];
    PROJ.a[1][1]=-proj[1+4*1];
    PROJ.a[2][2]=-proj[2+4*2];
    
#else
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    
    gluPerspective(Fov,aspect,Front,Back);
    
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    
    glGetFloatv(GL_PROJECTION_MATRIX, proj);
    
    for (i=0;i<4;i++)
        for (j=0;j<4;j++)
        {
            PROJ.a[j][i]=proj[i+4*j];
        }
    
    pPROJ=PROJ;
    
    PROJ.a[0][0]=-proj[0+4*0];
    PROJ.a[1][1]=-proj[1+4*1];
    PROJ.a[2][2]=-proj[2+4*2];
#endif
#endif
    
#ifdef API3D_METAL
    //------------------------------------------------------------------------------------------------ METAL -------------
    float rFov=(2*PI)*Fov/360.0f;
    
    worldMatrix.Id();
    viewMatrix.Id();
    
    MatrixPerspectiveFovLH( &PROJ, rFov, aspect, Front, Back );
    
    projectionMatrix=PROJ;
    pPROJ=PROJ;
#endif
    
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
    //------------------------------------------------------------------------------------------------ DIRECT3D ----------
    float rFov=(2*PI)*Fov/360.0f;
#if defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)
    
    worldMatrix.Id();
    viewMatrix.Id();
    
    MatrixPerspectiveFovLH( &PROJ, rFov, aspect, Front, Back );
    
    projectionMatrix=PROJ;
    pPROJ=PROJ;
#else
#ifdef API3D_DIRECT3D10
    D3DXMATRIX Id,proj;
    
    D3DXMatrixIdentity(&Id);
    
    worldMatrix=Id;
    viewMatrix=Id;
    
    D3DXMatrixPerspectiveFovLH( &proj, rFov, aspect, Front, Back );
    
    projectionMatrix=proj;
    
    PROJ.a[0][0]=proj._11;    PROJ.a[1][0]=proj._21;    PROJ.a[2][0]=proj._31;    PROJ.a[3][0]=proj._41;
    PROJ.a[0][1]=proj._12;    PROJ.a[1][1]=proj._22;    PROJ.a[2][1]=proj._32;    PROJ.a[3][1]=proj._42;
    PROJ.a[0][2]=proj._13;    PROJ.a[1][2]=proj._23;    PROJ.a[2][2]=proj._33;    PROJ.a[3][2]=proj._43;
    PROJ.a[0][3]=proj._14;    PROJ.a[1][3]=proj._24;    PROJ.a[2][3]=proj._34;    PROJ.a[3][3]=proj._44;
    
    pPROJ=PROJ;
#else
    D3DXMATRIX Id,proj;
    
    D3DXMatrixIdentity(&Id);
    D3DDevice->SetTransform(D3DTS_WORLD,&Id);
    D3DDevice->SetTransform(D3DTS_VIEW,&Id);
    
    D3DXMatrixPerspectiveFovLH( &proj, rFov, aspect, Front, Back );
    
    D3DDevice->SetTransform(D3DTS_PROJECTION,&proj);
    PROJ.a[0][0]=proj._11;    PROJ.a[1][0]=proj._21;    PROJ.a[2][0]=proj._31;    PROJ.a[3][0]=proj._41;
    PROJ.a[0][1]=proj._12;    PROJ.a[1][1]=proj._22;    PROJ.a[2][1]=proj._32;    PROJ.a[3][1]=proj._42;
    PROJ.a[0][2]=proj._13;    PROJ.a[1][2]=proj._23;    PROJ.a[2][2]=proj._33;    PROJ.a[3][2]=proj._43;
    PROJ.a[0][3]=proj._14;    PROJ.a[1][3]=proj._24;    PROJ.a[2][3]=proj._34;    PROJ.a[3][3]=proj._44;
    
    pPROJ=PROJ;
#endif
#endif
#endif
}

void C3DAPIBASE::SetProjection2()
{
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif

#ifdef API3D_VR

	PROJ=BASEPROJ;
	pPROJ=PROJ;

	for (int i=0;i<4;i++)
		for (int j=0;j<4;j++) projection[i+4*j]=PROJ.a[j][i];
	
	PROJ.a[0][0]=-PROJ.a[0][0];
	PROJ.a[1][1]=-PROJ.a[1][1];
	PROJ.a[2][2]=-PROJ.a[2][2];
	
	PROJ.a[2][1]=-PROJ.a[2][1];

	return;
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	float Fov;
	GLfloat proj[16];
	int i,j;
#ifdef API3D_OPENGL20
    if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN))) Fov=(float) (2*360*atan((float) SCREEN_Y/(2*Distance))/(2*3.14159));
	else Fov=(float) (2*360*atan((float) SCREEN_Y/(2*Distance))/(2*3.14159));

	if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN)))
		glProjPerspective(proj,Fov,(float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y,Front,Back);
	else
		glProjPerspective(proj,Fov,1.0f,Front,Back);

	for (i=0;i<4;i++)
		for (j=0;j<4;j++) 
		{
			projection[i+4*j]=PROJ.a[j][i]=proj[i+4*j];
		}
	
	pPROJ=PROJ;

	PROJ.a[0][0]=-proj[0+4*0]; 
	PROJ.a[1][1]=-proj[1+4*1]; 
	PROJ.a[2][2]=-proj[2+4*2]; 
#else
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	Fov=(float) (2*360*atan((float) SCREEN_Y/(2*Distance))/(2*3.14159));

	if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN)))
		gluPerspective(Fov,(float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y,Front,Back);
	else
		gluPerspective(Fov,1.0f,Front,Back);

	glGetFloatv(GL_PROJECTION_MATRIX, proj);

	for (i=0;i<4;i++)
	for (j=0;j<4;j++) 
	{
		PROJ.a[j][i]=proj[i+4*j]; 
	}

	pPROJ=PROJ;

	PROJ.a[0][0]=-proj[0+4*0]; 
	PROJ.a[1][1]=-proj[1+4*1]; 
	PROJ.a[2][2]=-proj[2+4*2]; 
#endif
#endif

#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -------------
	float Fov;

	Fov=(float) (2*atan((float) SCREEN_Y/(2*Distance)));

	if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN))) MatrixPerspectiveFovLH( &PROJ, Fov, (float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y, Front, Back );
	else MatrixPerspectiveFovLH( &PROJ, Fov, 1.0f, Front, Back );
		
	projectionMatrix=PROJ;
	pPROJ=PROJ;

	if (SelectedRenderTarget==-1)
	{
		MatrixOrthoLHS( &ProjOrtho, (float)SCREEN_X, (float)SCREEN_Y, 0.0f,1.0f );
	}

#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#if defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)
	float Fov;

	Fov=(float) (2*atan((float) SCREEN_Y/(2*Distance)));

	if ((SelectedRenderTarget==PRIMARY)||(states(SCALE_SCREEN))) MatrixPerspectiveFovLH( &PROJ, Fov, (float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y, Front, Back );
	else MatrixPerspectiveFovLH( &PROJ, Fov, 1.0f, Front, Back );
		
	projectionMatrix=PROJ;
	pPROJ=PROJ;

	if (SelectedRenderTarget==PRIMARY)
	{
		MatrixOrthoLHS( &ProjOrtho, (float)SCREEN_X, (float)SCREEN_Y, 0.0f,1.0f );
	}
#else
#ifdef API3D_DIRECT3D10
	float Fov;
	D3DXMATRIX proj;

	Fov=(float) (2*atan((float) SCREEN_Y/(2*Distance)));

	if ((SelectedRenderTarget==PRIMARY)||(states(SCALE_SCREEN))) D3DXMatrixPerspectiveFovLH( &proj, Fov, (float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y, Front, Back );
	else D3DXMatrixPerspectiveFovLH( &proj, Fov, 1.0f, Front, Back );
		
	projectionMatrix=proj;
	PROJ.a[0][0]=proj._11;	PROJ.a[1][0]=proj._21;	PROJ.a[2][0]=proj._31;	PROJ.a[3][0]=proj._41;
	PROJ.a[0][1]=proj._12;	PROJ.a[1][1]=proj._22;	PROJ.a[2][1]=proj._32;	PROJ.a[3][1]=proj._42;
	PROJ.a[0][2]=proj._13;	PROJ.a[1][2]=proj._23;	PROJ.a[2][2]=proj._33;	PROJ.a[3][2]=proj._43;
	PROJ.a[0][3]=proj._14;	PROJ.a[1][3]=proj._24;	PROJ.a[2][3]=proj._34;	PROJ.a[3][3]=proj._44;

	pPROJ=PROJ;

	if (SelectedRenderTarget==PRIMARY)
	{
		D3DXMatrixOrthoLH( &proj, (float)SCREEN_X, (float)SCREEN_Y, 0.0f,1.0f );

		ProjOrtho.a[0][0]=proj._11;	ProjOrtho.a[1][0]=proj._21;	ProjOrtho.a[2][0]=proj._31;	ProjOrtho.a[3][0]=proj._41;
		ProjOrtho.a[0][1]=-proj._12; ProjOrtho.a[1][1]=-proj._22; ProjOrtho.a[2][1]=-proj._32; ProjOrtho.a[3][1]=-proj._42;
		ProjOrtho.a[0][2]=proj._13;	ProjOrtho.a[1][2]=proj._23;	ProjOrtho.a[2][2]=proj._33;	ProjOrtho.a[3][2]=proj._43;
		ProjOrtho.a[0][3]=proj._14;	ProjOrtho.a[1][3]=proj._24;	ProjOrtho.a[2][3]=proj._34;	ProjOrtho.a[3][3]=proj._44;
	}
#else
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	float Fov;
	D3DXMATRIX proj;

	Fov=(float) (2*atan((float) SCREEN_Y/(2*Distance)));

	if ((SelectedRenderTarget==PRIMARY)||(states(SCALE_SCREEN))) D3DXMatrixPerspectiveFovLH( &proj, Fov, (float) (SCREEN_Ratio*SCREEN_X)/SCREEN_Y, Front, Back );
	else D3DXMatrixPerspectiveFovLH( &proj, Fov, 1.0f, Front, Back );
		
	D3DDevice->SetTransform(D3DTS_PROJECTION,&proj);
	PROJ.a[0][0]=proj._11;	PROJ.a[1][0]=proj._21;	PROJ.a[2][0]=proj._31;	PROJ.a[3][0]=proj._41;
	PROJ.a[0][1]=proj._12;	PROJ.a[1][1]=proj._22;	PROJ.a[2][1]=proj._32;	PROJ.a[3][1]=proj._42;
	PROJ.a[0][2]=proj._13;	PROJ.a[1][2]=proj._23;	PROJ.a[2][2]=proj._33;	PROJ.a[3][2]=proj._43;
	PROJ.a[0][3]=proj._14;	PROJ.a[1][3]=proj._24;	PROJ.a[2][3]=proj._34;	PROJ.a[3][3]=proj._44;

	pPROJ=PROJ;

#endif
#endif
#endif
}

#if defined(API3D_OPENGL)
void myglOrtho(float w, float h, float zn, float zf)
{
	GLfloat m[16];

	m[0 + 4 * 0] = 2.0f/w;
	m[0 + 4 * 1] = 0.0f;
	m[0 + 4 * 2] = 0.0f;
	m[0 + 4 * 3] = 0.0f;

	m[1 + 4 * 0] = 0.0f;
	m[1 + 4 * 1] = 2.0f/h;
	m[1 + 4 * 2] = 0.0f;
	m[1 + 4 * 3] = 0.0f;

	m[2 + 4 * 0] = 0.0f;
	m[2 + 4 * 1] = 0.0f;
	m[2 + 4 * 2] = 1.0f/(zf-zn);
	m[2 + 4 * 3] = zn/(zn-zf);

	m[3 + 4 * 0] = 0.0f;
	m[3 + 4 * 1] = 0.0f;
	m[3 + 4 * 2] = 0.0f;
	m[3 + 4 * 3] = 1.0f;

	glLoadMatrixf(m);
}
#endif

#if defined(API3D_OPENGL20)
void myglOrtho(GLfloat *m,float w, float h, float zn, float zf)
{
	m[0 + 4 * 0] = 2.0f/w;
	m[0 + 4 * 1] = 0.0f;
	m[0 + 4 * 2] = 0.0f;
	m[0 + 4 * 3] = 0.0f;

	m[1 + 4 * 0] = 0.0f;
	m[1 + 4 * 1] = 2.0f/h;
	m[1 + 4 * 2] = 0.0f;
	m[1 + 4 * 3] = 0.0f;

	m[2 + 4 * 0] = 0.0f;
	m[2 + 4 * 1] = 0.0f;
	m[2 + 4 * 2] = 1.0f/(zf-zn);
	m[2 + 4 * 3] = zn/(zn-zf);

	m[3 + 4 * 0] = 0.0f;
	m[3 + 4 * 1] = 0.0f;
	m[3 + 4 * 2] = 0.0f;
	m[3 + 4 * 3] = 1.0f;
}
#endif


void C3DAPIBASE::SetOrthoProjection(float szx,float szy)
{
#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	GLfloat proj[16];
	int i,j;

#ifdef API3D_OPENGL20

	myglOrtho(proj,szx, szy, Front, Back);

    for (i=0;i<4;i++)
        for (j=0;j<4;j++)
        {
            PROJ.a[j][i]=proj[i+4*j];
        }

	PROJ.a[0][0]=proj[0+4*0];
	PROJ.a[1][1]=proj[1+4*1];
	PROJ.a[2][2]=-proj[2+4*2];

	pPROJ=PROJ;

    for (i=0;i<4;i++)
        for (j=0;j<4;j++)
        {
            projection[i+4*j]=PROJ.a[j][i];
        }
#else

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	myglOrtho(szx, szy, Front, Back);
	
	glGetFloatv(GL_PROJECTION_MATRIX, proj);

	for (i=0;i<4;i++)
		for (j=0;j<4;j++) 
		{
			PROJ.a[j][i]=proj[i+4*j]; 
		}
	
	PROJ.a[0][0]=-proj[0+4*0]; 
	PROJ.a[1][1]=-proj[1+4*1]; 
	PROJ.a[2][2]=-proj[2+4*2]; 

	pPROJ=PROJ;

#endif
#endif

#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -------------
#ifdef IOS
    int ns=SelectedRenderTarget;
    if (ns>=0) MTLSetViewport(SndViewport[ns].TopLeftX,SndViewport[ns].TopLeftY,SndViewport[ns].TopLeftX+SndViewport[ns].Width,SndViewport[ns].TopLeftY+SndViewport[ns].Height);
#endif
	MatrixOrthoLH( &PROJ, szx,szy, Front, Back );
	projectionMatrix=PROJ;
	pPROJ=PROJ;
#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#if defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)
	MatrixOrthoLH( &PROJ, szx,szy, Front, Back );
	projectionMatrix=PROJ;
	pPROJ=PROJ;
#else
	D3DXMATRIX proj;
		
	D3DXMatrixOrthoLH( &proj, szx,szy, Front, Back );
#ifdef API3D_DIRECT3D10
	projectionMatrix=proj;
#else
	D3DDevice->SetTransform(D3DTS_PROJECTION,&proj);
#endif

	PROJ.a[0][0]=proj._11;	PROJ.a[1][0]=proj._21;	PROJ.a[2][0]=proj._31;	PROJ.a[3][0]=proj._41;
	PROJ.a[0][1]=proj._12;	PROJ.a[1][1]=proj._22;	PROJ.a[2][1]=proj._32;	PROJ.a[3][1]=proj._42;
	PROJ.a[0][2]=proj._13;	PROJ.a[1][2]=proj._23;	PROJ.a[2][2]=proj._33;	PROJ.a[3][2]=proj._43;
	PROJ.a[0][3]=proj._14;	PROJ.a[1][3]=proj._24;	PROJ.a[2][3]=proj._34;	PROJ.a[3][3]=proj._44;

	pPROJ=PROJ;
#endif
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function:

set projection matrix

void C3DAPIBASE::SetProjection(int SCX,int SCY)

Note: for secondary render target, SCALE,NO_SCALE is used to simulate primary surface aspect

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetProjection(int _SCX, int _SCY)
{
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif
    
    int SCX=_SCX;
    int SCY=_SCY;
    
    if (states(RENDER_TARGET)==PRIMARY)
	{
        SCX+=(int)(2*overscanX);
		projSCREENX=_SCX;
		projSCREENY=_SCY;
	}

#ifdef API3D_VR

	PROJ=BASEPROJ;
	pPROJ=PROJ;

	for (int i=0;i<4;i++)
		for (int j=0;j<4;j++) projection[i+4*j]=PROJ.a[j][i];

	
	PROJ.a[0][0]=-PROJ.a[0][0];
	PROJ.a[1][1]=-PROJ.a[1][1];
	PROJ.a[2][2]=-PROJ.a[2][2];

	PROJ.a[2][1]=-PROJ.a[2][1];

	return;
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
	//------------------------------------------------------------------------------------------------ OPEN GL -----------
	float Fov;
	GLfloat proj[16];
	int i,j;
#ifdef API3D_OPENGL20

    if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN))) Fov=(float) (2*360*atan((float) SCY/(2*Distance))/(2*3.14159));
	else Fov=(float) (2*360*atan((float) SCY/(2*Distance))/(2*3.14159));

	if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN)))
		glProjPerspective(proj,Fov,(float) (SCREEN_Ratio*SCX)/SCY,Front,Back);
	else
		glProjPerspective(proj,Fov,1.0f,Front,Back);

	for (i=0;i<4;i++)
		for (j=0;j<4;j++) 
		{
			projection[i+4*j]=PROJ.a[j][i]=proj[i+4*j];
		}
	
	pPROJ=PROJ;

	PROJ.a[0][0]=-proj[0+4*0];
	PROJ.a[1][1]=-proj[1+4*1]; 
	PROJ.a[2][2]=-proj[2+4*2];

#else
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	Fov=(float) (2*360*atan((float) SCY/(2*Distance))/(2*3.14159));

	if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN)))
		gluPerspective(Fov,(float) (SCREEN_Ratio*SCX)/SCY,Front,Back);
	else
		gluPerspective(Fov,1.0f,Front,Back);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glGetFloatv(GL_PROJECTION_MATRIX, proj);

	for (i=0;i<4;i++)
	for (j=0;j<4;j++) 
	{
		PROJ.a[j][i]=proj[i+4*j]; 
	}
	
	pPROJ=PROJ;

	PROJ.a[0][0]=-proj[0+4*0]; 
	PROJ.a[1][1]=-proj[1+4*1]; 
	PROJ.a[2][2]=-proj[2+4*2]; 
#endif	
#endif

#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -------------
	float Fov;

	Fov = (float)(2 * atan((float)SCY / (2 * Distance)));

	worldMatrix.Id();
	viewMatrix.Id();

	if ((SelectedRenderTarget == -1) || (states(SCALE_SCREEN))) MatrixPerspectiveFovLH(&PROJ, Fov, (float)(SCREEN_Ratio*SCX) / SCY, Front, Back);
	else MatrixPerspectiveFovLH(&PROJ, Fov, 1.0f, Front, Back);

	projectionMatrix=PROJ;
	pPROJ=PROJ;

	if (SelectedRenderTarget==-1)
	{
		MatrixOrthoLHS( &ProjOrtho, (float)SCX, (float)SCY, 0.0f, 1.0f );
	}

#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#if defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)
	float Fov;

	Fov = (float)(2 * atan((float)SCY / (2 * Distance)));

	worldMatrix.Id();
	viewMatrix.Id();

	if ((SelectedRenderTarget == PRIMARY) || (states(SCALE_SCREEN))) MatrixPerspectiveFovLH(&PROJ, Fov, (float)(SCREEN_Ratio*SCX) / SCY, Front, Back);		
	else MatrixPerspectiveFovLH(&PROJ, Fov, 1.0f, Front, Back);

	projectionMatrix=PROJ;
	pPROJ=PROJ;

	if (SelectedRenderTarget==PRIMARY)
	{
		MatrixOrthoLHS( &ProjOrtho, (float)SCX, (float)SCY, 0.0f, 1.0f );
	}
#else
#ifdef API3D_DIRECT3D10
	float Fov;
	D3DXMATRIX Id, proj;

	Fov = (float)(2 * atan((float)SCY / (2 * Distance)));
	D3DXMatrixIdentity(&Id);
	worldMatrix=Id;
	viewMatrix=Id;

	if ((SelectedRenderTarget == PRIMARY) || (states(SCALE_SCREEN))) D3DXMatrixPerspectiveFovLH(&proj, Fov, (float)(SCREEN_Ratio*SCX) / SCY, Front, Back);		
	else D3DXMatrixPerspectiveFovLH(&proj, Fov, 1.0f, Front, Back);

	projectionMatrix=proj;

	PROJ.a[0][0] = proj._11;	PROJ.a[1][0] = proj._21;	PROJ.a[2][0] = proj._31;	PROJ.a[3][0] = proj._41;
	PROJ.a[0][1] = proj._12;	PROJ.a[1][1] = proj._22;	PROJ.a[2][1] = proj._32;	PROJ.a[3][1] = proj._42;
	PROJ.a[0][2] = proj._13;	PROJ.a[1][2] = proj._23;	PROJ.a[2][2] = proj._33;	PROJ.a[3][2] = proj._43;
	PROJ.a[0][3] = proj._14;	PROJ.a[1][3] = proj._24;	PROJ.a[2][3] = proj._34;	PROJ.a[3][3] = proj._44;

	pPROJ=PROJ;

	if (SelectedRenderTarget==PRIMARY)
	{
		D3DXMatrixOrthoLH( &proj, (float)SCX, (float)SCY, 0.0f, 1.0f );

		ProjOrtho.a[0][0]=proj._11;	ProjOrtho.a[1][0]=proj._21;	ProjOrtho.a[2][0]=proj._31;	ProjOrtho.a[3][0]=proj._41;
		ProjOrtho.a[0][1]=-proj._12; ProjOrtho.a[1][1]=-proj._22; ProjOrtho.a[2][1]=-proj._32; ProjOrtho.a[3][1]=-proj._42;
		ProjOrtho.a[0][2]=proj._13;	ProjOrtho.a[1][2]=proj._23;	ProjOrtho.a[2][2]=proj._33;	ProjOrtho.a[3][2]=proj._43;
		ProjOrtho.a[0][3]=proj._14;	ProjOrtho.a[1][3]=proj._24;	ProjOrtho.a[2][3]=proj._34;	ProjOrtho.a[3][3]=proj._44;
	}
#else
	//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	float Fov;
	D3DXMATRIX Id, proj;

	Fov = (float)(2 * atan((float)SCY / (2 * Distance)));
	D3DXMatrixIdentity(&Id);
	D3DDevice->SetTransform(D3DTS_WORLD, &Id);
	D3DDevice->SetTransform(D3DTS_VIEW, &Id);

	if ((SelectedRenderTarget == PRIMARY) || (states(SCALE_SCREEN))) D3DXMatrixPerspectiveFovLH(&proj, Fov, (float)(SCREEN_Ratio*SCX) / SCY, Front, Back);
	else D3DXMatrixPerspectiveFovLH(&proj, Fov, 1.0f, Front, Back);

	D3DDevice->SetTransform(D3DTS_PROJECTION, &proj);
	PROJ.a[0][0] = proj._11;	PROJ.a[1][0] = proj._21;	PROJ.a[2][0] = proj._31;	PROJ.a[3][0] = proj._41;
	PROJ.a[0][1] = proj._12;	PROJ.a[1][1] = proj._22;	PROJ.a[2][1] = proj._32;	PROJ.a[3][1] = proj._42;
	PROJ.a[0][2] = proj._13;	PROJ.a[1][2] = proj._23;	PROJ.a[2][2] = proj._33;	PROJ.a[3][2] = proj._43;
	PROJ.a[0][3] = proj._14;	PROJ.a[1][3] = proj._24;	PROJ.a[2][3] = proj._34;	PROJ.a[3][3] = proj._44;

	pPROJ=PROJ;

	if (SelectedRenderTarget==PRIMARY)
	{
		D3DXMatrixOrthoLH( &proj, (float)SCX, (float)SCY, 0.0f, 1.0f );

		ProjOrtho.a[0][0]=proj._11;	ProjOrtho.a[1][0]=proj._21;	ProjOrtho.a[2][0]=proj._31;	ProjOrtho.a[3][0]=proj._41;
		ProjOrtho.a[0][1]=-proj._12; ProjOrtho.a[1][1]=-proj._22; ProjOrtho.a[2][1]=-proj._32; ProjOrtho.a[3][1]=-proj._42;
		ProjOrtho.a[0][2]=proj._13;	ProjOrtho.a[1][2]=proj._23;	ProjOrtho.a[2][2]=proj._33;	ProjOrtho.a[3][2]=proj._43;
		ProjOrtho.a[0][3]=proj._14;	ProjOrtho.a[1][3]=proj._24;	ProjOrtho.a[2][3]=proj._34;	ProjOrtho.a[3][3]=proj._44;
	}

#endif
#endif
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function:

set projection matrix

void C3DAPIBASE::SetProjection(int SCX,int SCY)

Note: for secondary render target, SCALE,NO_SCALE is used to simulate primary surface aspect

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetProjection2(int SCX, int SCY)
{
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif

#ifdef API3D_VR

	PROJ=BASEPROJ;
	pPROJ=PROJ;

	for (int i=0;i<4;i++)
		for (int j=0;j<4;j++) projection[i+4*j]=PROJ.a[j][i];

	
	PROJ.a[0][0]=-PROJ.a[0][0];
	PROJ.a[1][1]=-PROJ.a[1][1];
	PROJ.a[2][2]=-PROJ.a[2][2];
	
	PROJ.a[2][1]=-PROJ.a[2][1];

	return;
#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
	//------------------------------------------------------------------------------------------------ OPEN GL -----------
	float Fov;
	GLfloat proj[16];
	int i, j;
#ifdef API3D_OPENGL20
    
    if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN))) Fov=(float) (2*360*atan((float) SCY/(2*Distance))/(2*3.14159));
	else Fov=(float) (2*360*atan((float) SCY/(2*Distance))/(2*3.14159));

	if ((SelectedRenderTarget==-1)||(states(SCALE_SCREEN)))
		glProjPerspective(proj,Fov,(float) (SCREEN_Ratio*SCX)/SCY,Front,Back);
	else
		glProjPerspective(proj,Fov,1.0f,Front,Back);

	for (i=0;i<4;i++)
		for (j=0;j<4;j++) 
		{
			projection[i+4*j]=PROJ.a[j][i]=proj[i+4*j];
		}
	
	pPROJ=PROJ;

	PROJ.a[0][0]=-proj[0+4*0]; 
	PROJ.a[1][1]=-proj[1+4*1]; 
	PROJ.a[2][2]=-proj[2+4*2]; 
#else

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	Fov = (float)(2 * 360 * atan((float)SCY / (2 * Distance)) / (2 * 3.14159));

	if ((SelectedRenderTarget == -1) || (states(SCALE_SCREEN)))
		gluPerspective(Fov, (float)(SCREEN_Ratio*SCX) / SCY, Front, Back);
	else
		gluPerspective(Fov, 1.0f, Front, Back);

	glGetFloatv(GL_PROJECTION_MATRIX, proj);

	for (i = 0; i<4; i++)
	for (j = 0; j<4; j++)
	{
		PROJ.a[j][i] = proj[i + 4 * j];
	}

	pPROJ=PROJ;

	PROJ.a[0][0] = -proj[0 + 4 * 0];
	PROJ.a[1][1] = -proj[1 + 4 * 1];
	PROJ.a[2][2] = -proj[2 + 4 * 2];

#endif
#endif

#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -------------
	float Fov;

	Fov = (float)(2 * atan((float)SCY / (2 * Distance)));

	if ((SelectedRenderTarget == -1) || (states(SCALE_SCREEN))) MatrixPerspectiveFovLH(&PROJ, Fov, (float)(SCREEN_Ratio*SCX) / SCY, Front, Back);
	else MatrixPerspectiveFovLH(&PROJ, Fov, 1.0f, Front, Back);

	projectionMatrix=PROJ;
	pPROJ=PROJ;

#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
	//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#if defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)
	float Fov;

	Fov = (float)(2 * atan((float)SCY / (2 * Distance)));

	if ((SelectedRenderTarget == PRIMARY) || (states(SCALE_SCREEN))) MatrixPerspectiveFovLH(&PROJ, Fov, (float)(SCREEN_Ratio*SCX) / SCY, Front, Back);
	else MatrixPerspectiveFovLH(&PROJ, Fov, 1.0f, Front, Back);

	projectionMatrix=PROJ;
	pPROJ=PROJ;

#else
	float Fov;
	D3DXMATRIX Id, proj;

	Fov = (float)(2 * atan((float)SCY / (2 * Distance)));

	if ((SelectedRenderTarget == PRIMARY) || (states(SCALE_SCREEN))) D3DXMatrixPerspectiveFovLH(&proj, Fov, (float)(SCREEN_Ratio*SCX) / SCY, Front, Back);
	else D3DXMatrixPerspectiveFovLH(&proj, Fov, 1.0f, Front, Back);
#ifdef API3D_DIRECT3D10
	projectionMatrix=proj;
#else
	D3DDevice->SetTransform(D3DTS_PROJECTION, &proj);
#endif
	PROJ.a[0][0] = proj._11;	PROJ.a[1][0] = proj._21;	PROJ.a[2][0] = proj._31;	PROJ.a[3][0] = proj._41;
	PROJ.a[0][1] = proj._12;	PROJ.a[1][1] = proj._22;	PROJ.a[2][1] = proj._32;	PROJ.a[3][1] = proj._42;
	PROJ.a[0][2] = proj._13;	PROJ.a[1][2] = proj._23;	PROJ.a[2][2] = proj._33;	PROJ.a[3][2] = proj._43;
	PROJ.a[0][3] = proj._14;	PROJ.a[1][3] = proj._24;	PROJ.a[2][3] = proj._34;	PROJ.a[3][3] = proj._44;

	pPROJ=PROJ;
#endif
#endif
}



/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		
		Affichage ligne

		void C3DAPIBASE::Line(CVector A,CVector B,float r,float g,float b)
		void C3DAPIBASE::Line(float x1,float y1,float x2,float y2,float r,float g,float b)
        void C3DAPIBASE::Line(float x1,float y1,float x2,float y2,float r,float g,float b,float a)
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
void C3DAPIBASE::UpdateLines()
{
#if defined(API3D_DIRECT3D12)
	dirtyCRCState=true;
#endif
    if (vbdraw_line) return;
    
    if (nbline>0)
    {
        vbline.nVerticesActif=nbline;
        vbline.UnlockVertices();
        
        whileFlush=true;
        
        CVertexBuffer * actual=ActualVertexBuffer;
        CVertexBuffer * eff=ActualEffect;
        
        effect_hll_diffuse_nomap.setMatrix("MODEL",ProjOrtho);
        SetEffect(&effect_hll_diffuse_nomap);
        
        vbdraw_line=true;
        
        ActualVertexBuffer=&vbline;
        DrawVertexBuffer();
        
        vbdraw_line=false;
        
        ActualVertexBuffer=actual;
        ActualEffect=eff;
        
        whileFlush=false;
        
        vbline.LockVertices();
        nbline=0;
    }

    if (nbline3d>0)
    {
        vbline3d.nVerticesActif=nbline3d;
        vbline3d.UnlockVertices();
        
        whileFlush=true;
        
        CVertexBuffer * actual=ActualVertexBuffer;
        CVertexBuffer * eff=ActualEffect;
        
        effect_hll_diffuse_nomap.setMatrixWorldViewProj("MODEL");
        SetEffect(&effect_hll_diffuse_nomap);

        vbdraw_line=true;
        
        ActualVertexBuffer=&vbline3d;
        DrawVertexBuffer();
        
        vbdraw_line=false;
        
        ActualVertexBuffer=actual;
        ActualEffect=eff;
        
        whileFlush=false;
        
        vbline3d.LockVertices();
        nbline3d=0;
    }

#if defined(API3D_DIRECT3D12)
	dirtyCRCState=true;
#endif

}
#endif

void C3DAPIBASE::Line(float x1,float y1,float x2,float y2,float r,float g,float b)
{
    if (!Active) return;
    
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    
    vbline.SetColor(nbline+0,r,g,b,1.0f);
    vbline.SetColor(nbline+1,r,g,b,1.0f);
    vbline.SetVertex(nbline+0,x1-VIEWPORT.a[3][0]+decals_lines_x,y1-VIEWPORT.a[3][1]+decals_lines_y,0.1f);
    vbline.SetVertex(nbline+1,x2-VIEWPORT.a[3][0]+decals_lines_x,y2-VIEWPORT.a[3][1]+decals_lines_y,0.1f);
    nbline+=2;
    
    if (nbline==NB_LINE_MAX) UpdateLines();
#else
#ifdef API3D_OPENGL
#ifdef GLES
	glDisable(GL_TEXTURE_2D);
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	glOrthof(0,SCREEN_X,0,SCREEN_Y,-1,1);
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	glDisable(GL_DEPTH_TEST);

	GLfloat vertices[2*2];
	GLfloat colors[4*2];

	colors[4*0 + 0]=r;
	colors[4*0 + 1]=g;
	colors[4*0 + 2]=b;
	colors[4*0 + 3]=1.0f;
	colors[4*1 + 0]=r;
	colors[4*1 + 1]=g;
	colors[4*1 + 2]=b;
	colors[4*1 + 3]=1.0f;

	vertices[2*0 + 0]=x1; vertices[2*0 + 1]=SCREEN_Y-y1;
	vertices[2*1 + 0]=x2; vertices[2*1 + 1]=SCREEN_Y-y2;

	glVertexPointer(2,GL_FLOAT,0,vertices);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(4,GL_FLOAT,0,colors);
	glEnableClientState(GL_COLOR_ARRAY);
	glDrawArrays(GL_LINES,0,2);


	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glEnable(GL_DEPTH_TEST);
#else
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	//if (((SelectedRenderTarget>=0)||(aT<0))&&(!SecondarySurface)) return;
	glDisable(GL_TEXTURE_2D);
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
	{
		glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		glDisable(GL_DEPTH_TEST);
		glBegin(GL_LINES);
		glColor3f(r,g,b);
		glVertex3f(x1,SCREEN_Y-y1,0);
		glColor3f(r,g,b);
		glVertex3f(x2,SCREEN_Y-y2,0);
		glEnd();
	}
	else
	{
		glOrtho(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		glDisable(GL_DEPTH_TEST);
		glBegin(GL_LINES);
		glColor3f(r,g,b);
		glVertex3f(x1,tile_secondarysurfacesH[SelectedRenderTarget]-y1,0);
		glColor3f(r,g,b);
		glVertex3f(x2,tile_secondarysurfacesH[SelectedRenderTarget]-y2,0);
		glEnd();
	}

	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glEnable(GL_DEPTH_TEST);
#endif
#else
	struct CUSTOMVERTEX01 Vertices[2];
	DWORD color;

	color=D3DCOLOR_COLORVALUE(r,g,b,1);

	Vertices[0].color=D3DCOLOR_COLORVALUE(r,g,b,1);
	Vertices[1].color=Vertices[0].color;

	Vertices[0].x=(float) x1+decals_lines_x;
	Vertices[0].y=(float) y1+decals_lines_y;
	Vertices[0].rhw=(float) 2/(Front+Back);
	Vertices[0].z=0.5f;

	Vertices[1].x=(float) x2+decals_lines_x;
	Vertices[1].y=(float) y2+decals_lines_y;
	Vertices[1].rhw=(float) 2/(Front+Back);
	Vertices[1].z=0.5f;

	D3DDevice->SetTexture(0,Blanc);

#ifdef API3D_DIRECT3D9
	D3DDevice->SetFVF( D3DFVF_CUSTOMVERTEX01 );
#else
	D3DDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX01 );
#endif
	D3DDevice->DrawPrimitiveUP( D3DPT_LINELIST,1,Vertices,sizeof(CUSTOMVERTEX01));
#endif
#endif

}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */
void C3DAPIBASE::Line(float x1,float y1,float x2,float y2,float r,float g,float b,float a)
{
    if (!Active) return;
    
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)

    vbline.SetColor(nbline+0,r,g,b,a);
    vbline.SetColor(nbline+1,r,g,b,a);
    vbline.SetVertex(nbline+0,x1-VIEWPORT.a[3][0]+decals_lines_x,y1-VIEWPORT.a[3][1]+decals_lines_y,0.1f);
    vbline.SetVertex(nbline+1,x2-VIEWPORT.a[3][0]+decals_lines_x,y2-VIEWPORT.a[3][1]+decals_lines_y,0.1f);
    nbline+=2;
    
    if (nbline==NB_LINE_MAX) UpdateLines();
#else
#ifdef API3D_OPENGL
#ifdef GLES
    glDisable(GL_TEXTURE_2D);
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrthof(0,SCREEN_X,0,SCREEN_Y,-1,1);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glDisable(GL_DEPTH_TEST);
    
    GLfloat vertices[2*2];
    GLfloat colors[4*2];
    
    colors[4*0 + 0]=r;
    colors[4*0 + 1]=g;
    colors[4*0 + 2]=b;
    colors[4*0 + 3]=a;
    colors[4*1 + 0]=r;
    colors[4*1 + 1]=g;
    colors[4*1 + 2]=b;
    colors[4*1 + 3]=a;
    
    vertices[2*0 + 0]=x1; vertices[2*0 + 1]=SCREEN_Y-y1;
    vertices[2*1 + 0]=x2; vertices[2*1 + 1]=SCREEN_Y-y2;
    
    glVertexPointer(2,GL_FLOAT,0,vertices);
    glEnableClientState(GL_VERTEX_ARRAY);
    glColorPointer(4,GL_FLOAT,0,colors);
    glEnableClientState(GL_COLOR_ARRAY);
    glDrawArrays(GL_LINES,0,2);
    
    
    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glEnable(GL_DEPTH_TEST);
#else
    //------------------------------------------------------------------------------------------------ OPEN GL -----------
    //if (((SelectedRenderTarget>=0)||(aT<0))&&(!SecondarySurface)) return;
    glDisable(GL_TEXTURE_2D);
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (SelectedRenderTarget==-1)
    {
        glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        glDisable(GL_DEPTH_TEST);
        glBegin(GL_LINES);
        glColor4f(r,g,b,a);
        glVertex3f(x1,SCREEN_Y-y1,0);
        glColor4f(r,g,b,a);
        glVertex3f(x2,SCREEN_Y-y2,0);
        glEnd();
    }
    else
    {
        glOrtho(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        glDisable(GL_DEPTH_TEST);
        glBegin(GL_LINES);
        glColor4f(r,g,b,a);
        glVertex3f(x1,tile_secondarysurfacesH[SelectedRenderTarget]-y1,0);
        glColor4f(r,g,b,a);
        glVertex3f(x2,tile_secondarysurfacesH[SelectedRenderTarget]-y2,0);
        glEnd();
    }
    
    glMatrixMode(GL_MODELVIEW);
    glPopMatrix();
    glMatrixMode(GL_PROJECTION);
    glPopMatrix();
    glEnable(GL_DEPTH_TEST);
#endif
#else
    struct CUSTOMVERTEX01 Vertices[2];
    DWORD color;
    
    color=D3DCOLOR_COLORVALUE(r,g,b,a);
    
    Vertices[0].color=D3DCOLOR_COLORVALUE(r,g,b,a);
    Vertices[1].color=Vertices[0].color;
    
    Vertices[0].x=(float) x1+decals_lines_x;
    Vertices[0].y=(float) y1+decals_lines_y;
    Vertices[0].rhw=(float) 2/(Front+Back);
    Vertices[0].z=0.5f;
    
    Vertices[1].x=(float) x2+decals_lines_x;
    Vertices[1].y=(float) y2+decals_lines_y;
    Vertices[1].rhw=(float) 2/(Front+Back);
    Vertices[1].z=0.5f;
    
    D3DDevice->SetTexture(0,Blanc);
    
#ifdef API3D_DIRECT3D9
    D3DDevice->SetFVF( D3DFVF_CUSTOMVERTEX01 );
#else
    D3DDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX01 );
#endif
    D3DDevice->DrawPrimitiveUP( D3DPT_LINELIST,1,Vertices,sizeof(CUSTOMVERTEX01));
#endif
#endif
    
}


#ifndef GLES
void C3DAPIBASE::Line2(CVector A,CVector B,float r,float g,float b)
{
	float x1, y1, x2, y2;
	float z1, w1, z2, w2;
    
    if (!Active) return;

	CVector4 v;
	
	v.Init(A);
	v=v*WORLD;
	v=v*VIEW;
	v=v*PROJ;
	v=v*VIEWPORT;

	x1=v.x;
	y1=v.y;
	z1=v.z;
	w1=v.w;

	v.Init(B);
	v=v*WORLD;
	v=v*VIEW;
	v=v*PROJ;
	v=v*VIEWPORT;

	x2=v.x;
	y2=v.y;
	z2=v.z;
	w2=v.w;

#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)

    vbline.SetColor(nbline+0,r,g,b,1.0f);
    vbline.SetColor(nbline+1,r,g,b,1.0f);
    vbline.SetVertex(nbline+0,x1-VIEWPORT.a[3][0],y1-VIEWPORT.a[3][1],0.5f);
    vbline.SetVertex(nbline+1,x2-VIEWPORT.a[3][0],y2-VIEWPORT.a[3][1],0.5f);
    nbline+=2;
    if (nbline==NB_LINE_MAX) UpdateLines();
    
#else

#ifdef API3D_OPENGL
#else
	struct CUSTOMVERTEX01 Vertices[2];
	DWORD color;
	int pos[4][2]={ {-1,0},{1,0},{0,1},{0,-1} };

	for (int n=2;n>=0;n--)
	{
		color=D3DCOLOR_COLORVALUE(r/(n+1),g/(n+1),b/(n+1),1);

		Vertices[0].color=color;
		Vertices[1].color=color;

		for (int k=0;k<4;k++)
		{

			Vertices[0].x=(float) x1 + pos[k][0]*n;
			Vertices[0].y=(float) y1 + pos[k][1]*n;
			Vertices[0].rhw=(float) w1;
			Vertices[0].z=(float) z1;

			Vertices[1].x=(float) x2 + pos[k][0]*n;
			Vertices[1].y=(float) y2 + pos[k][1]*n;
			Vertices[1].rhw=(float) w2;
			Vertices[1].z=(float) z2;

	#ifdef API3D_DIRECT3D9
			D3DDevice->SetFVF( D3DFVF_CUSTOMVERTEX01 );
	#else
			D3DDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX01 );
	#endif
			D3DDevice->DrawPrimitiveUP( D3DPT_LINELIST,1,Vertices,sizeof(CUSTOMVERTEX01));
		}
	}
#endif
#endif
}
#endif

#ifndef GLES
void C3DAPIBASE::Line(float x1,float y1,float z1,float w1,float x2,float y2,float z2,float w2,float r,float g,float b)
{
    if (!Active) return;

#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)

    vbline.SetColor(nbline+0,r,g,b,1.0f);
    vbline.SetColor(nbline+1,r,g,b,1.0f);
    vbline.SetVertex(nbline+0,x1-VIEWPORT.a[3][0],y1-VIEWPORT.a[3][1],z1);
    vbline.SetVertex(nbline+1,x2-VIEWPORT.a[3][0],y2-VIEWPORT.a[3][1],z2);
    nbline+=2;
    
    if (nbline==NB_LINE_MAX) UpdateLines();
#else
#ifdef API3D_OPENGL
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	//if (((SelectedRenderTarget>=0)||(aT<0))&&(!SecondarySurface)) return;
	glDisable(GL_TEXTURE_2D);
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
	{
		glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		glDisable(GL_DEPTH_TEST);
		glBegin(GL_LINES);
		glColor3f(r,g,b);
		glVertex3f(x1,SCREEN_Y-y1,z1);
		glColor3f(r,g,b);
		glVertex3f(x2,SCREEN_Y-y2,z2);
		glEnd();
	}
	else
	{
		glOrtho(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		glDisable(GL_DEPTH_TEST);
		glBegin(GL_LINES);
		glColor3f(r,g,b);
		glVertex3f(x1,tile_secondarysurfacesH[SelectedRenderTarget]-y1,z1);
		glColor3f(r,g,b);
		glVertex3f(x2,tile_secondarysurfacesH[SelectedRenderTarget]-y2,z2);
		glEnd();
	}

	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glEnable(GL_DEPTH_TEST);
#else
	struct CUSTOMVERTEX01 Vertices[2];
	DWORD color;

	color=D3DCOLOR_COLORVALUE(r,g,b,1);

	Vertices[0].color=D3DCOLOR_COLORVALUE(r,g,b,1);
	Vertices[1].color=Vertices[0].color;

	Vertices[0].x=(float) x1;
	Vertices[0].y=(float) y1;
	Vertices[0].rhw=w1;
	Vertices[0].z=z1;

	Vertices[1].x=(float) x2;
	Vertices[1].y=(float) y2;
	Vertices[1].rhw=w2;
	Vertices[1].z=z2;

#ifdef API3D_DIRECT3D9
	D3DDevice->SetFVF( D3DFVF_CUSTOMVERTEX01 );
#else
	D3DDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX01 );
#endif
	D3DDevice->DrawPrimitiveUP( D3DPT_LINELIST,1,Vertices,sizeof(CUSTOMVERTEX01));

#endif
#endif
}
#endif

void C3DAPIBASE::Line(float x1,float y1,float x2,float y2,float r,float g,float b,float r2,float g2,float b2)
{
    if (!Active) return;
    
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)

    vbline.SetColor(nbline+0,r,g,b,1.0f);
    vbline.SetColor(nbline+1,r2,g2,b2,1.0f);
    vbline.SetVertex(nbline+0,x1-VIEWPORT.a[3][0],y1-VIEWPORT.a[3][1],0.5f);
    vbline.SetVertex(nbline+1,x2-VIEWPORT.a[3][0],y2-VIEWPORT.a[3][1],0.5f);
    nbline+=2;
    if (nbline==NB_LINE_MAX) UpdateLines();
    
#else
#ifdef API3D_OPENGL
#ifdef GLES
	glDisable(GL_TEXTURE_2D);
		glMatrixMode(GL_PROJECTION);
		glPushMatrix();
		glMatrixMode(GL_MODELVIEW);
		glPushMatrix();
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();

		glOrthof(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		glDisable(GL_DEPTH_TEST);
		GLfloat vertices[3*2];
		GLfloat colors[4*2];

		colors[4*0 + 0]=r;
		colors[4*0 + 1]=g;
		colors[4*0 + 2]=b;
		colors[4*0 + 3]=1.0f;
		colors[4*1 + 0]=r2;
		colors[4*1 + 1]=g2;
		colors[4*1 + 2]=b2;
		colors[4*1 + 3]=1.0f;

		vertices[2*0 + 0]=x1; vertices[2*0 + 1]=SCREEN_Y-y1;
		vertices[2*1 + 0]=x2; vertices[2*1 + 1]=SCREEN_Y-y2;

		glVertexPointer(2,GL_FLOAT,0,vertices);
		glEnableClientState(GL_VERTEX_ARRAY);
		glColorPointer(4,GL_FLOAT,0,colors);
		glEnableClientState(GL_COLOR_ARRAY);
		glDrawArrays(GL_LINES,0,2);

		glMatrixMode(GL_MODELVIEW);
		glPopMatrix();
		glMatrixMode(GL_PROJECTION);
		glPopMatrix();
		glEnable(GL_DEPTH_TEST);

#else
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	//if (((SelectedRenderTarget>=0)||(aT<0))&&(!SecondarySurface)) return;
	glDisable(GL_TEXTURE_2D);
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
	{
		glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		glDisable(GL_DEPTH_TEST);
		glBegin(GL_LINES);
		glColor3f(r,g,b);
		glVertex3f(x1,SCREEN_Y-y1,0);
		glColor3f(r2,g2,b2);
		glVertex3f(x2,SCREEN_Y-y2,0);
		glEnd();
	}
	else
	{
		glOrtho(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		glDisable(GL_DEPTH_TEST);
		glBegin(GL_LINES);
		glColor3f(r,g,b);
		glVertex3f(x1,tile_secondarysurfacesH[SelectedRenderTarget]-y1,0);
		glColor3f(r2,g2,b2);
		glVertex3f(x2,tile_secondarysurfacesH[SelectedRenderTarget]-y2,0);
		glEnd();
	}

	
	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glEnable(GL_DEPTH_TEST);
#endif
#else
	struct CUSTOMVERTEX01 Vertices[2];

	Vertices[0].color=D3DCOLOR_COLORVALUE(r,g,b,1);
	Vertices[1].color=D3DCOLOR_COLORVALUE(r2,g2,b2,1);

	Vertices[0].x=(float) x1;
	Vertices[0].y=(float) y1;
	Vertices[0].rhw=(float) 2/(Front+Back);
	Vertices[0].z=0.5f;

	Vertices[1].x=(float) x2;
	Vertices[1].y=(float) y2;
	Vertices[1].rhw=(float) 2/(Front+Back);
	Vertices[1].z=0.5f;

#ifdef API3D_DIRECT3D9
	D3DDevice->SetFVF( D3DFVF_CUSTOMVERTEX01 );
#else
	D3DDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX01 );
#endif
	D3DDevice->DrawPrimitiveUP( D3DPT_LINELIST,1,Vertices,sizeof(CUSTOMVERTEX01));

#endif
#endif
}


void C3DAPIBASE::Line(CVector A,CVector B,float r,float g,float b)
{
    if (!Active) return;
    
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)

    vbline3d.SetColor(nbline3d+0,r,g,b,1.0f);
    vbline3d.SetColor(nbline3d+1,r,g,b,1.0f);
    vbline3d.SetVertex(nbline3d+0,A);
    vbline3d.SetVertex(nbline3d+1,B);
    nbline3d+=2;
    if (nbline3d==NB_LINE_MAX) UpdateLines();
#else
#ifdef API3D_OPENGL
#ifdef GLES
	glDisable(GL_TEXTURE_2D);
	GLfloat vertices[3*2];
	GLfloat colors[4*2];

	colors[4*0 + 0]=r;
	colors[4*0 + 1]=g;
	colors[4*0 + 2]=b;
	colors[4*0 + 3]=1.0f;
	colors[4*1 + 0]=r;
	colors[4*1 + 1]=g;
	colors[4*1 + 2]=b;
	colors[4*1 + 3]=1.0f;

	vertices[3*0 + 0]=A.x; vertices[3*0 + 1]=A.y; vertices[3*0 + 2]=A.z;
	vertices[3*1 + 0]=B.x; vertices[3*1 + 1]=B.y; vertices[3*1 + 2]=B.z;

	glVertexPointer(3,GL_FLOAT,0,vertices);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(4,GL_FLOAT,0,colors);
	glEnableClientState(GL_COLOR_ARRAY);
	glDrawArrays(GL_LINES,0,2);

#else
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	glDisable(GL_TEXTURE_2D);
	glBegin(GL_LINES);
		glColor3f(r,g,b);
		glVertex3f(A.x,A.y,A.z);
		glVertex3f(B.x,B.y,B.z);
	glEnd();
#endif
#else

	struct XYZCOLOR * Vertices;

#ifdef API3D_DIRECT3D9
	D3DVB_XYZCOLOR->Lock(0,2*sizeof(XYZCOLOR),(void**)&Vertices,0);
#else
	D3DVB_XYZCOLOR->Lock(0,2*sizeof(XYZCOLOR),(BYTE**)&Vertices,0);
#endif

	DWORD color;
	color=D3DCOLOR_COLORVALUE(r,g,b,1);

	Vertices[0].x=A.x;
	Vertices[0].y=A.y;
	Vertices[0].z=A.z;
	Vertices[0].color=color;
	
	Vertices[1].x=B.x;
	Vertices[1].y=B.y;
	Vertices[1].z=B.z;
	Vertices[1].color=color;


	D3DVB_XYZCOLOR->Unlock();

#ifdef API3D_DIRECT3D9
	D3DDevice->SetFVF( D3DFVF_XYZCOLOR );
	D3DDevice->SetStreamSource( 0, D3DVB_XYZCOLOR,0, sizeof(XYZCOLOR) );
#else
	D3DDevice->SetVertexShader( D3DFVF_XYZCOLOR );
	D3DDevice->SetStreamSource( 0, D3DVB_XYZCOLOR, sizeof(XYZCOLOR) );
#endif

	
	D3DDevice->DrawPrimitive( D3DPT_LINELIST,0,1);
#endif
#endif
}

void C3DAPIBASE::Line(CVector A,CVector B,float r,float g,float b,float r2,float g2,float b2)
{
    if (!Active) return;
    
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)

    vbline3d.SetColor(nbline3d+0,r,g,b,1.0f);
    vbline3d.SetColor(nbline3d+1,r2,g2,b2,1.0f);
    vbline3d.SetVertex(nbline3d+0,A);
    vbline3d.SetVertex(nbline3d+1,B);
    nbline3d+=2;
    if (nbline3d==NB_LINE_MAX) UpdateLines();
#else
#ifdef API3D_OPENGL
//------------------------------------------------------------------------------------------------ OPEN GL -----------
#ifdef GLES
	glDisable(GL_TEXTURE_2D);
	GLfloat vertices[3*2];
	GLfloat colors[4*2];

	colors[4*0 + 0]=r;
	colors[4*0 + 1]=g;
	colors[4*0 + 2]=b;
	colors[4*0 + 3]=1.0f;
	colors[4*1 + 0]=r2;
	colors[4*1 + 1]=g2;
	colors[4*1 + 2]=b2;
	colors[4*1 + 3]=1.0f;

	vertices[3*0 + 0]=A.x; vertices[3*0 + 1]=A.y; vertices[3*0 + 2]=A.z;
	vertices[3*1 + 0]=B.x; vertices[3*1 + 1]=B.y; vertices[3*1 + 2]=B.z;

	glVertexPointer(3,GL_FLOAT,0,vertices);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(4,GL_FLOAT,0,colors);
	glEnableClientState(GL_COLOR_ARRAY);
	glDrawArrays(GL_LINES,0,2);

#else
	glDisable(GL_TEXTURE_2D);
	glBegin(GL_LINES);
		glColor3f(r,g,b);
		glVertex3f(A.x,A.y,A.z);
		glColor3f(r2,g2,b2);
		glVertex3f(B.x,B.y,B.z);
	glEnd();
#endif
#else

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	struct XYZCOLOR * Vertices;

#ifdef API3D_DIRECT3D9
	D3DVB_XYZCOLOR->Lock(0,2*sizeof(XYZCOLOR),(void**)&Vertices,0);
#else
	D3DVB_XYZCOLOR->Lock(0,2*sizeof(XYZCOLOR),(BYTE**)&Vertices,0);
#endif

	DWORD color;

	color=D3DCOLOR_COLORVALUE(r,g,b,1);
	Vertices[0].x=A.x;
	Vertices[0].y=A.y;
	Vertices[0].z=A.z;
	Vertices[0].color=color;

	color=D3DCOLOR_COLORVALUE(r2,g2,b2,1);
	Vertices[1].x=B.x;
	Vertices[1].y=B.y;
	Vertices[1].z=B.z;
	Vertices[1].color=color;


	D3DVB_XYZCOLOR->Unlock();

#ifdef API3D_DIRECT3D9
	D3DDevice->SetFVF( D3DFVF_XYZCOLOR );
	D3DDevice->SetStreamSource( 0, D3DVB_XYZCOLOR,0, sizeof(XYZCOLOR) );
#else
	D3DDevice->SetVertexShader( D3DFVF_XYZCOLOR );
	D3DDevice->SetStreamSource( 0, D3DVB_XYZCOLOR, sizeof(XYZCOLOR) );
#endif

	
	D3DDevice->DrawPrimitive( D3DPT_LINELIST,0,1);
#endif
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		
		Draw Glow a Pow2

		void C3DAPIBASE::Glow(float x,float y,float sx,float sy,float K2,int HL,float MISC)

		x,y : co in screen coord.
		sizex,sizey: lengths of quad
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::Glow(float x,float y,float sx,float sy,float K2,int HL,float MISC,float RATIO)
{
#if defined(API3D_DIRECT3D9)||(defined(WINDOWS_PHONE)&&!defined(WINDOWS_STORE))||defined(WEBASM)
	SetParams(API3D_BLEND,OFF);
    for (int n=0;n<HL;n++)
    {
#if defined(WEBASM)
        float f=2*(1-(float) n/HL)*MISC;
        if (f>1) f=1;
#else
        float f=(1-(float) n/HL)*MISC;
#endif
        if (n==0)
		{
			Blur(0,0,sx,sy,0+K2*n,0+K2*n*RATIO,f,f,f,1);
			SetParams(API3D_BLEND,BLEND_GOURAUD);
		}
		else Blur(0,0,sx,sy,0+K2*n,0+K2*n*RATIO,f,f,f,1);
    }
	SetParams(API3D_BLEND,OFF);
#else
    int oldsf=OverClass;
    OverClass=0;
	CVertexBuffer *old=OverClassQuadZ;
	Flush();
	CVector4 val(K2,1.0f/(float)HL,MISC,RATIO);
	effect_hll_quadglow.setVector4("PARAM",val);
	OverClassQuadZ=&effect_hll_quadglow;	
	Quad(x,y,sx,sy,0,0,1,1, 1,1,1,1);
	Flush();
	OverClassQuadZ=old;
	OverClass=oldsf;
#endif
}

void C3DAPIBASE::BlurTmp(float x,float y,float sx,float sy,float decalx,float decaly,float r,float g,float b,float a)
{
    Quad(x,y,sx,sy,    0.0f+decalx,    0.0f+decaly,    1.0f,            1.0f,            r,g,b,a);
    Quad(x,y,sx,sy,    0.0f,            0.0f+decaly,    1.0f-decalx,    1.0f,            r,g,b,a);
    Quad(x,y,sx,sy,    0.0f+decalx,    0.0f,            1.0f,            1.0f-decaly,    r,g,b,a);
    Quad(x,y,sx,sy,    0.0f,            0.0f,            1.0f-decalx,    1.0f-decaly,    r,g,b,a);
}

void C3DAPIBASE::GlowPow2(float x,float y,float sx,float sy,float K2,int HL,float MISC,float RATIO)
{
#if (defined(API3D_DIRECT3D9)||(defined(WINDOWS_PHONE)&&!defined(WINDOWS_STORE))||defined(WEBASM))
    SetParams(API3D_BLEND,OFF);
    for (int n=0;n<HL;n++)
    {
#if defined(WEBASM)
        float f=2*(1-(float) n/HL)*MISC;
        if (f>1) f=1;
#else
        float f=(1-(float) n/HL)*MISC;
#endif
        if (n==0)
        {
            BlurTmp(0,0,sx,sy,0+K2*n,0+K2*n*RATIO,f,f,f,1);
            SetParams(API3D_BLEND,BLEND_COLOR);
        }
        else BlurTmp(0,0,sx,sy,0+K2*n,0+K2*n*RATIO,f,f,f,1);
    }
    Flush();
    SetParams(API3D_BLEND,OFF);
#else
    CVertexBuffer *old=OverClassQuadZ;
    Flush();
    CVector4 val(K2,1.0f/(float)HL,MISC,RATIO);
    effect_hll_quadglow2.setVector4("PARAM",val);
    OverClassQuadZ=&effect_hll_quadglow2;
    Quad(x,y,sx,sy,0,0,1,1, 1,1,1,1);
    Flush();
    OverClassQuadZ=old;
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		
		Draw Quad

		void C3DAPIBASE::Quad(float x,float y,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b)

		x,y : co in screen coord.
		sizex,sizey: lengths of quad
		x1,y1,x2,y2 : mapping coo
		r,g,b : color
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::Quad(float x0,float y0,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b)
{
    if (!Active) return;
    
    if (x0+sizex<X1base) return;
    if (y0+sizey<Y1base) return;
    if (x0>X2base) return;
    if (y0>Y2base) return;

	if (nMultiQuadsXYZ>0) Flush();
    
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif

#ifdef API3D_OPENGL20
	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
    float _x=x+sizex;
    
	float zz=0.5f;

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int n=nMultiQuads<<2;

    int adr=(n<<2);
    
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=1.0f;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=1.0f;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=1.0f;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=1.0f;
    
    adr=(n<<1) +n;

    if (SelectedRenderTarget==-1)
    {
        float y=decals_quads_y-VIEWPORT.a[3][1]+y0;

        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=y;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=y;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=y+sizey;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=y+sizey;
        vbquads.BVertex_Array[adr++]=zz;
    }
    else
    {        
        float _y1=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-y0;
        float _y2=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-(y0+sizey);

        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=_y1;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=_y1;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=_y2;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=_y2;
        vbquads.BVertex_Array[adr++]=zz;
    }

    adr=(n<<1);

    if ((aT<0)&&((OverClass==0)))
    {
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=1-y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=1-y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=1-y2;
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=1-y2;
    }
    else
    {
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=y2;
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=y2;
    }

	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif


#ifdef API3D_OPENGL

	float x=decals_quads_x+x0;
	float y=decals_quads_y+y0;

#ifdef GLES

	glEnable(GL_TEXTURE_2D);

	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
		glOrthof(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
	else
		glOrthof(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glDisable(GL_DEPTH_TEST);


	GLfloat vertices[4*2];
	GLfloat texvertices[4*2];
	GLfloat colorvertices[4*4];

	colorvertices[0*4+0]=r;
	colorvertices[0*4+1]=g;
	colorvertices[0*4+2]=b;
	colorvertices[0*4+3]=1.0f;

	colorvertices[1*4+0]=r;
	colorvertices[1*4+1]=g;
	colorvertices[1*4+2]=b;
	colorvertices[1*4+3]=1.0f;

	colorvertices[2*4+0]=r;
	colorvertices[2*4+1]=g;
	colorvertices[2*4+2]=b;
	colorvertices[2*4+3]=1.0f;

	colorvertices[3*4+0]=r;
	colorvertices[3*4+1]=g;
	colorvertices[3*4+2]=b;
	colorvertices[3*4+3]=1.0f;

	texvertices[2*0+0]=x1; texvertices[2*0+1]=y1;
	vertices[2*0+0]=(float) (x); vertices[2*0+1]=(float) SCREEN_Y-y;

	texvertices[2*1+0]=x2; texvertices[2*1+1]=y1;
	vertices[2*1+0]=(float) ((x+sizex)); vertices[2*1+1]=(float) SCREEN_Y-y;

	texvertices[2*2+0]=x1; texvertices[2*2+1]=y2;
	vertices[2*2+0]=(float) (x); vertices[2*2+1]=(float) SCREEN_Y-(y+sizey);

	texvertices[2*3+0]=x2; texvertices[2*3+1]=y2;
	vertices[2*3+0]=(float) ((x+sizex)); vertices[2*3+1]=(float) SCREEN_Y-(y+sizey);

	glVertexPointer(2,GL_FLOAT,0,vertices);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(4,GL_FLOAT,0,colorvertices);
	glEnableClientState(GL_COLOR_ARRAY);
	glClientActiveTexture(GL_TEXTURE0);
	glTexCoordPointer(2,GL_FLOAT,0,texvertices);
	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
	glDrawArrays(GL_TRIANGLE_STRIP,0,4);



	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
#else
//------------------------------------------------------------------------------------------------ OPEN GL -----------

	glEnable(GL_TEXTURE_2D);


	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
		glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
	else
		glOrtho(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);
		
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glDisable(GL_DEPTH_TEST);

	glBegin(GL_QUADS);

	glColor4f(r,g,b,1.0f);
	if (aT<0)
	{
		if (SelectedRenderTarget>=0)
		{
			
			glTexCoord2f(x1,y2);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);
		}
		else
		{
		
			glTexCoord2f(x1,y2);
			glVertex3f((float) x,(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-(y+sizey)),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (SCREEN_Y-(y+sizey)),0);
		}
	
	}
	else
	{

		if (SelectedRenderTarget>=0)
		{
			
			glTexCoord2f(x1,y2);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);
		}
		else
		{
		
			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-(y+sizey)),0);

			glTexCoord2f(x1,y2);
			glVertex3f((float) x,(float) (SCREEN_Y-(y+sizey)),0);
		}

	}
	
	glEnd();


	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
#endif
#endif


#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
	float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
	float zz=0.999f;
	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads<<2;

	DWORD c=D3DCOLOR_COLORVALUE(r,g,b,1.0f);

	MultiQuads[(adr)+0].color=c;
	MultiQuads[(adr)+0].x=(float) x;
	MultiQuads[(adr)+0].y=(float) y;
	MultiQuads[(adr)+0].xm=x1;
	MultiQuads[(adr)+0].ym=y1;
	MultiQuads[(adr)+0].z=zz;

	MultiQuads[(adr)+1].color=c;
	MultiQuads[(adr)+1].x=(float) (x+sizex);
	MultiQuads[(adr)+1].y=(float) y;
	MultiQuads[(adr)+1].xm=x2;
	MultiQuads[(adr)+1].ym=y1;
	MultiQuads[(adr)+1].z=zz;

	MultiQuads[(adr)+2].color=c;
	MultiQuads[(adr)+2].x=(float) (x+sizex);
	MultiQuads[(adr)+2].y=(float) (y+sizey);
	MultiQuads[(adr)+2].xm=x2;
	MultiQuads[(adr)+2].ym=y2;
	MultiQuads[(adr)+2].z=zz;

	MultiQuads[(adr)+3].color=c;
	MultiQuads[(adr)+3].x=(float) (x);
	MultiQuads[(adr)+3].y=(float) (y+sizey);
	MultiQuads[(adr)+3].xm=x1;
	MultiQuads[(adr)+3].ym=y2;
	MultiQuads[(adr)+3].z=zz;

	nMultiQuads++;

	MultiQuadsZbuffer=0;

#else

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
	float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
#if defined(API3D_DIRECT3D12)
    float zz=0.5f;
#else
    float zz=1.0f;
#endif

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads*4;

	vbquads.SetColor(adr+0,r,g,b,1);
	vbquads.SetColor(adr+1,r,g,b,1);
	vbquads.SetColor(adr+2,r,g,b,1);
	vbquads.SetColor(adr+3,r,g,b,1);

	vbquads.SetVertex(adr+0,x,y,zz);
	vbquads.SetVertex(adr+1,x+sizex,y,zz);
	vbquads.SetVertex(adr+2,x+sizex,y+sizey,zz);
	vbquads.SetVertex(adr+3,x,y+sizey,zz);

	vbquads.SetTexCoo(adr+0,x1,y1);
	vbquads.SetTexCoo(adr+1,x2,y1);
	vbquads.SetTexCoo(adr+2,x2,y2);
	vbquads.SetTexCoo(adr+3,x1,y2);

	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		
		Draw Quad

		void C3DAPIBASE::Quad(float x,float y,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b,float a)

		x,y : co in screen coord.
		sizex,sizey: lengths of quad
		x1,y1,x2,y2 : mapping coo
		r,g,b,a : color
		
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::Quad(float x0,float y0,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b,float a)
{
    if (!Active) return;
    if (x0+sizex<X1base) return;
    if (y0+sizey<Y1base) return;
    if (x0>X2base) return;
    if (y0>Y2base) return;

	if (nMultiQuadsXYZ>0) Flush();
    
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif

#ifdef API3D_OPENGL20

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
    float _x=x+sizex;

	float zz=0.5f;

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int n=nMultiQuads<<2;

    int adr=(n<<2);
    
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    
    adr=(n<<1) +n;

    if (SelectedRenderTarget==-1)
    {
        float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=y;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=y;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=y+sizey;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=y+sizey;
        vbquads.BVertex_Array[adr++]=zz;
    }
    else
    {
        float _y1=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-y0;
        float _y2=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-(y0+sizey);
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=_y1;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=_y1;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=_y2;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=_y2;
        vbquads.BVertex_Array[adr++]=zz;
    }
    
    adr=(n<<1);

    if ((aT<0)&&((OverClass==0)))
    {
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=1-y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=1-y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=1-y2;
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=1-y2;
    }
    else
    {
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=y2;
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=y2;
    }

	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif


#ifdef API3D_OPENGL

	float x=decals_quads_x+x0;
	float y=decals_quads_y+y0;


#ifdef GLES

	glEnable(GL_TEXTURE_2D);


	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
		glOrthof(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
	else
		glOrthof(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glDisable(GL_DEPTH_TEST);


	GLfloat vertices[4*2];
	GLfloat texvertices[4*2];
	GLfloat colorvertices[4*4];

	colorvertices[0*4+0]=r;
	colorvertices[0*4+1]=g;
	colorvertices[0*4+2]=b;
	colorvertices[0*4+3]=a;

	colorvertices[1*4+0]=r;
	colorvertices[1*4+1]=g;
	colorvertices[1*4+2]=b;
	colorvertices[1*4+3]=a;

	colorvertices[2*4+0]=r;
	colorvertices[2*4+1]=g;
	colorvertices[2*4+2]=b;
	colorvertices[2*4+3]=a;

	colorvertices[3*4+0]=r;
	colorvertices[3*4+1]=g;
	colorvertices[3*4+2]=b;
	colorvertices[3*4+3]=a;

	texvertices[2*0+0]=x1; texvertices[2*0+1]=y1;
	vertices[2*0+0]=(float) (x); vertices[2*0+1]=(float) SCREEN_Y-y;

	texvertices[2*1+0]=x2; texvertices[2*1+1]=y1;
	vertices[2*1+0]=(float) ((x+sizex)); vertices[2*1+1]=(float) SCREEN_Y-y;

	texvertices[2*2+0]=x1; texvertices[2*2+1]=y2;
	vertices[2*2+0]=(float) (x); vertices[2*2+1]=(float) SCREEN_Y-(y+sizey);

	texvertices[2*3+0]=x2; texvertices[2*3+1]=y2;
	vertices[2*3+0]=(float) ((x+sizex)); vertices[2*3+1]=(float) SCREEN_Y-(y+sizey);

	glVertexPointer(2,GL_FLOAT,0,vertices);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(4,GL_FLOAT,0,colorvertices);
	glEnableClientState(GL_COLOR_ARRAY);
	glClientActiveTexture(GL_TEXTURE0);
	glTexCoordPointer(2,GL_FLOAT,0,texvertices);
	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
	glDrawArrays(GL_TRIANGLE_STRIP,0,4);



	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
#else
//------------------------------------------------------------------------------------------------ OPEN GL -----------

	glEnable(GL_TEXTURE_2D);


	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
		glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
	else
		glOrtho(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);
		
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glDisable(GL_DEPTH_TEST);

	glBegin(GL_QUADS);

	glColor4f(r,g,b,a);
	if (aT<0)
	{
		if (SelectedRenderTarget>=0)
		{
			
			glTexCoord2f(x1,y2);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);
		}
		else
		{
		
			glTexCoord2f(x1,y2);
			glVertex3f((float) x,(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-(y+sizey)),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (SCREEN_Y-(y+sizey)),0);
		}
	
	}
	else
	{

		if (SelectedRenderTarget>=0)
		{
			
			glTexCoord2f(x1,y2);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);
		}
		else
		{
		
			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-(y+sizey)),0);

			glTexCoord2f(x1,y2);
			glVertex3f((float) x,(float) (SCREEN_Y-(y+sizey)),0);
		}

	}
	
	glEnd();


	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
#endif
#endif


#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
	float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
	float zz=0.999f;

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads<<2;

	DWORD c=D3DCOLOR_COLORVALUE(r,g,b,a);

	MultiQuads[(adr)+0].color=c;
	MultiQuads[(adr)+0].x=(float) x;
	MultiQuads[(adr)+0].y=(float) y;
	MultiQuads[(adr)+0].xm=x1;
	MultiQuads[(adr)+0].ym=y1;
	MultiQuads[(adr)+0].z=zz;

	MultiQuads[(adr)+1].color=c;
	MultiQuads[(adr)+1].x=(float) (x+sizex);
	MultiQuads[(adr)+1].y=(float) y;
	MultiQuads[(adr)+1].xm=x2;
	MultiQuads[(adr)+1].ym=y1;
	MultiQuads[(adr)+1].z=zz;

	MultiQuads[(adr)+2].color=c;
	MultiQuads[(adr)+2].x=(float) (x+sizex);
	MultiQuads[(adr)+2].y=(float) (y+sizey);
	MultiQuads[(adr)+2].xm=x2;
	MultiQuads[(adr)+2].ym=y2;
	MultiQuads[(adr)+2].z=zz;

	MultiQuads[(adr)+3].color=c;
	MultiQuads[(adr)+3].x=(float) (x);
	MultiQuads[(adr)+3].y=(float) (y+sizey);
	MultiQuads[(adr)+3].xm=x1;
	MultiQuads[(adr)+3].ym=y2;
	MultiQuads[(adr)+3].z=zz;

	nMultiQuads++;

	MultiQuadsZbuffer=0;

#else

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
	float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
#if defined(API3D_DIRECT3D12)
    float zz=0.5f;
#else
    float zz=1.0f;
#endif

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads*4;

	vbquads.SetColor(adr+0,r,g,b,a);
	vbquads.SetColor(adr+1,r,g,b,a);
	vbquads.SetColor(adr+2,r,g,b,a);
	vbquads.SetColor(adr+3,r,g,b,a);

	vbquads.SetVertex(adr+0,x,y,zz);
	vbquads.SetVertex(adr+1,x+sizex,y,zz);
	vbquads.SetVertex(adr+2,x+sizex,y+sizey,zz);
	vbquads.SetVertex(adr+3,x,y+sizey,zz);

	vbquads.SetTexCoo(adr+0,x1,y1);
	vbquads.SetTexCoo(adr+1,x2,y1);
	vbquads.SetTexCoo(adr+2,x2,y2);
	vbquads.SetTexCoo(adr+3,x1,y2);

	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif
#endif

}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		
		Draw Quad Def

		void C3DAPIBASE::QuadDef(...)

		xABCD,yABCD : co in screen coord.
		x1,y1,x2,y2 : mapping coo
		r,g,b,a : color
		
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::QuadDef(float _xA,float _yA,float _xB,float _yB,float _xC,float _yC,float _xD,float _yD,float x1,float y1,float x2,float y2,float r,float g,float b,float a)
{
    if (!Active) return;

	if (nMultiQuadsXYZ>0) Flush();
    
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif

#ifdef API3D_OPENGL20  

	float zz=0.5f;

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int n=nMultiQuads<<2;

    int adr=(n<<2);
    
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    
    adr=(n<<1) +n;

    if (SelectedRenderTarget==-1)
    {
		float xA=decals_quads_x-VIEWPORT.a[3][0]+_xA;
		float yA=decals_quads_y-VIEWPORT.a[3][1]+_yA;

		float xB=decals_quads_x-VIEWPORT.a[3][0]+_xB;
		float yB=decals_quads_y-VIEWPORT.a[3][1]+_yB;

		float xC=decals_quads_x-VIEWPORT.a[3][0]+_xC;
		float yC=decals_quads_y-VIEWPORT.a[3][1]+_yC;

		float xD=decals_quads_x-VIEWPORT.a[3][0]+_xD;
		float yD=decals_quads_y-VIEWPORT.a[3][1]+_yD;

		vbquads.BVertex_Array[adr++]=xA;
        vbquads.BVertex_Array[adr++]=yA;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=xB;
        vbquads.BVertex_Array[adr++]=yB;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=xC;
        vbquads.BVertex_Array[adr++]=yC;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=xD;
        vbquads.BVertex_Array[adr++]=yD;
        vbquads.BVertex_Array[adr++]=zz;
    }
    else
    {
		float xA=decals_quads_x-VIEWPORT.a[3][0]+_xA;
		float yA=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-_yA;

		float xB=decals_quads_x-VIEWPORT.a[3][0]+_xB;
		float yB=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-_yB;

		float xC=decals_quads_x-VIEWPORT.a[3][0]+_xC;
		float yC=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-_yC;

		float xD=decals_quads_x-VIEWPORT.a[3][0]+_xD;
		float yD=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-_yD;

        vbquads.BVertex_Array[adr++]=xA;
        vbquads.BVertex_Array[adr++]=yA;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=xB;
        vbquads.BVertex_Array[adr++]=yB;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=xC;
        vbquads.BVertex_Array[adr++]=yC;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=xD;
        vbquads.BVertex_Array[adr++]=yD;
        vbquads.BVertex_Array[adr++]=zz;
    }
    
    adr=(n<<1);

    if ((aT<0)&&((OverClass==0)))
    {
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=1-y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=1-y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=1-y2;
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=1-y2;
    }
    else
    {
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=y2;
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=y2;
    }

	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif


#ifdef API3D_OPENGL

	float xA=decals_quads_x+_xA;
	float yA=decals_quads_y+_yA;

	float xB=decals_quads_x+_xB;
	float yB=decals_quads_y+_yB;

	float xC=decals_quads_x+_xC;
	float yC=decals_quads_y+_yC;

	float xD=decals_quads_x+_xD;
	float yD=decals_quads_y+_yD;


#ifdef GLES

	glEnable(GL_TEXTURE_2D);


	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
		glOrthof(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
	else
		glOrthof(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glDisable(GL_DEPTH_TEST);


	GLfloat vertices[4*2];
	GLfloat texvertices[4*2];
	GLfloat colorvertices[4*4];

	colorvertices[0*4+0]=r;
	colorvertices[0*4+1]=g;
	colorvertices[0*4+2]=b;
	colorvertices[0*4+3]=a;

	colorvertices[1*4+0]=r;
	colorvertices[1*4+1]=g;
	colorvertices[1*4+2]=b;
	colorvertices[1*4+3]=a;

	colorvertices[2*4+0]=r;
	colorvertices[2*4+1]=g;
	colorvertices[2*4+2]=b;
	colorvertices[2*4+3]=a;

	colorvertices[3*4+0]=r;
	colorvertices[3*4+1]=g;
	colorvertices[3*4+2]=b;
	colorvertices[3*4+3]=a;

	texvertices[2*0+0]=x1; texvertices[2*0+1]=y1;
	vertices[2*0+0]=(float) (xA); vertices[2*0+1]=(float) SCREEN_Y-yA;

	texvertices[2*1+0]=x2; texvertices[2*1+1]=y1;
	vertices[2*1+0]=(float) ((xB)); vertices[2*1+1]=(float) SCREEN_Y-yB;

	texvertices[2*2+0]=x1; texvertices[2*2+1]=y2;
	vertices[2*2+0]=(float) (xC); vertices[2*2+1]=(float) SCREEN_Y-yC;

	texvertices[2*3+0]=x2; texvertices[2*3+1]=y2;
	vertices[2*3+0]=(float) ((xD)); vertices[2*3+1]=(float) SCREEN_Y-yD;

	glVertexPointer(2,GL_FLOAT,0,vertices);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(4,GL_FLOAT,0,colorvertices);
	glEnableClientState(GL_COLOR_ARRAY);
	glClientActiveTexture(GL_TEXTURE0);
	glTexCoordPointer(2,GL_FLOAT,0,texvertices);
	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
	glDrawArrays(GL_TRIANGLE_STRIP,0,4);

	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
#else
//------------------------------------------------------------------------------------------------ OPEN GL -----------

	glEnable(GL_TEXTURE_2D);


	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
		glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
	else
		glOrtho(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);
		
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glDisable(GL_DEPTH_TEST);

	glBegin(GL_QUADS);

	glColor4f(r,g,b,a);
	if (aT<0)
	{
		if (SelectedRenderTarget>=0)
		{			
			glTexCoord2f(x1,y2);
			glVertex3f((float) xA,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-yA),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (xB),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-yB),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (xC),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-yC),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) xD,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-yD),0);
		}
		else
		{		
			glTexCoord2f(x1,y2);
			glVertex3f((float) xA,(float) (SCREEN_Y-yA),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) xB,(float) (SCREEN_Y-yB),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) xC,(float) (SCREEN_Y-yC),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) xD,(float) (SCREEN_Y-yD),0);
		}
	
	}
	else
	{
		if (SelectedRenderTarget>=0)
		{
			glTexCoord2f(x1,y2);
			glVertex3f((float) xA,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-yA),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) xB,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-yB),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) xC,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-yC),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) xD,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-yD),0);
		}
		else
		{
			glTexCoord2f(x1,y1);
			glVertex3f((float) xA,(float) (SCREEN_Y-yA),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) xB,(float) (SCREEN_Y-yB),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) xC,(float) (SCREEN_Y-yC),0);

			glTexCoord2f(x1,y2);
			glVertex3f((float) xD,(float) (SCREEN_Y-yD),0);
		}
	}
	
	glEnd();

	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
#endif
#endif


#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)

	float xA=decals_quads_x-VIEWPORT.a[3][0]+_xA;
	float yA=decals_quads_y-VIEWPORT.a[3][1]+_yA;

	float xB=decals_quads_x-VIEWPORT.a[3][0]+_xB;
	float yB=decals_quads_y-VIEWPORT.a[3][1]+_yB;

	float xC=decals_quads_x-VIEWPORT.a[3][0]+_xC;
	float yC=decals_quads_y-VIEWPORT.a[3][1]+_yC;

	float xD=decals_quads_x-VIEWPORT.a[3][0]+_xD;
	float yD=decals_quads_y-VIEWPORT.a[3][1]+_yD;

	float zz=0.999f;

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads<<2;

	DWORD c=D3DCOLOR_COLORVALUE(r,g,b,a);

	MultiQuads[(adr)+0].color=c;
	MultiQuads[(adr)+0].x=(float) xA;
	MultiQuads[(adr)+0].y=(float) yA;
	MultiQuads[(adr)+0].xm=x1;
	MultiQuads[(adr)+0].ym=y1;
	MultiQuads[(adr)+0].z=zz;

	MultiQuads[(adr)+1].color=c;
	MultiQuads[(adr)+1].x=(float) xB;
	MultiQuads[(adr)+1].y=(float) yB;
	MultiQuads[(adr)+1].xm=x2;
	MultiQuads[(adr)+1].ym=y1;
	MultiQuads[(adr)+1].z=zz;

	MultiQuads[(adr)+2].color=c;
	MultiQuads[(adr)+2].x=(float) xC;
	MultiQuads[(adr)+2].y=(float) yC;
	MultiQuads[(adr)+2].xm=x2;
	MultiQuads[(adr)+2].ym=y2;
	MultiQuads[(adr)+2].z=zz;

	MultiQuads[(adr)+3].color=c;
	MultiQuads[(adr)+3].x=(float) xD;
	MultiQuads[(adr)+3].y=(float) yD;
	MultiQuads[(adr)+3].xm=x1;
	MultiQuads[(adr)+3].ym=y2;
	MultiQuads[(adr)+3].z=zz;

	nMultiQuads++;

	MultiQuadsZbuffer=0;

#else

	float xA=decals_quads_x-VIEWPORT.a[3][0]+_xA;
	float yA=decals_quads_y-VIEWPORT.a[3][1]+_yA;

	float xB=decals_quads_x-VIEWPORT.a[3][0]+_xB;
	float yB=decals_quads_y-VIEWPORT.a[3][1]+_yB;

	float xC=decals_quads_x-VIEWPORT.a[3][0]+_xC;
	float yC=decals_quads_y-VIEWPORT.a[3][1]+_yC;

	float xD=decals_quads_x-VIEWPORT.a[3][0]+_xD;
	float yD=decals_quads_y-VIEWPORT.a[3][1]+_yD;

#if defined(API3D_DIRECT3D12)
    float zz=0.5f;
#else
    float zz=1.0f;
#endif

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads*4;

	vbquads.SetColor(adr+0,r,g,b,a);
	vbquads.SetColor(adr+1,r,g,b,a);
	vbquads.SetColor(adr+2,r,g,b,a);
	vbquads.SetColor(adr+3,r,g,b,a);

	vbquads.SetVertex(adr+0,xA,yA,zz);
	vbquads.SetVertex(adr+1,xB,yB,zz);
	vbquads.SetVertex(adr+2,xC,yC,zz);
	vbquads.SetVertex(adr+3,xD,yD,zz);

	vbquads.SetTexCoo(adr+0,x1,y1);
	vbquads.SetTexCoo(adr+1,x2,y1);
	vbquads.SetTexCoo(adr+2,x2,y2);
	vbquads.SetTexCoo(adr+3,x1,y2);

	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif
#endif

}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		
		Draw Quad Four

		void C3DAPIBASE::Quad(float x,float y,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b,float a)

		x,y : co in screen coord.
		sizex,sizey: lengths of quad
		x1,y1,x2,y2 : mapping coo
		r,g,b,a : color
		
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::QuadFour(float x0,float y0,float sizex,float sizey,float x1,float y1,float x2,float y2,float x3,float y3,float x4,float y4,float r,float g,float b,float a)
{
    if (!Active) return;
    if (x0+sizex<X1base) return;
    if (y0+sizey<Y1base) return;
    if (x0>X2base) return;
    if (y0>Y2base) return;

	if (nMultiQuadsXYZ>0) Flush();
    
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif

#ifdef API3D_OPENGL20

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
    float _x=x+sizex;

	float zz=0.5f;

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int n=nMultiQuads<<2;

    int adr=(n<<2);
    
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    
    adr=(n<<1) +n;

    if (SelectedRenderTarget==-1)
    {
        float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=y;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=y;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=y+sizey;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=y+sizey;
        vbquads.BVertex_Array[adr++]=zz;
    }
    else
    {
        float _y1=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-y0;
        float _y2=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-(y0+sizey);
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=_y1;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=_y1;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=_y2;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=_y2;
        vbquads.BVertex_Array[adr++]=zz;
    }
    
    adr=(n<<1);

    if ((aT<0)&&((OverClass==0)))
    {
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=1-y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=1-y2;
        vbquads.BTexCoo_Array[adr++]=x3; vbquads.BTexCoo_Array[adr++]=1-y3;
        vbquads.BTexCoo_Array[adr++]=x4; vbquads.BTexCoo_Array[adr++]=1-y4;
    }
    else
    {
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=y2;
        vbquads.BTexCoo_Array[adr++]=x3; vbquads.BTexCoo_Array[adr++]=y3;
        vbquads.BTexCoo_Array[adr++]=x4; vbquads.BTexCoo_Array[adr++]=y4;
    }

	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif

// NO BASIC OPENGL

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
	float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
	float zz=0.999f;

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads<<2;

	DWORD c=D3DCOLOR_COLORVALUE(r,g,b,a);

	MultiQuads[(adr)+0].color=c;
	MultiQuads[(adr)+0].x=(float) x;
	MultiQuads[(adr)+0].y=(float) y;
	MultiQuads[(adr)+0].xm=x1;
	MultiQuads[(adr)+0].ym=y1;
	MultiQuads[(adr)+0].z=zz;

	MultiQuads[(adr)+1].color=c;
	MultiQuads[(adr)+1].x=(float) (x+sizex);
	MultiQuads[(adr)+1].y=(float) y;
	MultiQuads[(adr)+1].xm=x2;
	MultiQuads[(adr)+1].ym=y2;
	MultiQuads[(adr)+1].z=zz;

	MultiQuads[(adr)+2].color=c;
	MultiQuads[(adr)+2].x=(float) (x+sizex);
	MultiQuads[(adr)+2].y=(float) (y+sizey);
	MultiQuads[(adr)+2].xm=x3;
	MultiQuads[(adr)+2].ym=y3;
	MultiQuads[(adr)+2].z=zz;

	MultiQuads[(adr)+3].color=c;
	MultiQuads[(adr)+3].x=(float) (x);
	MultiQuads[(adr)+3].y=(float) (y+sizey);
	MultiQuads[(adr)+3].xm=x4;
	MultiQuads[(adr)+3].ym=y4;
	MultiQuads[(adr)+3].z=zz;

	nMultiQuads++;

	MultiQuadsZbuffer=0;

#else

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
	float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
#if defined(API3D_DIRECT3D12)
    float zz=0.5f;
#else
    float zz=1.0f;
#endif

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads*4;

	vbquads.SetColor(adr+0,r,g,b,a);
	vbquads.SetColor(adr+1,r,g,b,a);
	vbquads.SetColor(adr+2,r,g,b,a);
	vbquads.SetColor(adr+3,r,g,b,a);

	vbquads.SetVertex(adr+0,x,y,zz);
	vbquads.SetVertex(adr+1,x+sizex,y,zz);
	vbquads.SetVertex(adr+2,x+sizex,y+sizey,zz);
	vbquads.SetVertex(adr+3,x,y+sizey,zz);

	vbquads.SetTexCoo(adr+0,x1,y1);
	vbquads.SetTexCoo(adr+1,x2,y2);
	vbquads.SetTexCoo(adr+2,x3,y3);
	vbquads.SetTexCoo(adr+3,x4,y4);

	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif
#endif

}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		
		Draw Quad

		void C3DAPIBASE::QuadGradient(float x,float y,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b,float a)

		x,y : co in screen coord.
		sizex,sizey: lengths of quad
		x1,y1,x2,y2 : mapping coo
		r,g,b,a : color
		
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::QuadGradient(float x0,float y0,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b,float a,float r2,float g2,float b2,float a2,int hv)
{
    if (!Active) return;
    if (x0+sizex<X1base) return;
    if (y0+sizey<Y1base) return;
    if (x0>X2base) return;
    if (y0>Y2base) return;

	if (nMultiQuadsXYZ>0) Flush();
    
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif

#ifdef API3D_OPENGL20

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
    float _x=x+sizex;

	float zz=0.5f;

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int n=nMultiQuads<<2;

    int adr=(n<<2);

    if (hv==0)
	{
		vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
		vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
		vbquads.BColor_Array[adr++]=r2; vbquads.BColor_Array[adr++]=g2; vbquads.BColor_Array[adr++]=b2; vbquads.BColor_Array[adr++]=a2;
		vbquads.BColor_Array[adr++]=r2; vbquads.BColor_Array[adr++]=g2; vbquads.BColor_Array[adr++]=b2; vbquads.BColor_Array[adr++]=a2;
	}
	else
	{
		vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
		vbquads.BColor_Array[adr++]=r2; vbquads.BColor_Array[adr++]=g2; vbquads.BColor_Array[adr++]=b2; vbquads.BColor_Array[adr++]=a2;
		vbquads.BColor_Array[adr++]=r2; vbquads.BColor_Array[adr++]=g2; vbquads.BColor_Array[adr++]=b2; vbquads.BColor_Array[adr++]=a2;
	    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
	}
    
    adr=(n<<1) +n;
    
    if (SelectedRenderTarget==-1)
    {
        float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=y;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=y;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=y+sizey;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=y+sizey;
        vbquads.BVertex_Array[adr++]=zz;
    }
    else
    {
        float _y1=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-y0;
        float _y2=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-(y0+sizey);
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=_y1;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=_y1;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=_y2;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=_y2;
        vbquads.BVertex_Array[adr++]=zz;
    }
    
    adr=(n<<1);
    
    if (aT<0)
    {
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=1-y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=1-y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=1-y2;
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=1-y2;
    }
    else
    {
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=y2;
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=y2;
    }
    
	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif


#ifdef API3D_OPENGL

	float x=decals_quads_x+x0;
	float y=decals_quads_y+y0;


#ifdef GLES

	glEnable(GL_TEXTURE_2D);


	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
		glOrthof(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
	else
		glOrthof(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glDisable(GL_DEPTH_TEST);


	GLfloat vertices[4*2];
	GLfloat texvertices[4*2];
	GLfloat colorvertices[4*4];

	colorvertices[0*4+0]=r;
	colorvertices[0*4+1]=g;
	colorvertices[0*4+2]=b;
	colorvertices[0*4+3]=a;

	colorvertices[1*4+0]=r;
	colorvertices[1*4+1]=g;
	colorvertices[1*4+2]=b;
	colorvertices[1*4+3]=a;

	colorvertices[2*4+0]=r;
	colorvertices[2*4+1]=g;
	colorvertices[2*4+2]=b;
	colorvertices[2*4+3]=a;

	colorvertices[3*4+0]=r;
	colorvertices[3*4+1]=g;
	colorvertices[3*4+2]=b;
	colorvertices[3*4+3]=a;

	texvertices[2*0+0]=x1; texvertices[2*0+1]=y1;
	vertices[2*0+0]=(float) (x); vertices[2*0+1]=(float) SCREEN_Y-y;

	texvertices[2*1+0]=x2; texvertices[2*1+1]=y1;
	vertices[2*1+0]=(float) ((x+sizex)); vertices[2*1+1]=(float) SCREEN_Y-y;

	texvertices[2*2+0]=x1; texvertices[2*2+1]=y2;
	vertices[2*2+0]=(float) (x); vertices[2*2+1]=(float) SCREEN_Y-(y+sizey);

	texvertices[2*3+0]=x2; texvertices[2*3+1]=y2;
	vertices[2*3+0]=(float) ((x+sizex)); vertices[2*3+1]=(float) SCREEN_Y-(y+sizey);

	glVertexPointer(2,GL_FLOAT,0,vertices);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(4,GL_FLOAT,0,colorvertices);
	glEnableClientState(GL_COLOR_ARRAY);
	glClientActiveTexture(GL_TEXTURE0);
	glTexCoordPointer(2,GL_FLOAT,0,texvertices);
	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
	glDrawArrays(GL_TRIANGLE_STRIP,0,4);



	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
#else
//------------------------------------------------------------------------------------------------ OPEN GL -----------

	glEnable(GL_TEXTURE_2D);


	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
		glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
	else
		glOrtho(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);
		
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glDisable(GL_DEPTH_TEST);

	glBegin(GL_QUADS);

	glColor4f(r,g,b,a);
	if (aT<0)
	{
		if (SelectedRenderTarget>=0)
		{
			
			glTexCoord2f(x1,y2);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);
		}
		else
		{
		
			glTexCoord2f(x1,y2);
			glVertex3f((float) x,(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-(y+sizey)),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (SCREEN_Y-(y+sizey)),0);
		}
	
	}
	else
	{

		if (SelectedRenderTarget>=0)
		{
			
			glTexCoord2f(x1,y2);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);
		}
		else
		{
		
			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-(y+sizey)),0);

			glTexCoord2f(x1,y2);
			glVertex3f((float) x,(float) (SCREEN_Y-(y+sizey)),0);
		}

	}
	
	glEnd();


	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
#endif
#endif


#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
	float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
	float zz=0.999f;

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads<<2;

	DWORD c=D3DCOLOR_COLORVALUE(r,g,b,a);
	DWORD c2=D3DCOLOR_COLORVALUE(r2,g2,b2,a2);

	MultiQuads[(adr)+0].color=c;
	MultiQuads[(adr)+0].x=(float) x;
	MultiQuads[(adr)+0].y=(float) y;
	MultiQuads[(adr)+0].xm=x1;
	MultiQuads[(adr)+0].ym=y1;
	MultiQuads[(adr)+0].z=zz;

	if (hv==0) MultiQuads[(adr)+1].color=c; else MultiQuads[(adr)+1].color=c2;
	MultiQuads[(adr)+1].x=(float) (x+sizex);
	MultiQuads[(adr)+1].y=(float) y;
	MultiQuads[(adr)+1].xm=x2;
	MultiQuads[(adr)+1].ym=y1;
	MultiQuads[(adr)+1].z=zz;

	MultiQuads[(adr)+2].color=c2;
	MultiQuads[(adr)+2].x=(float) (x+sizex);
	MultiQuads[(adr)+2].y=(float) (y+sizey);
	MultiQuads[(adr)+2].xm=x2;
	MultiQuads[(adr)+2].ym=y2;
	MultiQuads[(adr)+2].z=zz;

	if (hv==0) MultiQuads[(adr)+3].color=c2; else MultiQuads[(adr)+3].color=c;
	MultiQuads[(adr)+3].x=(float) (x);
	MultiQuads[(adr)+3].y=(float) (y+sizey);
	MultiQuads[(adr)+3].xm=x1;
	MultiQuads[(adr)+3].ym=y2;
	MultiQuads[(adr)+3].z=zz;

	nMultiQuads++;

	MultiQuadsZbuffer=0;

#else

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
	float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
#if defined(API3D_DIRECT3D12)
    float zz=0.5f;
#else
    float zz=1.0f;
#endif

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads*4;

	if (hv==0)
	{
		vbquads.SetColor(adr+0,r,g,b,a);
		vbquads.SetColor(adr+1,r,g,b,a);
		vbquads.SetColor(adr+2,r2,g2,b2,a2);
		vbquads.SetColor(adr+3,r2,g2,b2,a2);
	}
	else
	{
		vbquads.SetColor(adr+0,r,g,b,a);
		vbquads.SetColor(adr+1,r2,g2,b2,a2);
		vbquads.SetColor(adr+2,r2,g2,b2,a2);
		vbquads.SetColor(adr+3,r,g,b,a);
	}

	vbquads.SetVertex(adr+0,x,y,zz);
	vbquads.SetVertex(adr+1,x+sizex,y,zz);
	vbquads.SetVertex(adr+2,x+sizex,y+sizey,zz);
	vbquads.SetVertex(adr+3,x,y+sizey,zz);

	vbquads.SetTexCoo(adr+0,x1,y1);
	vbquads.SetTexCoo(adr+1,x2,y1);
	vbquads.SetTexCoo(adr+2,x2,y2);
	vbquads.SetTexCoo(adr+3,x1,y2);

	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif
#endif

}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		
		Draw Quad

		void C3DAPIBASE::Quad(float x,float y,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b,float a)

		x,y : co in screen coord.
		sizex,sizey: lengths of quad
		x1,y1,x2,y2 : mapping coo
		r,g,b,a : color
		
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::QuadTaper(float x0,float y0,float taper,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b,float a)
{
    if (!Active) return;
    if (x0+sizex<X1base+taper) return;
    if (y0+sizey<Y1base) return;
    if (x0>X2base) return;
    if (y0>Y2base) return;

	if (nMultiQuadsXYZ>0) Flush();
        
#ifdef API3D_OPENGL20

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
    float _x=x+sizex;

	float zz=0.5f;

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int n=nMultiQuads<<2;

    int adr=(n<<2);
    
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    vbquads.BColor_Array[adr++]=r; vbquads.BColor_Array[adr++]=g; vbquads.BColor_Array[adr++]=b; vbquads.BColor_Array[adr++]=a;
    
    adr=(n<<1) +n;
    
    if (SelectedRenderTarget==-1)
    {
        float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
        
        vbquads.BVertex_Array[adr++]=x+taper;
        vbquads.BVertex_Array[adr++]=y;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x+taper;
        vbquads.BVertex_Array[adr++]=y;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=y+sizey;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=y+sizey;
        vbquads.BVertex_Array[adr++]=zz;
    }
    else
    {
        float _y1=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-y0;
        float _y2=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-(y0+sizey);
        
        vbquads.BVertex_Array[adr++]=x+taper;
        vbquads.BVertex_Array[adr++]=_y1;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x+taper;
        vbquads.BVertex_Array[adr++]=_y1;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=_x;
        vbquads.BVertex_Array[adr++]=_y2;
        vbquads.BVertex_Array[adr++]=zz;
        
        vbquads.BVertex_Array[adr++]=x;
        vbquads.BVertex_Array[adr++]=_y2;
        vbquads.BVertex_Array[adr++]=zz;
    }
    
    adr=(n<<1);
    
    if (aT<0)
    {
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=1-y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=1-y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=1-y2;
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=1-y2;
    }
    else
    {
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=y1;
        vbquads.BTexCoo_Array[adr++]=x2; vbquads.BTexCoo_Array[adr++]=y2;
        vbquads.BTexCoo_Array[adr++]=x1; vbquads.BTexCoo_Array[adr++]=y2;
    }
    
	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif


#ifdef API3D_OPENGL

	float x=decals_quads_x+x0;
	float y=decals_quads_y+y0;


#ifdef GLES

	glEnable(GL_TEXTURE_2D);


	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
		glOrthof(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
	else
		glOrthof(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glDisable(GL_DEPTH_TEST);


	GLfloat vertices[4*2];
	GLfloat texvertices[4*2];
	GLfloat colorvertices[4*4];

	colorvertices[0*4+0]=r;
	colorvertices[0*4+1]=g;
	colorvertices[0*4+2]=b;
	colorvertices[0*4+3]=a;

	colorvertices[1*4+0]=r;
	colorvertices[1*4+1]=g;
	colorvertices[1*4+2]=b;
	colorvertices[1*4+3]=a;

	colorvertices[2*4+0]=r;
	colorvertices[2*4+1]=g;
	colorvertices[2*4+2]=b;
	colorvertices[2*4+3]=a;

	colorvertices[3*4+0]=r;
	colorvertices[3*4+1]=g;
	colorvertices[3*4+2]=b;
	colorvertices[3*4+3]=a;

	texvertices[2*0+0]=x1; texvertices[2*0+1]=y1;
	vertices[2*0+0]=(float) (x+taper); vertices[2*0+1]=(float) SCREEN_Y-y;

	texvertices[2*1+0]=x2; texvertices[2*1+1]=y1;
	vertices[2*1+0]=(float) ((x+sizex+taper)); vertices[2*1+1]=(float) SCREEN_Y-y;

	texvertices[2*2+0]=x1; texvertices[2*2+1]=y2;
	vertices[2*2+0]=(float) (x); vertices[2*2+1]=(float) SCREEN_Y-(y+sizey);

	texvertices[2*3+0]=x2; texvertices[2*3+1]=y2;
	vertices[2*3+0]=(float) ((x+sizex)); vertices[2*3+1]=(float) SCREEN_Y-(y+sizey);

	glVertexPointer(2,GL_FLOAT,0,vertices);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(4,GL_FLOAT,0,colorvertices);
	glEnableClientState(GL_COLOR_ARRAY);
	glClientActiveTexture(GL_TEXTURE0);
	glTexCoordPointer(2,GL_FLOAT,0,texvertices);
	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
	glDrawArrays(GL_TRIANGLE_STRIP,0,4);



	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
#else
//------------------------------------------------------------------------------------------------ OPEN GL -----------

	glEnable(GL_TEXTURE_2D);


	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
		glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
	else
		glOrtho(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);
		
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glDisable(GL_DEPTH_TEST);

	glBegin(GL_QUADS);

	glColor4f(r,g,b,a);
	if (aT<0)
	{
		if (SelectedRenderTarget>=0)
		{
			
			glTexCoord2f(x1,y2);
			glVertex3f((float) x+taper,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex+taper),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);
		}
		else
		{
		
			glTexCoord2f(x1,y2);
			glVertex3f((float) x+taper,(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex+taper),(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-(y+sizey)),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (SCREEN_Y-(y+sizey)),0);
		}
	
	}
	else
	{

		if (SelectedRenderTarget>=0)
		{
			
			glTexCoord2f(x1,y2);
			glVertex3f((float) x+taper,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex+taper),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);
		}
		else
		{
		
			glTexCoord2f(x1,y1);
			glVertex3f((float) x+taper,(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (x+sizex+taper),(float) (SCREEN_Y-y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-(y+sizey)),0);

			glTexCoord2f(x1,y2);
			glVertex3f((float) x,(float) (SCREEN_Y-(y+sizey)),0);
		}

	}
	
	glEnd();


	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
#endif
#endif


#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
	float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
	float zz=0.999f;

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads<<2;

	DWORD c=D3DCOLOR_COLORVALUE(r,g,b,a);

	MultiQuads[(adr)+0].color=c;
	MultiQuads[(adr)+0].x=(float) x+taper;
	MultiQuads[(adr)+0].y=(float) y;
	MultiQuads[(adr)+0].xm=x1;
	MultiQuads[(adr)+0].ym=y1;
	MultiQuads[(adr)+0].z=zz;

	MultiQuads[(adr)+1].color=c;
	MultiQuads[(adr)+1].x=(float) (x+sizex+taper);
	MultiQuads[(adr)+1].y=(float) y;
	MultiQuads[(adr)+1].xm=x2;
	MultiQuads[(adr)+1].ym=y1;
	MultiQuads[(adr)+1].z=zz;

	MultiQuads[(adr)+2].color=c;
	MultiQuads[(adr)+2].x=(float) (x+sizex);
	MultiQuads[(adr)+2].y=(float) (y+sizey);
	MultiQuads[(adr)+2].xm=x2;
	MultiQuads[(adr)+2].ym=y2;
	MultiQuads[(adr)+2].z=zz;

	MultiQuads[(adr)+3].color=c;
	MultiQuads[(adr)+3].x=(float) (x);
	MultiQuads[(adr)+3].y=(float) (y+sizey);
	MultiQuads[(adr)+3].xm=x1;
	MultiQuads[(adr)+3].ym=y2;
	MultiQuads[(adr)+3].z=zz;

	nMultiQuads++;

	MultiQuadsZbuffer=0;

#else

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
	float y=decals_quads_y-VIEWPORT.a[3][1]+y0;
	float zz=0.5f;

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads*4;

	vbquads.SetColor(adr+0,r,g,b,a);
	vbquads.SetColor(adr+1,r,g,b,a);
	vbquads.SetColor(adr+2,r,g,b,a);
	vbquads.SetColor(adr+3,r,g,b,a);

	vbquads.SetVertex(adr+0,x+taper,y,zz);
	vbquads.SetVertex(adr+1,x+sizex+taper,y,zz);
	vbquads.SetVertex(adr+2,x+sizex,y+sizey,zz);
	vbquads.SetVertex(adr+3,x,y+sizey,zz);

	vbquads.SetTexCoo(adr+0,x1,y1);
	vbquads.SetTexCoo(adr+1,x2,y1);
	vbquads.SetTexCoo(adr+2,x2,y2);
	vbquads.SetTexCoo(adr+3,x1,y2);

	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif
#endif

}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		
		Draw Quad

		void C3DAPIBASE::Quad(float x,float y,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b,float a)

		x,y : co in screen coord.
		sizex,sizey: lengths of quad
		x1,y1,x2,y2 : mapping coo
		r,g,b,a : color
		
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::QuadRot(float x0,float y0,float sizex,float sizey,float ang,float x1,float y1,float x2,float y2,float r,float g,float b,float a)
{
    if (!Active) return;

	if (nMultiQuadsXYZ>0) Flush();
    
#ifdef API3D_OPENGL20

	float s=sinf(ang*PI/180.0f);
	float c=cosf(ang*PI/180.0f);

	CVector2 p1,p2,p3,p4;
    
	p1.x=x0 - c*sizex - s*sizey;
	p1.y=y0 + s*sizex - c*sizey;
    
	p2.x=x0 + c*sizex - s*sizey;
	p2.y=y0 - s*sizex - c*sizey;
    
	p3.x=x0 + c*sizex + s*sizey;
	p3.y=y0 - s*sizex + c*sizey;
    
	p4.x=x0 - c*sizex + s*sizey;
	p4.y=y0 + s*sizex + c*sizey;
    
    if (SelectedRenderTarget==-1)
    {
        p1.x=decals_quads_x-VIEWPORT.a[3][0]+p1.x;
        p1.y=decals_quads_y-VIEWPORT.a[3][1]+p1.y;
        p2.x=decals_quads_x-VIEWPORT.a[3][0]+p2.x;
        p2.y=decals_quads_y-VIEWPORT.a[3][1]+p2.y;
        p3.x=decals_quads_x-VIEWPORT.a[3][0]+p3.x;
        p3.y=decals_quads_y-VIEWPORT.a[3][1]+p3.y;
        p4.x=decals_quads_x-VIEWPORT.a[3][0]+p4.x;
        p4.y=decals_quads_y-VIEWPORT.a[3][1]+p4.y;
    }
    else
    {
        p1.x=decals_quads_x-VIEWPORT.a[3][0]+p1.x;
        p1.y=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-p1.y;
        p2.x=decals_quads_x-VIEWPORT.a[3][0]+p2.x;
        p2.y=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-p2.y;
        p3.x=decals_quads_x-VIEWPORT.a[3][0]+p3.x;
        p3.y=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-p3.y;
        p4.x=decals_quads_x-VIEWPORT.a[3][0]+p4.x;
        p4.y=decals_quads_y-VIEWPORT.a[3][1]+VIEWPORT.a[1][1]*2-p4.y;
        
    }
    
	float zz=0.5f;

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads<<2;

	vbquads.SetColor(adr+0,r,g,b,a);
	vbquads.SetColor(adr+1,r,g,b,a);
	vbquads.SetColor(adr+2,r,g,b,a);
	vbquads.SetColor(adr+3,r,g,b,a);

	vbquads.SetVertex(adr+0,p1.x,p1.y,zz);
	vbquads.SetVertex(adr+1,p2.x,p2.y,zz);
	vbquads.SetVertex(adr+2,p3.x,p3.y,zz);
	vbquads.SetVertex(adr+3,p4.x,p4.y,zz);

    if (aT<0)
    {
        vbquads.SetTexCoo(adr+0,x1,1-y1);
        vbquads.SetTexCoo(adr+1,x2,1-y1);
        vbquads.SetTexCoo(adr+2,x2,1-y2);
        vbquads.SetTexCoo(adr+3,x1,1-y2);
    }
    else
    {
        vbquads.SetTexCoo(adr+0,x1,y1);
        vbquads.SetTexCoo(adr+1,x2,y1);
        vbquads.SetTexCoo(adr+2,x2,y2);
        vbquads.SetTexCoo(adr+3,x1,y2);
    }
    
	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif


#ifdef API3D_OPENGL

	float s=sinf(ang*PI/180.0f);
	float c=cosf(ang*PI/180.0f);

	float x=decals_quads_x+x0;
	float y=decals_quads_y+y0;

	CVector2 p1,p2,p3,p4;

	p1.x=x - c*sizex - s*sizey;
	p1.y=y + s*sizex - c*sizey;

	p2.x=x + c*sizex - s*sizey;
	p2.y=y - s*sizex - c*sizey;

	p3.x=x + c*sizex + s*sizey;
	p3.y=y - s*sizex + c*sizey;

	p4.x=x - c*sizex + s*sizey;
	p4.y=y + s*sizex + c*sizey;

#ifdef GLES

	glEnable(GL_TEXTURE_2D);

	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
		glOrthof(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
	else
		glOrthof(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glDisable(GL_DEPTH_TEST);


	GLfloat vertices[4*2];
	GLfloat texvertices[4*2];
	GLfloat colorvertices[4*4];

	colorvertices[0*4+0]=r;
	colorvertices[0*4+1]=g;
	colorvertices[0*4+2]=b;
	colorvertices[0*4+3]=a;

	colorvertices[1*4+0]=r;
	colorvertices[1*4+1]=g;
	colorvertices[1*4+2]=b;
	colorvertices[1*4+3]=a;

	colorvertices[2*4+0]=r;
	colorvertices[2*4+1]=g;
	colorvertices[2*4+2]=b;
	colorvertices[2*4+3]=a;

	colorvertices[3*4+0]=r;
	colorvertices[3*4+1]=g;
	colorvertices[3*4+2]=b;
	colorvertices[3*4+3]=a;

	texvertices[2*0+0]=x1; texvertices[2*0+1]=y1;
	vertices[2*0+0]=(float) (p1.x); vertices[2*0+1]=(float) SCREEN_Y-p1.y;

	texvertices[2*1+0]=x2; texvertices[2*1+1]=y1;
	vertices[2*1+0]=(float) (p2.x); vertices[2*1+1]=(float) SCREEN_Y-p2.y;

	texvertices[2*2+0]=x1; texvertices[2*2+1]=y2;
	vertices[2*2+0]=(float) (p3.x); vertices[2*2+1]=(float) SCREEN_Y-(p3.y);

	texvertices[2*3+0]=x2; texvertices[2*3+1]=y2;
	vertices[2*3+0]=(float) (p4.x); vertices[2*3+1]=(float) SCREEN_Y-(p4.y);

	glVertexPointer(2,GL_FLOAT,0,vertices);
	glEnableClientState(GL_VERTEX_ARRAY);
	glColorPointer(4,GL_FLOAT,0,colorvertices);
	glEnableClientState(GL_COLOR_ARRAY);
	glClientActiveTexture(GL_TEXTURE0);
	glTexCoordPointer(2,GL_FLOAT,0,texvertices);
	glEnableClientState(GL_TEXTURE_COORD_ARRAY);
	glDrawArrays(GL_TRIANGLE_STRIP,0,4);



	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
#else
//------------------------------------------------------------------------------------------------ OPEN GL -----------

	glEnable(GL_TEXTURE_2D);


	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1)
		glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
	else
		glOrtho(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);
		
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glDisable(GL_DEPTH_TEST);

	glBegin(GL_QUADS);

	glColor4f(r,g,b,a);
	if (aT<0)
	{
		if (SelectedRenderTarget>=0)
		{
			
			glTexCoord2f(x1,y2);
			glVertex3f((float) p1.x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-p1.y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (p2.x),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-p2.y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (p3.x),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(p3.y)),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) p4.x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(p4.y)),0);
		}
		else
		{
		
			glTexCoord2f(x1,y2);
			glVertex3f((float) p1.x,(float) (SCREEN_Y-p1.y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (p2.x),(float) (SCREEN_Y-p2.y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (p3.x),(float) (SCREEN_Y-p3.y),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) p4.x,(float) (SCREEN_Y-(p4.y)),0);
		}
	
	}
	else
	{

		if (SelectedRenderTarget>=0)
		{
			
			glTexCoord2f(x1,y2);
			glVertex3f((float) p1.x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-p1.y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) p2.x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-p2.y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) p3.x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-p3.y),0);

			glTexCoord2f(x1,y1);
			glVertex3f((float) p4.x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-p4.y),0);
		}
		else
		{
		
			glTexCoord2f(x1,y1);
			glVertex3f((float) p1.x,(float) (SCREEN_Y-p1.y),0);

			glTexCoord2f(x2,y1);
			glVertex3f((float) (p2.x),(float) (SCREEN_Y-p2.y),0);

			glTexCoord2f(x2,y2);
			glVertex3f((float) (p3.x),(float) (SCREEN_Y-p3.y),0);

			glTexCoord2f(x1,y2);
			glVertex3f((float) p4.x,(float) (SCREEN_Y-(p4.y)),0);
		}

	}
	
	glEnd();


	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
#endif
#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)

#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)

	float s=sinf(ang*PI/180.0f);
	float c=cosf(ang*PI/180.0f);

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
	float y=decals_quads_y-VIEWPORT.a[3][1]+y0;

	CVector2 p1,p2,p3,p4;

	p1.x=x - c*sizex - s*sizey;
	p1.y=y + s*sizex - c*sizey;

	p2.x=x + c*sizex - s*sizey;
	p2.y=y - s*sizex - c*sizey;

	p3.x=x + c*sizex + s*sizey;
	p3.y=y - s*sizex + c*sizey;

	p4.x=x - c*sizex + s*sizey;
	p4.y=y + s*sizex + c*sizey;


	float zz=0.999f;

	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads<<2;

	DWORD cc=D3DCOLOR_COLORVALUE(r,g,b,a);

	MultiQuads[(adr)+0].color=cc;
	MultiQuads[(adr)+0].x=(float) p1.x;
	MultiQuads[(adr)+0].y=(float) p1.y;
	MultiQuads[(adr)+0].xm=x1;
	MultiQuads[(adr)+0].ym=y1;
	MultiQuads[(adr)+0].z=zz;

	MultiQuads[(adr)+1].color=cc;
	MultiQuads[(adr)+1].x=(float) p2.x;
	MultiQuads[(adr)+1].y=(float) p2.y;
	MultiQuads[(adr)+1].xm=x2;
	MultiQuads[(adr)+1].ym=y1;
	MultiQuads[(adr)+1].z=zz;

	MultiQuads[(adr)+2].color=cc;
	MultiQuads[(adr)+2].x=(float) p3.x;
	MultiQuads[(adr)+2].y=(float) p3.y;
	MultiQuads[(adr)+2].xm=x2;
	MultiQuads[(adr)+2].ym=y2;
	MultiQuads[(adr)+2].z=zz;

	MultiQuads[(adr)+3].color=cc;
	MultiQuads[(adr)+3].x=(float) p4.x;
	MultiQuads[(adr)+3].y=(float) p4.y;
	MultiQuads[(adr)+3].xm=x1;
	MultiQuads[(adr)+3].ym=y2;
	MultiQuads[(adr)+3].z=zz;

	nMultiQuads++;

#else

	float s=sinf(ang*PI/180.0f);
	float c=cosf(ang*PI/180.0f);

	float x=decals_quads_x-VIEWPORT.a[3][0]+x0;
	float y=decals_quads_y-VIEWPORT.a[3][1]+y0;

	CVector2 p1,p2,p3,p4;

	p1.x=x - c*sizex - s*sizey;
	p1.y=y + s*sizex - c*sizey;

	p2.x=x + c*sizex - s*sizey;
	p2.y=y - s*sizex - c*sizey;

	p3.x=x + c*sizex + s*sizey;
	p3.y=y - s*sizex + c*sizey;

	p4.x=x - c*sizex + s*sizey;
	p4.y=y + s*sizex + c*sizey;
        
#ifdef API3D_DIRECT3D12
    float zz=0.5f;
#else
    float zz=1.0f;
#endif

	if (MultiQuadsZbuffer) Flush();
	else
	if (nMultiQuads>MAX_VBQUADS-1) Flush();

	int adr=nMultiQuads<<2;

	vbquads.SetColor(adr+0,r,g,b,a);
	vbquads.SetColor(adr+1,r,g,b,a);
	vbquads.SetColor(adr+2,r,g,b,a);
	vbquads.SetColor(adr+3,r,g,b,a);

	vbquads.SetVertex(adr+0,p1.x,p1.y,zz);
	vbquads.SetVertex(adr+1,p2.x,p2.y,zz);
	vbquads.SetVertex(adr+2,p3.x,p3.y,zz);
	vbquads.SetVertex(adr+3,p4.x,p4.y,zz);

    vbquads.SetTexCoo(adr+0,x1,y1);
    vbquads.SetTexCoo(adr+1,x2,y1);
    vbquads.SetTexCoo(adr+2,x2,y2);
    vbquads.SetTexCoo(adr+3,x1,y2);
    
	nMultiQuads++;
	MultiQuadsZbuffer=0;

#endif
#endif
}


void C3DAPIBASE::SetQuadDecals(float xx,float yy)
{
	decals_quads_x=xx;
	decals_quads_y=yy;
}



/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		
		Draw Quad

		void C3DAPIBASE::Quad2(float x,float y,float sizex,float sizey,float x1,float y1,float x2,float y2,...,float r,float g,float b,float a)

		x,y : co in screen coord.
		sizex,sizey: lengths of quad
		x1,y1,x2,y2 : mapping coo level 0
		px1,py1,px2,py2 : mapping coo level 1
		r,g,b,a : color

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::Quad2(float x,float y,float sizex,float sizey,float x1,float y1,float x2,float y2,float px1,float py1,float px2,float py2,float r,float g,float b,float a)
{
    if (!Active) return;
    
#ifdef API3D_OPENGL
#ifndef GLES
//------------------------------------------------------------------------------------------------ OPEN GL -----------

	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();


	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (SelectedRenderTarget==-1) glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
	else glOrtho(0.0f,tile_secondarysurfacesW[SelectedRenderTarget],0.0f,tile_secondarysurfacesH[SelectedRenderTarget],-1.0f,1.0f);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	glDisable(GL_DEPTH_TEST);

	glBegin(GL_QUADS);
		
	glColor4f(r,g,b,a);

	if (aT<0)
	{
		if (SelectedRenderTarget>=0)
		{
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1,y1);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px1,py1);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2,y1);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px2,py1);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2,y2);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px2,py2);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1,y2);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px1,py2);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);
		}
		else
		{
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1,y1);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px1,py1);
			glVertex3f((float) x,(float) (SCREEN_Y-y),0);
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2,y1);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px2,py1);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-y),0);
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2,y2);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px2,py2);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-(y+sizey)),0);
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1,y2);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px1,py2);
			glVertex3f((float) x,(float) (SCREEN_Y-(y+sizey)),0);
		}
	}
	else
	{
		if (SelectedRenderTarget>=0)
		{
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1,y2);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px1,py2);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2,y2);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px2,py2);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-y),0);
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2,y1);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px2,py1);
			glVertex3f((float) (x+sizex),(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1,y1);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px1,py1);
			glVertex3f((float) x,(float) (tile_secondarysurfacesH[SelectedRenderTarget]-(y+sizey)),0);
		}
		else
		{
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1,y2);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px1,py2);
			glVertex3f((float) x,(float) (SCREEN_Y-y),0);
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2,y2);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px2,py2);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-y),0);
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2,y1);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px2,py1);
			glVertex3f((float) (x+sizex),(float) (SCREEN_Y-(y+sizey)),0);
			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1,y1);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,px1,py1);
			glVertex3f((float) x,(float) (SCREEN_Y-(y+sizey)),0);
		}
	}

	glEnd();

	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();

	glEnable(GL_DEPTH_TEST);
#endif
#endif

#if defined(API3D_OPENGL20)||defined(API3D_METAL)||defined(API3D_DIRECT3D12)

	float _x=decals_quads_x-VIEWPORT.a[3][0]+x;
	float _y=decals_quads_y-VIEWPORT.a[3][1]+y;
	float zz=0.5f;

	vbquad2.LockVertices();

	vbquad2.SetColor(0,r,g,b,a);
	vbquad2.SetColor(1,r,g,b,a);
	vbquad2.SetColor(2,r,g,b,a);
	vbquad2.SetColor(3,r,g,b,a);

	vbquad2.SetVertex(0,_x,_y,zz);
	vbquad2.SetVertex(1,_x+sizex,_y,zz);
	vbquad2.SetVertex(2,_x+sizex,_y+sizey,zz);
	vbquad2.SetVertex(3,_x,_y+sizey,zz);

	vbquad2.SetTexCoo(0,x1,y1);
	vbquad2.SetTexCoo(1,x2,y1);
	vbquad2.SetTexCoo(2,x2,y2);
	vbquad2.SetTexCoo(3,x1,y2);

	vbquad2.SetTexCoo2(0,px1,py1);
	vbquad2.SetTexCoo2(1,px2,py1);
	vbquad2.SetTexCoo2(2,px2,py2);
	vbquad2.SetTexCoo2(3,px1,py2);
   
	vbquad2.UnlockVertices();

	whileFlush=true;

	CVertexBuffer * actual=ActualVertexBuffer;
	CVertexBuffer * eff=ActualEffect;

	effect_hll_quad2.setTexture("Tex",aT);
	effect_hll_quad2.setTexture("Tex2",aT2);
	effect_hll_quad2.setMatrix("PROJ",ProjOrtho);
	SetEffect(&effect_hll_quad2);

	SetVertexBuffer(&vbquad2);
	DrawVertexBuffer();

	ActualVertexBuffer=actual;
	ActualEffect=eff;

	whileFlush=false;

#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL) && !defined(API3D_DIRECT3D12)
#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)

	float _x=decals_quads_x-VIEWPORT.a[3][0]+x;
	float _y=decals_quads_y-VIEWPORT.a[3][1]+y;

	vbquad2.LockVertices();
	struct XYZCOLORTEX2 * Vertices=(struct XYZCOLORTEX2 *)vbquad2.pVertices;

	D3DCOLOR c=D3DCOLOR_COLORVALUE(r,g,b,a);

	Vertices[0].color=c;
	Vertices[1].color=c;
	Vertices[2].color=c;
	Vertices[3].color=c;

	Vertices[0].x=(float) _x;
	Vertices[0].y=(float) _y;
	Vertices[0].xm0=x1;
	Vertices[0].ym0=y1;
	Vertices[0].xm1=px1;
	Vertices[0].ym1=py1;
	Vertices[0].z=0.5f;

	Vertices[1].x=(float) (_x+sizex);
	Vertices[1].y=(float) _y;
	Vertices[1].xm0=x2;
	Vertices[1].ym0=y1;
	Vertices[1].xm1=px2;
	Vertices[1].ym1=py1;
	Vertices[1].z=0.5f;

	Vertices[2].x=(float) (_x+sizex);
	Vertices[2].y=(float) (_y+sizey);
	Vertices[2].xm0=x2;
	Vertices[2].ym0=y2;
	Vertices[2].xm1=px2;
	Vertices[2].ym1=py2;
	Vertices[2].z=0.5f;


	Vertices[3].x=(float) (_x);
	Vertices[3].y=(float) (_y+sizey);
	Vertices[3].xm0=x1;
	Vertices[3].ym0=y2;
	Vertices[3].xm1=px1;
	Vertices[3].ym1=py2;
	Vertices[3].z=0.5f;

	vbquad2.UnlockVertices();

	whileFlush=true;

	CVertexBuffer * actual=ActualVertexBuffer;
	CVertexBuffer * eff=ActualEffect;

	effect_hll_quad2.setTexture("Tex",aT);
	effect_hll_quad2.setTexture("Tex2",aT2);
	effect_hll_quad2.setMatrix("PROJ",ProjOrtho);
	SetEffect(&effect_hll_quad2);

	SetVertexBuffer(&vbquad2);
	DrawVertexBuffer();

	ActualVertexBuffer=actual;
	ActualEffect=eff;

	whileFlush=false;
#else

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	struct CUSTOMVERTEX02 Vertices[4];
#ifdef TOGGLE_ZBUFFER
	D3DDevice->SetRenderState(D3DRS_ZENABLE,D3DZB_FALSE);
	D3DDevice->SetRenderState(D3DRS_ZWRITEENABLE,0);
#endif

	Vertices[0].color=D3DCOLOR_COLORVALUE(r,g,b,a);
	Vertices[1].color=Vertices[0].color;
	Vertices[2].color=Vertices[0].color;
	Vertices[3].color=Vertices[0].color;

	Vertices[0].x=(float) x;
	Vertices[0].y=(float) y;
	Vertices[0].xm0=x1;
	Vertices[0].ym0=y1;
	Vertices[0].xm1=px1;
	Vertices[0].ym1=py1;
	Vertices[0].rhw=(float) 2/(Front+Back);
	Vertices[0].z=0.5f;

	Vertices[1].x=(float) (x+sizex);
	Vertices[1].y=(float) y;
	Vertices[1].xm0=x2;
	Vertices[1].ym0=y1;
	Vertices[1].xm1=px2;
	Vertices[1].ym1=py1;
	Vertices[1].rhw=Vertices[0].rhw;
	Vertices[1].z=0.5f;

	Vertices[2].x=(float) (x+sizex);
	Vertices[2].y=(float) (y+sizey);
	Vertices[2].xm0=x2;
	Vertices[2].ym0=y2;
	Vertices[2].xm1=px2;
	Vertices[2].ym1=py2;
	Vertices[2].rhw=Vertices[0].rhw;
	Vertices[2].z=0.5f;


	Vertices[3].x=(float) (x);
	Vertices[3].y=(float) (y+sizey);
	Vertices[3].xm0=x1;
	Vertices[3].ym0=y2;
	Vertices[3].xm1=px1;
	Vertices[3].ym1=py2;
	Vertices[3].rhw=Vertices[0].rhw;
	Vertices[3].z=0.5f;

#ifdef API3D_DIRECT3D9
	D3DDevice->SetFVF( D3DFVF_CUSTOMVERTEX02 );
#else
	D3DDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX02 );
#endif

	D3DDevice->DrawPrimitiveUP( D3DPT_TRIANGLEFAN,2,Vertices ,sizeof(CUSTOMVERTEX02));

#ifdef TOGGLE_ZBUFFER
	D3DDevice->SetRenderState(D3DRS_ZENABLE,D3DZB_TRUE);
	D3DDevice->SetRenderState(D3DRS_ZWRITEENABLE,1);
#endif
#endif
#endif

}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Misc
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


int GetCloserLight(C3DAPIBASE * api,CVector pos)
{
	int numLights[256];
	float rLights[256];
	int nbreLights;
	int n1,n2;
	int num;
	float r;
	int n;
	CVector u;
	
	nbreLights=0;
	for (n=0;n<64;n++)
	{
		if (api->Lights[n].enabled==1)
		{
			VECTORSUB(u,api->Lights[n].Pos,pos);
			rLights[nbreLights]=VECTORNORM2(u);
			numLights[nbreLights]=n;
			nbreLights++;
		}
	}

	for (n1=0;n1<nbreLights;n1++)
		for (n2=n1+1;n2<nbreLights;n2++)
		{
			if (rLights[n2]<rLights[n1])
			{
				r=rLights[n2];
				rLights[n2]=rLights[n1];
				rLights[n1]=r;

				num=numLights[n2];
				numLights[n2]=numLights[n1];
				numLights[n1]=num;
					
			}
		}

	if (nbreLights) return numLights[0];
	else return -1;
		
}


int GetSecondCloserLight(C3DAPIBASE * api,int ex,CVector pos)
{
	int numLights[256];
	float rLights[256];
	int nbreLights;
	int n1,n2;
	int num;
	float r;
	int n;
	CVector u;
	
	nbreLights=0;
	for (n=0;n<64;n++)
	{
		if ((api->Lights[n].enabled==1)&&(n!=ex))
		{
			VECTORSUB(u,api->Lights[n].Pos,pos);
			rLights[nbreLights]=VECTORNORM2(u);
			numLights[nbreLights]=n;
			nbreLights++;
		}
	}

	for (n1=0;n1<nbreLights;n1++)
		for (n2=n1+1;n2<nbreLights;n2++)
		{
			if (rLights[n2]<rLights[n1])
			{
				r=rLights[n2];
				rLights[n2]=rLights[n1];
				rLights[n1]=r;

				num=numLights[n2];
				numLights[n2]=numLights[n1];
				numLights[n1]=num;
					
			}
		}

	if (nbreLights) return numLights[0];
	else return -1;
		
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Render State Management for OpenGL
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef API3D_OPENGL20
void glSetRenderState(vpRenderState * RS,C3DAPIBASE *render)
{
	unsigned int s,d;
	int bld=RS->SrcBlend+RS->DstBlend+RS->Blend;
	render->PreviousBlend=bld;

	if (RS)
	{
		if ((RS->ZBufferWrite!=render->PreviousRS.ZBufferWrite)||(RS->ZBuffer!=render->PreviousRS.ZBuffer))
		{
			render->PreviousRS.ZBuffer=RS->ZBuffer;
			render->PreviousRS.ZBufferWrite=RS->ZBufferWrite;

			if (RS->ZBufferWrite==_FALSE)
			{
				glEnable(GL_DEPTH_TEST);
				glDepthMask(GL_FALSE);
			}
			else
			{
				if (RS->ZBuffer==_FALSE)
				{
					glDisable(GL_DEPTH_TEST);
					glDepthMask(GL_FALSE);
				}
				
                if (RS->ZBuffer==_TRUE)
                {
					glEnable(GL_DEPTH_TEST);
					glDepthMask(GL_TRUE);
				}
			}
		}

		//if (RS->ShadeMode==_SMOOTH) render->SetParams(API3D_SHADING,ON);
		//if (RS->ShadeMode==_FLAT) render->SetParams(API3D_SHADING,OFF);
		
		int val=0;

		if (RS->zbias!=render->PreviousRS.zbias)
		{
			render->PreviousRS.zbias=RS->zbias;

			switch (RS->zbias)
			{
			case _OFFSET_0:
				val=0;
				break;
			case _OFFSET_1:
				val=1;
				break;
			case _OFFSET_2:
				val=2;
				break;
			case _OFFSET_3:
				val=3;
				break;
			case _OFFSET_4:
				val=4;
				break;
			case _OFFSET_5:
				val=5;
				break;
			case _OFFSET_6:
				val=6;
				break;
			case _OFFSET_7:
				val=7;
				break;

			};
			render->SetParams(API3D_ZBIAS,val);
		}

		if (RS->SrcBlend!=render->PreviousRS.SrcBlend)
		{
			render->PreviousRS.SrcBlend=RS->SrcBlend;

			switch (RS->SrcBlend)
			{
				case _ZERO:
					s=GL_ZERO;
					break;
				case _ONE:
					s=GL_ONE;
					break;
				case _SRCALPHA:
					s=GL_SRC_ALPHA;
					break;
				case _INVSRCALPHA:
					s=GL_ONE_MINUS_SRC_ALPHA;
					break;
				case _SRCCOLOR:
					s=GL_SRC_COLOR;
					break;
				case _INVSRCCOLOR:
					s=GL_ONE_MINUS_SRC_COLOR;
					break;
				case _DSTALPHA:
					s=GL_DST_COLOR;
					break;
				case _INVDSTALPHA:
					s=GL_ONE_MINUS_DST_ALPHA;
					break;
				case _DSTCOLOR:
					s=GL_DST_COLOR;
					break;
				case _INVDSTCOLOR:
					s=GL_ONE_MINUS_DST_COLOR;
					break;

			};
		}

		if (RS->DstBlend!=render->PreviousRS.DstBlend)
		{
			render->PreviousRS.DstBlend=RS->DstBlend;

			switch (RS->DstBlend)
			{
				case _ZERO:
					d=GL_ZERO;
					break;
				case _ONE:
					d=GL_ONE;
					break;
				case _SRCALPHA:
					d=GL_SRC_ALPHA;
					break;
				case _INVSRCALPHA:
					d=GL_ONE_MINUS_SRC_ALPHA;
					break;
				case _SRCCOLOR:
					d=GL_SRC_COLOR;
					break;
				case _INVSRCCOLOR:
					d=GL_ONE_MINUS_SRC_COLOR;
					break;
				case _DSTALPHA:
					d=GL_DST_COLOR;
					break;
				case _INVDSTALPHA:
					d=GL_ONE_MINUS_DST_ALPHA;
					break;
				case _DSTCOLOR:
					d=GL_DST_COLOR;
					break;
				case _INVDSTCOLOR:
					d=GL_ONE_MINUS_DST_COLOR;
					break;

			};
		}

		if (RS->Blend!=render->PreviousRS.Blend)
		{
			render->PreviousRS.Blend=RS->Blend;

			switch(RS->Blend)
			{
			case _TRUE:
				glEnable(GL_BLEND);
				glBlendFunc(s,d);
				break;
			case _FALSE:
				glDisable(GL_BLEND);
				break;
			};
		}

		if (RS->Cull!=render->PreviousRS.Cull)
		{
			render->PreviousRS.Cull=RS->Cull;

			switch(RS->Cull)
			{
			case _NONE:
				render->SetParams(API3D_CULL,OFF);
				break;
			case _CCW:
				render->SetParams(API3D_CULL,ON);
				render->SetParams(API3D_CULL,CCW);
				break;
			case _CW:
				render->SetParams(API3D_CULL,ON);
				render->SetParams(API3D_CULL,CW);
				break;
			};
		}

		if (RS->RenderTarget!=_UNDEFINED)
		{
			render->PreviousRS.RenderTarget=RS->RenderTarget;

			switch (RS->RenderTarget)
			{
			case _RENDER:
				render->SetParams(API3D_RENDERTARGET,RENDER);
				break;
			case _STENCIL:
				render->SetParams(API3D_RENDERTARGET,STENCIL);
				break;
			case _ZBUFFER:
				render->SetParams(API3D_RENDERTARGET,ZBUFFER);
				break;
			case _BOTH:
				render->SetParams(API3D_RENDERTARGET,BOTH);
				break;
			case _BOTHZ:
				render->SetParams(API3D_RENDERTARGET,BOTH_WRITE_Z);
				break;
			case _TWOSIDED:
				if (glStencilOpSeparate)
				{
					render->SetParams(API3D_RENDERTARGET,STENCIL);
					render->SetParams(API3D_ZBUFFER,ON);
					render->SetParams(API3D_ZBUFFER,WRITEOFF);
					render->SetParams(API3D_CULL,OFF);
				
					glStencilMaskSeparate(GL_FRONT_AND_BACK,0xff);
					glStencilFuncSeparate(GL_FRONT_AND_BACK,GL_ALWAYS,1,0xff);

					if (render->states(ALGO_STENCIL_SHADOWING)==ALGO_REVERSE)
					{
						if (render->states(ZBUFFER_TEST_STENCIL)==0)
						{
							glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_INCR_WRAP,GL_KEEP);
							glStencilOpSeparate(GL_BACK,GL_KEEP,GL_DECR_WRAP,GL_KEEP);
						}
						else
						{
							glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_INCR_WRAP,GL_REPLACE);
							glStencilOpSeparate(GL_BACK,GL_KEEP,GL_DECR_WRAP,GL_REPLACE);
						}
					}
					else
					{
						if (render->states(ZBUFFER_TEST_STENCIL)==0)
						{
							glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_KEEP,GL_INCR_WRAP);
							glStencilOpSeparate(GL_BACK,GL_KEEP,GL_KEEP,GL_DECR_WRAP);
						}
						else
						{
							glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_REPLACE,GL_INCR_WRAP);
							glStencilOpSeparate(GL_BACK,GL_KEEP,GL_REPLACE,GL_DECR_WRAP);
						}
					}
				}
				break;
			};
		}

		if (RS->Stencil!=render->PreviousRS.Stencil)
		{
			render->PreviousRS.Stencil=RS->Stencil;			

			switch (RS->Stencil)
			{
			case _INCREMENT:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,INCREMENT);
				break;
			case _DECREMENT:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,DECREMENT);
				break;
			case _SET_ONE:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,SET_ONE);
				break;
			case _EQUAL_ZERO:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,EQUAL_ZERO);
				break;
			case _EQUAL_ONE:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,EQUAL_ONE);
				break;
			case _ALWAYS:
				glDisable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,ALWAYS);
				break;
			case _NOT_ONE:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,NOT_ONE);
				break;
			case _NOT_ZERO:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,NOT_ZERO);
				break;
			case _LESSEQUAL_ONE:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,LESSEQUAL_ONE);
				break;
			case _GREATEREQUAL_ONE:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,GREATEREQUAL_ONE);
				break;
			};
		}
	}
}

#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef API3D_OPENGL
#ifndef GLES
void glSetRenderState(vpRenderState * RS,C3DAPIBASE *render)
{
	unsigned int s,d;

	if (RS)
	{
		if ((RS->ZBufferWrite!=_UNDEFINED)||(RS->ZBuffer!=_UNDEFINED))
		{
			render->SetParams(API3D_ZBUFFER,ON);
			if (RS->ZBufferWrite==_FALSE) render->SetParams(API3D_ZBUFFER,WRITEOFF);
			if (RS->ZBuffer==_FALSE) render->SetParams(API3D_ZBUFFER,OFF);
		}

		if (RS->ShadeMode==_SMOOTH) render->SetParams(API3D_SHADING,ON);
		if (RS->ShadeMode==_FLAT) render->SetParams(API3D_SHADING,OFF);
		
		int val=0;

		if (RS->zbias!=_UNDEFINED)
		{
			switch (RS->zbias)
			{
			case _OFFSET_0:
				val=0;
				break;
			case _OFFSET_1:
				val=1;
				break;
			case _OFFSET_2:
				val=2;
				break;
			case _OFFSET_3:
				val=3;
				break;
			case _OFFSET_4:
				val=4;
				break;
			case _OFFSET_5:
				val=5;
				break;
			case _OFFSET_6:
				val=6;
				break;
			case _OFFSET_7:
				val=7;
				break;

			};
			render->SetParams(API3D_ZBIAS,val);
		}


#define glDEF 2

		int n;
		unsigned int tag;
		unsigned int rgb_mul[glDEF],rgb_s0[glDEF],rgb_s1[glDEF],rgb_op[glDEF];
		unsigned int a_mul[glDEF],a_s0[glDEF],a_s1[glDEF],a_op[glDEF];

		if (render->MultiTexture)
		{

			for (n=0;n<2;n++)
			{
				switch (RS->AArg1[n])
				{
				case _TEXTURE:
					
					a_s0[n]=GL_TEXTURE;
					break;
				case _DIFFUSE:
					a_s0[n]=GL_PRIMARY_COLOR_ARB;
					break;
				case _CURRENT:
					a_s0[n]=GL_PREVIOUS_ARB;
					break;
				case _SPECULAR:
					a_s0[n]=GL_PRIMARY_COLOR_ARB;
					break;
				};

				switch (RS->AArg2[n])
				{
				case _TEXTURE:
					a_s1[n]=GL_TEXTURE;
					break;
				case _DIFFUSE:
					a_s1[n]=GL_PRIMARY_COLOR_ARB;
					break;
				case _CURRENT:
					a_s1[n]=GL_PREVIOUS_ARB;
					break;
				case _SPECULAR:
					a_s1[n]=GL_PRIMARY_COLOR_ARB;
					break;
				};

				switch (RS->CArg1[n])
				{
				case _TEXTURE:
					rgb_s0[n]=GL_TEXTURE;
					break;
				case _DIFFUSE:
					rgb_s0[n]=GL_PRIMARY_COLOR_ARB;
					break;
				case _CURRENT:
					rgb_s0[n]=GL_PREVIOUS_ARB;
					break;
				case _SPECULAR:
					rgb_s0[n]=GL_PRIMARY_COLOR_ARB;
					break;
				};

				switch (RS->CArg2[n])
				{
				case _TEXTURE:
					rgb_s1[n]=GL_TEXTURE;
					break;
				case _DIFFUSE:
					rgb_s1[n]=GL_PRIMARY_COLOR_ARB;
					break;
				case _CURRENT:
					rgb_s1[n]=GL_PREVIOUS_ARB;
					break;
				case _SPECULAR:
					rgb_s1[n]=GL_PRIMARY_COLOR_ARB;
					break;
				};


				a_op[n]=GL_REPLACE;
				a_mul[n]=1;
				switch (RS->AOp[n])
				{
				case _MODULATE:
					a_op[n]=GL_MODULATE;
					break;
				case _MODULATE2X:
					a_op[n]=GL_MODULATE;
					a_mul[n]=2;
					break;
				case _ADD:
					a_op[n]=GL_ADD;
					break;
				case _ADDSIGNED:
					a_op[n]=GL_ADD_SIGNED_ARB;
					break;
				case _SUBTRACT:
					a_op[n]=GL_SUBTRACT_ARB;
					break;
				case _DISABLE:
					break;
				case _DOT3:
					a_op[n]=GL_DOT3_RGB_ARB;
					break;
				};



				tag=1;

				rgb_op[n]=GL_REPLACE;
				rgb_mul[n]=1;
				switch (RS->COp[n])
				{
				case _MODULATE:
					rgb_op[n]=GL_MODULATE;
					break;
				case _ADDSIGNED:
					rgb_op[n]=GL_ADD_SIGNED_ARB;
					break;
				case _MODULATE2X:
					rgb_op[n]=GL_MODULATE;
					rgb_mul[n]=2;
					break;
				case _ADD:
					rgb_op[n]=GL_ADD;
					break;
				case _SUBTRACT:
					rgb_op[n]=GL_SUBTRACT_ARB;
					break;
				case _DISABLE:
					tag=0;
					break;
				case _DOT3:
					rgb_op[n]=GL_DOT3_RGB_ARB;
					break;
				};

				if (tag)
				{
					glActiveTextureARB(GL_TEXTURE0_ARB+n);
					glEnable(GL_TEXTURE_2D);
					glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE_ARB);

					glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB,rgb_s0[n]);
					glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB,rgb_s1[n]);
					glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_RGB_ARB,GL_SRC_COLOR);
					glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_RGB_ARB,GL_SRC_COLOR);

					glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_ALPHA_ARB,a_s0[n]);
					glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_ALPHA_ARB,a_s1[n]);
					glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_ALPHA_ARB,GL_SRC_ALPHA);
					glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_ALPHA_ARB,GL_SRC_ALPHA);

					glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB_ARB,rgb_op[n]);
					glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_ALPHA_ARB,a_op[n]);

					glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE_ARB,rgb_mul[n]);
//					glTexEnvi(GL_TEXTURE_ENV,GL_ALPHA_SCALE_ARB,a_mul[n]);
				}
				else
				{
					glActiveTextureARB(GL_TEXTURE0_ARB+n);
					glDisable(GL_TEXTURE_2D);
				}
			}
		}
		else
		{
			switch (RS->COp[0])
			{
			case _MODULATE:
				rgb_op[0]=GL_MODULATE;
				break;
			case _ADDSIGNED:
				rgb_op[0]=GL_ADD;
				break;
			case _MODULATE2X:
				rgb_op[0]=GL_MODULATE;
				break;
			case _ADD:
				rgb_op[0]=GL_ADD;
				break;
			case _SUBTRACT:
				rgb_op[0]=GL_ADD;
				break;
			case _DISABLE:
				tag=0;
				break;
			case _DOT3:
				rgb_op[0]=GL_MODULATE;
				
				break;
			};
			
			if (tag)
			{
				glEnable(GL_TEXTURE_2D);
				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,rgb_op[0]);
			}
			else glDisable(GL_TEXTURE_2D);
		}

		if (RS->Dither!=_UNDEFINED)
		{
			switch(RS->Dither)
			{
			case _TRUE:
				render->SetParams(API3D_DITHERING,ON);
				break;
			case _FALSE:
				render->SetParams(API3D_DITHERING,OFF);
				break;
			};
		}

		if (RS->SrcBlend!=_UNDEFINED)
		{
			switch (RS->SrcBlend)
			{
				case _ZERO:
					s=GL_ZERO;
					break;
				case _ONE:
					s=GL_ONE;
					break;
				case _SRCALPHA:
					s=GL_SRC_ALPHA;
					break;
				case _INVSRCALPHA:
					s=GL_ONE_MINUS_SRC_ALPHA;
					break;
				case _SRCCOLOR:
					s=GL_SRC_COLOR;
					break;
				case _INVSRCCOLOR:
					s=GL_ONE_MINUS_SRC_COLOR;
					break;
				case _DSTALPHA:
					s=GL_DST_COLOR;
					break;
				case _INVDSTALPHA:
					s=GL_ONE_MINUS_DST_ALPHA;
					break;
				case _DSTCOLOR:
					s=GL_DST_COLOR;
					break;
				case _INVDSTCOLOR:
					s=GL_ONE_MINUS_DST_COLOR;
					break;

			};
		}

		if (RS->DstBlend!=_UNDEFINED)
		{
			switch (RS->DstBlend)
			{
				case _ZERO:
					d=GL_ZERO;
					break;
				case _ONE:
					d=GL_ONE;
					break;
				case _SRCALPHA:
					d=GL_SRC_ALPHA;
					break;
				case _INVSRCALPHA:
					d=GL_ONE_MINUS_SRC_ALPHA;
					break;
				case _SRCCOLOR:
					d=GL_SRC_COLOR;
					break;
				case _INVSRCCOLOR:
					d=GL_ONE_MINUS_SRC_COLOR;
					break;
				case _DSTALPHA:
					d=GL_DST_COLOR;
					break;
				case _INVDSTALPHA:
					d=GL_ONE_MINUS_DST_ALPHA;
					break;
				case _DSTCOLOR:
					d=GL_DST_COLOR;
					break;
				case _INVDSTCOLOR:
					d=GL_ONE_MINUS_DST_COLOR;
					break;

			};
		}

		if (RS->Blend!=_UNDEFINED)
		{
			switch(RS->Blend)
			{
			case _TRUE:
				glEnable(GL_BLEND);
				glBlendFunc(s,d);
				break;
			case _FALSE:
				glDisable(GL_BLEND);
				break;
			};
		}

		if (RS->Cull!=_UNDEFINED)
		{
			switch(RS->Cull)
			{
			case _NONE:
				render->SetParams(API3D_CULL,OFF);
				break;
			case _CCW:
				render->SetParams(API3D_CULL,ON);
				render->SetParams(API3D_CULL,CCW);
				break;
			case _CW:
				render->SetParams(API3D_CULL,ON);
				render->SetParams(API3D_CULL,CW);
				break;
			};
		}

		if (RS->RenderTarget!=_UNDEFINED)
		{
			switch (RS->RenderTarget)
			{
			case _RENDER:
				render->SetParams(API3D_RENDERTARGET,RENDER);
				break;
			case _STENCIL:
				render->SetParams(API3D_RENDERTARGET,STENCIL);
				break;
			case _ZBUFFER:
				render->SetParams(API3D_RENDERTARGET,ZBUFFER);
				break;
			case _BOTH:
				render->SetParams(API3D_RENDERTARGET,BOTH);
				break;
			case _BOTHZ:
				render->SetParams(API3D_RENDERTARGET,BOTH_WRITE_Z);
				break;
			case _TWOSIDED:
				if (glStencilOpSeparate)
				{
					render->SetParams(API3D_RENDERTARGET,STENCIL);
					render->SetParams(API3D_ZBUFFER,ON);
					render->SetParams(API3D_ZBUFFER,WRITEOFF);
					render->SetParams(API3D_CULL,OFF);
				
					glStencilMaskSeparate(GL_FRONT_AND_BACK,0xff);
					glStencilFuncSeparate(GL_FRONT_AND_BACK,GL_ALWAYS,1,0xff);

					if (render->states(ALGO_STENCIL_SHADOWING)==ALGO_REVERSE)
					{
						if (render->states(ZBUFFER_TEST_STENCIL)==0)
						{
							glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_INCR_WRAP,GL_KEEP);
							glStencilOpSeparate(GL_BACK,GL_KEEP,GL_DECR_WRAP,GL_KEEP);
						}
						else
						{
							glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_INCR_WRAP,GL_REPLACE);
							glStencilOpSeparate(GL_BACK,GL_KEEP,GL_DECR_WRAP,GL_REPLACE);
						}
					}
					else
					{
						if (render->states(ZBUFFER_TEST_STENCIL)==0)
						{
							glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_KEEP,GL_INCR_WRAP);
							glStencilOpSeparate(GL_BACK,GL_KEEP,GL_KEEP,GL_DECR_WRAP);
						}
						else
						{
							glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_REPLACE,GL_INCR_WRAP);
							glStencilOpSeparate(GL_BACK,GL_KEEP,GL_REPLACE,GL_DECR_WRAP);
						}
					}
				}
				break;
			};
		}

		if (RS->Stencil!=_UNDEFINED)
		{
			switch (RS->Stencil)
			{
			case _INCREMENT:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,INCREMENT);
				break;
			case _DECREMENT:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,DECREMENT);
				break;
			case _SET_ONE:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,SET_ONE);
				break;
			case _EQUAL_ZERO:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,EQUAL_ZERO);
				break;
			case _EQUAL_ONE:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,EQUAL_ONE);
				break;
			case _ALWAYS:
				glDisable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,ALWAYS);
				break;
			case _NOT_ONE:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,NOT_ONE);
				break;
			case _NOT_ZERO:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,NOT_ZERO);
				break;
			case _LESSEQUAL_ONE:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,LESSEQUAL_ONE);
				break;
			case _GREATEREQUAL_ONE:
				glEnable(GL_STENCIL_TEST);
				render->SetParams(API3D_STENCIL,GREATEREQUAL_ONE);
				break;
			};
		}

	}
}
#else

void glSetRenderState(vpRenderState * RS,C3DAPIBASE *render)
{
	unsigned int s,d;

	if (RS)
	{
		if ((RS->ZBufferWrite!=_UNDEFINED)||(RS->ZBuffer!=_UNDEFINED))
		{
			render->SetParams(API3D_ZBUFFER,ON);
			if (RS->ZBufferWrite==_FALSE) render->SetParams(API3D_ZBUFFER,WRITEOFF);
			if (RS->ZBuffer==_FALSE) render->SetParams(API3D_ZBUFFER,OFF);
		}

		if (RS->ShadeMode==_SMOOTH) render->SetParams(API3D_SHADING,ON);
		if (RS->ShadeMode==_FLAT) render->SetParams(API3D_SHADING,OFF);

		int val=0;

		if (RS->zbias!=_UNDEFINED)
		{
			switch (RS->zbias)
			{
			case _OFFSET_0:
				val=0;
				break;
			case _OFFSET_1:
				val=1;
				break;
			case _OFFSET_2:
				val=2;
				break;
			case _OFFSET_3:
				val=3;
				break;
			case _OFFSET_4:
				val=4;
				break;
			case _OFFSET_5:
				val=5;
				break;
			case _OFFSET_6:
				val=6;
				break;
			case _OFFSET_7:
				val=7;
				break;

			};
			render->SetParams(API3D_ZBIAS,val);
		}


#define glDEF 2

		int n;
		unsigned int tag;
		unsigned int rgb_mul[glDEF],rgb_s0[glDEF],rgb_s1[glDEF],rgb_op[glDEF];
		unsigned int a_mul[glDEF],a_s0[glDEF],a_s1[glDEF],a_op[glDEF];

		if (render->MultiTexture)
		{

			for (n=0;n<2;n++)
			{
				switch (RS->AArg1[n])
				{
				case _TEXTURE:

					a_s0[n]=GL_TEXTURE;
					break;
				case _DIFFUSE:
					a_s0[n]=GL_PRIMARY_COLOR;
					break;
				case _CURRENT:
					a_s0[n]=GL_PREVIOUS;
					break;
				case _SPECULAR:
					a_s0[n]=GL_PRIMARY_COLOR;
					break;
				};

				switch (RS->AArg2[n])
				{
				case _TEXTURE:
					a_s1[n]=GL_TEXTURE;
					break;
				case _DIFFUSE:
					a_s1[n]=GL_PRIMARY_COLOR;
					break;
				case _CURRENT:
					a_s1[n]=GL_PREVIOUS;
					break;
				case _SPECULAR:
					a_s1[n]=GL_PRIMARY_COLOR;
					break;
				};

				switch (RS->CArg1[n])
				{
				case _TEXTURE:
					rgb_s0[n]=GL_TEXTURE;
					break;
				case _DIFFUSE:
					rgb_s0[n]=GL_PRIMARY_COLOR;
					break;
				case _CURRENT:
					rgb_s0[n]=GL_PREVIOUS;
					break;
				case _SPECULAR:
					rgb_s0[n]=GL_PRIMARY_COLOR;
					break;
				};

				switch (RS->CArg2[n])
				{
				case _TEXTURE:
					rgb_s1[n]=GL_TEXTURE;
					break;
				case _DIFFUSE:
					rgb_s1[n]=GL_PRIMARY_COLOR;
					break;
				case _CURRENT:
					rgb_s1[n]=GL_PREVIOUS;
					break;
				case _SPECULAR:
					rgb_s1[n]=GL_PRIMARY_COLOR;
					break;
				};


				a_op[n]=GL_REPLACE;
				a_mul[n]=1;
				switch (RS->AOp[n])
				{
				case _MODULATE:
					a_op[n]=GL_MODULATE;
					break;
				case _MODULATE2X:
					a_op[n]=GL_MODULATE;
					a_mul[n]=2;
					break;
				case _ADD:
					a_op[n]=GL_ADD;
					break;
				case _ADDSIGNED:
					a_op[n]=GL_ADD_SIGNED;
					break;
				case _SUBTRACT:
					a_op[n]=GL_SUBTRACT;
					break;
				case _DISABLE:
					break;
				case _DOT3:
					a_op[n]=GL_DOT3_RGB;
					break;
				};



				tag=1;

				rgb_op[n]=GL_REPLACE;
				rgb_mul[n]=1;
				switch (RS->COp[n])
				{
				case _MODULATE:
					rgb_op[n]=GL_MODULATE;
					break;
				case _ADDSIGNED:
					rgb_op[n]=GL_ADD_SIGNED;
					break;
				case _MODULATE2X:
					rgb_op[n]=GL_MODULATE;
					rgb_mul[n]=2;
					break;
				case _ADD:
					rgb_op[n]=GL_ADD;
					break;
				case _SUBTRACT:
					rgb_op[n]=GL_SUBTRACT;
					break;
				case _DISABLE:
					tag=0;
					break;
				case _DOT3:
					rgb_op[n]=GL_DOT3_RGB;
					break;
				};

				if (tag)
				{
					glActiveTexture(GL_TEXTURE0+n);
					glEnable(GL_TEXTURE_2D);
					glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE);
/*
					glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB,rgb_s0[n]);
					glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB,rgb_s1[n]);
					glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_RGB,GL_SRC_COLOR);
					glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_RGB,GL_SRC_COLOR);

					glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_ALPHA,a_s0[n]);
					glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_ALPHA,a_s1[n]);
					glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_ALPHA,GL_SRC_ALPHA);
					glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_ALPHA,GL_SRC_ALPHA);
/**/
					glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB,rgb_op[n]);
					glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_ALPHA,a_op[n]);

					glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE,rgb_mul[n]);
//					glTexEnvi(GL_TEXTURE_ENV,GL_ALPHA_SCALE,a_mul[n]);
				}
				else
				{
					glActiveTexture(GL_TEXTURE0+n);
					glDisable(GL_TEXTURE_2D);
				}
			}
		}
		else
		{
			switch (RS->COp[0])
			{
			case _MODULATE:
				rgb_op[0]=GL_MODULATE;
				break;
			case _ADDSIGNED:
				rgb_op[0]=GL_ADD;
				break;
			case _MODULATE2X:
				rgb_op[0]=GL_MODULATE;
				break;
			case _ADD:
				rgb_op[0]=GL_ADD;
				break;
			case _SUBTRACT:
				rgb_op[0]=GL_ADD;
				break;
			case _DISABLE:
				tag=0;
				break;
			case _DOT3:
				rgb_op[0]=GL_MODULATE;

				break;
			};

			if (tag)
			{
				glEnable(GL_TEXTURE_2D);
				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,rgb_op[0]);
			}
			else glDisable(GL_TEXTURE_2D);
		}

		if (RS->Dither!=_UNDEFINED)
		{
			switch(RS->Dither)
			{
			case _TRUE:
				render->SetParams(API3D_DITHERING,ON);
				break;
			case _FALSE:
				render->SetParams(API3D_DITHERING,OFF);
				break;
			};
		}

		if (RS->SrcBlend!=_UNDEFINED)
		{
			switch (RS->SrcBlend)
			{
				case _ZERO:
					s=GL_ZERO;
					break;
				case _ONE:
					s=GL_ONE;
					break;
				case _SRCALPHA:
					s=GL_SRC_ALPHA;
					break;
				case _INVSRCALPHA:
					s=GL_ONE_MINUS_SRC_ALPHA;
					break;
				case _SRCCOLOR:
					s=GL_SRC_COLOR;
					break;
				case _INVSRCCOLOR:
					s=GL_ONE_MINUS_SRC_COLOR;
					break;
				case _DSTALPHA:
					s=GL_DST_COLOR;
					break;
				case _INVDSTALPHA:
					s=GL_ONE_MINUS_DST_ALPHA;
					break;
				case _DSTCOLOR:
					s=GL_DST_COLOR;
					break;
				case _INVDSTCOLOR:
					s=GL_ONE_MINUS_DST_COLOR;
					break;

			};
		}

		if (RS->DstBlend!=_UNDEFINED)
		{
			switch (RS->DstBlend)
			{
				case _ZERO:
					d=GL_ZERO;
					break;
				case _ONE:
					d=GL_ONE;
					break;
				case _SRCALPHA:
					d=GL_SRC_ALPHA;
					break;
				case _INVSRCALPHA:
					d=GL_ONE_MINUS_SRC_ALPHA;
					break;
				case _SRCCOLOR:
					d=GL_SRC_COLOR;
					break;
				case _INVSRCCOLOR:
					d=GL_ONE_MINUS_SRC_COLOR;
					break;
				case _DSTALPHA:
					d=GL_DST_COLOR;
					break;
				case _INVDSTALPHA:
					d=GL_ONE_MINUS_DST_ALPHA;
					break;
				case _DSTCOLOR:
					d=GL_DST_COLOR;
					break;
				case _INVDSTCOLOR:
					d=GL_ONE_MINUS_DST_COLOR;
					break;

			};
		}

		if (RS->Blend!=_UNDEFINED)
		{
			switch(RS->Blend)
			{
			case _TRUE:
				glEnable(GL_BLEND);
				glBlendFunc(s,d);
				break;
			case _FALSE:
				glDisable(GL_BLEND);
				break;
			};
		}

		if (RS->Cull!=_UNDEFINED)
		{
			switch(RS->Cull)
			{
			case _NONE:
				render->SetParams(API3D_CULL,OFF);
				break;
			case _CCW:
				render->SetParams(API3D_CULL,CCW);
				break;
			case _CW:
				render->SetParams(API3D_CULL,CW);
				break;
			};
		}

		if (RS->RenderTarget!=_UNDEFINED)
		{
			switch (RS->RenderTarget)
			{
			case _RENDER:
				render->SetParams(API3D_RENDERTARGET,RENDER);
				break;
			case _STENCIL:
				render->SetParams(API3D_RENDERTARGET,STENCIL);
				break;
			case _ZBUFFER:
				render->SetParams(API3D_RENDERTARGET,ZBUFFER);
				break;
			case _BOTH:
				render->SetParams(API3D_RENDERTARGET,BOTH);
				break;
			case _BOTHZ:
				render->SetParams(API3D_RENDERTARGET,BOTH_WRITE_Z);
				break;
			};
		}

		if (RS->Stencil!=_UNDEFINED)
		{
			switch (RS->Stencil)
			{
			case _INCREMENT:
				render->SetParams(API3D_STENCIL,INCREMENT);
				break;
			case _DECREMENT:
				render->SetParams(API3D_STENCIL,DECREMENT);
				break;
			case _SET_ONE:
				render->SetParams(API3D_STENCIL,SET_ONE);
				break;
			case _EQUAL_ZERO:
				render->SetParams(API3D_STENCIL,EQUAL_ZERO);
				break;
			case _EQUAL_ONE:
				render->SetParams(API3D_STENCIL,EQUAL_ONE);
				break;
			case _ALWAYS:
				render->SetParams(API3D_STENCIL,ALWAYS);
				break;
			case _NOT_ONE:
				render->SetParams(API3D_STENCIL,NOT_ONE);
				break;
			case _NOT_ZERO:
				render->SetParams(API3D_STENCIL,NOT_ZERO);
				break;
			case _LESSEQUAL_ONE:
				render->SetParams(API3D_STENCIL,LESSEQUAL_ONE);
				break;
			case _GREATEREQUAL_ONE:
				render->SetParams(API3D_STENCIL,GREATEREQUAL_ONE);
				break;
			};
		}

	}
}

#endif
#endif

#ifdef API3D_OPENGL
/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	Misc / OpenGL
  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

enum
{
	GL_GA_VERTEX_POSITION	=	0,
	GL_GA_WEIGHTS			=	1,
	GL_GA_NORMAL			=	2,
	GL_GA_PRIMARY_COLOR		=	3,
	GL_GA_SECONDARY_COLOR	=	4,
	GL_GA_FOG_COORD			=	5,
	GL_GA_MATRIX_INDEX		=	6,
	GL_GA_TEXTURE_COORD0	=	8,
	GL_GA_TEXTURE_COORD1	=	9,
	GL_GA_TEXTURE_COORD2	=	10,
	GL_GA_VERTEX_POSITION2	=	1,
	GL_GA_NORMAL2			=	3
};

char * vertexprogram_stencilshadow=
"uniform vec4 Light;\n"
"uniform vec4 VAR;\n"
"uniform mat4 VIEWPROJ;\n"
"uniform mat4 VIEW;\n"
"uniform mat4 WORLD;\n"
"\n"
"uniform mat4 PROJNEARPLANE;\n"
"\n"
"in vec4 VertexPosition;\n"
"in vec3 VertexNormal;\n"
"in vec2 MultiTexCoord0;\n"
"\n"
"void main(void)\n"
"{\n"
"  vec4 r0;\n"
"  vec4 r1;\n"
"  vec4 r2;\n"
"  vec4 r3;\n"
"  vec4 r11;\n"
"  r1 = WORLD * VertexPosition;\n"
"  r2.x = dot( WORLD[0].xyz , VertexNormal.xyz );\n"
"  r2.y = dot( WORLD[1].xyz , VertexNormal.xyz );\n"
"  r2.z = dot( WORLD[2].xyz , VertexNormal.xyz );\n"
"  r2.w = 0.0;\n"
"  r0.xyz = r1.xyz - Light.xyz;\n"
"  r3.x = dot(r0.xyz,r2.xyz);\n"
"  r3.x = MultiTexCoord0.x * r3.x;\n"
"  r3.x = ( r3.x > 0.0 ) ? 1.0 : 0.0;\n"
"  r3.x = VAR.x * r3.x;\n"
"  r0.xyz = r1.xyz + r3.xxx * r0.xyz;\n"
"  r0.w = r1.w;\n"
"  r3 = VIEW * r0;\n"
"  r11.x = ( r3.z >= VAR.z ) ? 1.0 : 0.0;\n"
"  r11.y = 1.0 - r11.x;\n"
"  r1 = r0 * r11.x;\n"
"  r2 = PROJNEARPLANE * r0;\n"
"  r2 = r2 * r11.y;\n"
"  r1 = r1 + r2;\n"
"  gl_Position = VIEWPROJ * r1;\n"
"}\n";


inline void getVertexFromBuffer_m(int n,CVertexBuffer *vb,CVector *p,CVector *N,float t)
{
	CVector p1,p2;
	CVector N1,N2;
	unsigned int adr=n+(n<<1);

	if (vb->stream1<0)
	{
		VECTORINIT(N1,vb->Normal_Array[adr+0],vb->Normal_Array[adr+1],vb->Normal_Array[adr+2]);
		VECTORINIT(p1,vb->Vertex_Array[adr+0],vb->Vertex_Array[adr+1],vb->Vertex_Array[adr+2]);

		VECTORINIT(N2,vb->streams_norms[0][adr+0],vb->streams_norms[0][adr+1],vb->streams_norms[0][adr+2]);
		VECTORINIT(p2,vb->streams[0][adr+0],vb->streams[0][adr+1],vb->streams[0][adr+2]);
	}
	else
	{
		VECTORINIT(N1,vb->streams_norms[vb->stream1][adr+0],vb->streams_norms[vb->stream1][adr+1],vb->streams_norms[vb->stream1][adr+2]);
		VECTORINIT(p1,vb->streams[vb->stream1][adr+0],vb->streams[vb->stream1][adr+1],vb->streams[vb->stream1][adr+2]);

		VECTORINIT(N2,vb->streams_norms[vb->stream2][adr+0],vb->streams_norms[vb->stream2][adr+1],vb->streams_norms[vb->stream2][adr+2]);
		VECTORINIT(p2,vb->streams[vb->stream2][adr+0],vb->streams[vb->stream2][adr+1],vb->streams[vb->stream2][adr+2]);
	}

	N->x=N1.x+t*(N2.x-N1.x);
	N->y=N1.y+t*(N2.y-N1.y);
	N->z=N1.z+t*(N2.z-N1.z);

	p->x=p1.x+t*(p2.x-p1.x);
	p->y=p1.y+t*(p2.y-p1.y);
	p->z=p1.z+t*(p2.z-p1.z);
}


#define getVertexFromBuffer(n,vb,p,N) \
{ \
	unsigned int adr=n+(n<<1); \
	N.x=vb->Normal_Array[adr+0]; \
	N.y=vb->Normal_Array[adr+1]; \
	N.z=vb->Normal_Array[adr+2]; \
	p.x=vb->Vertex_Array[adr+0]; \
	p.y=vb->Vertex_Array[adr+1]; \
	p.z=vb->Vertex_Array[adr+2]; \
} 

GLfloat ___mcnv[16];

GLfloat * cnv_matrix(CMatrix M)
{	
	int i,j;

	for (i=0;i<4;i++)
		for (j=0;j<4;j++) ___mcnv[i+4*j]=M.a[j][i];

	return ___mcnv;
}

#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function:

	void C3DAPIBASE::DrawVertexBuffer()		
			
	draw a vertexbuffer specified by SetVertexBuffer()

  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */
/*

AssignedTexture[value]
enum
{
	UNASSIGNED				=	0,
	TEXTURE_FROM_NT			=	1,
	TEXTURE_FROM_NT2		=	2,
	TEXTURE_FROM_NL			=	3,
	TEXTURE_FROM_NLVECTORS	=	4,
	TEXTURE_FROM_BUMP		=	5
};
*/
#ifdef API3D_DIRECT3D10

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int C3DAPIBASE::SetLayouts(CVertexBuffer * vb,D3D10_INPUT_ELEMENT_DESC *layout)
{
	int nb=0;

	switch (vb->TypeVB)
	{
	case 0:
	case 1:
	case 3:
		// texturage normal
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		nb=3;
		break;
	case 2:
		// gouraud simple
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		nb=2;
		break;
		
	case 4:
		// double texturage
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 1;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		nb=4;

		break;
	case 5:
		// TNL

		if (vb->Type&API3D_MORPH)
		{
			layout[0].SemanticName = "POSITION";
			layout[0].SemanticIndex = 0;
			layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
			layout[0].InputSlot = 0;
			layout[0].AlignedByteOffset = 0;
			layout[0].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
			layout[0].InstanceDataStepRate = 0;

			layout[1].SemanticName = "NORMAL";
			layout[1].SemanticIndex = 0;
			layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
			layout[1].InputSlot = 0;
			layout[1].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
			layout[1].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
			layout[1].InstanceDataStepRate = 0;

			layout[2].SemanticName = "TEXCOORD";
			layout[2].SemanticIndex = 0;
			layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
			layout[2].InputSlot = 0;
			layout[2].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
			layout[2].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
			layout[2].InstanceDataStepRate = 0;

			layout[3].SemanticName = "POSITION";
			layout[3].SemanticIndex = 1;
			layout[3].Format = DXGI_FORMAT_R32G32B32_FLOAT;
			layout[3].InputSlot = 1;
			layout[3].AlignedByteOffset = 0;
			layout[3].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
			layout[3].InstanceDataStepRate = 0;

			layout[4].SemanticName = "NORMAL";
			layout[4].SemanticIndex = 1;
			layout[4].Format = DXGI_FORMAT_R32G32B32_FLOAT;
			layout[4].InputSlot = 1;
			layout[4].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
			layout[4].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
			layout[4].InstanceDataStepRate = 0;

			layout[5].SemanticName = "TEXCOORD";
			layout[5].SemanticIndex = 1;
			layout[5].Format = DXGI_FORMAT_R32G32_FLOAT;
			layout[5].InputSlot = 1;
			layout[5].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
			layout[5].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
			layout[5].InstanceDataStepRate = 0;

			nb=6;
		}
		else
		{
		
			if (vb->Type&API3D_EDGESDG)
			{
				layout[0].SemanticName = "POSITION";
				layout[0].SemanticIndex = 0;
				layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
				layout[0].InputSlot = 0;
				layout[0].AlignedByteOffset = 0;
				layout[0].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
				layout[0].InstanceDataStepRate = 0;

				layout[1].SemanticName = "NORMAL";
				layout[1].SemanticIndex = 0;
				layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
				layout[1].InputSlot = 0;
				layout[1].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
				layout[1].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
				layout[1].InstanceDataStepRate = 0;

				layout[2].SemanticName = "TEXCOORD";
				layout[2].SemanticIndex = 0;
				layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
				layout[2].InputSlot = 0;
				layout[2].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
				layout[2].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
				layout[2].InstanceDataStepRate = 0;

				nb=3;
			}
			else
			{
				layout[0].SemanticName = "POSITION";
				layout[0].SemanticIndex = 0;
				layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
				layout[0].InputSlot = 0;
				layout[0].AlignedByteOffset = 0;
				layout[0].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
				layout[0].InstanceDataStepRate = 0;

				layout[1].SemanticName = "NORMAL";
				layout[1].SemanticIndex = 0;
				layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
				layout[1].InputSlot = 0;
				layout[1].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
				layout[1].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
				layout[1].InstanceDataStepRate = 0;

				layout[2].SemanticName = "TEXCOORD";
				layout[2].SemanticIndex = 0;
				layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
				layout[2].InputSlot = 0;
				layout[2].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
				layout[2].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
				layout[2].InstanceDataStepRate = 0;

				nb=3;
			}
		}
		break;
	case 6:
		// lightmap
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 1;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;
	
		nb=4;
		break;
	case 7:
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 1;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		layout[4].SemanticName = "TEXCOORD";
		layout[4].SemanticIndex = 2;
		layout[4].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[4].InputSlot = 0;
		layout[4].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[4].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[4].InstanceDataStepRate = 0;

		nb=5;
		break;

	case 8:
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "NORMAL";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "COLOR";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 0;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		layout[4].SemanticName = "TEXCOORD";
		layout[4].SemanticIndex = 1;
		layout[4].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[4].InputSlot = 0;
		layout[4].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[4].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[4].InstanceDataStepRate = 0;

		nb=5;
		break;

	case 9:
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "NORMAL";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "COLOR";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 0;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		layout[4].SemanticName = "TEXCOORD";
		layout[4].SemanticIndex = 1;
		layout[4].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[4].InputSlot = 0;
		layout[4].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[4].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[4].InstanceDataStepRate = 0;

		layout[5].SemanticName = "TEXCOORD";
		layout[5].SemanticIndex = 2;
		layout[5].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[5].InputSlot = 0;
		layout[5].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[5].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[5].InstanceDataStepRate = 0;

		layout[6].SemanticName = "TEXCOORD";
		layout[6].SemanticIndex = 3;
		layout[6].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[6].InputSlot = 0;
		layout[6].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[6].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[6].InstanceDataStepRate = 0;

		nb=7;
		break;

	case 10:
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 1;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		layout[4].SemanticName = "TEXCOORD";
		layout[4].SemanticIndex = 2;
		layout[4].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[4].InputSlot = 0;
		layout[4].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[4].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[4].InstanceDataStepRate = 0;

		layout[5].SemanticName = "TEXCOORD";
		layout[5].SemanticIndex = 3;
		layout[5].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[5].InputSlot = 0;
		layout[5].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[5].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[5].InstanceDataStepRate = 0;

		nb=6;
		break;

	case 32+0:
	case 32+1:
	case 32+3:
		// texturage normal
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "BLENDWEIGHT";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = 0;
		layout[1].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "COLOR";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 0;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		nb=4;

		break;
	case 32+2:
		// gouraud simple
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLOR );
		break;
	
	case 32+4:
		// double texturage
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX2 );
		break;
	case 32+5:
		// TNL
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "BLENDWEIGHT";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "NORMAL";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 0;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D10_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D10_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		nb=4;

		break;
	case 32+6:
		// lightmap
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX2 );
		break;
	case 32+7:
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX3 );
		break;

	case 32+9:
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZNORMALCOLORTEX4 );
		break;
	};

	return nb;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::SetRenderState(vpRenderState * RS,int multi)
{
	D3D10_BLEND s,d;
	int bld=RS->SrcBlend+RS->DstBlend+RS->Blend;
	PreviousBlend=bld;

	if (RS)
	{
		if ((RS->ZBufferWrite!=PreviousRS.ZBufferWrite)||(RS->ZBuffer!=PreviousRS.ZBuffer))
		{
			PreviousRS.ZBuffer=RS->ZBuffer;
			PreviousRS.ZBufferWrite=RS->ZBufferWrite;
			if (RS->ZBuffer==_TRUE) SetParams(API3D_ZBUFFER,ON);
			if (RS->ZBufferWrite==_FALSE) SetParams(API3D_ZBUFFER,WRITEOFF);
			if (RS->ZBuffer==_FALSE) SetParams(API3D_ZBUFFER,OFF);
		}

		if (RS->ShadeMode==_SMOOTH) SetParams(API3D_SHADING,ON);
		if (RS->ShadeMode==_FLAT) SetParams(API3D_SHADING,OFF);
	
		int val=0;

		if (RS->zbias!=PreviousRS.zbias)
		{
			PreviousRS.zbias=RS->zbias;

			switch (RS->zbias)
			{
			case _OFFSET_0:
				val=0;
				break;
			case _OFFSET_1:
				val=1;
				break;
			case _OFFSET_2:
				val=2;
				break;
			case _OFFSET_3:
				val=3;
				break;
			case _OFFSET_4:
				val=4;
				break;
			case _OFFSET_5:
				val=5;
				break;
			case _OFFSET_6:
				val=6;
				break;
			case _OFFSET_7:
				val=7;
				break;
			};
			SetParams(API3D_ZBIAS,val);
		}

		if (RS->SrcBlend!=PreviousRS.SrcBlend)
		{
			PreviousRS.SrcBlend=RS->SrcBlend;
			PreviousRS.Blend=_UNDEFINED;

			switch (RS->SrcBlend)
			{
				case _ZERO:
					s=D3D10_BLEND_ZERO;
					break;
				case _ONE:
					s=D3D10_BLEND_ONE;
					break;
				case _SRCALPHA:
					s=D3D10_BLEND_SRC_ALPHA;
					break;
				case _INVSRCALPHA:
					s=D3D10_BLEND_INV_SRC_ALPHA;
					break;
				case _SRCCOLOR:
					s=D3D10_BLEND_SRC_COLOR;
					break;
				case _INVSRCCOLOR:
					s=D3D10_BLEND_INV_SRC_COLOR;
					break;
				case _DSTALPHA:
					s=D3D10_BLEND_DEST_ALPHA;
					break;
				case _INVDSTALPHA:
					s=D3D10_BLEND_INV_DEST_ALPHA;
					break;
				case _DSTCOLOR:
					s=D3D10_BLEND_DEST_COLOR;
					break;
				case _INVDSTCOLOR:
					s=D3D10_BLEND_INV_DEST_COLOR;
					break;

			};
		}

		if (RS->DstBlend!=PreviousRS.DstBlend)
		{
			PreviousRS.DstBlend=RS->DstBlend;
			PreviousRS.Blend=_UNDEFINED;

			switch (RS->DstBlend)
			{
				case _ZERO:
					d=D3D10_BLEND_ZERO;
					break;
				case _ONE:
					d=D3D10_BLEND_ONE;
					break;
				case _SRCALPHA:
					d=D3D10_BLEND_SRC_ALPHA;
					break;
				case _INVSRCALPHA:
					d=D3D10_BLEND_INV_SRC_ALPHA;
					break;
				case _SRCCOLOR:
					d=D3D10_BLEND_SRC_COLOR;
					break;
				case _INVSRCCOLOR:
					d=D3D10_BLEND_INV_SRC_COLOR;
					break;
				case _DSTALPHA:
					d=D3D10_BLEND_DEST_ALPHA;
					break;
				case _INVDSTALPHA:
					d=D3D10_BLEND_INV_DEST_ALPHA;
					break;
				case _DSTCOLOR:
					d=D3D10_BLEND_DEST_COLOR;
					break;
				case _INVDSTCOLOR:
					d=D3D10_BLEND_INV_DEST_COLOR;
					break;

			};
		}

		if (RS->Blend!=PreviousRS.Blend)
		{
			PreviousRS.Blend=RS->Blend;

			switch(RS->Blend)
			{
			case _TRUE:
				if (blendStateTMP) blendStateTMP->Release();
				blendStateDesc.BlendEnable[0]=true;
				blendStateDesc.SrcBlend=s;
				blendStateDesc.DestBlend=d;
				blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
				blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
				blendStateDesc.SrcBlendAlpha=D3D10_BLEND_ONE;
				blendStateDesc.DestBlendAlpha=D3D10_BLEND_ZERO;
				device->CreateBlendState(&blendStateDesc,&blendStateTMP);
				device->OMSetBlendState(blendStateTMP,factors,0xFFFFFFFF);
				break;
			case _FALSE:
				device->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);
				break;
			};			
		}

		if (RS->Cull!=PreviousRS.Cull)
		{
			PreviousRS.Cull=RS->Cull;

			switch(RS->Cull)
			{
			case _NONE:
				SetParams(API3D_CULL,OFF);
				break;
			case _CCW:
				SetParams(API3D_CULL,CCW);
				break;
			case _CW:
				SetParams(API3D_CULL,CW);
				break;
			};
		}

		if (RS->RenderTarget!=PreviousRS.RenderTarget)
		{
			PreviousRS.RenderTarget=RS->RenderTarget;

			switch (RS->RenderTarget)
			{
			case _RENDER:
				SetParams(API3D_RENDERTARGET,RENDER);
				break;
			case _STENCIL:
				SetParams(API3D_RENDERTARGET,STENCIL);
				break;
			case _ZBUFFER:
				SetParams(API3D_RENDERTARGET,ZBUFFER);
				break;
			case _BOTH:
				SetParams(API3D_RENDERTARGET,BOTH);
				break;
			case _BOTHZ:
				SetParams(API3D_RENDERTARGET,BOTH_WRITE_Z);
				break;

			case _TWOSIDED:
				if (depthStencilState) depthStencilState->Release();

				depthStencilDesc.DepthEnable = true;
				depthStencilDesc.DepthWriteMask = D3D10_DEPTH_WRITE_MASK_ZERO;
				depthStencilDesc.DepthFunc = D3D10_COMPARISON_LESS_EQUAL;

				depthStencilDesc.StencilEnable = true;
				depthStencilDesc.StencilReadMask = 0xFF;
				depthStencilDesc.StencilWriteMask = 0xFF;

				if (states(ALGO_STENCIL_SHADOWING)==ALGO_REVERSE)
				{
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_INCR;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_DECR;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_ALWAYS;
				}
				else
				{
					depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_INCR;
					depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_DECR;
					depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_ALWAYS;
				}
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				device->OMSetDepthStencilState(depthStencilState, 1);

				if (blendStateTMP) blendStateTMP->Release();
				blendStateDesc.BlendEnable[0]=true;
				blendStateDesc.SrcBlend=D3D10_BLEND_ZERO;
				blendStateDesc.DestBlend=D3D10_BLEND_ONE;
				blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
				blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
				blendStateDesc.SrcBlendAlpha=D3D10_BLEND_ZERO;
				blendStateDesc.DestBlendAlpha=D3D10_BLEND_ONE;
				
				device->CreateBlendState(&blendStateDesc,&blendStateTMP);
				device->OMSetBlendState(blendStateTMP,factors,0xFFFFFFFF);

				rasterState->Release();
				rasterDesc.CullMode = D3D10_CULL_NONE;
				device->CreateRasterizerState(&rasterDesc, &rasterState);
				device->RSSetState(rasterState);
				break;
			};
		}

		if (RS->Stencil!=_UNDEFINED)
		{
			PreviousRS.Stencil=RS->Stencil;

			switch (RS->Stencil)
			{
			case _INCREMENT:
				SetParams(API3D_STENCIL,INCREMENT);
				break;
			case _DECREMENT:
				SetParams(API3D_STENCIL,DECREMENT);
				break;
			case _SET_ONE:
				SetParams(API3D_STENCIL,SET_ONE);
				break;
			case _EQUAL_ZERO:
				SetParams(API3D_STENCIL,EQUAL_ZERO);
				break;
			case _EQUAL_ONE:
				SetParams(API3D_STENCIL,EQUAL_ONE);
				break;
			case _ALWAYS:
				SetParams(API3D_STENCIL,ALWAYS);
				break;
			case _NOT_ONE:
				SetParams(API3D_STENCIL,NOT_ONE);
				break;
			case _NOT_ZERO:
				SetParams(API3D_STENCIL,NOT_ZERO);
				break;
			case _LESSEQUAL_ONE:
				SetParams(API3D_STENCIL,LESSEQUAL_ONE);
				break;
			case _GREATEREQUAL_ONE:
				SetParams(API3D_STENCIL,GREATEREQUAL_ONE);
				break;
			};
		}

	}
}
#endif

// II

#ifdef API3D_DIRECT3D11

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int C3DAPIBASE::SetLayouts(CVertexBuffer * vb,D3D11_INPUT_ELEMENT_DESC *layout)
{
	int nb=0;

	switch (vb->TypeVB)
	{
	case 0:
	case 1:
	case 3:
		// texturage normal
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		nb=3;
		break;
	case 2:
		// gouraud simple
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		nb=2;
		break;
		
	case 4:
		// double texturage
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 1;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		nb=4;

		break;
	case 5:
		// TNL

		if (vb->Type&API3D_MORPH)
		{
			layout[0].SemanticName = "POSITION";
			layout[0].SemanticIndex = 0;
			layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
			layout[0].InputSlot = 0;
			layout[0].AlignedByteOffset = 0;
			layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
			layout[0].InstanceDataStepRate = 0;

			layout[1].SemanticName = "NORMAL";
			layout[1].SemanticIndex = 0;
			layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
			layout[1].InputSlot = 0;
			layout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
			layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
			layout[1].InstanceDataStepRate = 0;

			layout[2].SemanticName = "TEXCOORD";
			layout[2].SemanticIndex = 0;
			layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
			layout[2].InputSlot = 0;
			layout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
			layout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
			layout[2].InstanceDataStepRate = 0;

			layout[3].SemanticName = "POSITION";
			layout[3].SemanticIndex = 1;
			layout[3].Format = DXGI_FORMAT_R32G32B32_FLOAT;
			layout[3].InputSlot = 1;
			layout[3].AlignedByteOffset = 0;
			layout[3].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
			layout[3].InstanceDataStepRate = 0;

			layout[4].SemanticName = "NORMAL";
			layout[4].SemanticIndex = 1;
			layout[4].Format = DXGI_FORMAT_R32G32B32_FLOAT;
			layout[4].InputSlot = 1;
			layout[4].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
			layout[4].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
			layout[4].InstanceDataStepRate = 0;

			layout[5].SemanticName = "TEXCOORD";
			layout[5].SemanticIndex = 1;
			layout[5].Format = DXGI_FORMAT_R32G32_FLOAT;
			layout[5].InputSlot = 1;
			layout[5].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
			layout[5].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
			layout[5].InstanceDataStepRate = 0;

			nb=6;
		}
		else
		{
		
			if (vb->Type&API3D_EDGESDG)
			{
				layout[0].SemanticName = "POSITION";
				layout[0].SemanticIndex = 0;
				layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
				layout[0].InputSlot = 0;
				layout[0].AlignedByteOffset = 0;
				layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				layout[0].InstanceDataStepRate = 0;

				layout[1].SemanticName = "NORMAL";
				layout[1].SemanticIndex = 0;
				layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
				layout[1].InputSlot = 0;
				layout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
				layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				layout[1].InstanceDataStepRate = 0;

				layout[2].SemanticName = "TEXCOORD";
				layout[2].SemanticIndex = 0;
				layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
				layout[2].InputSlot = 0;
				layout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
				layout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				layout[2].InstanceDataStepRate = 0;

				nb=3;
			}
			else
			{
				layout[0].SemanticName = "POSITION";
				layout[0].SemanticIndex = 0;
				layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
				layout[0].InputSlot = 0;
				layout[0].AlignedByteOffset = 0;
				layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				layout[0].InstanceDataStepRate = 0;

				layout[1].SemanticName = "NORMAL";
				layout[1].SemanticIndex = 0;
				layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
				layout[1].InputSlot = 0;
				layout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
				layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				layout[1].InstanceDataStepRate = 0;

				layout[2].SemanticName = "TEXCOORD";
				layout[2].SemanticIndex = 0;
				layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
				layout[2].InputSlot = 0;
				layout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
				layout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
				layout[2].InstanceDataStepRate = 0;

				nb=3;
			}
		}
		break;
	case 6:
		// lightmap
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 1;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;
	
		nb=4;
		break;

	case 7:
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 1;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		layout[4].SemanticName = "TEXCOORD";
		layout[4].SemanticIndex = 2;
		layout[4].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[4].InputSlot = 0;
		layout[4].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[4].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[4].InstanceDataStepRate = 0;

		nb=5;
		break;

	case 8:
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "NORMAL";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "COLOR";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 0;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		layout[4].SemanticName = "TEXCOORD";
		layout[4].SemanticIndex = 1;
		layout[4].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[4].InputSlot = 0;
		layout[4].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[4].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[4].InstanceDataStepRate = 0;

		nb=5;
		break;

	case 9:
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "NORMAL";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "COLOR";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 0;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		layout[4].SemanticName = "TEXCOORD";
		layout[4].SemanticIndex = 1;
		layout[4].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[4].InputSlot = 0;
		layout[4].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[4].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[4].InstanceDataStepRate = 0;

		layout[5].SemanticName = "TEXCOORD";
		layout[5].SemanticIndex = 2;
		layout[5].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[5].InputSlot = 0;
		layout[5].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[5].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[5].InstanceDataStepRate = 0;

		layout[6].SemanticName = "TEXCOORD";
		layout[6].SemanticIndex = 3;
		layout[6].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[6].InputSlot = 0;
		layout[6].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[6].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[6].InstanceDataStepRate = 0;

		nb=7;
		break;

	case 10:
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 1;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		layout[4].SemanticName = "TEXCOORD";
		layout[4].SemanticIndex = 2;
		layout[4].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[4].InputSlot = 0;
		layout[4].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[4].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[4].InstanceDataStepRate = 0;

		layout[5].SemanticName = "TEXCOORD";
		layout[5].SemanticIndex = 3;
		layout[5].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[5].InputSlot = 0;
		layout[5].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[5].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[5].InstanceDataStepRate = 0;

		nb=6;
		break;

	case 32+0:
	case 32+1:
	case 32+3:
		// texturage normal
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "BLENDWEIGHT";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = 0;
		layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "COLOR";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 0;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		nb=4;

		break;
	case 32+2:
		// gouraud simple
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLOR );
		break;
	
	case 32+4:
		// double texturage
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX2 );
		break;
	case 32+5:
		// TNL
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "BLENDWEIGHT";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "NORMAL";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 0;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D11_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D11_INPUT_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		nb=4;

		break;
	case 32+6:
		// lightmap
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX2 );
		break;
	case 32+7:
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX3 );
		break;

	case 32+9:
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZNORMALCOLORTEX4 );
		break;
	};

	return nb;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::SetRenderState(vpRenderState * RS,int multi)
{
	D3D11_BLEND s,d;
	int bld=RS->SrcBlend+RS->DstBlend+RS->Blend;
	PreviousBlend=bld;

	if (RS)
	{
		if ((RS->ZBufferWrite!=PreviousRS.ZBufferWrite)||(RS->ZBuffer!=PreviousRS.ZBuffer))
		{
			PreviousRS.ZBuffer=RS->ZBuffer;
			PreviousRS.ZBufferWrite=RS->ZBufferWrite;
			if (RS->ZBuffer==_TRUE) SetParams(API3D_ZBUFFER,ON);
			if (RS->ZBufferWrite==_FALSE) SetParams(API3D_ZBUFFER,WRITEOFF);
			if (RS->ZBuffer==_FALSE) SetParams(API3D_ZBUFFER,OFF);
		}

		if (RS->ShadeMode==_SMOOTH) SetParams(API3D_SHADING,ON);
		if (RS->ShadeMode==_FLAT) SetParams(API3D_SHADING,OFF);
	
		int val=0;

		if (RS->zbias!=PreviousRS.zbias)
		{
			PreviousRS.zbias=RS->zbias;

			switch (RS->zbias)
			{
			case _OFFSET_0:
				val=0;
				break;
			case _OFFSET_1:
				val=1;
				break;
			case _OFFSET_2:
				val=2;
				break;
			case _OFFSET_3:
				val=3;
				break;
			case _OFFSET_4:
				val=4;
				break;
			case _OFFSET_5:
				val=5;
				break;
			case _OFFSET_6:
				val=6;
				break;
			case _OFFSET_7:
				val=7;
				break;
			};
			SetParams(API3D_ZBIAS,val);
		}

		if (RS->SrcBlend!=PreviousRS.SrcBlend)
		{
			PreviousRS.SrcBlend=RS->SrcBlend;
			PreviousRS.Blend=_UNDEFINED;

			switch (RS->SrcBlend)
			{
				case _ZERO:
					s=D3D11_BLEND_ZERO;
					break;
				case _ONE:
					s=D3D11_BLEND_ONE;
					break;
				case _SRCALPHA:
					s=D3D11_BLEND_SRC_ALPHA;
					break;
				case _INVSRCALPHA:
					s=D3D11_BLEND_INV_SRC_ALPHA;
					break;
				case _SRCCOLOR:
					s=D3D11_BLEND_SRC_COLOR;
					break;
				case _INVSRCCOLOR:
					s=D3D11_BLEND_INV_SRC_COLOR;
					break;
				case _DSTALPHA:
					s=D3D11_BLEND_DEST_ALPHA;
					break;
				case _INVDSTALPHA:
					s=D3D11_BLEND_INV_DEST_ALPHA;
					break;
				case _DSTCOLOR:
					s=D3D11_BLEND_DEST_COLOR;
					break;
				case _INVDSTCOLOR:
					s=D3D11_BLEND_INV_DEST_COLOR;
					break;

			};
		}		

		if (RS->DstBlend!=PreviousRS.DstBlend)
		{
			PreviousRS.DstBlend=RS->DstBlend;
			PreviousRS.Blend=_UNDEFINED;

			switch (RS->DstBlend)
			{
				case _ZERO:
					d=D3D11_BLEND_ZERO;
					break;
				case _ONE:
					d=D3D11_BLEND_ONE;
					break;
				case _SRCALPHA:
					d=D3D11_BLEND_SRC_ALPHA;
					break;
				case _INVSRCALPHA:
					d=D3D11_BLEND_INV_SRC_ALPHA;
					break;
				case _SRCCOLOR:
					d=D3D11_BLEND_SRC_COLOR;
					break;
				case _INVSRCCOLOR:
					d=D3D11_BLEND_INV_SRC_COLOR;
					break;
				case _DSTALPHA:
					d=D3D11_BLEND_DEST_ALPHA;
					break;
				case _INVDSTALPHA:
					d=D3D11_BLEND_INV_DEST_ALPHA;
					break;
				case _DSTCOLOR:
					d=D3D11_BLEND_DEST_COLOR;
					break;
				case _INVDSTCOLOR:
					d=D3D11_BLEND_INV_DEST_COLOR;
					break;

			};
		}

		if (RS->Blend!=PreviousRS.Blend)
		{
			PreviousRS.Blend=RS->Blend;

			switch(RS->Blend)
			{
			case _TRUE:
				if (blendStateTMP) blendStateTMP->Release();
				blendStateDesc.RenderTarget[0].BlendEnable=true;
				blendStateDesc.RenderTarget[0].SrcBlend=s;
				blendStateDesc.RenderTarget[0].DestBlend=d;
				blendStateDesc.RenderTarget[0].BlendOp=D3D11_BLEND_OP_ADD;
				blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D11_BLEND_OP_ADD;
				blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_ONE;
				blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_ZERO;
				device->CreateBlendState(&blendStateDesc,&blendStateTMP);
				devicecontext->OMSetBlendState(blendStateTMP,factors,0xFFFFFFFF);
				break;
			case _FALSE:
				devicecontext->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);
				break;
			};			
		}

		if (RS->Cull!=PreviousRS.Cull)
		{
			PreviousRS.Cull=RS->Cull;

			switch(RS->Cull)
			{
			case _NONE:
				SetParams(API3D_CULL,OFF);
				break;
			case _CCW:
				SetParams(API3D_CULL,CCW);
				break;
			case _CW:
				SetParams(API3D_CULL,CW);
				break;
			};
		}

		if (RS->RenderTarget!=PreviousRS.RenderTarget)
		{
			PreviousRS.RenderTarget=RS->RenderTarget;

			switch (RS->RenderTarget)
			{
			case _RENDER:
				SetParams(API3D_RENDERTARGET,RENDER);
				break;
			case _STENCIL:
				SetParams(API3D_RENDERTARGET,STENCIL);
				break;
			case _ZBUFFER:
				SetParams(API3D_RENDERTARGET,ZBUFFER);
				break;
			case _BOTH:
				SetParams(API3D_RENDERTARGET,BOTH);
				break;
			case _BOTHZ:
				SetParams(API3D_RENDERTARGET,BOTH_WRITE_Z);
				break;

			case _TWOSIDED:
				if (depthStencilState) depthStencilState->Release();

				depthStencilDesc.DepthEnable = true;
				depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;
				depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;

				depthStencilDesc.StencilEnable = true;
				depthStencilDesc.StencilReadMask = 0xFF;
				depthStencilDesc.StencilWriteMask = 0xFF;

				if (states(ALGO_STENCIL_SHADOWING)==ALGO_REVERSE)
				{
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
				}
				else
				{
					depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_INCR;
					depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_DECR;
					depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
				}
				device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
				devicecontext->OMSetDepthStencilState(depthStencilState, 1);

				if (blendStateTMP) blendStateTMP->Release();
				blendStateDesc.RenderTarget[0].BlendEnable=true;
				blendStateDesc.RenderTarget[0].SrcBlend=D3D11_BLEND_ZERO;
				blendStateDesc.RenderTarget[0].DestBlend=D3D11_BLEND_ONE;
				blendStateDesc.RenderTarget[0].BlendOp=D3D11_BLEND_OP_ADD;
				blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D11_BLEND_OP_ADD;
				blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_ZERO;
				blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_ONE;
				
				device->CreateBlendState(&blendStateDesc,&blendStateTMP);
				devicecontext->OMSetBlendState(blendStateTMP,factors,0xFFFFFFFF);

				if (rasterState) rasterState->Release();
				rasterDesc.CullMode = D3D11_CULL_NONE;
				device->CreateRasterizerState(&rasterDesc, &rasterState);
				devicecontext->RSSetState(rasterState);
				break;
			};
		}

		if (RS->Stencil!=PreviousRS.Stencil)
		{
			PreviousRS.Stencil=RS->Stencil;

			switch (RS->Stencil)
			{
			case _INCREMENT:
				SetParams(API3D_STENCIL,INCREMENT);
				break;
			case _DECREMENT:
				SetParams(API3D_STENCIL,DECREMENT);
				break;
			case _SET_ONE:
				SetParams(API3D_STENCIL,SET_ONE);
				break;
			case _EQUAL_ZERO:
				SetParams(API3D_STENCIL,EQUAL_ZERO);
				break;
			case _EQUAL_ONE:
				SetParams(API3D_STENCIL,EQUAL_ONE);
				break;
			case _ALWAYS:
				SetParams(API3D_STENCIL,ALWAYS);
				break;
			case _NOT_ONE:
				SetParams(API3D_STENCIL,NOT_ONE);
				break;
			case _NOT_ZERO:
				SetParams(API3D_STENCIL,NOT_ZERO);
				break;
			case _LESSEQUAL_ONE:
				SetParams(API3D_STENCIL,LESSEQUAL_ONE);
				break;
			case _GREATEREQUAL_ONE:
				SetParams(API3D_STENCIL,GREATEREQUAL_ONE);
				break;
			};
		}

	}
}
#endif

#ifdef API3D_DIRECT3D12

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int C3DAPIBASE::SetLayouts(CVertexBuffer * vb,D3D12_INPUT_ELEMENT_DESC *layout)
{
	int nb=0;

	switch (vb->TypeVB)
	{
	case 0:
	case 1:
	case 3:
		// texturage normal
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT ;
		layout[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		nb=3;
		break;
	case 2:
		// gouraud simple
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		nb=2;
		break;
		
	case 4:
		// double texturage
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 1;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		nb=4;

		break;
	case 5:
		// TNL

		if (vb->Type&API3D_MORPH)
		{
			layout[0].SemanticName = "POSITION";
			layout[0].SemanticIndex = 0;
			layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
			layout[0].InputSlot = 0;
			layout[0].AlignedByteOffset = 0;
			layout[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
			layout[0].InstanceDataStepRate = 0;

			layout[1].SemanticName = "NORMAL";
			layout[1].SemanticIndex = 0;
			layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
			layout[1].InputSlot = 0;
			layout[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
			layout[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
			layout[1].InstanceDataStepRate = 0;

			layout[2].SemanticName = "TEXCOORD";
			layout[2].SemanticIndex = 0;
			layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
			layout[2].InputSlot = 0;
			layout[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
			layout[2].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
			layout[2].InstanceDataStepRate = 0;

			layout[3].SemanticName = "POSITION";
			layout[3].SemanticIndex = 1;
			layout[3].Format = DXGI_FORMAT_R32G32B32_FLOAT;
			layout[3].InputSlot = 1;
			layout[3].AlignedByteOffset = 0;
			layout[3].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
			layout[3].InstanceDataStepRate = 0;

			layout[4].SemanticName = "NORMAL";
			layout[4].SemanticIndex = 1;
			layout[4].Format = DXGI_FORMAT_R32G32B32_FLOAT;
			layout[4].InputSlot = 1;
			layout[4].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
			layout[4].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
			layout[4].InstanceDataStepRate = 0;

			layout[5].SemanticName = "TEXCOORD";
			layout[5].SemanticIndex = 1;
			layout[5].Format = DXGI_FORMAT_R32G32_FLOAT;
			layout[5].InputSlot = 1;
			layout[5].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
			layout[5].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
			layout[5].InstanceDataStepRate = 0;

			nb=6;
		}
		else
		{
		
			if (vb->Type&API3D_EDGESDG)
			{
				layout[0].SemanticName = "POSITION";
				layout[0].SemanticIndex = 0;
				layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
				layout[0].InputSlot = 0;
				layout[0].AlignedByteOffset = 0;
				layout[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
				layout[0].InstanceDataStepRate = 0;

				layout[1].SemanticName = "NORMAL";
				layout[1].SemanticIndex = 0;
				layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
				layout[1].InputSlot = 0;
				layout[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
				layout[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
				layout[1].InstanceDataStepRate = 0;

				layout[2].SemanticName = "TEXCOORD";
				layout[2].SemanticIndex = 0;
				layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
				layout[2].InputSlot = 0;
				layout[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
				layout[2].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
				layout[2].InstanceDataStepRate = 0;

				nb=3;
			}
			else
			{
				layout[0].SemanticName = "POSITION";
				layout[0].SemanticIndex = 0;
				layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
				layout[0].InputSlot = 0;
				layout[0].AlignedByteOffset = 0;
				layout[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
				layout[0].InstanceDataStepRate = 0;

				layout[1].SemanticName = "NORMAL";
				layout[1].SemanticIndex = 0;
				layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
				layout[1].InputSlot = 0;
				layout[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
				layout[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
				layout[1].InstanceDataStepRate = 0;

				layout[2].SemanticName = "TEXCOORD";
				layout[2].SemanticIndex = 0;
				layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
				layout[2].InputSlot = 0;
				layout[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
				layout[2].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
				layout[2].InstanceDataStepRate = 0;

				nb=3;
			}
		}
		break;
	case 6:
		// lightmap
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 1;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;
	
		nb=4;
		break;
	case 7:
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 1;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		layout[4].SemanticName = "TEXCOORD";
		layout[4].SemanticIndex = 2;
		layout[4].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[4].InputSlot = 0;
		layout[4].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[4].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[4].InstanceDataStepRate = 0;

		nb=5;
		break;

	case 8:
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "NORMAL";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "COLOR";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 0;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		layout[4].SemanticName = "TEXCOORD";
		layout[4].SemanticIndex = 1;
		layout[4].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[4].InputSlot = 0;
		layout[4].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[4].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[4].InstanceDataStepRate = 0;

		nb=5;
		break;

	case 9:
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "NORMAL";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "COLOR";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 0;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		layout[4].SemanticName = "TEXCOORD";
		layout[4].SemanticIndex = 1;
		layout[4].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[4].InputSlot = 0;
		layout[4].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[4].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[4].InstanceDataStepRate = 0;

		layout[5].SemanticName = "TEXCOORD";
		layout[5].SemanticIndex = 2;
		layout[5].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[5].InputSlot = 0;
		layout[5].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[5].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[5].InstanceDataStepRate = 0;

		layout[6].SemanticName = "TEXCOORD";
		layout[6].SemanticIndex = 3;
		layout[6].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[6].InputSlot = 0;
		layout[6].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[6].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[6].InstanceDataStepRate = 0;

		nb=7;
		break;

	case 10:
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "COLOR";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "TEXCOORD";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 1;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		layout[4].SemanticName = "TEXCOORD";
		layout[4].SemanticIndex = 2;
		layout[4].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[4].InputSlot = 0;
		layout[4].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[4].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[4].InstanceDataStepRate = 0;

		layout[5].SemanticName = "TEXCOORD";
		layout[5].SemanticIndex = 3;
		layout[5].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[5].InputSlot = 0;
		layout[5].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[5].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[5].InstanceDataStepRate = 0;

		nb=6;
		break;

	case 32+0:
	case 32+1:
	case 32+3:
		// texturage normal
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "BLENDWEIGHT";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = 0;
		layout[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "COLOR";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R8G8B8A8_UNORM;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 0;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		nb=4;

		break;
	case 32+2:
		// gouraud simple
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLOR );
		break;
	
	case 32+4:
		// double texturage
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX2 );
		break;
	case 32+5:
		// TNL
		layout[0].SemanticName = "POSITION";
		layout[0].SemanticIndex = 0;
		layout[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[0].InputSlot = 0;
		layout[0].AlignedByteOffset = 0;
		layout[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[0].InstanceDataStepRate = 0;

		layout[1].SemanticName = "BLENDWEIGHT";
		layout[1].SemanticIndex = 0;
		layout[1].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
		layout[1].InputSlot = 0;
		layout[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[1].InstanceDataStepRate = 0;

		layout[2].SemanticName = "NORMAL";
		layout[2].SemanticIndex = 0;
		layout[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		layout[2].InputSlot = 0;
		layout[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[2].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[2].InstanceDataStepRate = 0;

		layout[3].SemanticName = "TEXCOORD";
		layout[3].SemanticIndex = 0;
		layout[3].Format = DXGI_FORMAT_R32G32_FLOAT;
		layout[3].InputSlot = 0;
		layout[3].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		layout[3].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		layout[3].InstanceDataStepRate = 0;

		nb=4;

		break;
	case 32+6:
		// lightmap
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX2 );
		break;
	case 32+7:
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX3 );
		break;

	case 32+9:
		//D3DDevice->SetFVF( D3DFVF_BLENDXYZNORMALCOLORTEX4 );
		break;
	};

	return nb;
}

//#define blendStateDesc GlobalPipelineDesc.BlendState
//#define depthStencilDesc GlobalPipelineDesc.DepthStencilState
//#define rasterDesc GlobalPipelineDesc.RasterizerState
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool C3DAPIBASE::PipelineDescChanges()
{
	if (PreviousPipelineDesc.RasterizerState.CullMode!=GlobalPipelineDesc.RasterizerState.CullMode) return true;
	/**/
    if (PreviousPipelineDesc.DepthStencilState.DepthEnable!=GlobalPipelineDesc.DepthStencilState.DepthEnable) return true;
    if (PreviousPipelineDesc.DepthStencilState.DepthWriteMask!=GlobalPipelineDesc.DepthStencilState.DepthWriteMask) return true;
    if (PreviousPipelineDesc.DepthStencilState.DepthFunc!=GlobalPipelineDesc.DepthStencilState.DepthFunc) return true;
	/*
    if (PreviousPipelineDesc.DepthStencilState.StencilEnable!=GlobalPipelineDesc.DepthStencilState.StencilEnable) return true;
    if (PreviousPipelineDesc.DepthStencilState.StencilReadMask!=GlobalPipelineDesc.DepthStencilState.StencilReadMask) return true;
    if (PreviousPipelineDesc.DepthStencilState.StencilWriteMask!=GlobalPipelineDesc.DepthStencilState.StencilWriteMask) return true;
	/**/
    if (PreviousPipelineDesc.BlendState.RenderTarget[0].BlendEnable!=GlobalPipelineDesc.BlendState.RenderTarget[0].BlendEnable) return true;
    if (PreviousPipelineDesc.BlendState.RenderTarget[0].SrcBlend!=GlobalPipelineDesc.BlendState.RenderTarget[0].SrcBlend) return true;
    if (PreviousPipelineDesc.BlendState.RenderTarget[0].DestBlend!=GlobalPipelineDesc.BlendState.RenderTarget[0].DestBlend) return true;
    //if (PreviousPipelineDesc.BlendState.RenderTarget[0].BlendOp!=GlobalPipelineDesc.BlendState.RenderTarget[0].BlendOp) return true;
    //if (PreviousPipelineDesc.BlendState.RenderTarget[0].SrcBlendAlpha!=GlobalPipelineDesc.BlendState.RenderTarget[0].SrcBlendAlpha) return true;
    //if (PreviousPipelineDesc.BlendState.RenderTarget[0].DestBlendAlpha!=GlobalPipelineDesc.BlendState.RenderTarget[0].DestBlendAlpha) return true;
    //if (PreviousPipelineDesc.BlendState.RenderTarget[0].BlendOpAlpha!=GlobalPipelineDesc.BlendState.RenderTarget[0].BlendOpAlpha) return true;
	/*
    if (PreviousPipelineDesc.DepthStencilState.FrontFace.StencilFailOp!=GlobalPipelineDesc.DepthStencilState.FrontFace.StencilFailOp) return true;
    if (PreviousPipelineDesc.DepthStencilState.FrontFace.StencilDepthFailOp!=GlobalPipelineDesc.DepthStencilState.FrontFace.StencilDepthFailOp) return true;
    if (PreviousPipelineDesc.DepthStencilState.FrontFace.StencilPassOp!=GlobalPipelineDesc.DepthStencilState.FrontFace.StencilPassOp) return true;
    if (PreviousPipelineDesc.DepthStencilState.FrontFace.StencilFunc!=GlobalPipelineDesc.DepthStencilState.FrontFace.StencilFunc) return true;

    if (PreviousPipelineDesc.DepthStencilState.BackFace.StencilFailOp!=GlobalPipelineDesc.DepthStencilState.BackFace.StencilFailOp) return true;
    if (PreviousPipelineDesc.DepthStencilState.BackFace.StencilDepthFailOp!=GlobalPipelineDesc.DepthStencilState.BackFace.StencilDepthFailOp) return true;
    if (PreviousPipelineDesc.DepthStencilState.BackFace.StencilPassOp!=GlobalPipelineDesc.DepthStencilState.BackFace.StencilPassOp) return true;
    if (PreviousPipelineDesc.DepthStencilState.BackFace.StencilFunc!=GlobalPipelineDesc.DepthStencilState.BackFace.StencilFunc) return true;
	/**/
    return false;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::PipelineDescBackup()
{
    PreviousPipelineDesc.RasterizerState.CullMode=GlobalPipelineDesc.RasterizerState.CullMode;

    PreviousPipelineDesc.DepthStencilState.DepthEnable=GlobalPipelineDesc.DepthStencilState.DepthEnable;
    PreviousPipelineDesc.DepthStencilState.DepthWriteMask=GlobalPipelineDesc.DepthStencilState.DepthWriteMask;
    PreviousPipelineDesc.DepthStencilState.DepthFunc=GlobalPipelineDesc.DepthStencilState.DepthFunc;

    PreviousPipelineDesc.DepthStencilState.StencilEnable=GlobalPipelineDesc.DepthStencilState.StencilEnable;
    PreviousPipelineDesc.DepthStencilState.StencilReadMask=GlobalPipelineDesc.DepthStencilState.StencilReadMask;
    PreviousPipelineDesc.DepthStencilState.StencilWriteMask=GlobalPipelineDesc.DepthStencilState.StencilWriteMask;

    PreviousPipelineDesc.DepthStencilState.FrontFace.StencilFailOp=GlobalPipelineDesc.DepthStencilState.FrontFace.StencilFailOp;
    PreviousPipelineDesc.DepthStencilState.FrontFace.StencilDepthFailOp=GlobalPipelineDesc.DepthStencilState.FrontFace.StencilDepthFailOp;
    PreviousPipelineDesc.DepthStencilState.FrontFace.StencilPassOp=GlobalPipelineDesc.DepthStencilState.FrontFace.StencilPassOp;
    PreviousPipelineDesc.DepthStencilState.FrontFace.StencilFunc=GlobalPipelineDesc.DepthStencilState.FrontFace.StencilFunc;

    PreviousPipelineDesc.DepthStencilState.BackFace.StencilFailOp=GlobalPipelineDesc.DepthStencilState.BackFace.StencilFailOp;
    PreviousPipelineDesc.DepthStencilState.BackFace.StencilDepthFailOp=GlobalPipelineDesc.DepthStencilState.BackFace.StencilDepthFailOp;
    PreviousPipelineDesc.DepthStencilState.BackFace.StencilPassOp=GlobalPipelineDesc.DepthStencilState.BackFace.StencilPassOp;
    PreviousPipelineDesc.DepthStencilState.BackFace.StencilFunc=GlobalPipelineDesc.DepthStencilState.BackFace.StencilFunc;

    PreviousPipelineDesc.BlendState.RenderTarget[0].BlendEnable=GlobalPipelineDesc.BlendState.RenderTarget[0].BlendEnable;
    PreviousPipelineDesc.BlendState.RenderTarget[0].SrcBlend=GlobalPipelineDesc.BlendState.RenderTarget[0].SrcBlend;
    PreviousPipelineDesc.BlendState.RenderTarget[0].DestBlend=GlobalPipelineDesc.BlendState.RenderTarget[0].DestBlend;
    PreviousPipelineDesc.BlendState.RenderTarget[0].BlendOp=GlobalPipelineDesc.BlendState.RenderTarget[0].BlendOp;
    PreviousPipelineDesc.BlendState.RenderTarget[0].SrcBlendAlpha=GlobalPipelineDesc.BlendState.RenderTarget[0].SrcBlendAlpha;
    PreviousPipelineDesc.BlendState.RenderTarget[0].DestBlendAlpha=GlobalPipelineDesc.BlendState.RenderTarget[0].DestBlendAlpha;
    PreviousPipelineDesc.BlendState.RenderTarget[0].BlendOpAlpha=GlobalPipelineDesc.BlendState.RenderTarget[0].BlendOpAlpha;
}

// RS12
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::SetRenderState(vpRenderState * RS,int multi)
{
	D3D12_BLEND s,d;
	int bld=RS->SrcBlend+RS->DstBlend+RS->Blend;
	PreviousBlend=bld;

	if (RS)
	{
		if ((RS->ZBufferWrite!=PreviousRS.ZBufferWrite)||(RS->ZBuffer!=PreviousRS.ZBuffer))
		{
			PreviousRS.ZBuffer=RS->ZBuffer;
			PreviousRS.ZBufferWrite=RS->ZBufferWrite;
			if (RS->ZBuffer==_TRUE) SetParams(API3D_ZBUFFER,ON);
			if (RS->ZBufferWrite==_FALSE) SetParams(API3D_ZBUFFER,WRITEOFF);
			if (RS->ZBuffer==_FALSE) SetParams(API3D_ZBUFFER,OFF);
            
            dirtyCRCState=true;
		}

		if (RS->ShadeMode==_SMOOTH) SetParams(API3D_SHADING,ON);
		if (RS->ShadeMode==_FLAT) SetParams(API3D_SHADING,OFF);
	
		int val=0;

		if (RS->zbias!=PreviousRS.zbias)
		{
			PreviousRS.zbias=RS->zbias;
            
            dirtyCRCState=true;

			switch (RS->zbias)
			{
			case _OFFSET_0:
				val=0;
				break;
			case _OFFSET_1:
				val=1;
				break;
			case _OFFSET_2:
				val=2;
				break;
			case _OFFSET_3:
				val=3;
				break;
			case _OFFSET_4:
				val=4;
				break;
			case _OFFSET_5:
				val=5;
				break;
			case _OFFSET_6:
				val=6;
				break;
			case _OFFSET_7:
				val=7;
				break;
			};
			SetParams(API3D_ZBIAS,val);
		}

		if (RS->SrcBlend!=PreviousRS.SrcBlend)
		{
			PreviousRS.SrcBlend=RS->SrcBlend;
			PreviousRS.Blend=_UNDEFINED;
            
            dirtyCRCState=true;

			switch (RS->SrcBlend)
			{
				case _ZERO:
					s=D3D12_BLEND_ZERO;
					break;
				case _ONE:
					s=D3D12_BLEND_ONE;
					break;
				case _SRCALPHA:
					s=D3D12_BLEND_SRC_ALPHA;
					break;
				case _INVSRCALPHA:
					s=D3D12_BLEND_INV_SRC_ALPHA;
					break;
				case _SRCCOLOR:
					s=D3D12_BLEND_SRC_COLOR;
					break;
				case _INVSRCCOLOR:
					s=D3D12_BLEND_INV_SRC_COLOR;
					break;
				case _DSTALPHA:
					s=D3D12_BLEND_DEST_ALPHA;
					break;
				case _INVDSTALPHA:
					s=D3D12_BLEND_INV_DEST_ALPHA;
					break;
				case _DSTCOLOR:
					s=D3D12_BLEND_DEST_COLOR;
					break;
				case _INVDSTCOLOR:
					s=D3D12_BLEND_INV_DEST_COLOR;
					break;
			};
		}		

		if (RS->DstBlend!=PreviousRS.DstBlend)
		{
			PreviousRS.DstBlend=RS->DstBlend;
			PreviousRS.Blend=_UNDEFINED;
            
            dirtyCRCState=true;

			switch (RS->DstBlend)
			{
				case _ZERO:
					d=D3D12_BLEND_ZERO;
					break;
				case _ONE:
					d=D3D12_BLEND_ONE;
					break;
				case _SRCALPHA:
					d=D3D12_BLEND_SRC_ALPHA;
					break;
				case _INVSRCALPHA:
					d=D3D12_BLEND_INV_SRC_ALPHA;
					break;
				case _SRCCOLOR:
					d=D3D12_BLEND_SRC_COLOR;
					break;
				case _INVSRCCOLOR:
					d=D3D12_BLEND_INV_SRC_COLOR;
					break;
				case _DSTALPHA:
					d=D3D12_BLEND_DEST_ALPHA;
					break;
				case _INVDSTALPHA:
					d=D3D12_BLEND_INV_DEST_ALPHA;
					break;
				case _DSTCOLOR:
					d=D3D12_BLEND_DEST_COLOR;
					break;
				case _INVDSTCOLOR:
					d=D3D12_BLEND_INV_DEST_COLOR;
					break;
			};
		}

		if (RS->Blend!=PreviousRS.Blend)
		{
			PreviousRS.Blend=RS->Blend;
            
            dirtyCRCState=true;

			switch(RS->Blend)
			{
			case _TRUE:
				blendStateDesc.RenderTarget[0].BlendEnable=true;
				blendStateDesc.RenderTarget[0].SrcBlend=s;
				blendStateDesc.RenderTarget[0].DestBlend=d;
				blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
				blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
				blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_ONE;
				blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ZERO;
				break;
			case _FALSE:
				blendStateDesc.RenderTarget[0].BlendEnable=false;
				break;
			};			
		}

		if (RS->Cull!=PreviousRS.Cull)
		{
			PreviousRS.Cull=RS->Cull;
            
            dirtyCRCState=true;

			switch(RS->Cull)
			{
			case _NONE:
				SetParams(API3D_CULL,OFF);
				break;
			case _CCW:
				SetParams(API3D_CULL,CCW);
				break;
			case _CW:
				SetParams(API3D_CULL,CW);
				break;
			};
		}

		if (RS->RenderTarget!=PreviousRS.RenderTarget)
		{
			PreviousRS.RenderTarget=RS->RenderTarget;
            
            dirtyCRCState=true;

			switch (RS->RenderTarget)
			{
			case _RENDER:
				SetParams(API3D_RENDERTARGET,RENDER);
				break;
			case _STENCIL:
				SetParams(API3D_RENDERTARGET,STENCIL);
				break;
			case _ZBUFFER:
				SetParams(API3D_RENDERTARGET,ZBUFFER);
				break;
			case _BOTH:
				SetParams(API3D_RENDERTARGET,BOTH);
				break;
			case _BOTHZ:
				SetParams(API3D_RENDERTARGET,BOTH_WRITE_Z);
				break;

			case _TWOSIDED:
				depthStencilDesc.DepthEnable = true;
				depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
				depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;

				depthStencilDesc.StencilEnable = true;
				depthStencilDesc.StencilReadMask = 0xFF;
				depthStencilDesc.StencilWriteMask = 0xFF;

				if (states(ALGO_STENCIL_SHADOWING)==ALGO_REVERSE)
				{
					depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_INCR;
					depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_DECR;
					depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;
				}
				else
				{
					depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
					depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_INCR;
					depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

					depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
					depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_DECR;
					depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;
				}

				blendStateDesc.RenderTarget[0].BlendEnable=true;
				blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_ZERO;
				blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ONE;
				blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
				blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
				blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_ZERO;
				blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ONE;
				
				rasterDesc.CullMode = D3D12_CULL_MODE_NONE;
				break;
			};
		}

		if (RS->Stencil!=PreviousRS.Stencil)
		{
			PreviousRS.Stencil=RS->Stencil;
            
            dirtyCRCState=true;

			switch (RS->Stencil)
			{
			case _INCREMENT:
				SetParams(API3D_STENCIL,INCREMENT);
				break;
			case _DECREMENT:
				SetParams(API3D_STENCIL,DECREMENT);
				break;
			case _SET_ONE:
				SetParams(API3D_STENCIL,SET_ONE);
				break;
			case _EQUAL_ZERO:
				SetParams(API3D_STENCIL,EQUAL_ZERO);
				break;
			case _EQUAL_ONE:
				SetParams(API3D_STENCIL,EQUAL_ONE);
				break;
			case _ALWAYS:
				SetParams(API3D_STENCIL,ALWAYS);
				break;
			case _NOT_ONE:
				SetParams(API3D_STENCIL,NOT_ONE);
				break;
			case _NOT_ZERO:
				SetParams(API3D_STENCIL,NOT_ZERO);
				break;
			case _LESSEQUAL_ONE:
				SetParams(API3D_STENCIL,LESSEQUAL_ONE);
				break;
			case _GREATEREQUAL_ONE:
				SetParams(API3D_STENCIL,GREATEREQUAL_ONE);
				break;
			};
		}
	}
}
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#if defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)||defined(API3D_METAL)
void C3DAPIBASE::MultiTextureShaders(CIndicesSE * nfo,CVertexBuffer *eff)
{	
    if (ActualVertexBuffer->Type&API3D_ENVMAPPING)
    {
        if (fn_stage1) eff->setTexture("Tex",fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
        else
        {
            if ((nfo->nT+Decal_nt>=0)&&(nfo->nT+Decal_nt<NBRE_MAX_TEXTURES))
                if (cTexture[nfo->nT+Decal_nt]) eff->setTexture("Tex",nfo->nT+Decal_nt);
        }
        
        if (states(ENV_SHADERS)==0)
        {
            if (fn_stage0) eff->setTexture("Env",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
            else
            {
                if ((nfo->nT2+Decal_nt2>=0)&&(nfo->nT2+Decal_nt2<NBRE_MAX_TEXTURES))
                    if (cTexture[nfo->nT2+Decal_nt2]) eff->setTexture("Env",nfo->nT2+Decal_nt2);
            }
        }
    }
    else
    {
        if (ActualVertexBuffer->TypeVB==6)
        {
            if (fn_stage0) eff->setLightmap("Tex1",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
            else eff->setLightmap("Tex1",nfo->nL);

            if (fn_stage1) eff->setTexture("Tex2",fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
            else
            {
                if ((nfo->nT+Decal_nt>=0)&&(nfo->nT+Decal_nt<NBRE_MAX_TEXTURES))
                if (cTexture[nfo->nT+Decal_nt]) eff->setTexture("Tex2",nfo->nT+Decal_nt);
            }
        }
        else
        if (ActualVertexBuffer->TypeVB==4)
        {
            if (fn_stage0) eff->setTexture("Tex1",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
            else
            {
                if ((nfo->nT+Decal_nt>=0)&&(nfo->nT+Decal_nt<NBRE_MAX_TEXTURES))
                if (cTexture[nfo->nT+Decal_nt]) eff->setTexture("Tex1",nfo->nT+Decal_nt);
            }

            if (fn_stage1) eff->setTexture("Tex2",fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
            else
            {
                if ((nfo->nT2>=0)&&(nfo->nT2<NBRE_MAX_TEXTURES))
                if (cTexture[nfo->nT2]) eff->setTexture("Tex2",nfo->nT2);
            }
        }
        else
        {
            if (fn_stage0) eff->setTexture("Tex1",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
            else
            {
                if ((nfo->nT+Decal_nt>=0)&&(nfo->nT+Decal_nt<NBRE_MAX_TEXTURES))
                if (cTexture[nfo->nT+Decal_nt]) eff->setTexture("Tex1",nfo->nT+Decal_nt);
            }
        }
    }
}
#endif

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::DrawVertexBufferSetupSizeDest(CVertexBuffer *eff,CIndicesSE * nfo)
{
	int x,y,tag;
	CVector4 vec;
	char *texturename;

	if (eff->vp->RenderState[0][0].AlphaRef==-666)
	{
		if (set_alphatest) eff->setFloat("REFALPHA",val_alphatest);
		else eff->setFloat("REFALPHA",-SMALLF2);

#ifdef API3D_DIRECT3D12
		if ((eff->vp->FSRSample0==0)&&(eff->vp->FSRSample1==0)&&(eff->vp->SizingTexture0==0))
		{
			eff->effect->Update();
			return;
		}
#endif
	}

	if ((eff->vp->FSRSample0==0)&&(eff->vp->FSRSample1==0)&&(eff->vp->SizingTexture0==0)) return;

	if(eff->vp->SizingTexture0)
	{
		tag=0;
		texturename=eff->vp->RenderState[0][0].Texture[0];
		if(texturename)
		{
			if(eff->AssignedTexture[TEXTURE_FROM_NT])
				if(strcmp(eff->AssignedTexture[TEXTURE_FROM_NT],texturename)==0)
				{
					x=cTexture[nfo->nT+Decal_nt]->data.Tilex;
					y=cTexture[nfo->nT+Decal_nt]->data.Tiley;
					tag=1;
				}

			if(eff->AssignedTexture[TEXTURE_FROM_NTPLUSONE])
				if(strcmp(eff->AssignedTexture[TEXTURE_FROM_NTPLUSONE],texturename)==0)
				{
					x=cTexture[nfo->nT+Decal_nt+1]->data.Tilex;
					y=cTexture[nfo->nT+Decal_nt+1]->data.Tiley;
					tag=1;
				}

			if(eff->AssignedTexture[TEXTURE_FROM_NT2])
				if(strcmp(eff->AssignedTexture[TEXTURE_FROM_NT2],texturename)==0)
				{
					x=cTexture[nfo->nT2]->data.Tilex;
					y=cTexture[nfo->nT2]->data.Tiley;
					tag=1;
				}

			if(eff->AssignedTexture[TEXTURE_FROM_BUMP])
				if(strcmp(eff->AssignedTexture[TEXTURE_FROM_BUMP],texturename)==0)
				{
					x=cTexture[nfo->nT+bumpmap_settexture]->data.Tilex;
					y=cTexture[nfo->nT+bumpmap_settexture]->data.Tiley;
					tag=1;
				}

			if(eff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE])
				if(strcmp(eff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE],texturename)==0)
				{
					x=cTexture[nfo->nT+1+bumpmap_settexture]->data.Tilex;
					y=cTexture[nfo->nT+1+bumpmap_settexture]->data.Tiley;
					tag=1;
				}

			if(tag)
			{
				vec.Init((float)x,(float)y,1.0f/x,1.0f/y);
				eff->setVector4("SIZEDESTZ",vec);
			}
		}
	}

	if (eff->vp->FSRSample0)
	{
		tag=0;
		texturename=eff->vp->RenderState[0][0].Texture[0];
		if (texturename)
		{
			if (eff->AssignedTexture[TEXTURE_FROM_NT])
			if (strcmp(eff->AssignedTexture[TEXTURE_FROM_NT],texturename)==0)
			{
				x=cTexture[nfo->nT+Decal_nt]->data.Tilex;
				y=cTexture[nfo->nT+Decal_nt]->data.Tiley;
				tag=1;
			}

			if (eff->AssignedTexture[TEXTURE_FROM_NTPLUSONE])
			if (strcmp(eff->AssignedTexture[TEXTURE_FROM_NTPLUSONE],texturename)==0)
			{
				x=cTexture[nfo->nT+Decal_nt+1]->data.Tilex;
				y=cTexture[nfo->nT+Decal_nt+1]->data.Tiley;
				tag=1;
			}

			if (eff->AssignedTexture[TEXTURE_FROM_NT2])
			if (strcmp(eff->AssignedTexture[TEXTURE_FROM_NT2],texturename)==0)
			{
				x=cTexture[nfo->nT2]->data.Tilex;
				y=cTexture[nfo->nT2]->data.Tiley;
				tag=1;
			}

			if (eff->AssignedTexture[TEXTURE_FROM_BUMP])
			if (strcmp(eff->AssignedTexture[TEXTURE_FROM_BUMP],texturename)==0)
			{
				x=cTexture[nfo->nT+bumpmap_settexture]->data.Tilex;
				y=cTexture[nfo->nT+bumpmap_settexture]->data.Tiley;
				tag=1;
			}

			if (eff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE])
			if (strcmp(eff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE],texturename)==0)
			{
				x=cTexture[nfo->nT+1+bumpmap_settexture]->data.Tilex;
				y=cTexture[nfo->nT+1+bumpmap_settexture]->data.Tiley;
				tag=1;
			}

			if (tag)
			{
				vec.Init((float)x,(float)y,1.0f/x,1.0f/y);
				eff->setVector4("SIZEDEST0",vec);
			}
		}
	}

	if (eff->vp->FSRSample1)
	{
		tag=0;
		texturename=eff->vp->RenderState[0][0].Texture[1];
		if (texturename)
		{
			if (eff->AssignedTexture[TEXTURE_FROM_NT])
			if (strcmp(eff->AssignedTexture[TEXTURE_FROM_NT],texturename)==0)
			{
				x=cTexture[nfo->nT+Decal_nt]->data.Tilex;
				y=cTexture[nfo->nT+Decal_nt]->data.Tiley;
				tag=1;
			}

			if (eff->AssignedTexture[TEXTURE_FROM_NTPLUSONE])
			if (strcmp(eff->AssignedTexture[TEXTURE_FROM_NTPLUSONE],texturename)==0)
			{
				x=cTexture[nfo->nT+Decal_nt+1]->data.Tilex;
				y=cTexture[nfo->nT+Decal_nt+1]->data.Tiley;
				tag=1;
			}

			if (eff->AssignedTexture[TEXTURE_FROM_NT2])
			if (strcmp(eff->AssignedTexture[TEXTURE_FROM_NT2],texturename)==0)
			{
				x=cTexture[nfo->nT2]->data.Tilex;
				y=cTexture[nfo->nT2]->data.Tiley;
				tag=1;
			}

			if (eff->AssignedTexture[TEXTURE_FROM_BUMP])
			if (strcmp(eff->AssignedTexture[TEXTURE_FROM_BUMP],texturename)==0)
			{
				x=cTexture[nfo->nT+bumpmap_settexture]->data.Tilex;
				y=cTexture[nfo->nT+bumpmap_settexture]->data.Tiley;
				tag=1;
			}

			if (eff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE])
			if (strcmp(eff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE],texturename)==0)
			{
				x=cTexture[nfo->nT+1+bumpmap_settexture]->data.Tilex;
				y=cTexture[nfo->nT+1+bumpmap_settexture]->data.Tiley;
				tag=1;
			}

			if (tag)
			{
				vec.Init((float)x,(float)y,1.0f/x,1.0f/y);
				eff->setVector4("SIZEDEST1",vec);
			}
		}
	}

#ifdef API3D_DIRECT3D12
	eff->effect->Update();
#endif
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::DrawVertexBuffer()
{
	CIndicesSE * nfo;
	CIndicesSE tmp_iSE;
	int ref_value;
    
    if (!Active) return;
	if (ActualVertexBuffer==NULL) return;
    
    // flag detect
    if (ActualVertexBuffer->Grouped)
    {
        int ok=0;
        nfo=ActualVertexBuffer->ListeSE.GetFirst();
        while (nfo)
        {
			if (nfo->nT<0) return;
            if (nfo->flag==valueflag) ok=1;
            nfo=ActualVertexBuffer->ListeSE.GetNext();
        }
        
        if (ok==0) return;
    }
    
	count_nv+=ActualVertexBuffer->nVerticesActif;
	count_nf+=ActualVertexBuffer->nIndicesActif/3;
	count_nfavoid+=ActualVertexBuffer->nIndices/3;
	count_nvb++;

	tmp_iSE.nL=-1;
	tmp_iSE.nLV=-1;
	tmp_iSE.nT=-1;
	tmp_iSE.nT2=-1;

	int replace=states(REPLACE_ACTIVE);

#ifdef API3D_METAL
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// METAL

	int n;
	CVertexBuffer * VBEFF=NULL;
	bool TNL=false;

	if (((!(ActualVertexBuffer->Type&API3D_VERTEXPROGRAM))&&(!ActualEffect))&&(!vbdraw_line))
	{
		if (ActualVertexBuffer->TypeVB==9)
		{
			if (states(RENDER_TARGET_OPTIONS)==STENCIL)
			{
				VBEFF=&effect_hll_bump_mapping_displacement_s;
				SetBUILTINVertexBuffer(VBEFF);
			}
			else
			{
				VBEFF=&effect_hll_bump_mapping_displacement;
				SetBUILTINVertexBuffer(VBEFF);

				CVector vect;
				if ((ActualVertexBuffer->Lights[0]>=0)&&(ActualVertexBuffer->Lights[0]<nLights)) VBEFF->setVector("vecLight1",Lights[ActualVertexBuffer->Lights[0]].Pos);
				if ((ActualVertexBuffer->Lights[1]>=0)&&(ActualVertexBuffer->Lights[1]<nLights)) VBEFF->setVector("vecLight2",Lights[ActualVertexBuffer->Lights[1]].Pos);
				if ((ActualVertexBuffer->Lights[2]>=0)&&(ActualVertexBuffer->Lights[2]<nLights)) VBEFF->setVector("vecLight3",Lights[ActualVertexBuffer->Lights[2]].Pos);
					
				if ((ActualVertexBuffer->Lights[0]>=0)&&(ActualVertexBuffer->Lights[0]<nLights)) vect.x=Lights[ActualVertexBuffer->Lights[0]].variation; else vect.x=0.0f;
				vect.y=vect.z=vect.x;
				VBEFF->setVector("vecVar1",vect);
				if ((ActualVertexBuffer->Lights[1]>=0)&&(ActualVertexBuffer->Lights[1]<nLights)) vect.x=Lights[ActualVertexBuffer->Lights[1]].variation; else vect.x=0.0f;
				vect.y=vect.z=vect.x;
				VBEFF->setVector("vecVar2",vect);
				if ((ActualVertexBuffer->Lights[2]>=0)&&(ActualVertexBuffer->Lights[2]<nLights)) vect.x=Lights[ActualVertexBuffer->Lights[2]].variation; else vect.x=0.0f;
				vect.y=vect.z=vect.x;
				VBEFF->setVector("vecVar3",vect);
			}

			VBEFF->setMatrixWorld("WORLD");
			VBEFF->setMatrixViewProj("VIEWPROJ");

			CMatrix M;
			M.Inverse4x4(VIEW);

			CVector v;
            v.Init( M.a[3][0],M.a[3][1],M.a[3][2] );

			VBEFF->setVector("Eye",v);
		}
		else
		if (ActualVertexBuffer->TypeVB==7)
		{
			if (states(RENDER_TARGET_OPTIONS)==STENCIL)
			{
				VBEFF=&effect_hll_bump_mapping_s;
				SetBUILTINVertexBuffer(VBEFF);
			}
			else
			{
				if (states(SPECIAL_ANIMATED))
				{
					VBEFF=&effect_hll_bump_mapping_anim;
					SetBUILTINVertexBuffer(VBEFF);

					CVector vect;
					VBEFF->setVector("vecLight1",Lights[ActualVertexBuffer->Lights[0]].Pos);
					VBEFF->setVector("vecLight2",Lights[ActualVertexBuffer->Lights[1]].Pos);
					VBEFF->setVector("vecLight3",Lights[ActualVertexBuffer->Lights[2]].Pos);
					
					vect.x=Lights[ActualVertexBuffer->Lights[0]].variation;
					vect.y=vect.z=vect.x;
					VBEFF->setVector("vecVar1",vect);
					vect.x=Lights[ActualVertexBuffer->Lights[1]].variation;
					vect.y=vect.z=vect.x;
					VBEFF->setVector("vecVar2",vect);
					vect.x=Lights[ActualVertexBuffer->Lights[2]].variation;
					vect.y=vect.z=vect.x;
					VBEFF->setVector("vecVar3",vect);
				}
				else
				{
					VBEFF=&effect_hll_bump_mapping;
					SetBUILTINVertexBuffer(VBEFF);
				}
			}
			VBEFF->setMatrixWorld("WORLD");
			VBEFF->setMatrixViewProj("VIEWPROJ");
		}
		else
		if (ActualVertexBuffer->Type&API3D_ENVMAPPING)
		{
			int tagmorph=0;

			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				tagmorph=1;
				if (states(SHADERS)==1) VBEFF=&effect_hll_envmap2_morph;
				else VBEFF=&effect_hll_envmap1_morph;
			}
			else
			{
				if (states(SHADERS)==1) VBEFF=&effect_hll_envmap2;
				else VBEFF=&effect_hll_envmap1;
			}

			SetBUILTINVertexBuffer(VBEFF);

			CMatrix M;
			M.Inverse4x4(VIEW);

			CVector v;
			v.Init( M.a[3][0],M.a[3][1],M.a[3][2] );

			CVector u,u2,pz;
			pz.Init(0,0,0);

			u.Init(WORLD.a[3][0] - ActualVertexBuffer->L.x,WORLD.a[3][1] - ActualVertexBuffer->L.y,WORLD.a[3][2] - ActualVertexBuffer->L.z);
			u.Normalise();
			u2.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);
			CVector ldir,ldir2;

			if (states(SHADERS)==1)
			{
				n=GetCloserLight(this,u2);
				if (n>=0)
				{
					u2=u2-Lights[n].Pos;
					u2.Normalise();
				}
				else
				{
					u2.Init(0,0,0);
				}
				ldir.x=u2.x;
				ldir.y=u2.y;
				ldir.z=u2.z;
				
				u2.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);

				n=GetSecondCloserLight(this,n,u2);
				if (n>=0)
				{
					u2=u2-Lights[n].Pos;
					u2.Normalise();
				}
				else
				{
					u2.Init(0,0,0);
				}
				ldir2.x=u2.x;
				ldir2.y=u2.y;
				ldir2.z=u2.z;
			}
			else
			{
				ldir.x=u.x;
				ldir.y=u.y;
				ldir.z=u.z;
			}
			
			ActualVertexBuffer->Ldir=-1*u;

			CMatrix ML;
			ML.Id();
			ML.View(pz,-1*u,0);
	
			if (tagmorph) VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);

			VBEFF->setMatrix("MATLIGHT", ML);
			VBEFF->setMatrixWorld("WORLD");
			VBEFF->setMatrixViewProj("VIEWPROJ");
			VBEFF->setVector("VECLIGHT", ldir);
			VBEFF->setVector("CAMERA", v);

			if (states(SHADERS)==1)
			{
				CVector tmp;
				tmp.Init(Ambient.r,Ambient.g,Ambient.b);
				VBEFF->setVector("AMBIENT",tmp);
				VBEFF->setVector("VECLIGHT2", ldir2);
			}

            if (!ActualVertexBuffer->Grouped)
            {
                if (states(ENV_SHADERS)!=0)
                {
                    VBEFF->setTexture("Tex",aT2);
                    VBEFF->setTexture("Env",aT);
                }
                else
                {
                    VBEFF->setTexture("Tex",aT);
                    VBEFF->setTexture("Env",aT2);
                }
            }
            else if (states(ENV_SHADERS)!=0) VBEFF->setTexture("Env",aT);

            VBEFF->setVector("FactorMap",CVector(1,1,0));
		}

		if (ActualVertexBuffer->Type&API3D_EDGESDG)
		{
			int tagtmp=0;
			int tagmorph=0;

			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				tagmorph=1;
				if (states(ALGO_STENCIL_SHADOWING)!=ALGO_ALTERNATIVE) VBEFF=&effect_hll_stencil_simple_morph;
				else { VBEFF=&effect_hll_stencil_alternative_morph; tagtmp=1; }				
			}
			else
			{
				if (states(ALGO_STENCIL_SHADOWING)!=ALGO_ALTERNATIVE) VBEFF=&effect_hll_stencil_simple;
				else { VBEFF=&effect_hll_stencil_alternative; tagtmp=1; }
			}

			SetBUILTINVertexBuffer(VBEFF);

			float znear=Front+0.1f;
			CMatrix Mplane;
			CPlane plane;
			CMatrix M;
			CVector view;
			CVector camera;
			CVector4 v4light,v1,v2;
			CVector tmp;
			CVector light;

			light=Lights[ActualVertexBuffer->iValue1].Pos;

			if (tagtmp) 
			{
				v4light.Init(light);
				M.Inverse4x4(VIEW);
				camera.Init(M.a[3][0],M.a[3][1],M.a[3][2]);
				view.Init(M.a[2][0],M.a[2][1],M.a[2][2]);
				view.Normalise();
				camera=camera + znear * view;
				plane.a=view.x; plane.b=view.y; plane.c=view.z; plane.d=-(view||camera);
	
				if (plane.Distance(light)<0) { plane.a=-view.x; plane.b=-view.y; plane.c=-view.z; plane.d=(view||camera); }

				Mplane.Id();
				Mplane.ShadowProjection(v4light,plane);
			}

			tmp.Init(ActualVertexBuffer->fValue1,0.0f,znear);

			VBEFF->setVector("VAR",tmp);
			VBEFF->setPoint("Light",light);
			VBEFF->setMatrixViewProj("VIEWPROJ");
			if (tagtmp) VBEFF->setMatrix("PROJNEARPLANE",Mplane);
			if (tagtmp) VBEFF->setMatrix("VIEW",VIEW);
			VBEFF->setMatrix("WORLD",WORLD);
			if (tagmorph) VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
			
			SetParams(API3D_RENDERTARGET,STENCIL);
            
            if (states(ALGO_STENCIL_SHADOWING)==ALGO_REVERSE) MTLSetZBufferStencil(API3D_STENCIL,TWOSIDED_REVERSE);
			else MTLSetZBufferStencil(API3D_STENCIL,TWOSIDED_ALTERNATIVE);

            SetParams(API3D_ZBUFFER,ON);
            SetParams(API3D_ZBUFFER,WRITEOFF);
            SetParams(API3D_CULL,OFF);
            
		}
		else
		{
			// COLOR
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			if (ActualVertexBuffer->TypeVB==2)
			{
				VBEFF=&effect_hll_diffuse_nomap;
				SetBUILTINVertexBuffer(VBEFF);
				VBEFF->setMatrixWorldViewProj("MODEL");
			}

			// COLORTEX
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			if ((ActualVertexBuffer->TypeVB==0)||(ActualVertexBuffer->TypeVB==1)||(ActualVertexBuffer->TypeVB==3))  
			{
				if (set_alphatest) VBEFF=&effect_hll_diffuse_alphatest; else VBEFF=&effect_hll_diffuse;
				SetBUILTINVertexBuffer(VBEFF);

				if (!ActualVertexBuffer->Grouped) VBEFF->setTexture("Tex",aT);
				
				VBEFF->setMatrixWorld("WORLD");
				VBEFF->setMatrixViewProj("VIEWPROJ");
			}

			// TNL
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			if ((ActualVertexBuffer->TypeVB==5)&&((ActualVertexBuffer->Type&API3D_ENVMAPPING)==0))
			{
				if (!Lighting) return;
				TNL=true;
				if (Specular)
				{
					CMatrix M;
					CVector camera;
					M.Inverse4x4(VIEW);
					camera.Init(M.a[3][0],M.a[3][1],M.a[3][2]);

					if (ActualVertexBuffer->Type&API3D_MORPH)
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_specular_morph_alphatest;
						else VBEFF=&effect_hll_TNL_specular_morph;
						SetBUILTINVertexBuffer(VBEFF);

						VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
					}
					else
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_specular_alphatest;
						else VBEFF=&effect_hll_TNL_specular;
						SetBUILTINVertexBuffer(VBEFF);
					}
					VBEFF->setVector("CAMERA",camera);
				}
				else
				{
					if (ActualVertexBuffer->Type&API3D_MORPH)
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_morph_alphatest;
						else VBEFF=&effect_hll_TNL_morph;
						SetBUILTINVertexBuffer(VBEFF);
						VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
					}
					else
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_alphatest;
						else VBEFF=&effect_hll_TNL;
						SetBUILTINVertexBuffer(VBEFF);
					}
				}

				VBEFF->setMatrixWorld("WORLD");
				VBEFF->setMatrixViewProj("VIEWPROJ");
				if (!ActualVertexBuffer->Grouped) VBEFF->setTexture("Tex",aT);

				CVector u,vb_Pos,vv;
				int numLights[64];
				float rLights[64];
				int nbreLights;
				int n1,n2;

				vb_Pos.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);
			
				nbreLights=0;
				for (n=0;n<1024;n++)
				{
					if (Lights[n].enabled==1)
					{
						if (nbreLights<64)
						{
							if (Lights[n].directionnal)
							{
								u=Lights[n].Pos;
								rLights[nbreLights]=VECTORNORM(u);
								numLights[nbreLights]=n;
								nbreLights++;
							}
							else
							{
								VECTORSUB(u,Lights[n].Pos,vb_Pos);
								rLights[nbreLights]=VECTORNORM(u);
								numLights[nbreLights]=n;
								nbreLights++;
							}
						}
					}
				}

				for (n1=0;n1<nbreLights;n1++)
					for (n2=n1+1;n2<nbreLights;n2++)
					{
						if (rLights[n2]<rLights[n1])
						{
							float r=rLights[n2];
							rLights[n2]=rLights[n1];
							rLights[n1]=r;
							int num=numLights[n2];
							numLights[n2]=numLights[n1];
							numLights[n1]=num;
						}
					}

				if (nbreLights>8) nbreLights=8;

				static char * nameLIGHT[8]={ "LIGHT1","LIGHT2","LIGHT3","LIGHT4","LIGHT5","LIGHT6","LIGHT7","LIGHT8" };
				static char * nameCOUL[8]={ "COUL1","COUL2","COUL3","COUL4","COUL5","COUL6","COUL7","COUL8" };

				CVector tmp;

				for (n=0;n<nbreLights;n++)
				{
					int nl=numLights[n];
					tmp.Init(Lights[nl].r,Lights[nl].g,Lights[nl].b);
					if (Lights[nl].directionnal)
					{
						vv=vb_Pos - 100.0f*Lights[nl].Pos;
						VBEFF->setVector(nameLIGHT[n],vv);
					}
					else VBEFF->setVector(nameLIGHT[n],Lights[nl].Pos);
					VBEFF->setPoint(nameCOUL[n],tmp);
				}

				if (nbreLights<8)
					for (n=nbreLights;n<8;n++)
					{
						tmp.Init(0,0,0);
						VBEFF->setVector(nameLIGHT[n],vb_Pos);
						VBEFF->setVector(nameCOUL[n],tmp);
					}

				tmp.Init(Ambient.r,Ambient.g,Ambient.b);
				VBEFF->setVector("AMBIENT",tmp);
				if (set_alphatest) VBEFF->setFloat("ALPHA",val_alphatest);

				if ((!ActualVertexBuffer->Grouped)&&(Specular))
				{
					float POW=20.0f;
					if (aT>=0)
                    if (iTexture[aT])
						if (iTexture[aT]->Material) POW = (float) iTexture[aT]->Material->power;
					VBEFF->setFloat("POWER",POW);
				}

			}

			// MULTITEXTURE
			///////////////////////////////////////////////////////////////////////////////////////////////////////////

			if ((ActualVertexBuffer->TypeVB==4)||(ActualVertexBuffer->TypeVB==6))
			{
				if (set_alphatest)
				{
					if ((LevelTexture0==0)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi00_at;
					if ((LevelTexture0==1)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi10_at;
					if ((LevelTexture0==0)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi01_at;
					if ((LevelTexture0==1)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi11_at;
				}
				else
				{
					if ((LevelTexture0==0)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi00;
					if ((LevelTexture0==1)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi10;
					if ((LevelTexture0==0)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi01;
					if ((LevelTexture0==1)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi11;
				}

				SetBUILTINVertexBuffer(VBEFF);

				if (!ActualVertexBuffer->Grouped)
				{
					if (lT<0) VBEFF->setTexture("Tex1",aT); else VBEFF->setLightmap("Tex1",lT);
					if (lT<0) VBEFF->setTexture("Tex2",aT2); else VBEFF->setLightmap("Tex2",lT2);
				}

				VBEFF->setMatrixWorldViewProj("MODEL");
				if (set_alphatest) VBEFF->setFloat("ALPHA",val_alphatest);
			}
		}
	}

	int changeblend=PreviousBlend;
	int state_blending=states(BLENDING);
	int state_culling=states(CULLING);

	// SHADERS EXEC
	PreviousRS.ZBuffer=PreviousRS.ZBufferWrite=_UNDEFINED;

	if (!ActualVertexBuffer->Grouped)
	{
		if ((ActualVertexBuffer->Type&API3D_VERTEXPROGRAM)||(ActualEffect)||(VBEFF))
		{
			CVertexBuffer *vb=ActualVertexBuffer;
			CVertexBuffer *vbeff;

			if (ActualEffect) vbeff=ActualEffect;
			else vbeff=ActualVertexBuffer;

			if (VBEFF) vbeff=VBEFF;

			int type=ActualVertexBuffer->Type;

			if ((vbeff->vp->shadermodel)&&(vb->nIndicesActif>0))
			{
				int npass=vbeff->vp->get_pass_count();

				for (int p=0;p<npass;p++)
				{
					if (vbdraw_line) MTLDrawPrimitivesLines(vb,vbeff);
					else MTLDrawPrimitives(vb,vbeff);
				}

				vbeff->modifparams=false;
			}
		}
	}
	else
	{
		// GROUPED

		if ((ActualVertexBuffer->Type&API3D_VERTEXPROGRAM)||(ActualEffect)||(VBEFF))
		{

			CVertexBuffer *vb=ActualVertexBuffer;	
			CVertexBuffer *vbeff;

			if (ActualEffect) vbeff=ActualEffect;
			else vbeff=ActualVertexBuffer;

			if (VBEFF) vbeff=VBEFF;

			int type=ActualVertexBuffer->Type;
			int ra,rb;

			switch (states(ALPHA_MULTI_GROUP_DRAW))
			{
			case 0:
				ra=0;rb=0;
				break;
			case 1:
				ra=0;rb=2;
				break;
			case 2:
				ra=1;rb=2;
				break;
			};

			int texture_stage0=aT;
			int texture_stage1=aT2;
            
			if ((vbeff->vp->shadermodel)&&(vb->nIndicesActif>0))
			{
				//////////////////////////////////////////////////////////////////////////////////////////////////////////// SHADERMODEL
				int npass=vbeff->vp->get_pass_count();

				for (int p=0;p<npass;p++)
				{
					ntmax=0;

					bool draw=true;

					if ((ra==0)&&(!ActualVertexBuffer->HasRef)) ra=rb=0;
					PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
                    
					for (ref_value=ra;ref_value<=rb;ref_value++)
					{
						if (state_blending<3)
						{
                            if (ref_value==0)
                            {
                                MTLSetAlphaBlending(false,0,0);
                                PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
                            }
                            else
                            if (ref_value==1)
                            {
								MTLSetAlphaBlending(true,METAL_SRC_ALPHA,METAL_ONE_MINUS_SRC_ALPHA);
                                PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
                            }
                            else
							if (ref_value==2)
							{
								MTLSetAlphaBlending(true,METAL_ONE,METAL_ONE);
								PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
							}
						}

						nfo=ActualVertexBuffer->ListeSE.GetFirst();
						while (nfo)
						{
							if ((nfo->ref==ref_value)&&(nfo->flag==valueflag))
							{
								if (ActualVertexBuffer->TypeVB==9)
								{
									draw=true;
									if (fn_stage_draw) 
										if (fn_stage_draw(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)==0) draw=false;

									if (states(RENDER_TARGET_OPTIONS)!=STENCIL)
									{
										if (draw)
										{
											if (fn_stage0) vbeff->setLightmap("lightmap",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setLightmap("lightmap",nfo->nL);
								
											if (fn_stage1) vbeff->setTexture("tex",fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setTexture("tex",nfo->nT+Decal_nt);
								
											if (fn_stage2) vbeff->setLightmap("vectors",fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setLightmap("vectors",nfo->nLV);

											if (fn_stage3) vbeff->setTexture("bump",fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setTexture("bump",nfo->nT+bumpmap_settexture);

											if (fn_stage4) vbeff->setTexture("displace",fn_stage4(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setTexture("displace",nfo->nT+bump_displace);

											if (fn_stage5) vbeff->setTexture("horizon",fn_stage5(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setTexture("horizon",nfo->nT+bump_horizon);
										}
									}
								}
								else
								if (ActualVertexBuffer->TypeVB==7)
								{
									draw=true;
									if (fn_stage_draw) 
										if (fn_stage_draw(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)==0) draw=false;

									if (states(RENDER_TARGET_OPTIONS)!=STENCIL)
									{
										if (draw)
										{	
											if (fn_stage0) vbeff->setLightmap("lightmap",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setLightmap("lightmap",nfo->nL);
								
											if (fn_stage1) vbeff->setTexture("tex",fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setTexture("tex",nfo->nT+Decal_nt);
								
											if (fn_stage2) vbeff->setLightmap("vectors",fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setLightmap("vectors",nfo->nLV);

											if (fn_stage3) vbeff->setTexture("bump",fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setTexture("bump",nfo->nT+bumpmap_settexture);
										}
									}
								}
								else
								if (TNL)
								{
									vbeff->setTexture("Tex",nfo->nT+Decal_nt);
									if (Specular)
									{
										float POW=20.0f;
                                        if (iTexture[nfo->nT])
										if (iTexture[nfo->nT]->Material) POW = (float) iTexture[nfo->nT]->Material->power;
										vbeff->setFloat("POWER",POW);
									}
								}
								else
								if ((ActualVertexBuffer->TypeVB==4)||(ActualVertexBuffer->TypeVB==6)||(ActualVertexBuffer->Type&API3D_ENVMAPPING))
								{
									if (ContextEffect)
									{
										draw=ContextEffect->update(vbeff,nfo->nT,nfo->nT2,nfo->tag);

										if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
										if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0], aT);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1], aT2);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2], aT3);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3], aT4);

										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4], aT5);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5], aT6);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6], aT7);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7], aT8);
									}
									else MultiTextureShaders(nfo,vbeff);
								}
								else
								{
									if (ContextEffect)
									{
										draw=ContextEffect->update(vbeff,nfo->nT,nfo->nT2,nfo->tag);

										DrawVertexBufferSetupSizeDest(vbeff,nfo);
                                        
                                        vbeff->modiftextures=true;
                                        
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) if (nfo->nL>=0) vbeff->res[TEXTURE_FROM_NL]->tex=Lightmap[nfo->nL];
                                        
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) if (nfo->nLV>=0) vbeff->res[TEXTURE_FROM_NLVECTORS]->tex=Lightmap[nfo->nLV];
                                        
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) if (aT>=0) vbeff->res[TEXTURE_FROM_RENDER_0]->tex=Texture[aT]; else vbeff->res[TEXTURE_FROM_RENDER_0]->tex=aT;
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) if (aT2>=0) vbeff->res[TEXTURE_FROM_RENDER_1]->tex=Texture[aT2]; else vbeff->res[TEXTURE_FROM_RENDER_1]->tex=aT2;
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) if (aT3>=0) vbeff->res[TEXTURE_FROM_RENDER_2]->tex=Texture[aT3]; else vbeff->res[TEXTURE_FROM_RENDER_2]->tex=aT3;
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) if (aT4>=0) vbeff->res[TEXTURE_FROM_RENDER_3]->tex=Texture[aT4]; else vbeff->res[TEXTURE_FROM_RENDER_3]->tex=aT4;
                                        
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4]) if (aT5>=0) vbeff->res[TEXTURE_FROM_RENDER_4]->tex=Texture[aT5]; else vbeff->res[TEXTURE_FROM_RENDER_4]->tex=aT5;
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5]) if (aT6>=0) vbeff->res[TEXTURE_FROM_RENDER_5]->tex=Texture[aT6]; else vbeff->res[TEXTURE_FROM_RENDER_5]->tex=aT6;
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6]) if (aT7>=0) vbeff->res[TEXTURE_FROM_RENDER_6]->tex=Texture[aT7]; else vbeff->res[TEXTURE_FROM_RENDER_6]->tex=aT7;
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7]) if (aT8>=0) vbeff->res[TEXTURE_FROM_RENDER_7]->tex=Texture[aT8]; else vbeff->res[TEXTURE_FROM_RENDER_7]->tex=aT8;
                                        
                                        /*
										if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
										if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);

										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0], aT);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1], aT2);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2], aT3);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3], aT4);

										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4],aT5);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5],aT6);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6], aT7);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7], aT8);
                                         
                                         /**/
                                       
									}
									else
									{
										if (((ActualVertexBuffer->TypeVB==0)||(ActualVertexBuffer->TypeVB==1)||(ActualVertexBuffer->TypeVB==3))&&(VBEFF))
										{
											if (fn_stage0) vbeff->setTexture("Tex",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else
											{
												if ((nfo->nT+Decal_nt>=0)&&(nfo->nT+Decal_nt<NBRE_MAX_TEXTURES))
												if (cTexture[nfo->nT+Decal_nt])
													vbeff->setTexture("Tex",nfo->nT+Decal_nt);
											}
										}
										else
										{
                                            vbeff->modiftextures=true;
                                            
											DrawVertexBufferSetupSizeDest(vbeff,nfo);
                                            
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_NT]) vbeff->res[TEXTURE_FROM_NT]->tex=Texture[nfo->nT+Decal_nt];
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_NTPLUSONE]) vbeff->res[TEXTURE_FROM_NTPLUSONE]->tex=Texture[nfo->nT+Decal_nt+1];
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_NT2]) vbeff->res[TEXTURE_FROM_NT2]->tex=Texture[nfo->nT2];
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_BUMP]) vbeff->res[TEXTURE_FROM_BUMP]->tex=Texture[nfo->nT+bumpmap_settexture];
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE]) vbeff->res[TEXTURE_FROM_BUMPPLUSONE]->tex=Texture[nfo->nT+1+bumpmap_settexture];

                                            if (vbeff->AssignedTexture[TEXTURE_FROM_DISPLACE]) vbeff->res[TEXTURE_FROM_DISPLACE]->tex=Texture[nfo->nT+bump_displace];
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_HORIZON]) vbeff->res[TEXTURE_FROM_HORIZON]->tex=Texture[nfo->nT+bump_horizon];

                                            if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) if (nfo->nL>=0) vbeff->res[TEXTURE_FROM_NL]->tex=Lightmap[nfo->nL];
                                            
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) if (nfo->nLV>=0) vbeff->res[TEXTURE_FROM_NLVECTORS]->tex=Lightmap[nfo->nLV];
                                            
                                            
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) if (aT>=0) vbeff->res[TEXTURE_FROM_RENDER_0]->tex=Texture[aT]; else vbeff->res[TEXTURE_FROM_RENDER_0]->tex=aT;
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) if (aT2>=0) vbeff->res[TEXTURE_FROM_RENDER_1]->tex=Texture[aT2]; else vbeff->res[TEXTURE_FROM_RENDER_1]->tex=aT2;
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) if (aT3>=0) vbeff->res[TEXTURE_FROM_RENDER_2]->tex=Texture[aT3]; else vbeff->res[TEXTURE_FROM_RENDER_2]->tex=aT3;
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) if (aT4>=0) vbeff->res[TEXTURE_FROM_RENDER_3]->tex=Texture[aT4]; else vbeff->res[TEXTURE_FROM_RENDER_3]->tex=aT4;
                                            
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4]) if (aT5>=0) vbeff->res[TEXTURE_FROM_RENDER_4]->tex=Texture[aT5]; else vbeff->res[TEXTURE_FROM_RENDER_4]->tex=aT5;
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5]) if (aT6>=0) vbeff->res[TEXTURE_FROM_RENDER_5]->tex=Texture[aT6]; else vbeff->res[TEXTURE_FROM_RENDER_5]->tex=aT6;
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6]) if (aT7>=0) vbeff->res[TEXTURE_FROM_RENDER_6]->tex=Texture[aT7]; else vbeff->res[TEXTURE_FROM_RENDER_6]->tex=aT7;
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7]) if (aT8>=0) vbeff->res[TEXTURE_FROM_RENDER_7]->tex=Texture[aT8]; else vbeff->res[TEXTURE_FROM_RENDER_7]->tex=aT8;
                                            
                                            
                                            /*
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_NT]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_NT],nfo->nT+Decal_nt);
											if (vbeff->AssignedTexture[TEXTURE_FROM_NT2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_NT2],nfo->nT2);
											if (vbeff->AssignedTexture[TEXTURE_FROM_BUMP]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_BUMP],nfo->nT+bumpmap_settexture);
 
                                            
											if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
											if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);

											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0],aT);
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1],aT2);
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2], aT3);
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3], aT4);

											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4],aT5);
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5],aT6);
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6], aT7);
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7], aT8);
                                             /**/
										}
									}
								}

								if (draw)
								{																	
									if ((nfo->iEnd-nfo->iStart)>0)
									{
										if (nfo->strip==0) MTLDrawPrimitivesRangePass(p,vb,nfo->vStart,nfo->vEnd,nfo->iStart,nfo->iEnd,vbeff);
                                        else MTLDrawPrimitivesRangePassStrip(p,vb,nfo->vStart,nfo->vEnd,nfo->iStart,nfo->iEnd,vbeff);
									}
								}
							}
							
							nfo=ActualVertexBuffer->ListeSE.GetNext();
						}
					}

                    vbeff->modifparams=false;
				}
			}
		}
	}

	if (MachineState==0)
	{
		SetParams(API3D_CULL,ON);
		if (state_culling==1) SetParams(API3D_CULL,CCW);
		else SetParams(API3D_CULL,CW);
	}

	if ((MachineState==0)||(PreviousBlend!=changeblend))
	{
		PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
		*states[BLENDING]=-1;

		switch (state_blending)
		{
		case 0:
			SetParams(API3D_BLEND,OFF);
			break;
		case 1:
			SetParams(API3D_BLEND,ON);
			break;
		case 2:
			SetParams(API3D_BLEND,BLEND_GOURAUD);
			break;
		case 3:
			SetParams(API3D_BLEND,BLEND_INVERSE);
			break;
		case 4:
			SetParams(API3D_BLEND,BLEND_COLOR);
			break;
		case 5:
			SetParams(API3D_BLEND,BLEND_ADD);
			break;
		};
	}

	return;

#endif

#ifdef API3D_OPENGL20
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// OPENGL 2.0
	if (ActualVertexBuffer->vbo)
	{
		glBindBufferARB(GL_ARRAY_BUFFER,ActualVertexBuffer->VB);
		glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER,ActualVertexBuffer->IB);
	}

	int n;
	CVertexBuffer * VBEFF=NULL;
	bool TNL=false;

	if (((!(ActualVertexBuffer->Type&API3D_VERTEXPROGRAM))&&(!ActualEffect))&&(!vbdraw_line))
	{
		if (ActualVertexBuffer->TypeVB==9)
		{
			if (states(RENDER_TARGET_OPTIONS)==STENCIL)
			{
				VBEFF=&effect_hll_bump_mapping_displacement_s;
				SetBUILTINVertexBuffer(VBEFF);
			}
			else
			{
				VBEFF=&effect_hll_bump_mapping_displacement;
				SetBUILTINVertexBuffer(VBEFF);

				CVector vect;
				if ((ActualVertexBuffer->Lights[0]>=0)&&(ActualVertexBuffer->Lights[0]<nLights)) VBEFF->setVector("vecLight1",Lights[ActualVertexBuffer->Lights[0]].Pos);
				if ((ActualVertexBuffer->Lights[1]>=0)&&(ActualVertexBuffer->Lights[1]<nLights)) VBEFF->setVector("vecLight2",Lights[ActualVertexBuffer->Lights[1]].Pos);
				if ((ActualVertexBuffer->Lights[2]>=0)&&(ActualVertexBuffer->Lights[2]<nLights)) VBEFF->setVector("vecLight3",Lights[ActualVertexBuffer->Lights[2]].Pos);
					
				if ((ActualVertexBuffer->Lights[0]>=0)&&(ActualVertexBuffer->Lights[0]<nLights)) vect.x=Lights[ActualVertexBuffer->Lights[0]].variation; else vect.x=0.0f;
				vect.y=vect.z=vect.x;
				VBEFF->setVector("vecVar1",vect);
				if ((ActualVertexBuffer->Lights[1]>=0)&&(ActualVertexBuffer->Lights[1]<nLights)) vect.x=Lights[ActualVertexBuffer->Lights[1]].variation; else vect.x=0.0f;
				vect.y=vect.z=vect.x;
				VBEFF->setVector("vecVar2",vect);
				if ((ActualVertexBuffer->Lights[2]>=0)&&(ActualVertexBuffer->Lights[2]<nLights)) vect.x=Lights[ActualVertexBuffer->Lights[2]].variation; else vect.x=0.0f;
				vect.y=vect.z=vect.x;
				VBEFF->setVector("vecVar3",vect);
			}

			VBEFF->setMatrixWorld("WORLD");
			VBEFF->setMatrixViewProj("VIEWPROJ");

			CMatrix M;
			M.Inverse4x4(VIEW);

			CVector v;
            v.Init( M.a[3][0],M.a[3][1],M.a[3][2] );

			VBEFF->setVector("Eye",v);
		}
		else
		if (ActualVertexBuffer->TypeVB==7)
		{
			if (states(RENDER_TARGET_OPTIONS)==STENCIL)
			{
				VBEFF=&effect_hll_bump_mapping_s;
				SetBUILTINVertexBuffer(VBEFF);
			}
			else
			{
				if (states(SPECIAL_ANIMATED))
				{
					VBEFF=&effect_hll_bump_mapping_anim;
					SetBUILTINVertexBuffer(VBEFF);

					CVector vect;
					VBEFF->setVector("vecLight1",Lights[ActualVertexBuffer->Lights[0]].Pos);
					VBEFF->setVector("vecLight2",Lights[ActualVertexBuffer->Lights[1]].Pos);
					VBEFF->setVector("vecLight3",Lights[ActualVertexBuffer->Lights[2]].Pos);
					
					vect.x=Lights[ActualVertexBuffer->Lights[0]].variation;
					vect.y=vect.z=vect.x;
					VBEFF->setVector("vecVar1",vect);
					vect.x=Lights[ActualVertexBuffer->Lights[1]].variation;
					vect.y=vect.z=vect.x;
					VBEFF->setVector("vecVar2",vect);
					vect.x=Lights[ActualVertexBuffer->Lights[2]].variation;
					vect.y=vect.z=vect.x;
					VBEFF->setVector("vecVar3",vect);
				}
				else
				{
					VBEFF=&effect_hll_bump_mapping;
					SetBUILTINVertexBuffer(VBEFF);
				}
			}
			VBEFF->setMatrixWorld("WORLD");
			VBEFF->setMatrixViewProj("VIEWPROJ");
		}
		else
		if (ActualVertexBuffer->Type&API3D_ENVMAPPING)
		{
			int tagmorph=0;

			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				tagmorph=1;
				if (states(SHADERS)==1) VBEFF=&effect_hll_envmap2_morph;
				else VBEFF=&effect_hll_envmap1_morph;
			}
			else
			{
                if (states(SHADERS)==1) VBEFF=&effect_hll_envmap2;
                else VBEFF=&effect_hll_envmap1;
			}

			SetBUILTINVertexBuffer(VBEFF);

			CMatrix M;
			M.Inverse4x4(VIEW);

			CVector v;
			v.Init( M.a[3][0],M.a[3][1],M.a[3][2] );

			CVector u,u2,pz;
			pz.Init(0,0,0);

			u.Init(WORLD.a[3][0] - ActualVertexBuffer->L.x,WORLD.a[3][1] - ActualVertexBuffer->L.y,WORLD.a[3][2] - ActualVertexBuffer->L.z);
			u.Normalise();
			u2.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);
			CVector ldir,ldir2;

			if (states(SHADERS)==1)
			{
				n=GetCloserLight(this,u2);
				if (n>=0)
				{
					u2=u2-Lights[n].Pos;
					u2.Normalise();
				}
				else
				{
					u2.Init(0,0,0);
				}
				ldir.x=u2.x;
				ldir.y=u2.y;
				ldir.z=u2.z;
				
				u2.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);

				n=GetSecondCloserLight(this,n,u2);
				if (n>=0)
				{
					u2=u2-Lights[n].Pos;
					u2.Normalise();
				}
				else
				{
					u2.Init(0,0,0);
				}
				ldir2.x=u2.x;
				ldir2.y=u2.y;
				ldir2.z=u2.z;
			}
			else
			{
				ldir.x=u.x;
				ldir.y=u.y;
				ldir.z=u.z;
			}
			
			ActualVertexBuffer->Ldir=-1*u;

			CMatrix ML;
			ML.Id();
			ML.View(pz,-1*u,0);
	
			if (tagmorph) VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);

			VBEFF->setMatrix("MATLIGHT", ML);
			VBEFF->setMatrixWorld("WORLD");
			VBEFF->setMatrixViewProj("VIEWPROJ");
			VBEFF->setVector("VECLIGHT", ldir);
			VBEFF->setVector("CAMERA", v);

			if (states(SHADERS)==1)
			{
				CVector tmp;
				tmp.Init(Ambient.r,Ambient.g,Ambient.b);
				VBEFF->setVector("AMBIENT",tmp);
				VBEFF->setVector("VECLIGHT2", ldir2);
			}
	
			if (!ActualVertexBuffer->Grouped)
			{
                if (states(ENV_SHADERS)!=0)
                {
                    VBEFF->setTexture("Tex",aT2);
                    VBEFF->setTexture("Env",aT);
                }
                else
                {
                    VBEFF->setTexture("Tex",aT);
                    VBEFF->setTexture("Env",aT2);
                }
			}
			else if (states(ENV_SHADERS)!=0) VBEFF->setTexture("Env",aT);
            
            if (states(ENV_SHADERS)!=0)
            {
                if (aT<0) VBEFF->setVector("FactorMap",CVector(1,-1,0));
                else VBEFF->setVector("FactorMap",CVector(1,1,0));
            }
            else
            {
                if (aT2<0) VBEFF->setVector("FactorMap",CVector(1,-1,0));
                else VBEFF->setVector("FactorMap",CVector(1,1,0));
            }
		}

		if (ActualVertexBuffer->Type&API3D_EDGESDG)
		{
			int tagtmp=0;
			int tagmorph=0;

			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				tagmorph=1;
				if (states(ALGO_STENCIL_SHADOWING)!=ALGO_ALTERNATIVE) VBEFF=&effect_hll_stencil_simple_morph;
				else { VBEFF=&effect_hll_stencil_alternative_morph; tagtmp=1; }				
			}
			else
			{
				if (states(ALGO_STENCIL_SHADOWING)!=ALGO_ALTERNATIVE) VBEFF=&effect_hll_stencil_simple;
				else { VBEFF=&effect_hll_stencil_alternative; tagtmp=1; }
			}

			SetBUILTINVertexBuffer(VBEFF);

			float znear=Front+0.1f;
			CMatrix Mplane;
			CPlane plane;
			CMatrix M;
			CVector view;
			CVector camera;
			CVector4 v4light,v1,v2;
			CVector tmp;
			CVector light;

			light=Lights[ActualVertexBuffer->iValue1].Pos;

			if (tagtmp) 
			{
				v4light.Init(light);
				M.Inverse4x4(VIEW);
				camera.Init(M.a[3][0],M.a[3][1],M.a[3][2]);
				view.Init(M.a[2][0],M.a[2][1],M.a[2][2]);
				view.Normalise();
				camera=camera + znear * view;
				plane.a=view.x; plane.b=view.y; plane.c=view.z; plane.d=-(view||camera);
	
				if (plane.Distance(light)<0) { plane.a=-view.x; plane.b=-view.y; plane.c=-view.z; plane.d=(view||camera); }

				Mplane.Id();
				Mplane.ShadowProjection(v4light,plane);
			}

			tmp.Init(ActualVertexBuffer->fValue1,0.0f,znear);

			VBEFF->setVector("VAR",tmp);
			VBEFF->setPoint("Light",light);
			VBEFF->setMatrixViewProj("VIEWPROJ");
			if (tagtmp) VBEFF->setMatrix("PROJNEARPLANE",Mplane);
			if (tagtmp) VBEFF->setMatrix("VIEW",VIEW);
			VBEFF->setMatrix("WORLD",WORLD);
			if (tagmorph) VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
			
			SetParams(API3D_RENDERTARGET,STENCIL);
			SetParams(API3D_ZBUFFER,ON);
			SetParams(API3D_ZBUFFER,WRITEOFF);
			SetParams(API3D_CULL,OFF);
				
			glStencilMaskSeparate(GL_FRONT_AND_BACK,0xff);
			glStencilFuncSeparate(GL_FRONT_AND_BACK,GL_ALWAYS,1,0xff);

			if (states(ALGO_STENCIL_SHADOWING)==ALGO_REVERSE)
			{
				if (states(ZBUFFER_TEST_STENCIL)==0)
				{
					glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_INCR_WRAP,GL_KEEP);
					glStencilOpSeparate(GL_BACK,GL_KEEP,GL_DECR_WRAP,GL_KEEP);
				}
				else
				{
					glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_INCR_WRAP,GL_REPLACE);
					glStencilOpSeparate(GL_BACK,GL_KEEP,GL_DECR_WRAP,GL_REPLACE);
				}
			}
			else
			{
				if (states(ZBUFFER_TEST_STENCIL)==0)
				{
					glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_KEEP,GL_INCR_WRAP);
					glStencilOpSeparate(GL_BACK,GL_KEEP,GL_KEEP,GL_DECR_WRAP);
				}
				else
				{
					glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_REPLACE,GL_INCR_WRAP);
					glStencilOpSeparate(GL_BACK,GL_KEEP,GL_REPLACE,GL_DECR_WRAP);
				}
			}
		}
		else
		{
			// COLOR
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			if (ActualVertexBuffer->TypeVB==2)
			{
				VBEFF=&effect_hll_diffuse_nomap;
				SetBUILTINVertexBuffer(VBEFF);
				VBEFF->setMatrixWorldViewProj("MODEL");
			}

			// COLORTEX
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			if ((ActualVertexBuffer->TypeVB==0)||(ActualVertexBuffer->TypeVB==1)||(ActualVertexBuffer->TypeVB==3))  
			{
				if (set_alphatest) VBEFF=&effect_hll_diffuse_alphatest; else VBEFF=&effect_hll_diffuse;
				SetBUILTINVertexBuffer(VBEFF);

				if (!ActualVertexBuffer->Grouped) VBEFF->setTexture("Tex",aT);
				
				VBEFF->setMatrixWorld("WORLD");
				VBEFF->setMatrixViewProj("VIEWPROJ");
			}

			// TNL
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			if ((ActualVertexBuffer->TypeVB==5)&&((ActualVertexBuffer->Type&API3D_ENVMAPPING)==0))
			{
				if (!Lighting) return;
				TNL=true;
				if (Specular)
				{
					CMatrix M;
					CVector camera;
					M.Inverse4x4(VIEW);
					camera.Init(M.a[3][0],M.a[3][1],M.a[3][2]);

					if (ActualVertexBuffer->Type&API3D_MORPH)
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_specular_morph_alphatest;
						else VBEFF=&effect_hll_TNL_specular_morph;
						SetBUILTINVertexBuffer(VBEFF);

						VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
					}
					else
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_specular_alphatest;
						else VBEFF=&effect_hll_TNL_specular;
						SetBUILTINVertexBuffer(VBEFF);
					}
					VBEFF->setVector("CAMERA",camera);
				}
				else
				{
					if (ActualVertexBuffer->Type&API3D_MORPH)
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_morph_alphatest;
						else VBEFF=&effect_hll_TNL_morph;
						SetBUILTINVertexBuffer(VBEFF);
						VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
					}
					else
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_alphatest;
						else VBEFF=&effect_hll_TNL;
						SetBUILTINVertexBuffer(VBEFF);
					}
				}

				VBEFF->setMatrixWorld("WORLD");
				VBEFF->setMatrixViewProj("VIEWPROJ");
				if (!ActualVertexBuffer->Grouped) VBEFF->setTexture("Tex",aT);

				CVector u,vb_Pos,vv;
				int numLights[64];
				float rLights[64];
				int nbreLights;
				int n1,n2;

				vb_Pos.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);
			
				nbreLights=0;
				for (n=0;n<1024;n++)
				{
					if (Lights[n].enabled==1)
					{
						if (nbreLights<64)
						{
							if (Lights[n].directionnal)
							{
								u=Lights[n].Pos;
								rLights[nbreLights]=VECTORNORM(u);
								numLights[nbreLights]=n;
								nbreLights++;
							}
							else
							{
								VECTORSUB(u,Lights[n].Pos,vb_Pos);
								rLights[nbreLights]=VECTORNORM(u);
								numLights[nbreLights]=n;
								nbreLights++;
							}
						}
					}
				}

				for (n1=0;n1<nbreLights;n1++)
					for (n2=n1+1;n2<nbreLights;n2++)
					{
						if (rLights[n2]<rLights[n1])
						{
							float r=rLights[n2];
							rLights[n2]=rLights[n1];
							rLights[n1]=r;
							int num=numLights[n2];
							numLights[n2]=numLights[n1];
							numLights[n1]=num;
						}
					}

				if (nbreLights>8) nbreLights=8;

				static char * nameLIGHT[8]={ "LIGHT1","LIGHT2","LIGHT3","LIGHT4","LIGHT5","LIGHT6","LIGHT7","LIGHT8" };
				static char * nameCOUL[8]={ "COUL1","COUL2","COUL3","COUL4","COUL5","COUL6","COUL7","COUL8" };

				CVector tmp;

				for (n=0;n<nbreLights;n++)
				{
					int nl=numLights[n];
					tmp.Init(Lights[nl].r,Lights[nl].g,Lights[nl].b);
					if (Lights[nl].directionnal)
					{
						vv=vb_Pos - 100.0f*Lights[nl].Pos;
						VBEFF->setVector(nameLIGHT[n],vv);
					}
					else VBEFF->setVector(nameLIGHT[n],Lights[nl].Pos);
					VBEFF->setPoint(nameCOUL[n],tmp);
				}

				if (nbreLights<8)
					for (n=nbreLights;n<8;n++)
					{
						tmp.Init(0,0,0);
						VBEFF->setVector(nameLIGHT[n],vb_Pos);
						VBEFF->setVector(nameCOUL[n],tmp);
					}

				tmp.Init(Ambient.r,Ambient.g,Ambient.b);
				VBEFF->setVector("AMBIENT",tmp);
				if (set_alphatest) VBEFF->setFloat("ALPHA",val_alphatest);

				if ((!ActualVertexBuffer->Grouped)&&(Specular))
				{
					float POW=20.0f;
					if (aT>=0)
                    if (iTexture[aT])
						if (iTexture[aT]->Material) POW = (float) iTexture[aT]->Material->power;
					VBEFF->setFloat("POWER",POW);
				}

			}

			// MULTITEXTURE
			///////////////////////////////////////////////////////////////////////////////////////////////////////////

			if ((ActualVertexBuffer->TypeVB==4)||(ActualVertexBuffer->TypeVB==6))
			{
				if (set_alphatest)
				{
					if ((LevelTexture0==GL_MODULATE)&&(LevelTexture1==GL_MODULATE)) VBEFF=&effect_hll_multi00_at;
					if ((LevelTexture0==GL_ADD)&&(LevelTexture1==GL_MODULATE)) VBEFF=&effect_hll_multi10_at;
					if ((LevelTexture0==GL_MODULATE)&&(LevelTexture1==GL_ADD)) VBEFF=&effect_hll_multi01_at;
					if ((LevelTexture0==GL_ADD)&&(LevelTexture1==GL_ADD)) VBEFF=&effect_hll_multi11_at;
				}
				else
				{
					if ((LevelTexture0==GL_MODULATE)&&(LevelTexture1==GL_MODULATE)) VBEFF=&effect_hll_multi00;
					if ((LevelTexture0==GL_ADD)&&(LevelTexture1==GL_MODULATE)) VBEFF=&effect_hll_multi10;
					if ((LevelTexture0==GL_MODULATE)&&(LevelTexture1==GL_ADD)) VBEFF=&effect_hll_multi01;
					if ((LevelTexture0==GL_ADD)&&(LevelTexture1==GL_ADD)) VBEFF=&effect_hll_multi11;
				}

				SetBUILTINVertexBuffer(VBEFF);

				if (!ActualVertexBuffer->Grouped)
				{
					if (lT<0) VBEFF->setTexture("Tex1",aT); else VBEFF->setLightmap("Tex1",lT);
					if (lT<0) VBEFF->setTexture("Tex2",aT2); else VBEFF->setLightmap("Tex2",lT2);
				}

				VBEFF->setMatrixWorldViewProj("MODEL");
				if (set_alphatest) VBEFF->setFloat("ALPHA",val_alphatest);
			}
		}
	}

	int changeblend=PreviousBlend;
	int state_blending=states(BLENDING);
	int state_culling=states(CULLING);

    // GL2GROUPED

	// SHADERS EXEC
	PreviousRS.ZBuffer=PreviousRS.ZBufferWrite=_UNDEFINED;

	if (!ActualVertexBuffer->Grouped)
	{
		if ((ActualVertexBuffer->Type&API3D_VERTEXPROGRAM)||(ActualEffect)||(VBEFF))
		{
			CVertexBuffer *vb=ActualVertexBuffer;
			CVertexBuffer *vbeff;

			if (ActualEffect) vbeff=ActualEffect;
			else vbeff=ActualVertexBuffer;

            if (VBEFF) { vbeff=VBEFF; PreviousEffect=NULL; vbeff->modifparams=1; }

			int type=ActualVertexBuffer->Type;

			if (vbeff->vp->shadermodel)
			{
				int vertex=-666;
				int vertex2=-666;
				int color=-666;
				int normal=-666;
				int normal2=-666;
				int weights=-666;
				int texcoo0=-666;
				int texcoo1=-666;
				int texcoo2=-666;
				int texcoo3=-666;

				int texture_stage0=aT;
				int texture_stage1=aT2;
				ntmax=0;
				int loc;

				int npass=vbeff->vp->get_pass_count();

				for (int p=0;p<npass;p++)
				{
                    if (vbeff!=PreviousEffect)
                    {
                        PreviousEffect=vbeff;
                        
                        glUseProgramObjectARB(vbeff->glslprograms[p]);
                    }
                    else
                    {
                        if (npass>1) glUseProgramObjectARB(vbeff->glslprograms[p]);
                    }

					if (type&API3D_STREAMS)
					{
						if (ActualVertexBuffer->stream1>=0)
						{
							loc=vertex=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams[ActualVertexBuffer->stream1]);
						}
						else
						{
							loc=vertex=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
						}

						if (ActualVertexBuffer->stream2>=0)
						{
							loc=vertex2=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition2");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams[ActualVertexBuffer->stream2]);
						}

					}
					else
					{
						loc=vertex=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition");
						glEnableVertexAttribArrayARB(loc);
						glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
					}


					if ((type&API3D_STREAMS)&&(type&API3D_NORMALDATAS))
					{
						if (ActualVertexBuffer->stream1>=0)
						{
							loc=normal=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams_norms[ActualVertexBuffer->stream1]);
						}
						else
						{
							loc=normal=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Normal_Array);
						}

						if (ActualVertexBuffer->stream2>=0)
						{
							loc=normal2=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal2");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams_norms[ActualVertexBuffer->stream2]);
						}
					}
					else
					if (type&API3D_NORMALDATAS)
					{
						loc=normal=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal");
						glEnableVertexAttribArrayARB(loc);
						glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Normal_Array);
					}

					if ((type&API3D_COLORDATAS)||(type&API3D_COLORDATAS4)||(type&API3D_FOURTEX))
					{
						loc=color=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexColor");
						glEnableVertexAttribArrayARB(loc);
						glVertexAttribPointerARB(loc, 4,GL_FLOAT,GL_FALSE,0,vb->Color_Array);
					}
				
					if (type&API3D_BLENDING)
					{
						loc=weights=glGetAttribLocationARB(vbeff->glslprograms[p], "IWeights");
						
						glEnableVertexAttribArrayARB(loc);
						glVertexAttribPointerARB(loc,4,GL_FLOAT,GL_FALSE,0,vb->WeightsIndices_Array);
					}

					for (n=0;n<4;n++)
					{
						if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
						{
							switch (n)
							{
							case 0:
								loc=texcoo0=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord0");
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
								}
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
								}
								break;
							case 1:
								loc=texcoo1=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord1");
								
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
								}
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
								}
								break;
							case 2:
								loc=texcoo2=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord2");
								
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
								}
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
								}
								break;
							case 3:
								loc=texcoo3=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord3");
								
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
								}

								break;
							};
						}
					}

					int nt=0;
					Env *e=vbeff->vp->listenv.GetFirst();
					while (e)
					{
						if (e->type==TYPE_TEXTURE)
						{
							if (e->loc<0) e->loc=loc=glGetUniformLocationARB(vbeff->glslprograms[p],e->name);
							else loc=e->loc;

							glActiveTextureARB(GL_TEXTURE0_ARB+nt);
							glEnable(GL_TEXTURE_2D);
							glBindTexture(GL_TEXTURE_2D,e->tex);
#if (!defined(ANDROID))&&(!defined(IOS))&&(!defined(WEBASM))
							glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
#ifndef GLES
#ifdef OCULUS
#else
							glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE_ARB,1);
#endif
#endif
#endif
							glUniform1i(loc,nt++);
							if (nt>ntmax) ntmax=nt;
						}
						else
					    if (e->modif)
					    {
							if (e->loc<0) e->loc=loc=glGetUniformLocationARB(vbeff->glslprograms[p],e->name);
							else loc=e->loc;

					        e->modif=false;

                            if (e->type==TYPE_VECTOR) glUniform4f(loc,e->v[0],e->v[1],e->v[2],e->v[3]);
                            else
                            if (e->type==TYPE_MATRIX) glUniformMatrix4fv(loc,1,false,e->m);
                            else
                            if (e->type==TYPE_MATRIXLIST) glUniformMatrix4fv(loc,e->nb+1,false,e->mm);
                            else
                            if (e->type==TYPE_VECTORLIST) glUniform4fv(loc,e->nb+1,e->vv);
						}
						
						e=vbeff->vp->listenv.GetNext();
					}

					if (vbdraw_line)
					{
						glDrawArrays(GL_LINES,0,vb->nVerticesActif);
					}
					else
					{
						glSetRenderState(&vbeff->vp->RenderState[vbeff->vp->selected_tech][p],this);
#if defined(ANDROID)&&!defined(UNSIGNEDSHORTINDICES)
                        if (LIB3D_TYPE_INDEX==GL_UNSIGNED_INT)
                            glDrawElements(GL_TRIANGLES,vb->nIndicesActif,LIB3D_TYPE_INDEX,vb->Index_Array);
                        else
                            glDrawElements(GL_TRIANGLES,vb->nIndicesActif,LIB3D_TYPE_INDEX,vb->Index_Array16);
#else
						glDrawElements(GL_TRIANGLES,vb->nIndicesActif,LIB3D_TYPE_INDEX,vb->Index_Array);
#endif
					}

					if (vertex>=0) glDisableVertexAttribArrayARB(vertex);
					if (vertex2>=0) glDisableVertexAttribArrayARB(vertex2);
					if (normal>=0) glDisableVertexAttribArrayARB(normal);
					if (normal2>=0) glDisableVertexAttribArrayARB(normal2);
					if (color>=0) glDisableVertexAttribArrayARB(color);
					if (weights>=0) glDisableVertexAttribArrayARB(weights);

					if (texcoo0>=0) glDisableVertexAttribArrayARB(texcoo0);
					if (texcoo1>=0) glDisableVertexAttribArrayARB(texcoo1);
					if (texcoo2>=0) glDisableVertexAttribArrayARB(texcoo2);
					if (texcoo3>=0) glDisableVertexAttribArrayARB(texcoo3);
				}

				vbeff->modifparams=false;
/*
				for (n=0;n<ntmax;n++)
				{
					if (n==0)
					{
						SetTexture(texture_stage0);
					}
					else
					if (n==1)
					{
						SetTexture2(texture_stage1);
					}
					else
					{
						glActiveTextureARB(GL_TEXTURE0_ARB+n);
						glDisable(GL_TEXTURE_2D);
					}
				}
/**/
				//glUseProgramObjectARB(0);

			}
		}
	}
	else
	{
		// GROUPED

		if ((ActualVertexBuffer->Type&API3D_VERTEXPROGRAM)||(ActualEffect)||(VBEFF))
		{
			CVertexBuffer *vb=ActualVertexBuffer;	
			CVertexBuffer *vbeff;

			if (ActualEffect) vbeff=ActualEffect;
			else vbeff=ActualVertexBuffer;

            if (VBEFF) { vbeff=VBEFF; PreviousEffect=NULL; vbeff->modifparams=1; }

			int type=ActualVertexBuffer->Type;
			int ra,rb;

			switch (states(ALPHA_MULTI_GROUP_DRAW))
			{
			case 0:
				ra=0;rb=0;
				break;
			case 1:
				ra=0;rb=2;
				break;
			case 2:
				ra=1;rb=2;
				break;
			};

			int texture_stage0=aT;
			int texture_stage1=aT2;
			
			if (vbeff->vp->shadermodel)
			{
				//////////////////////////////////////////////////////////////////////////////////////////////////////////// SHADERMODEL
				int npass=vbeff->vp->get_pass_count();

				for (int p=0;p<npass;p++)
				{
					int vertex=-666;
					int vertex2=-666;
					int color=-666;
					int normal=-666;
					int normal2=-666;
					int weights=-666;
					int texcoo0=-666;
					int texcoo1=-666;
					int texcoo2=-666;
					int texcoo3=-666;
					ntmax=0;
					int loc;
					
                    int reloc=0;
                    
                    if (force_reloc) reloc=1;
                    force_reloc=false;
                    
                    if (vbeff!=PreviousEffect)
                    {
                        if ((PreviousEffect)&&(npass==1))
                            if (PreviousEffect->vp)
                                if (PreviousEffect->vp->vertex[p]>=0)
                                {
                                    if (PreviousEffect->vp->vertex[p]>=0) glDisableVertexAttribArrayARB(PreviousEffect->vp->vertex[p]);
                                    if (PreviousEffect->vp->vertex2[p]>=0) glDisableVertexAttribArrayARB(PreviousEffect->vp->vertex2[p]);
                                    if (PreviousEffect->vp->normal[p]>=0) glDisableVertexAttribArrayARB(PreviousEffect->vp->normal[p]);
                                    if (PreviousEffect->vp->normal2[p]>=0) glDisableVertexAttribArrayARB(PreviousEffect->vp->normal2[p]);
                                    if (PreviousEffect->vp->color[p]>=0) glDisableVertexAttribArrayARB(PreviousEffect->vp->color[p]);
                                    if (PreviousEffect->vp->weights[p]>=0) glDisableVertexAttribArrayARB(PreviousEffect->vp->weights[p]);
                                    
                                    if (PreviousEffect->vp->texcoo0[p]>=0) glDisableVertexAttribArrayARB(PreviousEffect->vp->texcoo0[p]);
                                    if (PreviousEffect->vp->texcoo1[p]>=0) glDisableVertexAttribArrayARB(PreviousEffect->vp->texcoo1[p]);
                                    if (PreviousEffect->vp->texcoo2[p]>=0) glDisableVertexAttribArrayARB(PreviousEffect->vp->texcoo2[p]);
                                    if (PreviousEffect->vp->texcoo3[p]>=0) glDisableVertexAttribArrayARB(PreviousEffect->vp->texcoo3[p]);
                                }
                        
                        reloc=1;
                        PreviousEffect=vbeff;
                        
                        glUseProgramObjectARB(vbeff->glslprograms[p]);
                    }
                    else
                    {
                        if (npass>1) glUseProgramObjectARB(vbeff->glslprograms[p]);
                    }

                    if (vbeff->vp->vertex[p]==-666)
                    {
                        if (type&API3D_STREAMS)
                        {
                            if (ActualVertexBuffer->stream1>=0)
                            {
                                vbeff->vp->vertex[p]=loc=vertex=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition");
                                glEnableVertexAttribArrayARB(loc);
                                glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams[ActualVertexBuffer->stream1]);
                            }
                            else
                            {
                                vbeff->vp->vertex[p]=loc=vertex=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition");
                                glEnableVertexAttribArrayARB(loc);
                                glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
                            }
                            
                            if (ActualVertexBuffer->stream2>=0)
                            {
                                vbeff->vp->vertex2[p]=loc=vertex2=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition2");
                                glEnableVertexAttribArrayARB(loc);
                                glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams[ActualVertexBuffer->stream2]);
                            }
                        }
                        else
                        {
                            vbeff->vp->vertex[p]=loc=vertex=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition");
                            glEnableVertexAttribArrayARB(loc);
                            glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
                        }
                        
                        if ((type&API3D_STREAMS)&&(type&API3D_NORMALDATAS))
                        {
                            if (ActualVertexBuffer->stream1>=0)
                            {
                                vbeff->vp->normal[p]=loc=normal=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal");
                                glEnableVertexAttribArrayARB(loc);
                                glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams_norms[ActualVertexBuffer->stream1]);
                            }
                            else
                            {
                                vbeff->vp->normal[p]=loc=normal=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal");
                                glEnableVertexAttribArrayARB(loc);
                                glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Normal_Array);
                            }
                            
                            if (ActualVertexBuffer->stream2>=0)
                            {
                                vbeff->vp->normal2[p]=loc=normal2=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal2");
                                glEnableVertexAttribArrayARB(loc);
                                glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams_norms[ActualVertexBuffer->stream2]);
                            }
                        }
                        else
                            if (type&API3D_NORMALDATAS)
                            {
                                vbeff->vp->normal[p]=loc=normal=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal");
                                if (loc>=0)
                                {
                                    glEnableVertexAttribArrayARB(loc);
                                    glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Normal_Array);
                                }
                            }
                        
                        if ((type&API3D_COLORDATAS)||(type&API3D_COLORDATAS4))
                        {
                            vbeff->vp->color[p]=loc=color=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexColor");
                            glEnableVertexAttribArrayARB(loc);
                            glVertexAttribPointerARB(loc, 4,GL_FLOAT,GL_FALSE,0,vb->Color_Array);
                        }
                        
                        if (type&API3D_BLENDING)
                        {
                            vbeff->vp->weights[p]=loc=weights=glGetAttribLocationARB(vbeff->glslprograms[p], "IWeights");
                            glEnableVertexAttribArrayARB(loc);
                            glVertexAttribPointerARB(loc,4,GL_FLOAT,GL_FALSE,0,vb->WeightsIndices_Array);
                        }
                        
                        for (n=0;n<4;n++)
                        {
                            if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
                            {
                                switch (n)
                                {
                                    case 0:
                                        vbeff->vp->texcoo0[p]=loc=texcoo0=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord0");

                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
                                        }
                                        else
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
                                        }
                                        else
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
                                        }
                                        else
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
                                        }
                                        break;
                                    case 1:
                                        vbeff->vp->texcoo1[p]=loc=texcoo1=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord1");
                                        
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
                                        }
                                        else
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
                                        }
                                        else
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
                                        }
                                        else
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
                                        }
                                        break;
                                    case 2:
                                        vbeff->vp->texcoo2[p]=loc=texcoo2=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord2");
                                        
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
                                        }
                                        else
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
                                        }
                                        else
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
                                        }
                                        else
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
                                        }
                                        break;
                                    case 3:
                                        vbeff->vp->texcoo3[p]=loc=texcoo3=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord3");
                                        
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
                                        }
                                        else
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
                                        }
                                        else
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
                                        }
                                        else
                                        if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
                                        {
                                            glEnableVertexAttribArrayARB(loc);
                                            glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
                                        }
                                        break;
                                };
                            }
                        }
                    }
                    else
                    {
						if (reloc==1)
						{
							// REINIT OF LOC ENABLES

							if (type&API3D_STREAMS)
							{
								if (ActualVertexBuffer->stream1>=0)
								{
									loc=vertex=vbeff->vp->vertex[p];
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams[ActualVertexBuffer->stream1]);
								}
								else
								{
									loc=vertex=vbeff->vp->vertex[p];
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
								}
                            
								if (ActualVertexBuffer->stream2>=0)
								{
									loc=vertex2=vbeff->vp->vertex2[p];
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams[ActualVertexBuffer->stream2]);
								}
							}
							else
							{
								loc=vertex=vbeff->vp->vertex[p];
								glEnableVertexAttribArrayARB(loc);
								glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
							}
                        
							if ((type&API3D_STREAMS)&&(type&API3D_NORMALDATAS))
							{
								if (ActualVertexBuffer->stream1>=0)
								{
									loc=normal=vbeff->vp->normal[p];
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams_norms[ActualVertexBuffer->stream1]);
								}
								else
								{
									loc=normal=vbeff->vp->normal[p];
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Normal_Array);
								}
                            
								if (ActualVertexBuffer->stream2>=0)
								{
									loc=normal2=vbeff->vp->normal2[p];
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams_norms[ActualVertexBuffer->stream2]);
								}
							}
							else
								if (type&API3D_NORMALDATAS)
								{
									loc=normal=vbeff->vp->normal[p];
									if (loc>=0)
									{
										glEnableVertexAttribArrayARB(loc);
										glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Normal_Array);
									}
								}
                        
							if ((type&API3D_COLORDATAS)||(type&API3D_COLORDATAS4))
							{
								loc=color=vbeff->vp->color[p];
								glEnableVertexAttribArrayARB(loc);
								glVertexAttribPointerARB(loc, 4,GL_FLOAT,GL_FALSE,0,vb->Color_Array);
							}
                        
							if (type&API3D_BLENDING)
							{
								loc=weights=vbeff->vp->weights[p];
								glEnableVertexAttribArrayARB(loc);
								glVertexAttribPointerARB(loc,4,GL_FLOAT,GL_FALSE,0,vb->WeightsIndices_Array);
							}

							for (n=0;n<4;n++)
							{
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
								{
									switch (n)
									{
										case 0:
											loc=texcoo0=vbeff->vp->texcoo0[p];
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
											}
											break;
										case 1:
											loc=texcoo1=vbeff->vp->texcoo1[p];
                                        
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
											}
											break;
										case 2:
											loc=texcoo2=vbeff->vp->texcoo2[p];
                                        
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
											}
											break;
										case 3:
											loc=texcoo3=vbeff->vp->texcoo3[p];
                                        
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
											{
												glEnableVertexAttribArrayARB(loc);
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
											}
											break;
									};
								}
							}

						}
						else
						{
							// SAME EFFECT

							if (type&API3D_STREAMS)
							{
								if (ActualVertexBuffer->stream1>=0)
								{
									loc=vertex=vbeff->vp->vertex[p];
									glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams[ActualVertexBuffer->stream1]);
								}
								else
								{
									loc=vertex=vbeff->vp->vertex[p];
									glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
								}
                            
								if (ActualVertexBuffer->stream2>=0)
								{
									loc=vertex2=vbeff->vp->vertex2[p];
									glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams[ActualVertexBuffer->stream2]);
								}
							}
							else
							{
								loc=vertex=vbeff->vp->vertex[p];
								glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
							}
                        
							if ((type&API3D_STREAMS)&&(type&API3D_NORMALDATAS))
							{
								if (ActualVertexBuffer->stream1>=0)
								{
									loc=normal=vbeff->vp->normal[p];
									glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams_norms[ActualVertexBuffer->stream1]);
								}
								else
								{
									loc=normal=vbeff->vp->normal[p];
									glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Normal_Array);
								}
                            
								if (ActualVertexBuffer->stream2>=0)
								{
									loc=normal2=vbeff->vp->normal2[p];
									glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams_norms[ActualVertexBuffer->stream2]);
								}
							}
							else
								if (type&API3D_NORMALDATAS)
								{
									loc=normal=vbeff->vp->normal[p];
									if (loc>=0)
									{
										glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Normal_Array);
									}
								}
                        
							if ((type&API3D_COLORDATAS)||(type&API3D_COLORDATAS4))
							{
								loc=color=vbeff->vp->color[p];
								glVertexAttribPointerARB(loc, 4,GL_FLOAT,GL_FALSE,0,vb->Color_Array);
							}
                        
							if (type&API3D_BLENDING)
							{
								loc=weights=vbeff->vp->weights[p];
								glVertexAttribPointerARB(loc,4,GL_FLOAT,GL_FALSE,0,vb->WeightsIndices_Array);
							}

							for (n=0;n<4;n++)
							{
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
								{
									switch (n)
									{
										case 0:
											loc=texcoo0=vbeff->vp->texcoo0[p];
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
											}
											break;
										case 1:
											loc=texcoo1=vbeff->vp->texcoo1[p];
                                        
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
											}
											break;
										case 2:
											loc=texcoo2=vbeff->vp->texcoo2[p];
                                        
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
											}
											break;
										case 3:
											loc=texcoo3=vbeff->vp->texcoo3[p];
                                        
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
											}
											else
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO3)
											{
												glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo4_Array);
											}
											break;
									};
								}
							}
						}
                    }

                    if (vbeff->modifparams)
                    {
                        Env *e=vbeff->vp->listenv.GetFirst();
                        while (e)
                        {
                            if (e->type!=TYPE_TEXTURE)
                            {
                                if (e->modif)
                                {
		                            if (e->loc<0) e->loc=loc=glGetUniformLocationARB(vbeff->glslprograms[p],e->name);
	                                else loc=e->loc;

                                    e->modif=false;

                                    if (e->type==TYPE_VECTOR) glUniform4f(loc,e->v[0],e->v[1],e->v[2],e->v[3]);
                                    else
                                    if (e->type==TYPE_MATRIX) glUniformMatrix4fv(loc,1,false,e->m);
                                    else
                                    if (e->type==TYPE_MATRIXLIST)
                                    {
                                        glUniformMatrix4fv(loc,e->nb+1,false,e->mm);
                                    }
                                    else
                                    if (e->type==TYPE_VECTORLIST) glUniform4fv(loc,e->nb+1,e->vv);
                                }
                            }
                            e=vbeff->vp->listenv.GetNext();
                        }
                    }

					bool draw=true;

					if ((ra==0)&&(!ActualVertexBuffer->HasRef)) ra=rb=0;
					PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
                    
					for (ref_value=ra;ref_value<=rb;ref_value++)
					{
						if (state_blending<3)
						{
                            if (ref_value==0)
                            {
                                glDisable(GL_BLEND);
                                PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
                            }
                            else
                            if (ref_value==1)
                            {
                                glEnable(GL_BLEND);
                                glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
                                PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
                            }
                            else
							if (ref_value==2)
							{
								glEnable(GL_BLEND);
								glBlendFunc(GL_ONE,GL_ONE);
								PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
							}
						}

						nfo=ActualVertexBuffer->ListeSE.GetFirst();
						while (nfo)
						{
							if ((nfo->ref==ref_value)&&(nfo->flag==valueflag))
							{
								if (ActualVertexBuffer->TypeVB==9)
								{
									draw=true;
									if (fn_stage_draw) 
										if (fn_stage_draw(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)==0) draw=false;

									if (states(RENDER_TARGET_OPTIONS)!=STENCIL)
									{
										if (draw)
										{
											if (fn_stage0) vbeff->setLightmap("lightmap",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setLightmap("lightmap",nfo->nL);
								
											if (fn_stage1) vbeff->setTexture("tex",fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setTexture("tex",nfo->nT+Decal_nt);
								
											if (fn_stage2) vbeff->setLightmap("vectors",fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setLightmap("vectors",nfo->nLV);

											if (fn_stage3) vbeff->setTexture("bump",fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setTexture("bump",nfo->nT+bumpmap_settexture);

											if (fn_stage4) vbeff->setTexture("displace",fn_stage4(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setTexture("displace",nfo->nT+bump_displace);

											if (fn_stage5) vbeff->setTexture("horizon",fn_stage5(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setTexture("horizon",nfo->nT+bump_horizon);
										}
									}
								}
								else
								if (ActualVertexBuffer->TypeVB==7)
								{
									draw=true;
									if (fn_stage_draw) 
										if (fn_stage_draw(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)==0) draw=false;

									if (states(RENDER_TARGET_OPTIONS)!=STENCIL)
									{
										if (draw)
										{	
											if (fn_stage0) vbeff->setLightmap("lightmap",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setLightmap("lightmap",nfo->nL);
								
											if (fn_stage1) vbeff->setTexture("tex",fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setTexture("tex",nfo->nT+Decal_nt);
								
											if (fn_stage2) vbeff->setLightmap("vectors",fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setLightmap("vectors",nfo->nLV);

											if (fn_stage3) vbeff->setTexture("bump",fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else vbeff->setTexture("bump",nfo->nT+bumpmap_settexture);
										}
									}
								}
								else
								if (TNL)
								{
									vbeff->setTexture("Tex",nfo->nT+Decal_nt);
									if (Specular)
									{
										float POW=20.0f;
                                        if (iTexture[nfo->nT])
										if (iTexture[nfo->nT]->Material) POW = (float) iTexture[nfo->nT]->Material->power;
										vbeff->setFloat("POWER",POW);
									}
								}
								else
								if ((ActualVertexBuffer->TypeVB==4)||(ActualVertexBuffer->TypeVB==6)||(ActualVertexBuffer->Type&API3D_ENVMAPPING))
								{
									if (ContextEffect)
									{
										draw=ContextEffect->update(vbeff,nfo->nT,nfo->nT2,nfo->tag);

                                        if (vbeff->modifparams)
                                        {
                                            Env *e=vbeff->vp->listenv.GetFirst();
                                            while (e)
                                            {
                                                if (e->type!=TYPE_TEXTURE)
                                                {
                                                    if (e->modif)
                                                    {
                                                        e->modif=false;

                                                        if (e->loc<0) e->loc=loc=glGetUniformLocationARB(vbeff->glslprograms[p],e->name);
                                                        else loc=e->loc;

                                                        if (e->type==TYPE_VECTOR) glUniform4f(loc,e->v[0],e->v[1],e->v[2],e->v[3]);
                                                        else
                                                        if (e->type==TYPE_MATRIX) glUniformMatrix4fv(loc,1,false,e->m);
                                                        else
                                                        if (e->type==TYPE_MATRIXLIST)
                                                        {
                                                            glUniformMatrix4fv(loc,e->nb+1,false,e->mm);
                                                        }
                                                        else
                                                        if (e->type==TYPE_VECTORLIST) glUniform4fv(loc,e->nb+1,e->vv);
                                                    }
                                                }
                                                e=vbeff->vp->listenv.GetNext();
                                            }
										}

										if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
										if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0], aT);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1], aT2);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2], aT3);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3], aT4);

										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4], aT5);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5], aT6);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6], aT7);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7], aT8);
									}
									else
                                    {
                                        MultiTextureShaders(nfo,vbeff);
                                    }
								}
								else
								{
									if (ContextEffect)
									{
										draw=ContextEffect->update(vbeff,nfo->nT,nfo->nT2,nfo->tag);

										DrawVertexBufferSetupSizeDest(vbeff,nfo);

                                        if (vbeff->modifparams)
                                        {
											Env *e=vbeff->vp->listenv.GetFirst();
											while (e)
											{
												if (e->type!=TYPE_TEXTURE)
												{
													if (e->modif)
													{
														if (e->loc<0) e->loc=loc=glGetUniformLocationARB(vbeff->glslprograms[p],e->name);
														else loc=e->loc;

														e->modif=false;

														if (e->type==TYPE_VECTOR) glUniform4f(loc,e->v[0],e->v[1],e->v[2],e->v[3]);
														else
														if (e->type==TYPE_MATRIX) glUniformMatrix4fv(loc,1,false,e->m);
														else
														if (e->type==TYPE_MATRIXLIST)
														{
															glUniformMatrix4fv(loc,e->nb+1,false,e->mm);
														}
														else
														if (e->type==TYPE_VECTORLIST) glUniform4fv(loc,e->nb+1,e->vv);
													}
												}
												e=vbeff->vp->listenv.GetNext();
											}
										}
                                        /*
										if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
										if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0], aT);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1], aT2);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2], aT3);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3], aT4);
                                        /**/
                                        
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) if (nfo->nL>=0) vbeff->res[TEXTURE_FROM_NL]->tex=Lightmap[nfo->nL];
                                        
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) if (nfo->nLV>=0) vbeff->res[TEXTURE_FROM_NLVECTORS]->tex=Lightmap[nfo->nLV];

#ifdef VR_SCREENPROJ
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) if (aT>=0) vbeff->res[TEXTURE_FROM_RENDER_0]->tex=Texture[aT];
										else if (aT==-666) vbeff->res[TEXTURE_FROM_RENDER_0]->tex=renderedTextureSPVR; else vbeff->res[TEXTURE_FROM_RENDER_0]->tex=renderedTexture[-(aT+1)];

                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) if (aT2>=0) vbeff->res[TEXTURE_FROM_RENDER_1]->tex=Texture[aT2];
										else if (aT2==-666) vbeff->res[TEXTURE_FROM_RENDER_1]->tex=renderedTextureSPVR; else vbeff->res[TEXTURE_FROM_RENDER_1]->tex=renderedTexture[-(aT2+1)];

                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) if (aT3>=0) vbeff->res[TEXTURE_FROM_RENDER_2]->tex=Texture[aT3];
										else if (aT3==-666) vbeff->res[TEXTURE_FROM_RENDER_2]->tex=renderedTextureSPVR; else vbeff->res[TEXTURE_FROM_RENDER_2]->tex=renderedTexture[-(aT3+1)];

                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) if (aT4>=0) vbeff->res[TEXTURE_FROM_RENDER_3]->tex=Texture[aT4];
										else if (aT4==-666) vbeff->res[TEXTURE_FROM_RENDER_3]->tex=renderedTextureSPVR; else vbeff->res[TEXTURE_FROM_RENDER_3]->tex=renderedTexture[-(aT4+1)];
#else
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) if (aT>=0) vbeff->res[TEXTURE_FROM_RENDER_0]->tex=Texture[aT]; else vbeff->res[TEXTURE_FROM_RENDER_0]->tex=renderedTexture[-(aT+1)];
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) if (aT2>=0) vbeff->res[TEXTURE_FROM_RENDER_1]->tex=Texture[aT2]; else vbeff->res[TEXTURE_FROM_RENDER_1]->tex=renderedTexture[-(aT2+1)];
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) if (aT3>=0) vbeff->res[TEXTURE_FROM_RENDER_2]->tex=Texture[aT3]; else vbeff->res[TEXTURE_FROM_RENDER_2]->tex=renderedTexture[-(aT3+1)];
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) if (aT4>=0) vbeff->res[TEXTURE_FROM_RENDER_3]->tex=Texture[aT4]; else vbeff->res[TEXTURE_FROM_RENDER_3]->tex=renderedTexture[-(aT4+1)];
#endif

										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4]) if (aT5>=0) vbeff->res[TEXTURE_FROM_RENDER_4]->tex=Texture[aT5]; else vbeff->res[TEXTURE_FROM_RENDER_4]->tex=renderedTexture[-(aT5+1)];
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5]) if (aT6>=0) vbeff->res[TEXTURE_FROM_RENDER_5]->tex=Texture[aT6]; else vbeff->res[TEXTURE_FROM_RENDER_5]->tex=renderedTexture[-(aT6+1)];
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6]) if (aT7>=0) vbeff->res[TEXTURE_FROM_RENDER_6]->tex=Texture[aT7]; else vbeff->res[TEXTURE_FROM_RENDER_6]->tex=renderedTexture[-(aT7+1)];
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7]) if (aT8>=0) vbeff->res[TEXTURE_FROM_RENDER_7]->tex=Texture[aT8]; else vbeff->res[TEXTURE_FROM_RENDER_7]->tex=renderedTexture[-(aT8+1)];
 
									}
									else
									{
                                        draw=true;
										if (((ActualVertexBuffer->TypeVB==0)||(ActualVertexBuffer->TypeVB==1)||(ActualVertexBuffer->TypeVB==3))&&(VBEFF))
										{
											if (fn_stage0) vbeff->setTexture("Tex",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
											else
											{
												if ((nfo->nT+Decal_nt>=0)&&(nfo->nT+Decal_nt<NBRE_MAX_TEXTURES))
												if (cTexture[nfo->nT+Decal_nt])
													vbeff->setTexture("Tex",nfo->nT+Decal_nt);
											}
										}
										else
										{
											DrawVertexBufferSetupSizeDest(vbeff,nfo);

                                            if (vbeff->modifparams)
                                            {
                                                Env *e=vbeff->vp->listenv.GetFirst();
                                                while (e)
                                                {
                                                    if (e->type!=TYPE_TEXTURE)
                                                    {
                                                        if (e->modif)
                                                        {
		                                                    if (e->loc<0) e->loc=loc=glGetUniformLocationARB(vbeff->glslprograms[p],e->name);
	                                                        else loc=e->loc;

                                                            e->modif=false;

                                                            if (e->type==TYPE_VECTOR) glUniform4f(loc,e->v[0],e->v[1],e->v[2],e->v[3]);
                                                            else
                                                            if (e->type==TYPE_MATRIX) glUniformMatrix4fv(loc,1,false,e->m);
                                                            else
                                                            if (e->type==TYPE_MATRIXLIST)
                                                            {
                                                                glUniformMatrix4fv(loc,e->nb+1,false,e->mm);
                                                            }
                                                            else
                                                            if (e->type==TYPE_VECTORLIST) glUniform4fv(loc,e->nb+1,e->vv);
                                                        }
                                                    }
                                                    e=vbeff->vp->listenv.GetNext();
                                                }
                                            }

                                            if (vbeff->AssignedTexture[TEXTURE_FROM_NT]) vbeff->res[TEXTURE_FROM_NT]->tex=Texture[nfo->nT+Decal_nt];
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_NTPLUSONE]) vbeff->res[TEXTURE_FROM_NTPLUSONE]->tex=Texture[nfo->nT+Decal_nt+1];
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_NT2]) vbeff->res[TEXTURE_FROM_NT2]->tex=Texture[nfo->nT2];
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_BUMP]) vbeff->res[TEXTURE_FROM_BUMP]->tex=Texture[nfo->nT+bumpmap_settexture];
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE]) vbeff->res[TEXTURE_FROM_BUMPPLUSONE]->tex=Texture[nfo->nT+1+bumpmap_settexture];

                                            if (vbeff->AssignedTexture[TEXTURE_FROM_DISPLACE]) vbeff->res[TEXTURE_FROM_DISPLACE]->tex=Texture[nfo->nT+bump_displace];
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_HORIZON]) vbeff->res[TEXTURE_FROM_HORIZON]->tex=Texture[nfo->nT+bump_horizon];

											if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) if (nfo->nL>=0) vbeff->res[TEXTURE_FROM_NL]->tex=Lightmap[nfo->nL];
                                            
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) if (nfo->nLV>=0) vbeff->res[TEXTURE_FROM_NLVECTORS]->tex=Lightmap[nfo->nLV];
                                            
#ifdef VR_SCREENPROJ
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) if (aT>=0) vbeff->res[TEXTURE_FROM_RENDER_0]->tex=Texture[aT];
											else if (aT==-666) vbeff->res[TEXTURE_FROM_RENDER_0]->tex=renderedTextureSPVR; else vbeff->res[TEXTURE_FROM_RENDER_0]->tex=renderedTexture[-(aT+1)];

                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) if (aT2>=0) vbeff->res[TEXTURE_FROM_RENDER_1]->tex=Texture[aT2];
											else if (aT2==-666) vbeff->res[TEXTURE_FROM_RENDER_1]->tex=renderedTextureSPVR; else vbeff->res[TEXTURE_FROM_RENDER_1]->tex=renderedTexture[-(aT2+1)];

                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) if (aT3>=0) vbeff->res[TEXTURE_FROM_RENDER_2]->tex=Texture[aT3];
											else if (aT3==-666) vbeff->res[TEXTURE_FROM_RENDER_2]->tex=renderedTextureSPVR; else vbeff->res[TEXTURE_FROM_RENDER_2]->tex=renderedTexture[-(aT3+1)];

                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) if (aT4>=0) vbeff->res[TEXTURE_FROM_RENDER_3]->tex=Texture[aT4];
											else if (aT4==-666) vbeff->res[TEXTURE_FROM_RENDER_3]->tex=renderedTextureSPVR; else vbeff->res[TEXTURE_FROM_RENDER_3]->tex=renderedTexture[-(aT4+1)];
#else
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) if (aT>=0) vbeff->res[TEXTURE_FROM_RENDER_0]->tex=Texture[aT]; else vbeff->res[TEXTURE_FROM_RENDER_0]->tex=renderedTexture[-(aT+1)];
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) if (aT2>=0) vbeff->res[TEXTURE_FROM_RENDER_1]->tex=Texture[aT2]; else vbeff->res[TEXTURE_FROM_RENDER_1]->tex=renderedTexture[-(aT2+1)];
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) if (aT3>=0) vbeff->res[TEXTURE_FROM_RENDER_2]->tex=Texture[aT3]; else vbeff->res[TEXTURE_FROM_RENDER_2]->tex=renderedTexture[-(aT3+1)];
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) if (aT4>=0) vbeff->res[TEXTURE_FROM_RENDER_3]->tex=Texture[aT4]; else vbeff->res[TEXTURE_FROM_RENDER_3]->tex=renderedTexture[-(aT4+1)];
#endif
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4]) if (aT5>=0) vbeff->res[TEXTURE_FROM_RENDER_4]->tex=Texture[aT5]; else vbeff->res[TEXTURE_FROM_RENDER_4]->tex=renderedTexture[-(aT5+1)];
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5]) if (aT6>=0) vbeff->res[TEXTURE_FROM_RENDER_5]->tex=Texture[aT6]; else vbeff->res[TEXTURE_FROM_RENDER_5]->tex=renderedTexture[-(aT6+1)];
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6]) if (aT7>=0) vbeff->res[TEXTURE_FROM_RENDER_6]->tex=Texture[aT7]; else vbeff->res[TEXTURE_FROM_RENDER_6]->tex=renderedTexture[-(aT7+1)];
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7]) if (aT8>=0) vbeff->res[TEXTURE_FROM_RENDER_7]->tex=Texture[aT8]; else vbeff->res[TEXTURE_FROM_RENDER_7]->tex=renderedTexture[-(aT8+1)];

/*
                                            if (vbeff->AssignedTexture[TEXTURE_FROM_NT]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_NT],nfo->nT+Decal_nt);
											if (vbeff->AssignedTexture[TEXTURE_FROM_NT2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_NT2],nfo->nT2);
											if (vbeff->AssignedTexture[TEXTURE_FROM_BUMP]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_BUMP],nfo->nT+bumpmap_settexture);
 
                                            
											if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
											if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0],aT);
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1],aT2);
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2], aT3);
											if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3], aT4);
 /**/
										}
									}
								}

								if (draw)
								{	
									
									int nt=0;
									Env *e=vbeff->vp->listenv.GetFirst();
									while (e)
									{
										if (e->type==TYPE_TEXTURE)
										{
											int loc;
											if (e->loc<0) e->loc=loc=glGetUniformLocationARB(vbeff->glslprograms[p],e->name);
											else loc=e->loc;

											glActiveTextureARB(GL_TEXTURE0_ARB+nt);
											glEnable(GL_TEXTURE_2D);
											glBindTexture(GL_TEXTURE_2D,e->tex);

//											EFFECT_NT[nt]=e->tex;
//#ifndef ANDROID
//											glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
//#ifndef GLES
//											glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE_ARB,1);
//#endif
//#endif
											glUniform1i(loc,nt++);
//											if (nt>ntmax) ntmax=nt;
										}

                                        if (e->type==TYPE_TEXTUREVS)
                                        {
                                            int loc;
                                            if (e->loc<0) e->loc=loc=glGetUniformLocationARB(vbeff->glslprograms[p],e->name);
                                            else loc=e->loc;

                                            glActiveTextureARB(GL_TEXTURE0_ARB+nt);
                                            glEnable(GL_TEXTURE_2D);
                                            glBindTexture(GL_TEXTURE_2D,e->tex);

                                            glUniform1i(loc,nt++);
                                        }

										e=vbeff->vp->listenv.GetNext();
									}
									
									if ((nfo->iEnd-nfo->iStart)>0)
									{
										glSetRenderState(&vbeff->vp->RenderState[vbeff->vp->selected_tech][p],this);
                                        
#if defined(NOGETPROC)&&!defined(GLESFULL)&&!defined(GLES20)
                                        glDrawRangeElements(GL_TRIANGLES,nfo->vStart,nfo->vEnd,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(vb->Index_Array[nfo->iStart]));
                                        //glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(vb->Index_Array[nfo->iStart]));
#else
#if defined(ANDROID)&&!defined(UNSIGNEDSHORTINDICES)
                                        if (LIB3D_TYPE_INDEX==GL_UNSIGNED_INT)
                                            glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(vb->Index_Array[nfo->iStart]));
                                        else
                                            glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(vb->Index_Array16[nfo->iStart]));
#else
                                        glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(vb->Index_Array[nfo->iStart]));
#endif
#endif
									}
								}
							}
							
							nfo=ActualVertexBuffer->ListeSE.GetNext();
						}
					}

                    vbeff->modifparams=false;
					
					/*
					for (n=0;n<ntmax;n++)
					{
						if (n==0)
						{
							SetTexture(texture_stage0);
						}
						else
						if (n==1)
						{
							SetTexture2(texture_stage1);
						}
						else
						{
							glActiveTextureARB(GL_TEXTURE0_ARB+n);
							glDisable(GL_TEXTURE_2D);
						}
					}
					
					glUseProgramObjectARB(0);
					/**/
                    
                    // DIS
                    if ((type&API3D_STREAMS)||(type&API3D_BLENDING))
                    {
                        force_reloc=true;
                        if (vertex>=0) glDisableVertexAttribArrayARB(vertex);
                        if (vertex2>=0) glDisableVertexAttribArrayARB(vertex2);
                        if (normal>=0) glDisableVertexAttribArrayARB(normal);
                        if (normal2>=0) glDisableVertexAttribArrayARB(normal2);
                        if (color>=0) glDisableVertexAttribArrayARB(color);
                        if (weights>=0) glDisableVertexAttribArrayARB(weights);
                        if (texcoo0>=0) glDisableVertexAttribArrayARB(texcoo0);
                        if (texcoo1>=0) glDisableVertexAttribArrayARB(texcoo1);
                        if (texcoo2>=0) glDisableVertexAttribArrayARB(texcoo2);
                        if (texcoo3>=0) glDisableVertexAttribArrayARB(texcoo3);
                    }
				}
			}
		}
	}

	if (MachineState==0)
	{
		SetParams(API3D_CULL,ON);
		if (state_culling==1) SetParams(API3D_CULL,CCW);
		else SetParams(API3D_CULL,CW);
	}

	if ((MachineState==0)||(PreviousBlend!=changeblend))
	{
		PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
		*states[BLENDING]=-1;

		switch (state_blending)
		{
		case 0:
			SetParams(API3D_BLEND,OFF);
			break;
		case 1:
			SetParams(API3D_BLEND,ON);
			break;
		case 2:
			SetParams(API3D_BLEND,BLEND_GOURAUD);
			break;
		case 3:
			SetParams(API3D_BLEND,BLEND_INVERSE);
			break;
		case 4:
			SetParams(API3D_BLEND,BLEND_COLOR);
			break;
		case 5:
			SetParams(API3D_BLEND,BLEND_ADD);
			break;
		};
	}
	else *states[BLENDING]=-1;

	if (ActualVertexBuffer->vbo)
	{
		glBindBufferARB(GL_ARRAY_BUFFER,0);
		glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER,0);
	}

	return;

#endif

#ifdef API3D_DIRECT3D12
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// DIRECT3D 11
    if ((!SecondarySurface)&&(SelectedRenderTarget!=PRIMARY)) return;

    int n;
    CVertexBuffer * VBEFF=NULL;
    bool TNL=false;

    if (((!(ActualVertexBuffer->Type&API3D_VERTEXPROGRAM))&&(!ActualEffect))&&(!vbdraw_line))
    {
        if (ActualVertexBuffer->TypeVB==9)
        {
            if (states(RENDER_TARGET_OPTIONS)==STENCIL)
            {
                VBEFF=&effect_hll_bump_mapping_displacement_s;
                SetBUILTINVertexBuffer(VBEFF);
            }
            else
            {
                VBEFF=&effect_hll_bump_mapping_displacement;
                SetBUILTINVertexBuffer(VBEFF);

                CVector vect;
                VBEFF->setVector("vecLight1",Lights[ActualVertexBuffer->Lights[0]].Pos);
                VBEFF->setVector("vecLight2",Lights[ActualVertexBuffer->Lights[1]].Pos);
                VBEFF->setVector("vecLight3",Lights[ActualVertexBuffer->Lights[2]].Pos);
                    
                vect.x=Lights[ActualVertexBuffer->Lights[0]].variation;
                vect.y=vect.z=vect.x;
                VBEFF->setVector("vecVar1",vect);
                vect.x=Lights[ActualVertexBuffer->Lights[1]].variation;
                vect.y=vect.z=vect.x;
                VBEFF->setVector("vecVar2",vect);
                vect.x=Lights[ActualVertexBuffer->Lights[2]].variation;
                vect.y=vect.z=vect.x;
                VBEFF->setVector("vecVar3",vect);
            }

            VBEFF->setMatrixWorld("WORLD");
            VBEFF->setMatrixViewProj("VIEWPROJ");
            CMatrix matViewInv;

            matViewInv.Inverse4x4(viewMatrix);

            CVector v;
            v.Init( matViewInv.a[3][0], matViewInv.a[3][1], matViewInv.a[3][2] );

            VBEFF->setVector("Eye",v);
        }
        else
        if (ActualVertexBuffer->TypeVB==7)
        {
            if (states(RENDER_TARGET_OPTIONS)==STENCIL)
            {
                VBEFF=&effect_hll_bump_mapping_s;
                SetBUILTINVertexBuffer(VBEFF);
            }
            else
            {
                if (states(SPECIAL_ANIMATED))
                {
                    VBEFF=&effect_hll_bump_mapping_anim;
                    SetBUILTINVertexBuffer(VBEFF);

                    CVector vect;
                    VBEFF->setVector("vecLight1",Lights[ActualVertexBuffer->Lights[0]].Pos);
                    VBEFF->setVector("vecLight2",Lights[ActualVertexBuffer->Lights[1]].Pos);
                    VBEFF->setVector("vecLight3",Lights[ActualVertexBuffer->Lights[2]].Pos);
                    
                    vect.x=Lights[ActualVertexBuffer->Lights[0]].variation;
                    vect.y=vect.z=vect.x;
                    VBEFF->setVector("vecVar1",vect);
                    vect.x=Lights[ActualVertexBuffer->Lights[1]].variation;
                    vect.y=vect.z=vect.x;
                    VBEFF->setVector("vecVar2",vect);
                    vect.x=Lights[ActualVertexBuffer->Lights[2]].variation;
                    vect.y=vect.z=vect.x;
                    VBEFF->setVector("vecVar3",vect);
                }
                else
                {
                    VBEFF=&effect_hll_bump_mapping;
                    SetBUILTINVertexBuffer(VBEFF);
                }
            }
            VBEFF->setMatrixWorld("WORLD");
            VBEFF->setMatrixViewProj("VIEWPROJ");
        }
        else
        if (ActualVertexBuffer->Type&API3D_ENVMAPPING)
        {
            int tagmorph=0;

            if (ActualVertexBuffer->Type&API3D_MORPH)
            {
                tagmorph=1;
                if (states(SHADERS)==1) VBEFF=&effect_hll_envmap2_morph;
                else VBEFF=&effect_hll_envmap1_morph;
            }
            else
            {
                if (states(SHADERS)==1) VBEFF=&effect_hll_envmap2;
                else VBEFF=&effect_hll_envmap1;
            }

            SetBUILTINVertexBuffer(VBEFF);

            CMatrix matViewInv;
            matViewInv.Inverse4x4(viewMatrix);

            CVector v;
            v.Init( matViewInv.a[3][0], matViewInv.a[3][1], matViewInv.a[3][2] );

            CVector u,u2,pz;
            pz.Init(0,0,0);

            u.Init(worldMatrix.a[3][0] - ActualVertexBuffer->L.x,worldMatrix.a[3][1] - ActualVertexBuffer->L.y,worldMatrix.a[3][2] - ActualVertexBuffer->L.z);
            u.Normalise();
            u2.Init(worldMatrix.a[3][0],worldMatrix.a[3][1],worldMatrix.a[3][2]);
            CVector ldir,ldir2;

            if (states(SHADERS)==1)
            {
                n=GetCloserLight(this,u2);
                if (n>=0)
                {
                    u2=u2-Lights[n].Pos;
                    u2.Normalise();
                }
                else
                {
                    u2.Init(0,0,0);
                }
                ldir.x=u2.x;
                ldir.y=u2.y;
                ldir.z=u2.z;
                
                u2.Init(worldMatrix.a[3][0],worldMatrix.a[3][1],worldMatrix.a[3][2]);
                n=GetSecondCloserLight(this,n,u2);
                if (n>=0)
                {
                    u2=u2-Lights[n].Pos;
                    u2.Normalise();
                }
                else
                {
                    u2.Init(0,0,0);
                }
                ldir2.x=u2.x;
                ldir2.y=u2.y;
                ldir2.z=u2.z;
            }
            else
            {
                ldir.x=u.x;
                ldir.y=u.y;
                ldir.z=u.z;
            }
            
            ActualVertexBuffer->Ldir=-1*u;

            CMatrix M;
            M.Id();
            M.View(pz,-1*u,0);

            if (tagmorph) VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);

            VBEFF->setMatrix("MATLIGHT", M);
            VBEFF->setMatrixWorld("WORLD");
            VBEFF->setMatrixViewProj("VIEWPROJ");
            VBEFF->setVector("VECLIGHT", ldir);
            VBEFF->setVector("CAMERA", v);

            if (states(SHADERS) == 1)
            {
                CVector tmp;
                tmp.Init(Ambient.r,Ambient.g,Ambient.b);
                VBEFF->setVector("AMBIENT",tmp);
                VBEFF->setVector("VECLIGHT2", ldir2);
            }

            if (!ActualVertexBuffer->Grouped)
            {
                if (states(SHADERS)!=0)
                {
                    VBEFF->setTexture("Tex", aT2);
                    VBEFF->setTexture("Env", aT);
                }
                else
                {
                    VBEFF->setTexture("Tex", aT);
                    VBEFF->setTexture("Env", aT2);
                }
            }
            else if (states(ENV_SHADERS)!=0) VBEFF->setTexture("Env",aT);
            
            VBEFF->setVector("FactorMap",CVector(1,1,0));
        }

        if (ActualVertexBuffer->Type&API3D_EDGESDG)
        {
            int tagtmp=0;
            int tagmorph=0;

            if (ActualVertexBuffer->Type&API3D_MORPH)
            {
                tagmorph=1;
                if (states(ALGO_STENCIL_SHADOWING)!=ALGO_ALTERNATIVE) VBEFF=&effect_hll_stencil_simple_morph;
                else { VBEFF=&effect_hll_stencil_alternative_morph; tagtmp=1; }
            }
            else
            {
                if (states(ALGO_STENCIL_SHADOWING)!=ALGO_ALTERNATIVE) VBEFF=&effect_hll_stencil_simple;
                else { VBEFF=&effect_hll_stencil_alternative; tagtmp=1; }
            }

            SetBUILTINVertexBuffer(VBEFF);

            float znear=Front+0.1f;
            CMatrix Mplane;
            CPlane plane;
            CMatrix M;
            CVector view;
            CVector camera;
            CVector4 v4light,v1,v2;
            CVector tmp;
            CVector light;
            //HIC
            light=Lights[ActualVertexBuffer->iValue1].Pos;

            if (tagtmp)
            {
                v4light.Init(light);
                M.Inverse4x4(VIEW);
                camera.Init(M.a[3][0],M.a[3][1],M.a[3][2]);
                view.Init(M.a[2][0],M.a[2][1],M.a[2][2]);
                view.Normalise();
                camera=camera + znear * view;
                plane.a=view.x; plane.b=view.y; plane.c=view.z; plane.d=-(view||camera);

                if (plane.Distance(light)<0) { plane.a=-view.x; plane.b=-view.y; plane.c=-view.z; plane.d=(view||camera); }

                Mplane.Id();
                Mplane.ShadowProjection(v4light,plane);
            }

            tmp.Init(ActualVertexBuffer->fValue1,0.0f,znear);

            VBEFF->setVector("VAR",tmp);
            VBEFF->setPoint("Light",light);
            VBEFF->setMatrixViewProj("VIEWPROJ");
            if (tagtmp) VBEFF->setMatrix("PROJNEARPLANE",Mplane);
            if (tagtmp) VBEFF->setMatrix("VIEW",VIEW);
            VBEFF->setMatrix("WORLD",WORLD);
            if (tagmorph) VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
 
            depthStencilDesc.DepthEnable = true;
            depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
            depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;

            depthStencilDesc.StencilEnable = true;
            depthStencilDesc.StencilReadMask = 0xFF;
            depthStencilDesc.StencilWriteMask = 0xFF;

            if (states(ALGO_STENCIL_SHADOWING)==ALGO_REVERSE)
            {
                depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_INCR;
                depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

                depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_DECR;
                depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;
            }
            else
            {
                depthStencilDesc.FrontFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.FrontFace.StencilPassOp = D3D12_STENCIL_OP_INCR;
                depthStencilDesc.FrontFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;

                depthStencilDesc.BackFace.StencilFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilDepthFailOp = D3D12_STENCIL_OP_KEEP;
                depthStencilDesc.BackFace.StencilPassOp = D3D12_STENCIL_OP_DECR;
                depthStencilDesc.BackFace.StencilFunc = D3D12_COMPARISON_FUNC_ALWAYS;
            }

            blendStateDesc.RenderTarget[0].BlendEnable=true;
            blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_ZERO;
            blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ONE;
            blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
            blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
            blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_ZERO;
            blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ONE;

            rasterDesc.CullMode = D3D12_CULL_MODE_NONE;
        }
        else
        {
            // COLOR
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            if (ActualVertexBuffer->TypeVB==2)
            {
                VBEFF=&effect_hll_diffuse_nomap;
                VBEFF->setMatrixWorldViewProj("MODEL");
            }

            // COLORTEX
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            if ((ActualVertexBuffer->TypeVB==0)||(ActualVertexBuffer->TypeVB==1)||(ActualVertexBuffer->TypeVB==3))
            {
                if (set_alphatest) VBEFF=&effect_hll_diffuse_alphatest; else VBEFF=&effect_hll_diffuse;
                SetBUILTINVertexBuffer(VBEFF);

                if (!ActualVertexBuffer->Grouped) VBEFF->setTexture("Tex",aT);
                
                VBEFF->setMatrixWorld("WORLD");
                VBEFF->setMatrixViewProj("VIEWPROJ");
            }

            // TNL
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////
            if ((ActualVertexBuffer->TypeVB==5)&&((ActualVertexBuffer->Type&API3D_ENVMAPPING)==0))
            {
                if (!Lighting) return;
                TNL=true;
                if (Specular)
                {
                    CMatrix M;
                    CVector camera;
                    M.Inverse4x4(VIEW);
                    camera.Init(M.a[3][0],M.a[3][1],M.a[3][2]);

                    if (ActualVertexBuffer->Type&API3D_MORPH)
                    {
                        if (set_alphatest) VBEFF=&effect_hll_TNL_specular_morph_alphatest;
                        else VBEFF=&effect_hll_TNL_specular_morph;
                        SetBUILTINVertexBuffer(VBEFF);

                        VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
                    }
                    else
                    {
                        if (set_alphatest) VBEFF=&effect_hll_TNL_specular_alphatest;
                        else VBEFF=&effect_hll_TNL_specular;
                        SetBUILTINVertexBuffer(VBEFF);
                    }
                    VBEFF->setVector("CAMERA",camera);
                }
                else
                {
                    if (ActualVertexBuffer->Type&API3D_MORPH)
                    {
                        if (set_alphatest) VBEFF=&effect_hll_TNL_morph_alphatest;
                        else VBEFF=&effect_hll_TNL_morph;
                        SetBUILTINVertexBuffer(VBEFF);

                        VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
                    }
                    else
                    {
                        if (set_alphatest) VBEFF=&effect_hll_TNL_alphatest;
                        else VBEFF=&effect_hll_TNL;
                        SetBUILTINVertexBuffer(VBEFF);
                    }
                }

                VBEFF->setMatrixWorld("WORLD");
                VBEFF->setMatrixViewProj("VIEWPROJ");
                if (!ActualVertexBuffer->Grouped) VBEFF->setTexture("Tex",aT);

                CVector u,vb_Pos,vv;
                int numLights[64];
                float rLights[64];
                int nbreLights;
                int n1,n2;

                vb_Pos.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);
            
                nbreLights=0;
                for (n=0;n<1024;n++)
                {
                    if (Lights[n].enabled==1)
                    {
                        if (nbreLights<64)
                        {
                            if (Lights[n].directionnal)
                            {
                                u=Lights[n].Pos;
                                rLights[nbreLights]=VECTORNORM(u);
                                numLights[nbreLights]=n;
                                nbreLights++;
                            }
                            else
                            {
                                VECTORSUB(u,Lights[n].Pos,vb_Pos);
                                rLights[nbreLights]=VECTORNORM(u);
                                numLights[nbreLights]=n;
                                nbreLights++;
                            }
                        }
                    }
                }

                for (n1=0;n1<nbreLights;n1++)
                    for (n2=n1+1;n2<nbreLights;n2++)
                    {
                        if (rLights[n2]<rLights[n1])
                        {
                            float r=rLights[n2];
                            rLights[n2]=rLights[n1];
                            rLights[n1]=r;
                            int num=numLights[n2];
                            numLights[n2]=numLights[n1];
                            numLights[n1]=num;
                        }
                    }

                if (nbreLights>8) nbreLights=8;

                static char * nameLIGHT[8]={ "LIGHT1","LIGHT2","LIGHT3","LIGHT4","LIGHT5","LIGHT6","LIGHT7","LIGHT8" };
                static char * nameCOUL[8]={ "COUL1","COUL2","COUL3","COUL4","COUL5","COUL6","COUL7","COUL8" };

                CVector tmp;

                for (n=0;n<nbreLights;n++)
                {
                    int nl=numLights[n];
                    tmp.Init(Lights[nl].r,Lights[nl].g,Lights[nl].b);
                    if (Lights[nl].directionnal)
                    {
                        vv=vb_Pos - 100.0f*Lights[nl].Pos;
                        VBEFF->setVector(nameLIGHT[n],vv);
                    }
                    else VBEFF->setVector(nameLIGHT[n],Lights[nl].Pos);
                    VBEFF->setPoint(nameCOUL[n],tmp);
                }

                if (nbreLights<8)
                    for (n=nbreLights;n<8;n++)
                    {
                        tmp.Init(0,0,0);
                        VBEFF->setVector(nameLIGHT[n],vb_Pos);
                        VBEFF->setVector(nameCOUL[n],tmp);
                    }

                tmp.Init(Ambient.r,Ambient.g,Ambient.b);
                VBEFF->setVector("AMBIENT",tmp);
                if (set_alphatest) VBEFF->setFloat("ALPHA",val_alphatest);

                if ((!ActualVertexBuffer->Grouped)&&(Specular))
                {
                    float POW=20.0f;
                    if (aT>=0)
                    if (iTexture[aT])
                        if (iTexture[aT]->Material) POW = (float) iTexture[aT]->Material->power;
                    VBEFF->setFloat("POWER",POW);
                }

            }

            // MULTITEXTURE
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////

            if ((ActualVertexBuffer->TypeVB==4)||(ActualVertexBuffer->TypeVB==6))
            {
                if (set_alphatest)
                {
                    if ((LevelTexture0==0)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi00_at;
                    if ((LevelTexture0==1)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi10_at;
                    if ((LevelTexture0==0)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi01_at;
                    if ((LevelTexture0==1)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi11_at;
                }
                else
                {
                    if ((LevelTexture0==0)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi00;
                    if ((LevelTexture0==1)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi10;
                    if ((LevelTexture0==0)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi01;
                    if ((LevelTexture0==1)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi11;
                }

                SetBUILTINVertexBuffer(VBEFF);

                if (!ActualVertexBuffer->Grouped)
                {
                    if (lT<0) VBEFF->setTexture("Tex1",aT); else VBEFF->setLightmap("Tex1",lT);
                    if (lT<0) VBEFF->setTexture("Tex2",aT2); else VBEFF->setLightmap("Tex2",lT2);
                }

                VBEFF->setMatrixWorldViewProj("MODEL");
                if (set_alphatest) VBEFF->setFloat("ALPHA",val_alphatest);
            }
        }
    }

    int changeblend=PreviousBlend;
    int state_blending=states(BLENDING);
    int state_culling=states(CULLING);

    CVertexBuffer * vbeffect=NULL;

	PreviousRS.ZBuffer=PreviousRS.ZBufferWrite=_UNDEFINED;

    if (!ActualVertexBuffer->Grouped)
    {
        PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;

        if ((ActualVertexBuffer->Type&API3D_VERTEXPROGRAM)||(ActualEffect)||(VBEFF))
        {
            if (ActualEffect) vbeffect=ActualEffect;
            else vbeffect=ActualVertexBuffer;

            if (VBEFF) vbeffect=VBEFF;

            if (!vbeffect->layout)
            {
                D3D12_INPUT_ELEMENT_DESC LayoutDesc[16];
                int num=SetLayouts(ActualVertexBuffer,LayoutDesc);
				vbeffect->layout=new D3D12_INPUT_ELEMENT_DESC[num];
				vbeffect->nlayout=num;
				memcpy(vbeffect->layout,LayoutDesc,num*sizeof(D3D12_INPUT_ELEMENT_DESC));
            }

            D3D12_VERTEX_BUFFER_VIEW vbs[2];
            int nbvbs=1;

            if (ActualVertexBuffer->Type&API3D_MORPH)
            {
                nbvbs=2;
                if (ActualVertexBuffer->Type&API3D_STREAMS)
                {
                    if (ActualVertexBuffer->stream1>=0) vbs[0]=ActualVertexBuffer->STREAMSVIEW[ActualVertexBuffer->stream1];
                    else vbs[0]=ActualVertexBuffer->D3DVBVIEW;

                    if (ActualVertexBuffer->stream2>=0) vbs[1]=ActualVertexBuffer->STREAMSVIEW[ActualVertexBuffer->stream2];
                    else vbs[1]=ActualVertexBuffer->D3DVBVIEW;
                }
                else
                {
                    vbs[0]=ActualVertexBuffer->D3DVBVIEW;
                    vbs[1]=ActualVertexBuffer->STREAMSVIEW[0];
                }
            }
            else
            {
                vbs[0]=ActualVertexBuffer->D3DVBVIEW;
            }

            unsigned int strides[2];
            unsigned int offsets[2]={0,0};

            strides[0] = ActualVertexBuffer->_sizeVB;
            strides[1] = ActualVertexBuffer->_sizeVB;

			vbeffect->effect->Update();

            if (vbdraw_line)
            {
                D3DFX_TECHNIQUE_DESC techniqueDesc;
                vbeffect->tech->GetDesc(&techniqueDesc);

                for(int p=0; p<(int)techniqueDesc.Passes; ++p)
                {
                    CreateRootSignature(vbeffect);
                    commandList=CreatePipelineState(vbeffect,commandList,p,vbeffect->layout,vbeffect->nlayout,true);
                    GraphicDescriptorTable(vbeffect,commandList);

                    commandList->IASetVertexBuffers(0, nbvbs, vbs);
                    commandList->DrawInstanced(ActualVertexBuffer->nVerticesActif,1,0,0);

                    //CloseAndExecuteCommandList(commandList);
					//commandList=NULL;
                    
                    PipelineDescBackup();
                }
            }
            else
            {
                D3DFX_TECHNIQUE_DESC techniqueDesc;
                vbeffect->tech->GetDesc(&techniqueDesc);
                
                for(int p=0; p<(int)techniqueDesc.Passes; ++p)
                {
                    PreviousRS.RenderTarget=_UNDEFINED;
                    
                    SetRenderState(&vbeffect->vp->RenderState[vbeffect->vp->selected_tech][p],1);

                    int tag=0;
                    if (p>0) tag=1;
                    if (vbeffect!=prevEffect) tag=1;
                    //if (PipelineDescChanges()) tag=2;

                    if (tag)
                    {
						CreateRootSignature(vbeffect);
						commandList=CreatePipelineState(vbeffect,commandList,p,vbeffect->layout,vbeffect->nlayout,false);
						vbeffect->effect->set=true;
                    }
                    else commandList=CreatePreviousSetCommandList(vbeffect,commandList);
                    
					GraphicDescriptorTable(vbeffect,commandList);

					commandList->IASetVertexBuffers(0, nbvbs, vbs);
					commandList->IASetIndexBuffer(&ActualVertexBuffer->D3DINDEXVIEW);

					commandList->DrawIndexedInstanced(ActualVertexBuffer->nIndicesActif,1,0,0,0);
					commandsexecuted[frameIndex]=true;
					//ExecuteIndirect(ActualVertexBuffer,vbeffect,0,ActualVertexBuffer->nIndicesActif,commandList);

                    PipelineDescBackup();
                }
				
                prevEffect=vbeffect;

                if (state_culling==1) SetParams(API3D_CULL,CCW);
                else SetParams(API3D_CULL,CW);

                if (ActualVertexBuffer->Type&API3D_EDGESDG)
                {
                    blendStateDesc.RenderTarget[0].BlendEnable=false;
                    blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_ONE;
                    blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ZERO;
                    blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
                    blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
                    blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_ONE;
                    blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ZERO;
                }
            }
        }
    }
    else
    {
        bool draw=true;
        // GROUPED

        int ra,rb;
        switch(states(ALPHA_MULTI_GROUP_DRAW))
        {
        case 0:
            ra=0;rb=0;
            break;
        case 1:
            ra=0;rb=2;
            break;
        case 2:
            ra=1;rb=2;
            break;
        };

        if (!ActualVertexBuffer->HasRef) ra=rb=0;

        if ((ActualVertexBuffer->Type&API3D_VERTEXPROGRAM)||(ActualEffect)||(VBEFF))
        {
            if (ActualEffect) vbeffect=ActualEffect;
            else vbeffect=ActualVertexBuffer;

            if (VBEFF) vbeffect=VBEFF;

            if (!vbeffect->layout)
            {
                D3D12_INPUT_ELEMENT_DESC LayoutDesc[16];
                int num=SetLayouts(ActualVertexBuffer,LayoutDesc);
				vbeffect->layout=new D3D12_INPUT_ELEMENT_DESC[num];
				vbeffect->nlayout=num;
				memcpy(vbeffect->layout,LayoutDesc,num*sizeof(D3D12_INPUT_ELEMENT_DESC));
            }

            D3D12_VERTEX_BUFFER_VIEW vbs[2];
            int nbvbs=1;

            if (ActualVertexBuffer->Type&API3D_MORPH)
            {
                nbvbs=2;
                if (ActualVertexBuffer->Type&API3D_STREAMS)
                {
                    if (ActualVertexBuffer->stream1>=0) vbs[0]=ActualVertexBuffer->STREAMSVIEW[ActualVertexBuffer->stream1];
                    else vbs[0]=ActualVertexBuffer->D3DVBVIEW;

                    if (ActualVertexBuffer->stream2>=0) vbs[1]=ActualVertexBuffer->STREAMSVIEW[ActualVertexBuffer->stream2];
                    else vbs[1]=ActualVertexBuffer->D3DVBVIEW;
                }
                else
                {
                    vbs[0]=ActualVertexBuffer->D3DVBVIEW;
                    vbs[1]=ActualVertexBuffer->STREAMSVIEW[0];
                }
            }
            else
            {
                vbs[0]=ActualVertexBuffer->D3DVBVIEW;
            }

            unsigned int strides[2];
            unsigned int offsets[2]={0,0};

            strides[0] = ActualVertexBuffer->_sizeVB;
            strides[1] = ActualVertexBuffer->_sizeVB;

            PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
            if ((ra==0)&&(state_blending!=0)&&(state_blending<3))
            {
				//if (blendStateDesc.RenderTarget[0].BlendEnable)
				//changeblend=-1;
                blendStateDesc.RenderTarget[0].BlendEnable=false;
            }

			vbeffect->effect->Update();

            for (ref_value=ra;ref_value<=rb;ref_value++)
            {
                if (state_blending<3)
                {
                    if (ref_value==1)   // ON
                    {
                        blendStateDesc.RenderTarget[0].BlendEnable=true;
                        blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_SRC_ALPHA;
                        blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_INV_SRC_ALPHA;
                        blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
                        blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_SRC_ALPHA;
                        blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_INV_SRC_ALPHA;
                        blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
                        PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
						changeblend=-1;
                    }
                    else
                    if (ref_value==2)   // ADD
                    {
                        blendStateDesc.RenderTarget[0].BlendEnable=true;
                        blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_SRC_ALPHA;
                        blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ONE;
                        blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
                        blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_SRC_ALPHA;
                        blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ONE;
                        blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
                        PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
						changeblend=-1;
                    }
                }

                nfo=ActualVertexBuffer->ListeSE.GetFirst();
                while (nfo)
                {
                    if ((nfo->ref==ref_value)&&(nfo->flag==valueflag))
                    {
                        if (ActualVertexBuffer->TypeVB==9)
                        {
                            draw=true;
                            if (fn_stage_draw)
                                if (fn_stage_draw(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)==0) draw=false;

                            if (states(RENDER_TARGET_OPTIONS)!=STENCIL)
                            {
                                if (draw)
                                {
                                    if (fn_stage0) vbeffect->setLightmap("lightmap",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
                                    else vbeffect->setLightmap("lightmap",nfo->nL);
                                
                                    if (fn_stage1) vbeffect->setTexture("tex",fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
                                    else vbeffect->setTexture("tex",nfo->nT+Decal_nt);
                                
                                    if (fn_stage2) vbeffect->setLightmap("vectors",fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
                                    else vbeffect->setLightmap("vectors",nfo->nLV);

                                    if (fn_stage3) vbeffect->setTexture("bump",fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
                                    else vbeffect->setTexture("bump",nfo->nT+bumpmap_settexture);

                                    if (fn_stage4) vbeffect->setTexture("displace",fn_stage4(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
                                    else vbeffect->setTexture("displace",nfo->nT+bump_displace);

                                    if (fn_stage5) vbeffect->setTexture("horizon",fn_stage5(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
                                    else vbeffect->setTexture("horizon",nfo->nT+bump_horizon);
                                }
                            }
                        }
                        else
                        if (ActualVertexBuffer->TypeVB==7)
                        {
                            draw=true;
                            if (fn_stage_draw)
                                if (fn_stage_draw(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)==0) draw=false;

                            if (states(RENDER_TARGET_OPTIONS)!=STENCIL)
                            {
                                if (draw)
                                {
                                    if (fn_stage0) vbeffect->setLightmap("lightmap",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
                                    else vbeffect->setLightmap("lightmap",nfo->nL);
                                
                                    if (fn_stage1) vbeffect->setTexture("tex",fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
                                    else vbeffect->setTexture("tex",nfo->nT+Decal_nt);
                                
                                    if (fn_stage2) vbeffect->setLightmap("vectors",fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
                                    else vbeffect->setLightmap("vectors",nfo->nLV);

                                    if (fn_stage3) vbeffect->setTexture("bump",fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
                                    else vbeffect->setTexture("bump",nfo->nT+bumpmap_settexture);
                                }
                            }
                        }
                        else
                        if (TNL)
                        {
                            vbeffect->setTexture("Tex",nfo->nT+Decal_nt);
                            if (Specular)
                            {
                                float POW=20.0f;
                                if (iTexture[nfo->nT])
                                if (iTexture[nfo->nT]->Material) POW = (float) iTexture[nfo->nT]->Material->power;
                                vbeffect->setFloat("POWER",POW);
                            }
                        }
                        else
                        if ((ActualVertexBuffer->TypeVB==4)||(ActualVertexBuffer->TypeVB==6)||(ActualVertexBuffer->Type&API3D_ENVMAPPING))
                        {
                            if (ContextEffect)
                            {
                                draw=ContextEffect->update(vbeffect,nfo->nT,nfo->nT2,nfo->tag);

                                if (vbeffect->AssignedTexture[TEXTURE_FROM_NL]) vbeffect->setLightmap(vbeffect->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeffect->setLightmap(vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0], aT);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1], aT2);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2], aT3);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3], aT4);

                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4], aT5);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5], aT6);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6], aT7);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7], aT8);
                            }
                            else MultiTextureShaders(nfo,vbeffect);
                        }
                        else
                        {
                            if (ContextEffect)
                            {
                                draw=ContextEffect->update(vbeffect,nfo->nT,nfo->nT2,nfo->tag);

								DrawVertexBufferSetupSizeDest(vbeffect,nfo);

                                if (vbeffect->AssignedTexture[TEXTURE_FROM_NL]) if (nfo->nL>=0) vbeffect->res[TEXTURE_FROM_NL]->SetResource(Lightmap[nfo->nL]);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS]) if (nfo->nLV>=0) vbeffect->res[TEXTURE_FROM_NLVECTORS]->SetResource(Lightmap[nfo->nLV]);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0]) if (aT>=0) vbeffect->res[TEXTURE_FROM_RENDER_0]->SetResource(Texture[aT]); else vbeffect->res[TEXTURE_FROM_RENDER_0]->SetResource(&shaderResourceView[-(aT+1)]);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1]) if (aT2>=0) vbeffect->res[TEXTURE_FROM_RENDER_1]->SetResource(Texture[aT2]); else vbeffect->res[TEXTURE_FROM_RENDER_1]->SetResource(&shaderResourceView[-(aT2+1)]);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2]) if (aT3>=0) vbeffect->res[TEXTURE_FROM_RENDER_2]->SetResource(Texture[aT3]); else vbeffect->res[TEXTURE_FROM_RENDER_2]->SetResource(&shaderResourceView[-(aT3+1)]);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3]) if (aT4>=0) vbeffect->res[TEXTURE_FROM_RENDER_3]->SetResource(Texture[aT4]); else vbeffect->res[TEXTURE_FROM_RENDER_3]->SetResource(&shaderResourceView[-(aT4+1)]);

                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4]) if (aT5>=0) vbeffect->res[TEXTURE_FROM_RENDER_4]->SetResource(Texture[aT5]); else vbeffect->res[TEXTURE_FROM_RENDER_4]->SetResource(&shaderResourceView[-(aT5+1)]);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5]) if (aT6>=0) vbeffect->res[TEXTURE_FROM_RENDER_5]->SetResource(Texture[aT6]); else vbeffect->res[TEXTURE_FROM_RENDER_5]->SetResource(&shaderResourceView[-(aT6+1)]);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6]) if (aT7>=0) vbeffect->res[TEXTURE_FROM_RENDER_6]->SetResource(Texture[aT7]); else vbeffect->res[TEXTURE_FROM_RENDER_6]->SetResource(&shaderResourceView[-(aT7+1)]);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7]) if (aT8>=0) vbeffect->res[TEXTURE_FROM_RENDER_7]->SetResource(Texture[aT8]); else vbeffect->res[TEXTURE_FROM_RENDER_7]->SetResource(&shaderResourceView[-(aT8+1)]);
                            }
                            else
                            {
                                if (((ActualVertexBuffer->TypeVB==0)||(ActualVertexBuffer->TypeVB==1)||(ActualVertexBuffer->TypeVB==3))&&(VBEFF))
                                {
                                    //vbeffect->setTexture("Tex",nfo->nT+Decal_nt);
                                    if (fn_stage0) vbeffect->setTexture("Tex",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
                                    else
                                    {
                                        if ((nfo->nT+Decal_nt>=0)&&(nfo->nT+Decal_nt<NBRE_MAX_TEXTURES))
                                        if (cTexture[nfo->nT+Decal_nt]) vbeffect->setTexture("Tex",nfo->nT+Decal_nt);
                                    }
                                }
                                else
                                {
									DrawVertexBufferSetupSizeDest(vbeffect,nfo);

                                    if (vbeffect->AssignedTexture[TEXTURE_FROM_NT]) vbeffect->res[TEXTURE_FROM_NT]->SetResource(Texture[nfo->nT+Decal_nt]);
                                    if (vbeffect->AssignedTexture[TEXTURE_FROM_NTPLUSONE]) vbeffect->res[TEXTURE_FROM_NTPLUSONE]->SetResource(Texture[nfo->nT+Decal_nt+1]);
                                    if (vbeffect->AssignedTexture[TEXTURE_FROM_NT2]) vbeffect->res[TEXTURE_FROM_NT2]->SetResource(Texture[nfo->nT2]);
                                    if (vbeffect->AssignedTexture[TEXTURE_FROM_BUMP]) vbeffect->res[TEXTURE_FROM_BUMP]->SetResource(Texture[nfo->nT+bumpmap_settexture]);
                                    if (vbeffect->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE]) vbeffect->res[TEXTURE_FROM_BUMPPLUSONE]->SetResource(Texture[nfo->nT+1+bumpmap_settexture]);

									if (vbeffect->AssignedTexture[TEXTURE_FROM_DISPLACE]) vbeffect->res[TEXTURE_FROM_DISPLACE]->SetResource(Texture[nfo->nT+bump_displace]);
									if (vbeffect->AssignedTexture[TEXTURE_FROM_HORIZON]) vbeffect->res[TEXTURE_FROM_HORIZON]->SetResource(Texture[nfo->nT+bump_horizon]);

                                    if (vbeffect->AssignedTexture[TEXTURE_FROM_NL]) if (nfo->nL>=0) vbeffect->res[TEXTURE_FROM_NL]->SetResource(Lightmap[nfo->nL]);
                                    if (vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS]) if (nfo->nLV>=0) vbeffect->res[TEXTURE_FROM_NLVECTORS]->SetResource(Lightmap[nfo->nLV]);

                                    if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0])&&(vbeffect->res[TEXTURE_FROM_RENDER_0])) if (aT>=0) vbeffect->res[TEXTURE_FROM_RENDER_0]->SetResource(Texture[aT]); else vbeffect->res[TEXTURE_FROM_RENDER_0]->SetResource(&shaderResourceView[-(aT+1)]);
                                    if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1])&&(vbeffect->res[TEXTURE_FROM_RENDER_1])) if (aT2>=0) vbeffect->res[TEXTURE_FROM_RENDER_1]->SetResource(Texture[aT2]); else vbeffect->res[TEXTURE_FROM_RENDER_1]->SetResource(&shaderResourceView[-(aT2+1)]);
                                    if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2])&&(vbeffect->res[TEXTURE_FROM_RENDER_2])) if (aT3>=0) vbeffect->res[TEXTURE_FROM_RENDER_2]->SetResource(Texture[aT3]); else vbeffect->res[TEXTURE_FROM_RENDER_2]->SetResource(&shaderResourceView[-(aT3+1)]);
                                    if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3])&&(vbeffect->res[TEXTURE_FROM_RENDER_3])) if (aT4>=0) vbeffect->res[TEXTURE_FROM_RENDER_3]->SetResource(Texture[aT4]); else vbeffect->res[TEXTURE_FROM_RENDER_3]->SetResource(&shaderResourceView[-(aT4+1)]);

                                    if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4])&&(vbeffect->res[TEXTURE_FROM_RENDER_4])) if (aT5>=0) vbeffect->res[TEXTURE_FROM_RENDER_4]->SetResource(Texture[aT5]); else vbeffect->res[TEXTURE_FROM_RENDER_4]->SetResource(&shaderResourceView[-(aT5+1)]);
                                    if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5])&&(vbeffect->res[TEXTURE_FROM_RENDER_5])) if (aT6>=0) vbeffect->res[TEXTURE_FROM_RENDER_5]->SetResource(Texture[aT6]); else vbeffect->res[TEXTURE_FROM_RENDER_5]->SetResource(&shaderResourceView[-(aT6+1)]);
                                    if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6])&&(vbeffect->res[TEXTURE_FROM_RENDER_6])) if (aT7>=0) vbeffect->res[TEXTURE_FROM_RENDER_6]->SetResource(Texture[aT7]); else vbeffect->res[TEXTURE_FROM_RENDER_6]->SetResource(&shaderResourceView[-(aT7+1)]);
                                    if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7])&&(vbeffect->res[TEXTURE_FROM_RENDER_7])) if (aT8>=0) vbeffect->res[TEXTURE_FROM_RENDER_7]->SetResource(Texture[aT8]); else vbeffect->res[TEXTURE_FROM_RENDER_7]->SetResource(&shaderResourceView[-(aT8+1)]);
                                }
                            }
                        }

                        if ((vbeffect->effect)&&(draw))
                        {
                            D3DFX_TECHNIQUE_DESC techniqueDesc;
                            vbeffect->tech->GetDesc(&techniqueDesc);
						
                            for(int p=0; p<(int)techniqueDesc.Passes; ++p)
                            {
                                SetRenderState(&vbeffect->vp->RenderState[vbeffect->vp->selected_tech][p],0);
                                
								int tag=0;
								if (p>0) tag=1;
								if (vbeffect!=prevEffect) tag=1;
								//if (PipelineDescChanges()) tag=2;
																
								if ((tag)||(changeblend<0))
								{
									CreateRootSignature(vbeffect);
									commandList=CreatePipelineState(vbeffect,commandList,p,vbeffect->layout,vbeffect->nlayout,false);
									vbeffect->effect->set=true;									
								}
								else commandList=CreatePreviousSetCommandList(vbeffect,commandList);

                                GraphicDescriptorTable(vbeffect,commandList);

                                commandList->IASetVertexBuffers(0, nbvbs, vbs);
                                commandList->IASetIndexBuffer(&ActualVertexBuffer->D3DINDEXVIEW);

                                commandList->DrawIndexedInstanced((nfo->iEnd-nfo->iStart),1,nfo->iStart,0,0);
								commandsexecuted[frameIndex]=true;
								//ExecuteIndirect(ActualVertexBuffer,vbeffect,nfo->iStart,nfo->iEnd,commandList);

								if (changeblend<0) changeblend=0;
								
								PipelineDescBackup();
                            }

							prevEffect=vbeffect;
                        }
                    }
                    nfo=ActualVertexBuffer->ListeSE.GetNext();
                }
            }
        }
    }

    if ((MachineState==0)||(PreviousBlend!=changeblend))
    {
        //PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
        
        switch (state_blending)
        {
        case 0:     // OFF
            blendStateDesc.RenderTarget[0].BlendEnable=false;
            blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_ONE;
            blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ZERO;
            blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_ONE;
            blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ZERO;
            break;
        case 1:     // ON
            blendStateDesc.RenderTarget[0].BlendEnable=true;
            blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_SRC_ALPHA;
            blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_INV_SRC_ALPHA;
            blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
            blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_SRC_ALPHA;
            blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_INV_SRC_ALPHA;
            blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
            break;
        case 2:     // GOURAUD
            blendStateDesc.RenderTarget[0].BlendEnable=true;
            blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_SRC_ALPHA;
            blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ONE;
            blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
            blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_SRC_ALPHA;
            blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ONE;
            blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
            break;
        case 3:     // COLOR
            blendStateDesc.RenderTarget[0].BlendEnable=true;
            blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_DEST_COLOR;
            blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ZERO;
            blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
            blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_DEST_ALPHA;
            blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ZERO;
            blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
            break;
        case 4:     // INVERSE
            blendStateDesc.RenderTarget[0].BlendEnable=true;
            blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_INV_SRC_ALPHA;
            blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_SRC_ALPHA;
            blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
            blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_INV_SRC_ALPHA;
            blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_SRC_ALPHA;
            blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
            break;
        case 5:     // ADD
            blendStateDesc.RenderTarget[0].BlendEnable=true;
            blendStateDesc.RenderTarget[0].SrcBlend=D3D12_BLEND_ONE;
            blendStateDesc.RenderTarget[0].DestBlend=D3D12_BLEND_ONE;
            blendStateDesc.RenderTarget[0].BlendOp=D3D12_BLEND_OP_ADD;
            blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D12_BLEND_ONE;
            blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D12_BLEND_ONE;
            blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D12_BLEND_OP_ADD;
            break;
        };

        *states[BLENDING]=state_blending;
    }

    if (MachineState==0)
    {
        if (state_culling==1) SetParams(API3D_CULL,CCW);
        else SetParams(API3D_CULL,CW);
    }

	PipelineDescBackup();

	CounterCommandList++;
	if (CounterCommandList>256)
	{
		CounterCommandList=0;
		CloseOpenedCommandList();

		prevEffect=NULL;
		commandList=NULL;
		actualpipeline=NULL;
		previouspipe=NULL;
	}

    return;

#else
#ifdef API3D_DIRECT3D11
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// DIRECT3D 11
	if ((!SecondarySurface)&&(SelectedRenderTarget!=PRIMARY)) return;

	int n;
	CVertexBuffer * VBEFF=NULL;
	bool TNL=false;

	if (((!(ActualVertexBuffer->Type&API3D_VERTEXPROGRAM))&&(!ActualEffect))&&(!vbdraw_line))
	{
		if (ActualVertexBuffer->TypeVB==9)
		{
			if (states(RENDER_TARGET_OPTIONS)==STENCIL)
			{
				VBEFF=&effect_hll_bump_mapping_displacement_s;
				SetBUILTINVertexBuffer(VBEFF);
			}
			else
			{
				VBEFF=&effect_hll_bump_mapping_displacement;
				SetBUILTINVertexBuffer(VBEFF);

				CVector vect;
				VBEFF->setVector("vecLight1",Lights[ActualVertexBuffer->Lights[0]].Pos);
				VBEFF->setVector("vecLight2",Lights[ActualVertexBuffer->Lights[1]].Pos);
				VBEFF->setVector("vecLight3",Lights[ActualVertexBuffer->Lights[2]].Pos);
					
				vect.x=Lights[ActualVertexBuffer->Lights[0]].variation;
				vect.y=vect.z=vect.x;
				VBEFF->setVector("vecVar1",vect);
				vect.x=Lights[ActualVertexBuffer->Lights[1]].variation;
				vect.y=vect.z=vect.x;
				VBEFF->setVector("vecVar2",vect);
				vect.x=Lights[ActualVertexBuffer->Lights[2]].variation;
				vect.y=vect.z=vect.x;
				VBEFF->setVector("vecVar3",vect);
			}

			VBEFF->setMatrixWorld("WORLD");
			VBEFF->setMatrixViewProj("VIEWPROJ");
			CMatrix matViewInv;

			matViewInv.Inverse4x4(viewMatrix);

			CVector v;
            v.Init( matViewInv.a[3][0], matViewInv.a[3][1], matViewInv.a[3][2] );

			VBEFF->setVector("Eye",v);
		}
		else
		if (ActualVertexBuffer->TypeVB==7)
		{
			if (states(RENDER_TARGET_OPTIONS)==STENCIL)
			{
				VBEFF=&effect_hll_bump_mapping_s;
				SetBUILTINVertexBuffer(VBEFF);
			}
			else
			{
				if (states(SPECIAL_ANIMATED))
				{
					VBEFF=&effect_hll_bump_mapping_anim;
					SetBUILTINVertexBuffer(VBEFF);

					CVector vect;
					VBEFF->setVector("vecLight1",Lights[ActualVertexBuffer->Lights[0]].Pos);
					VBEFF->setVector("vecLight2",Lights[ActualVertexBuffer->Lights[1]].Pos);
					VBEFF->setVector("vecLight3",Lights[ActualVertexBuffer->Lights[2]].Pos);
					
					vect.x=Lights[ActualVertexBuffer->Lights[0]].variation;
					vect.y=vect.z=vect.x;
					VBEFF->setVector("vecVar1",vect);
					vect.x=Lights[ActualVertexBuffer->Lights[1]].variation;
					vect.y=vect.z=vect.x;
					VBEFF->setVector("vecVar2",vect);
					vect.x=Lights[ActualVertexBuffer->Lights[2]].variation;
					vect.y=vect.z=vect.x;
					VBEFF->setVector("vecVar3",vect);
				}
				else
				{
					VBEFF=&effect_hll_bump_mapping;
					SetBUILTINVertexBuffer(VBEFF);
				}
			}
			VBEFF->setMatrixWorld("WORLD");
			VBEFF->setMatrixViewProj("VIEWPROJ");
		}
		else
		if (ActualVertexBuffer->Type&API3D_ENVMAPPING)
		{
			int tagmorph=0;

			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				tagmorph=1;
				if (states(SHADERS)==1) VBEFF=&effect_hll_envmap2_morph;
				else VBEFF=&effect_hll_envmap1_morph;
			}
			else
			{
				if (states(SHADERS)==1) VBEFF=&effect_hll_envmap2;
				else VBEFF=&effect_hll_envmap1;
			}

			SetBUILTINVertexBuffer(VBEFF);

			CMatrix matViewInv;
			matViewInv.Inverse4x4(viewMatrix);


			CVector v;
            v.Init( matViewInv.a[3][0], matViewInv.a[3][1], matViewInv.a[3][2] );

			CVector u,u2,pz;
			pz.Init(0,0,0);

			u.Init(worldMatrix.a[3][0] - ActualVertexBuffer->L.x,worldMatrix.a[3][1] - ActualVertexBuffer->L.y,worldMatrix.a[3][2] - ActualVertexBuffer->L.z);
			u.Normalise();
			u2.Init(worldMatrix.a[3][0],worldMatrix.a[3][1],worldMatrix.a[3][2]);
			CVector ldir,ldir2;

			if (states(SHADERS)==1)
			{
				n=GetCloserLight(this,u2);
				if (n>=0)
				{
					u2=u2-Lights[n].Pos;
					u2.Normalise();
				}
				else
				{
					u2.Init(0,0,0);
				}
				ldir.x=u2.x;
				ldir.y=u2.y;
				ldir.z=u2.z;
				
				u2.Init(worldMatrix.a[3][0],worldMatrix.a[3][1],worldMatrix.a[3][2]);
				n=GetSecondCloserLight(this,n,u2);
				if (n>=0)
				{
					u2=u2-Lights[n].Pos;
					u2.Normalise();
				}
				else
				{
					u2.Init(0,0,0);
				}
				ldir2.x=u2.x;
				ldir2.y=u2.y;
				ldir2.z=u2.z;
			}
			else
			{
				ldir.x=u.x;
				ldir.y=u.y;
				ldir.z=u.z;
			}
			
			ActualVertexBuffer->Ldir=-1*u;

			CMatrix M;
			M.Id();
			M.View(pz,-1*u,0);
	
			if (tagmorph) VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);

			VBEFF->setMatrix("MATLIGHT", M);
			VBEFF->setMatrixWorld("WORLD");
			VBEFF->setMatrixViewProj("VIEWPROJ");
			VBEFF->setVector("VECLIGHT", ldir);
			VBEFF->setVector("CAMERA", v);

			if (states(SHADERS) == 1)
			{
				CVector tmp;
				tmp.Init(Ambient.r,Ambient.g,Ambient.b);
				VBEFF->setVector("AMBIENT",tmp);
				VBEFF->setVector("VECLIGHT2", ldir2);
			}
	
			if (!ActualVertexBuffer->Grouped)
			{
				if (states(SHADERS)!=0)
				{
					VBEFF->setTexture("Tex", aT2);
					VBEFF->setTexture("Env", aT);
				}
				else
				{
					VBEFF->setTexture("Tex", aT);
					VBEFF->setTexture("Env", aT2);
				}
			}
			else if (states(ENV_SHADERS)!=0) VBEFF->setTexture("Env",aT);
            
            VBEFF->setVector("FactorMap",CVector(1,1,0));
		}

		if (ActualVertexBuffer->Type&API3D_EDGESDG)
		{
			int tagtmp=0;
			int tagmorph=0;

			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				tagmorph=1;
				if (states(ALGO_STENCIL_SHADOWING)!=ALGO_ALTERNATIVE) VBEFF=&effect_hll_stencil_simple_morph;
				else { VBEFF=&effect_hll_stencil_alternative_morph; tagtmp=1; }
			}
			else
			{
				if (states(ALGO_STENCIL_SHADOWING)!=ALGO_ALTERNATIVE) VBEFF=&effect_hll_stencil_simple;
				else { VBEFF=&effect_hll_stencil_alternative; tagtmp=1; }
			}

			SetBUILTINVertexBuffer(VBEFF);

			float znear=Front+0.1f;
			CMatrix Mplane;
			CPlane plane;
			CMatrix M;
			CVector view;
			CVector camera;
			CVector4 v4light,v1,v2;
			CVector tmp;
			CVector light;
			//HIC
			light=Lights[ActualVertexBuffer->iValue1].Pos;

			if (tagtmp) 
			{
				v4light.Init(light);
				M.Inverse4x4(VIEW);
				camera.Init(M.a[3][0],M.a[3][1],M.a[3][2]);
				view.Init(M.a[2][0],M.a[2][1],M.a[2][2]);
				view.Normalise();
				camera=camera + znear * view;
				plane.a=view.x; plane.b=view.y; plane.c=view.z; plane.d=-(view||camera);
	
				if (plane.Distance(light)<0) { plane.a=-view.x; plane.b=-view.y; plane.c=-view.z; plane.d=(view||camera); }

				Mplane.Id();
				Mplane.ShadowProjection(v4light,plane);
			}

			tmp.Init(ActualVertexBuffer->fValue1,0.0f,znear);

			VBEFF->setVector("VAR",tmp);
			VBEFF->setPoint("Light",light);	
			VBEFF->setMatrixViewProj("VIEWPROJ");
			if (tagtmp) VBEFF->setMatrix("PROJNEARPLANE",Mplane);
			if (tagtmp) VBEFF->setMatrix("VIEW",VIEW);
			VBEFF->setMatrix("WORLD",WORLD);
			if (tagmorph) VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
			
			if (depthStencilState) depthStencilState->Release();

			depthStencilDesc.DepthEnable = true;
			depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ZERO;
			depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;

			depthStencilDesc.StencilEnable = true;
			depthStencilDesc.StencilReadMask = 0xFF;
			depthStencilDesc.StencilWriteMask = 0xFF;

			if (states(ALGO_STENCIL_SHADOWING)==ALGO_REVERSE)
			{
				depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
				depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

				depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
				depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
			}
			else
			{
				depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_INCR;
				depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

				depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_DECR;
				depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
			}

			device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
			devicecontext->OMSetDepthStencilState(depthStencilState, 1);

			if (blendStateTMP) blendStateTMP->Release();
			blendStateDesc.RenderTarget[0].BlendEnable=true;
			blendStateDesc.RenderTarget[0].SrcBlend=D3D11_BLEND_ZERO;
			blendStateDesc.RenderTarget[0].DestBlend=D3D11_BLEND_ONE;
			blendStateDesc.RenderTarget[0].BlendOp=D3D11_BLEND_OP_ADD;
			blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D11_BLEND_OP_ADD;
			blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_ZERO;
			blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_ONE;
			device->CreateBlendState(&blendStateDesc,&blendStateTMP);
			devicecontext->OMSetBlendState(blendStateTMP,factors,0xFFFFFFFF);

			if (rasterState) rasterState->Release();
			rasterDesc.CullMode = D3D11_CULL_NONE;
			device->CreateRasterizerState(&rasterDesc, &rasterState);
			devicecontext->RSSetState(rasterState);
		}
		else
		{
			// COLOR
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			if (ActualVertexBuffer->TypeVB==2)
			{
				VBEFF=&effect_hll_diffuse_nomap;
				VBEFF->setMatrixWorldViewProj("MODEL");
			}

			// COLORTEX
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			if ((ActualVertexBuffer->TypeVB==0)||(ActualVertexBuffer->TypeVB==1)||(ActualVertexBuffer->TypeVB==3))  
			{
				if (set_alphatest) VBEFF=&effect_hll_diffuse_alphatest; else VBEFF=&effect_hll_diffuse;
				SetBUILTINVertexBuffer(VBEFF);

				if (!ActualVertexBuffer->Grouped) VBEFF->setTexture("Tex",aT);
				
				VBEFF->setMatrixWorld("WORLD");
				VBEFF->setMatrixViewProj("VIEWPROJ");
			}

			// TNL
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			if ((ActualVertexBuffer->TypeVB==5)&&((ActualVertexBuffer->Type&API3D_ENVMAPPING)==0))
			{
				if (!Lighting) return;
				TNL=true;
				if (Specular)
				{
					CMatrix M;
					CVector camera;
					M.Inverse4x4(VIEW);
					camera.Init(M.a[3][0],M.a[3][1],M.a[3][2]);

					if (ActualVertexBuffer->Type&API3D_MORPH)
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_specular_morph_alphatest;
						else VBEFF=&effect_hll_TNL_specular_morph;
						SetBUILTINVertexBuffer(VBEFF);

						VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
					}
					else
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_specular_alphatest;
						else VBEFF=&effect_hll_TNL_specular;
						SetBUILTINVertexBuffer(VBEFF);
					}
					VBEFF->setVector("CAMERA",camera);
				}
				else
				{
					if (ActualVertexBuffer->Type&API3D_MORPH)
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_morph_alphatest;
						else VBEFF=&effect_hll_TNL_morph;
						SetBUILTINVertexBuffer(VBEFF);

						VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
					}
					else
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_alphatest;
						else VBEFF=&effect_hll_TNL;
						SetBUILTINVertexBuffer(VBEFF);
					}
				}

				VBEFF->setMatrixWorld("WORLD");
				VBEFF->setMatrixViewProj("VIEWPROJ");
				if (!ActualVertexBuffer->Grouped) VBEFF->setTexture("Tex",aT);

				CVector u,vb_Pos,vv;
				int numLights[64];
				float rLights[64];
				int nbreLights;
				int n1,n2;

				vb_Pos.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);
			
				nbreLights=0;
				for (n=0;n<1024;n++)
				{
					if (Lights[n].enabled==1)
					{
						if (nbreLights<64)
						{
							if (Lights[n].directionnal)
							{
								u=Lights[n].Pos;
								rLights[nbreLights]=VECTORNORM(u);
								numLights[nbreLights]=n;
								nbreLights++;
							}
							else
							{
								VECTORSUB(u,Lights[n].Pos,vb_Pos);
								rLights[nbreLights]=VECTORNORM(u);
								numLights[nbreLights]=n;
								nbreLights++;
							}
						}
					}
				}

				for (n1=0;n1<nbreLights;n1++)
					for (n2=n1+1;n2<nbreLights;n2++)
					{
						if (rLights[n2]<rLights[n1])
						{
							float r=rLights[n2];
							rLights[n2]=rLights[n1];
							rLights[n1]=r;
							int num=numLights[n2];
							numLights[n2]=numLights[n1];
							numLights[n1]=num;
						}
					}

				if (nbreLights>8) nbreLights=8;

				static char * nameLIGHT[8]={ "LIGHT1","LIGHT2","LIGHT3","LIGHT4","LIGHT5","LIGHT6","LIGHT7","LIGHT8" };
				static char * nameCOUL[8]={ "COUL1","COUL2","COUL3","COUL4","COUL5","COUL6","COUL7","COUL8" };

				CVector tmp;

				for (n=0;n<nbreLights;n++)
				{
					int nl=numLights[n];
					tmp.Init(Lights[nl].r,Lights[nl].g,Lights[nl].b);
					if (Lights[nl].directionnal)
					{
						vv=vb_Pos - 100.0f*Lights[nl].Pos;
						VBEFF->setVector(nameLIGHT[n],vv);
					}
					else VBEFF->setVector(nameLIGHT[n],Lights[nl].Pos);
					VBEFF->setPoint(nameCOUL[n],tmp);
				}

				if (nbreLights<8)
					for (n=nbreLights;n<8;n++)
					{
						tmp.Init(0,0,0);
						VBEFF->setVector(nameLIGHT[n],vb_Pos);
						VBEFF->setVector(nameCOUL[n],tmp);
					}

				tmp.Init(Ambient.r,Ambient.g,Ambient.b);
				VBEFF->setVector("AMBIENT",tmp);
				if (set_alphatest) VBEFF->setFloat("ALPHA",val_alphatest);

				if ((!ActualVertexBuffer->Grouped)&&(Specular))
				{
					float POW=20.0f;
					if (aT>=0)
                    if (iTexture[aT])
						if (iTexture[aT]->Material) POW = (float) iTexture[aT]->Material->power;
					VBEFF->setFloat("POWER",POW);
				}

			}

			// MULTITEXTURE
			///////////////////////////////////////////////////////////////////////////////////////////////////////////

			if ((ActualVertexBuffer->TypeVB==4)||(ActualVertexBuffer->TypeVB==6))
			{
				if (set_alphatest)
				{
					if ((LevelTexture0==0)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi00_at;
					if ((LevelTexture0==1)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi10_at;
					if ((LevelTexture0==0)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi01_at;
					if ((LevelTexture0==1)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi11_at;
				}
				else
				{					
					if ((LevelTexture0==0)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi00;
					if ((LevelTexture0==1)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi10;
					if ((LevelTexture0==0)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi01;
					if ((LevelTexture0==1)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi11;
				}

				SetBUILTINVertexBuffer(VBEFF);

				if (!ActualVertexBuffer->Grouped)
				{
					if (lT<0) VBEFF->setTexture("Tex1",aT); else VBEFF->setLightmap("Tex1",lT);
					if (lT<0) VBEFF->setTexture("Tex2",aT2); else VBEFF->setLightmap("Tex2",lT2);
				}

				VBEFF->setMatrixWorldViewProj("MODEL");
				if (set_alphatest) VBEFF->setFloat("ALPHA",val_alphatest);
			}
		}
	}

	int changeblend=PreviousBlend;
	int state_blending=states(BLENDING);
	int state_culling=states(CULLING);

	CVertexBuffer * vbeffect=NULL;

	PreviousRS.ZBuffer=PreviousRS.ZBufferWrite=_UNDEFINED;

	if (!ActualVertexBuffer->Grouped)
	{
		PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;

		if ((ActualVertexBuffer->Type&API3D_VERTEXPROGRAM)||(ActualEffect)||(VBEFF))
		{
			if (ActualEffect) vbeffect=ActualEffect;
			else vbeffect=ActualVertexBuffer;

			if (VBEFF) vbeffect=VBEFF;

			if (!vbeffect->layout)
			{
				D3D11_INPUT_ELEMENT_DESC LayoutDesc[16];
				int num=SetLayouts(ActualVertexBuffer,LayoutDesc);
				D3DX11_PASS_DESC passDesc;
				vbeffect->tech->GetPassByIndex(0)->GetDesc(&passDesc);
				device->CreateInputLayout(LayoutDesc, num, passDesc.pIAInputSignature, passDesc.IAInputSignatureSize, &vbeffect->layout);
			}

			ID3D11Buffer* vbs[2];
			int nbvbs=1;

			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				nbvbs=2;

				if (ActualVertexBuffer->Type&API3D_STREAMS)
				{
					if (ActualVertexBuffer->stream1>=0) vbs[0]=ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream1];
					else vbs[0]=ActualVertexBuffer->D3DVB;

					if (ActualVertexBuffer->stream2>=0) vbs[1]=ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream2];
					else vbs[1]=ActualVertexBuffer->D3DVB;
				}
				else
				{
					vbs[0]=ActualVertexBuffer->D3DVB;
					vbs[1]=ActualVertexBuffer->STREAMS[0];
				}
			}
			else
			{
				vbs[0]=ActualVertexBuffer->D3DVB;
			}

			unsigned int strides[2];
			unsigned int offsets[2]={0,0};

			strides[0] = ActualVertexBuffer->_sizeVB;
			strides[1] = ActualVertexBuffer->_sizeVB;

			if (vbdraw_line)
			{
				devicecontext->IASetInputLayout(vbeffect->layout);
				devicecontext->IASetVertexBuffers(0, nbvbs, vbs, strides, offsets);
				devicecontext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINELIST);

				D3DX11_TECHNIQUE_DESC techniqueDesc;
				vbeffect->tech->GetDesc(&techniqueDesc);

				for(int p=0; p<(int)techniqueDesc.Passes; ++p)
				{
					vbeffect->tech->GetPassByIndex(p)->Apply(0,devicecontext);
					devicecontext->Draw(ActualVertexBuffer->nVerticesActif, 0);
				}
			}
			else
			{
				devicecontext->IASetInputLayout(vbeffect->layout);
				devicecontext->IASetVertexBuffers(0, nbvbs, vbs, strides, offsets);
				devicecontext->IASetIndexBuffer(ActualVertexBuffer->D3DINDEX, DXGI_FORMAT_R32_UINT, 0);
				devicecontext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

				D3DX11_TECHNIQUE_DESC techniqueDesc;
				vbeffect->tech->GetDesc(&techniqueDesc);

				for(int p=0; p<(int)techniqueDesc.Passes; ++p)
				{
					PreviousRS.RenderTarget=_UNDEFINED;
					SetRenderState(&vbeffect->vp->RenderState[vbeffect->vp->selected_tech][p],1);
					vbeffect->tech->GetPassByIndex(p)->Apply(0,devicecontext);
					devicecontext->DrawIndexed(ActualVertexBuffer->nIndicesActif, 0, 0);
				}

				if (state_culling==1) SetParams(API3D_CULL,CCW);
				else SetParams(API3D_CULL,CW);

				if (ActualVertexBuffer->Type&API3D_EDGESDG)
				{
					blendStateDesc.RenderTarget[0].BlendEnable=false;
					blendStateDesc.RenderTarget[0].SrcBlend=D3D11_BLEND_ONE;
					blendStateDesc.RenderTarget[0].DestBlend=D3D11_BLEND_ZERO;
					blendStateDesc.RenderTarget[0].BlendOp=D3D11_BLEND_OP_ADD;
					blendStateDesc.RenderTarget[0].BlendOpAlpha=D3D11_BLEND_OP_ADD;
					blendStateDesc.RenderTarget[0].SrcBlendAlpha=D3D11_BLEND_ONE;
					blendStateDesc.RenderTarget[0].DestBlendAlpha=D3D11_BLEND_ZERO;
				}
			}
		}
	}
	else
	{
		bool draw=true;
		// GROUPED

		int ra,rb;
		switch(states(ALPHA_MULTI_GROUP_DRAW))
		{
		case 0:
			ra=0;rb=0;
			break;
		case 1:
			ra=0;rb=2;
			break;
		case 2:
			ra=1;rb=2;
			break;
		};

		if (!ActualVertexBuffer->HasRef) ra=rb=0;

		if ((ActualVertexBuffer->Type&API3D_VERTEXPROGRAM)||(ActualEffect)||(VBEFF))
		{
			if (ActualEffect) vbeffect=ActualEffect;
			else vbeffect=ActualVertexBuffer;

			if (VBEFF) vbeffect=VBEFF;

			if (!vbeffect->layout)
			{
				D3D11_INPUT_ELEMENT_DESC LayoutDesc[16];
				int num=SetLayouts(ActualVertexBuffer,LayoutDesc);
				D3DX11_PASS_DESC passDesc;
				vbeffect->tech->GetPassByIndex(0)->GetDesc(&passDesc);
				device->CreateInputLayout(LayoutDesc, num, passDesc.pIAInputSignature, passDesc.IAInputSignatureSize, &vbeffect->layout);
			}

			ID3D11Buffer* vbs[2];
			int nbvbs=1;

			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				nbvbs=2;
				if (ActualVertexBuffer->Type&API3D_STREAMS)
				{
					if (ActualVertexBuffer->stream1>=0) vbs[0]=ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream1];
					else vbs[0]=ActualVertexBuffer->D3DVB;

					if (ActualVertexBuffer->stream2>=0) vbs[1]=ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream2];
					else vbs[1]=ActualVertexBuffer->D3DVB;
				}
				else
				{
					vbs[0]=ActualVertexBuffer->D3DVB;
					vbs[1]=ActualVertexBuffer->STREAMS[0];
				}
			}
			else
			{
				vbs[0]=ActualVertexBuffer->D3DVB;
			}

			unsigned int strides[2];
			unsigned int offsets[2]={0,0};

			strides[0] = ActualVertexBuffer->_sizeVB;
			strides[1] = ActualVertexBuffer->_sizeVB;

			devicecontext->IASetInputLayout(vbeffect->layout);
			devicecontext->IASetVertexBuffers(0, nbvbs, vbs, strides, offsets);
			devicecontext->IASetIndexBuffer(ActualVertexBuffer->D3DINDEX, DXGI_FORMAT_R32_UINT, 0);
			devicecontext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

			PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
			if ((ra==0)&&(state_blending!=0)&&(state_blending<3)) devicecontext->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);

			for (ref_value=ra;ref_value<=rb;ref_value++)
			{
				if (state_blending<3)
				{
					if (ref_value==1)
					{ 
						devicecontext->OMSetBlendState(blendStateON,factors,0xFFFFFFFF); changeblend=-1;
						PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
					}
					else
					if (ref_value==2)
					{ 
						devicecontext->OMSetBlendState(blendStateGOURAUD,factors,0xFFFFFFFF); changeblend=-1;
						PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
					}
				}

				nfo=ActualVertexBuffer->ListeSE.GetFirst();
				while (nfo)
				{
					if ((nfo->ref==ref_value)&&(nfo->flag==valueflag))
					{
						if (ActualVertexBuffer->TypeVB==9)
						{
							draw=true;
							if (fn_stage_draw) 
								if (fn_stage_draw(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)==0) draw=false;

							if (states(RENDER_TARGET_OPTIONS)!=STENCIL)
							{
								if (draw)
								{
									if (fn_stage0) vbeffect->setLightmap("lightmap",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setLightmap("lightmap",nfo->nL);
								
									if (fn_stage1) vbeffect->setTexture("tex",fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setTexture("tex",nfo->nT+Decal_nt);
								
									if (fn_stage2) vbeffect->setLightmap("vectors",fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setLightmap("vectors",nfo->nLV);

									if (fn_stage3) vbeffect->setTexture("bump",fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setTexture("bump",nfo->nT+bumpmap_settexture);

									if (fn_stage4) vbeffect->setTexture("displace",fn_stage4(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setTexture("displace",nfo->nT+bump_displace);

									if (fn_stage5) vbeffect->setTexture("horizon",fn_stage5(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setTexture("horizon",nfo->nT+bump_horizon);
								}
							}
						}
						else
						if (ActualVertexBuffer->TypeVB==7)
						{
							draw=true;
							if (fn_stage_draw) 
								if (fn_stage_draw(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)==0) draw=false;

							if (states(RENDER_TARGET_OPTIONS)!=STENCIL)
							{
								if (draw)
								{	
									if (fn_stage0) vbeffect->setLightmap("lightmap",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setLightmap("lightmap",nfo->nL);
								
									if (fn_stage1) vbeffect->setTexture("tex",fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setTexture("tex",nfo->nT+Decal_nt);
								
									if (fn_stage2) vbeffect->setLightmap("vectors",fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setLightmap("vectors",nfo->nLV);

									if (fn_stage3) vbeffect->setTexture("bump",fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setTexture("bump",nfo->nT+bumpmap_settexture);
								}
							}
						}
						else
						if (TNL)
						{
							vbeffect->setTexture("Tex",nfo->nT+Decal_nt);
							if (Specular)
							{
								float POW=20.0f;
                                if (iTexture[nfo->nT])
								if (iTexture[nfo->nT]->Material) POW = (float) iTexture[nfo->nT]->Material->power;
								vbeffect->setFloat("POWER",POW);
							}
						}
						else
						if ((ActualVertexBuffer->TypeVB==4)||(ActualVertexBuffer->TypeVB==6)||(ActualVertexBuffer->Type&API3D_ENVMAPPING))
						{
							if (ContextEffect)
							{
								draw=ContextEffect->update(vbeffect,nfo->nT,nfo->nT2,nfo->tag);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_NL]) vbeffect->setLightmap(vbeffect->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeffect->setLightmap(vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0], aT);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1], aT2);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2], aT3);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3], aT4);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4], aT5);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5], aT6);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6], aT7);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7], aT8);
							}
							else MultiTextureShaders(nfo,vbeffect);
						}
						else
						{
							if (ContextEffect)
							{
								draw=ContextEffect->update(vbeffect,nfo->nT,nfo->nT2,nfo->tag);

								DrawVertexBufferSetupSizeDest(vbeffect,nfo);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_NL]) if (nfo->nL>=0) vbeffect->res[TEXTURE_FROM_NL]->SetResource(Lightmap[nfo->nL]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS]) if (nfo->nLV>=0) vbeffect->res[TEXTURE_FROM_NLVECTORS]->SetResource(Lightmap[nfo->nLV]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0]) if (aT>=0) vbeffect->res[TEXTURE_FROM_RENDER_0]->SetResource(Texture[aT]); else vbeffect->res[TEXTURE_FROM_RENDER_0]->SetResource(shaderResourceView[-(aT+1)]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1]) if (aT2>=0) vbeffect->res[TEXTURE_FROM_RENDER_1]->SetResource(Texture[aT2]); else vbeffect->res[TEXTURE_FROM_RENDER_1]->SetResource(shaderResourceView[-(aT2+1)]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2]) if (aT3>=0) vbeffect->res[TEXTURE_FROM_RENDER_2]->SetResource(Texture[aT3]); else vbeffect->res[TEXTURE_FROM_RENDER_2]->SetResource(shaderResourceView[-(aT3+1)]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3]) if (aT4>=0) vbeffect->res[TEXTURE_FROM_RENDER_3]->SetResource(Texture[aT4]); else vbeffect->res[TEXTURE_FROM_RENDER_3]->SetResource(shaderResourceView[-(aT4+1)]);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4]) if (aT5>=0) vbeffect->res[TEXTURE_FROM_RENDER_4]->SetResource(Texture[aT5]); else vbeffect->res[TEXTURE_FROM_RENDER_4]->SetResource(shaderResourceView[-(aT5+1)]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5]) if (aT6>=0) vbeffect->res[TEXTURE_FROM_RENDER_5]->SetResource(Texture[aT6]); else vbeffect->res[TEXTURE_FROM_RENDER_5]->SetResource(shaderResourceView[-(aT6+1)]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6]) if (aT7>=0) vbeffect->res[TEXTURE_FROM_RENDER_6]->SetResource(Texture[aT7]); else vbeffect->res[TEXTURE_FROM_RENDER_6]->SetResource(shaderResourceView[-(aT7+1)]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7]) if (aT8>=0) vbeffect->res[TEXTURE_FROM_RENDER_7]->SetResource(Texture[aT8]); else vbeffect->res[TEXTURE_FROM_RENDER_7]->SetResource(shaderResourceView[-(aT8+1)]);
							}
							else
							{
								if (((ActualVertexBuffer->TypeVB==0)||(ActualVertexBuffer->TypeVB==1)||(ActualVertexBuffer->TypeVB==3))&&(VBEFF))
								{
									//vbeffect->setTexture("Tex",nfo->nT+Decal_nt);
									if (fn_stage0) vbeffect->setTexture("Tex",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else
									{
										if ((nfo->nT+Decal_nt>=0)&&(nfo->nT+Decal_nt<NBRE_MAX_TEXTURES))
										if (cTexture[nfo->nT+Decal_nt]) vbeffect->setTexture("Tex",nfo->nT+Decal_nt);
									}
								}
								else
								{
									DrawVertexBufferSetupSizeDest(vbeffect,nfo);

									if (vbeffect->AssignedTexture[TEXTURE_FROM_NT]) vbeffect->res[TEXTURE_FROM_NT]->SetResource(Texture[nfo->nT+Decal_nt]);
                                    if (vbeffect->AssignedTexture[TEXTURE_FROM_NTPLUSONE]) vbeffect->res[TEXTURE_FROM_NTPLUSONE]->SetResource(Texture[nfo->nT+Decal_nt+1]);
									if (vbeffect->AssignedTexture[TEXTURE_FROM_NT2]) vbeffect->res[TEXTURE_FROM_NT2]->SetResource(Texture[nfo->nT2]);
									if (vbeffect->AssignedTexture[TEXTURE_FROM_BUMP]) vbeffect->res[TEXTURE_FROM_BUMP]->SetResource(Texture[nfo->nT+bumpmap_settexture]);
                                    if (vbeffect->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE]) vbeffect->res[TEXTURE_FROM_BUMPPLUSONE]->SetResource(Texture[nfo->nT+1+bumpmap_settexture]);

									if (vbeffect->AssignedTexture[TEXTURE_FROM_DISPLACE]) vbeffect->res[TEXTURE_FROM_DISPLACE]->SetResource(Texture[nfo->nT+bump_displace]);
									if (vbeffect->AssignedTexture[TEXTURE_FROM_HORIZON]) vbeffect->res[TEXTURE_FROM_HORIZON]->SetResource(Texture[nfo->nT+bump_horizon]);

									if (vbeffect->AssignedTexture[TEXTURE_FROM_NL]) if (nfo->nL>=0) vbeffect->res[TEXTURE_FROM_NL]->SetResource(Lightmap[nfo->nL]);
									if (vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS]) if (nfo->nLV>=0) vbeffect->res[TEXTURE_FROM_NLVECTORS]->SetResource(Lightmap[nfo->nLV]);

									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0])&&(vbeffect->res[TEXTURE_FROM_RENDER_0])) if (aT>=0) vbeffect->res[TEXTURE_FROM_RENDER_0]->SetResource(Texture[aT]); else vbeffect->res[TEXTURE_FROM_RENDER_0]->SetResource(shaderResourceView[-(aT+1)]);
									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1])&&(vbeffect->res[TEXTURE_FROM_RENDER_1])) if (aT2>=0) vbeffect->res[TEXTURE_FROM_RENDER_1]->SetResource(Texture[aT2]); else vbeffect->res[TEXTURE_FROM_RENDER_1]->SetResource(shaderResourceView[-(aT2+1)]);
									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2])&&(vbeffect->res[TEXTURE_FROM_RENDER_2])) if (aT3>=0) vbeffect->res[TEXTURE_FROM_RENDER_2]->SetResource(Texture[aT3]); else vbeffect->res[TEXTURE_FROM_RENDER_2]->SetResource(shaderResourceView[-(aT3+1)]);
									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3])&&(vbeffect->res[TEXTURE_FROM_RENDER_3])) if (aT4>=0) vbeffect->res[TEXTURE_FROM_RENDER_3]->SetResource(Texture[aT4]); else vbeffect->res[TEXTURE_FROM_RENDER_3]->SetResource(shaderResourceView[-(aT4+1)]);

									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4])&&(vbeffect->res[TEXTURE_FROM_RENDER_4])) if (aT5>=0) vbeffect->res[TEXTURE_FROM_RENDER_4]->SetResource(Texture[aT5]); else vbeffect->res[TEXTURE_FROM_RENDER_4]->SetResource(shaderResourceView[-(aT5+1)]);
									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5])&&(vbeffect->res[TEXTURE_FROM_RENDER_5])) if (aT6>=0) vbeffect->res[TEXTURE_FROM_RENDER_5]->SetResource(Texture[aT6]); else vbeffect->res[TEXTURE_FROM_RENDER_5]->SetResource(shaderResourceView[-(aT6+1)]);
									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6])&&(vbeffect->res[TEXTURE_FROM_RENDER_6])) if (aT7>=0) vbeffect->res[TEXTURE_FROM_RENDER_6]->SetResource(Texture[aT7]); else vbeffect->res[TEXTURE_FROM_RENDER_6]->SetResource(shaderResourceView[-(aT7+1)]);
									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7])&&(vbeffect->res[TEXTURE_FROM_RENDER_7])) if (aT8>=0) vbeffect->res[TEXTURE_FROM_RENDER_7]->SetResource(Texture[aT8]); else vbeffect->res[TEXTURE_FROM_RENDER_7]->SetResource(shaderResourceView[-(aT8+1)]);
								}
							}

						}

						if ((vbeffect->effect)&&(draw))
						{
							D3DX11_TECHNIQUE_DESC techniqueDesc;
							vbeffect->tech->GetDesc(&techniqueDesc);

							for(int p=0; p<(int)techniqueDesc.Passes; ++p)
							{
								SetRenderState(&vbeffect->vp->RenderState[vbeffect->vp->selected_tech][p],0);
								vbeffect->tech->GetPassByIndex(p)->Apply(0,devicecontext);
								devicecontext->DrawIndexed((nfo->iEnd-nfo->iStart), nfo->iStart, 0);
							}
						}
					}
					nfo=ActualVertexBuffer->ListeSE.GetNext();
				}
			}
		}
	}

	if ((MachineState==0)||(PreviousBlend!=changeblend))
	{
		PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;

		switch (state_blending)
		{
		case 0:
			devicecontext->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);
			break;
		case 1:
			devicecontext->OMSetBlendState(blendStateON,factors,0xFFFFFFFF);
			break;
		case 2:
			devicecontext->OMSetBlendState(blendStateGOURAUD,factors,0xFFFFFFFF);
			break;
		case 3:
			devicecontext->OMSetBlendState(blendStateCOLOR,factors,0xFFFFFFFF);
			break;
		case 4:
			devicecontext->OMSetBlendState(blendStateINVERSE,factors,0xFFFFFFFF);
			break;
		case 5:
			devicecontext->OMSetBlendState(blendStateADD,factors,0xFFFFFFFF);
			break;
		};

		*states[BLENDING]=state_blending;
	}

	if (MachineState==0)
	{
		if (state_culling==1) SetParams(API3D_CULL,CCW);
		else SetParams(API3D_CULL,CW);
	}

	return;
#else
#ifdef API3D_DIRECT3D10
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// DIRECT3D 10
	if ((!SecondarySurface)&&(SelectedRenderTarget!=PRIMARY)) return;

	int n;
	CVertexBuffer * VBEFF=NULL;
	bool TNL=false;

	if (((!(ActualVertexBuffer->Type&API3D_VERTEXPROGRAM))&&(!ActualEffect))&&(!vbdraw_line))
	{
		if (ActualVertexBuffer->TypeVB==9)
		{
			if (states(RENDER_TARGET_OPTIONS)==STENCIL)
			{
				VBEFF=&effect_hll_bump_mapping_displacement_s;
				SetBUILTINVertexBuffer(VBEFF);
			}
			else
			{
				VBEFF=&effect_hll_bump_mapping_displacement;
				SetBUILTINVertexBuffer(VBEFF);

				CVector vect;
				VBEFF->setVector("vecLight1",Lights[ActualVertexBuffer->Lights[0]].Pos);
				VBEFF->setVector("vecLight2",Lights[ActualVertexBuffer->Lights[1]].Pos);
				VBEFF->setVector("vecLight3",Lights[ActualVertexBuffer->Lights[2]].Pos);
					
				vect.x=Lights[ActualVertexBuffer->Lights[0]].variation;
				vect.y=vect.z=vect.x;
				VBEFF->setVector("vecVar1",vect);
				vect.x=Lights[ActualVertexBuffer->Lights[1]].variation;
				vect.y=vect.z=vect.x;
				VBEFF->setVector("vecVar2",vect);
				vect.x=Lights[ActualVertexBuffer->Lights[2]].variation;
				vect.y=vect.z=vect.x;
				VBEFF->setVector("vecVar3",vect);
			}

			VBEFF->setMatrixWorld("WORLD");
			VBEFF->setMatrixViewProj("VIEWPROJ");
			D3DXMATRIX matViewInv;
			D3DXMatrixInverse( &matViewInv, NULL, &viewMatrix );

			CVector v;
            v.Init( matViewInv._41, matViewInv._42, matViewInv._43 );

			VBEFF->setVector("Eye",v);
		}
		else
		if (ActualVertexBuffer->TypeVB==7)
		{
			if (states(RENDER_TARGET_OPTIONS)==STENCIL)
			{
				VBEFF=&effect_hll_bump_mapping_s;
				SetBUILTINVertexBuffer(VBEFF);
			}
			else
			{
				if (states(SPECIAL_ANIMATED))
				{
					VBEFF=&effect_hll_bump_mapping_anim;
					SetBUILTINVertexBuffer(VBEFF);

					CVector vect;
					VBEFF->setVector("vecLight1",Lights[ActualVertexBuffer->Lights[0]].Pos);
					VBEFF->setVector("vecLight2",Lights[ActualVertexBuffer->Lights[1]].Pos);
					VBEFF->setVector("vecLight3",Lights[ActualVertexBuffer->Lights[2]].Pos);
					
					vect.x=Lights[ActualVertexBuffer->Lights[0]].variation;
					vect.y=vect.z=vect.x;
					VBEFF->setVector("vecVar1",vect);
					vect.x=Lights[ActualVertexBuffer->Lights[1]].variation;
					vect.y=vect.z=vect.x;
					VBEFF->setVector("vecVar2",vect);
					vect.x=Lights[ActualVertexBuffer->Lights[2]].variation;
					vect.y=vect.z=vect.x;
					VBEFF->setVector("vecVar3",vect);
				}
				else
				{
					VBEFF=&effect_hll_bump_mapping;
					SetBUILTINVertexBuffer(VBEFF);
				}
			}
			VBEFF->setMatrixWorld("WORLD");
			VBEFF->setMatrixViewProj("VIEWPROJ");
		}
		else
		if (ActualVertexBuffer->Type&API3D_ENVMAPPING)
		{
			int tagmorph=0;

			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				tagmorph=1;
				if (states(SHADERS)==1) VBEFF=&effect_hll_envmap2_morph;
				else VBEFF=&effect_hll_envmap1_morph;
			}
			else
			{
				if (states(SHADERS)==1) VBEFF=&effect_hll_envmap2;
				else VBEFF=&effect_hll_envmap1;
			}

			SetBUILTINVertexBuffer(VBEFF);

			D3DXMATRIX matViewInv;
			D3DXMatrixInverse( &matViewInv, NULL, &viewMatrix );

			CVector v;
            v.Init( matViewInv._41, matViewInv._42, matViewInv._43 );

			CVector u,u2,pz;
			pz.Init(0,0,0);

			u.Init(worldMatrix._41 - ActualVertexBuffer->L.x,worldMatrix._42 - ActualVertexBuffer->L.y,worldMatrix._43 - ActualVertexBuffer->L.z);
			u.Normalise();
			u2.Init(worldMatrix._41,worldMatrix._42,worldMatrix._43);
			CVector ldir,ldir2;

			if (states(SHADERS)==1)
			{
				n=GetCloserLight(this,u2);
				if (n>=0)
				{
					u2=u2-Lights[n].Pos;
					u2.Normalise();
				}
				else
				{
					u2.Init(0,0,0);
				}
				ldir.x=u2.x;
				ldir.y=u2.y;
				ldir.z=u2.z;
				
				u2.Init(worldMatrix._41,worldMatrix._42,worldMatrix._43);
				n=GetSecondCloserLight(this,n,u2);
				if (n>=0)
				{
					u2=u2-Lights[n].Pos;
					u2.Normalise();
				}
				else
				{
					u2.Init(0,0,0);
				}
				ldir2.x=u2.x;
				ldir2.y=u2.y;
				ldir2.z=u2.z;
			}
			else
			{
				ldir.x=u.x;
				ldir.y=u.y;
				ldir.z=u.z;
			}
			
			ActualVertexBuffer->Ldir=-1*u;

			CMatrix M;
			M.Id();
			M.View(pz,-1*u,0);
	
			if (tagmorph) VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);

			VBEFF->setMatrix("MATLIGHT", M);
			VBEFF->setMatrixWorld("WORLD");
			VBEFF->setMatrixViewProj("VIEWPROJ");
			VBEFF->setVector("VECLIGHT", ldir);
			VBEFF->setVector("CAMERA", v);

			if (states(SHADERS)==1)
			{
				CVector tmp;
				tmp.Init(Ambient.r,Ambient.g,Ambient.b);
				VBEFF->setVector("AMBIENT",tmp);
				VBEFF->setVector("VECLIGHT2", ldir2);
			}
	
			if (!ActualVertexBuffer->Grouped)
			{
				if (states(SHADERS) != 0)
				{
					VBEFF->setTexture("Tex", aT2);
					VBEFF->setTexture("Env", aT);
				}
				else
				{
					VBEFF->setTexture("Tex", aT);
					VBEFF->setTexture("Env", aT2);
				}
			}
			else if (states(ENV_SHADERS)!=0) VBEFF->setTexture("Env",aT);
            
            VBEFF->setVector("FactorMap",CVector(1,1,0));
		}

		if (ActualVertexBuffer->Type&API3D_EDGESDG)
		{
			int tagtmp=0;
			int tagmorph=0;

			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				tagmorph=1;
				if (states(ALGO_STENCIL_SHADOWING)!=ALGO_ALTERNATIVE) VBEFF=&effect_hll_stencil_simple_morph;
				else { VBEFF=&effect_hll_stencil_alternative_morph; tagtmp=1; }
			}
			else
			{
				if (states(ALGO_STENCIL_SHADOWING)!=ALGO_ALTERNATIVE) VBEFF=&effect_hll_stencil_simple;
				else { VBEFF=&effect_hll_stencil_alternative; tagtmp=1; }
			}

			SetBUILTINVertexBuffer(VBEFF);

			float znear=Front+0.1f;
			CMatrix Mplane;
			CPlane plane;
			CMatrix M;
			CVector view;
			CVector camera;
			CVector4 v4light,v1,v2;
			CVector tmp;
			CVector light;
			//HIC
			light=Lights[ActualVertexBuffer->iValue1].Pos;

			if (tagtmp) 
			{
				v4light.Init(light);
				M.Inverse4x4(VIEW);
				camera.Init(M.a[3][0],M.a[3][1],M.a[3][2]);
				view.Init(M.a[2][0],M.a[2][1],M.a[2][2]);
				view.Normalise();
				camera=camera + znear * view;
				plane.a=view.x; plane.b=view.y; plane.c=view.z; plane.d=-(view||camera);
	
				if (plane.Distance(light)<0) { plane.a=-view.x; plane.b=-view.y; plane.c=-view.z; plane.d=(view||camera); }

				Mplane.Id();
				Mplane.ShadowProjection(v4light,plane);
			}

			tmp.Init(ActualVertexBuffer->fValue1,0.0f,znear);

			VBEFF->setVector("VAR",tmp);
			VBEFF->setPoint("Light",light);
			VBEFF->setMatrixViewProj("VIEWPROJ");
			if (tagtmp) VBEFF->setMatrix("PROJNEARPLANE",Mplane);
			if (tagtmp) VBEFF->setMatrix("VIEW",VIEW);
			VBEFF->setMatrix("WORLD",WORLD);
			if (tagmorph) VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
			
			if (depthStencilState) depthStencilState->Release();

			depthStencilDesc.DepthEnable = true;
			depthStencilDesc.DepthWriteMask = D3D10_DEPTH_WRITE_MASK_ZERO;
			depthStencilDesc.DepthFunc = D3D10_COMPARISON_LESS_EQUAL;

			depthStencilDesc.StencilEnable = true;
			depthStencilDesc.StencilReadMask = 0xFF;
			depthStencilDesc.StencilWriteMask = 0xFF;

			if (states(ALGO_STENCIL_SHADOWING)==ALGO_REVERSE)
			{
				depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_INCR;
				depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

				depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_DECR;
				depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_ALWAYS;
			}
			else
			{
				depthStencilDesc.FrontFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.FrontFace.StencilPassOp = D3D10_STENCIL_OP_INCR;
				depthStencilDesc.FrontFace.StencilFunc = D3D10_COMPARISON_ALWAYS;

				depthStencilDesc.BackFace.StencilFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilDepthFailOp = D3D10_STENCIL_OP_KEEP;
				depthStencilDesc.BackFace.StencilPassOp = D3D10_STENCIL_OP_DECR;
				depthStencilDesc.BackFace.StencilFunc = D3D10_COMPARISON_ALWAYS;
			}

			device->CreateDepthStencilState(&depthStencilDesc, &depthStencilState);
			device->OMSetDepthStencilState(depthStencilState, 1);

			if (blendStateTMP) blendStateTMP->Release();
			blendStateDesc.BlendEnable[0]=true;
			blendStateDesc.SrcBlend=D3D10_BLEND_ZERO;
			blendStateDesc.DestBlend=D3D10_BLEND_ONE;
			blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
			blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
			blendStateDesc.SrcBlendAlpha=D3D10_BLEND_ZERO;
			blendStateDesc.DestBlendAlpha=D3D10_BLEND_ONE;
			device->CreateBlendState(&blendStateDesc,&blendStateTMP);
			device->OMSetBlendState(blendStateTMP,factors,0xFFFFFFFF);

			rasterState->Release();
			rasterDesc.CullMode = D3D10_CULL_NONE;
			device->CreateRasterizerState(&rasterDesc, &rasterState);
			device->RSSetState(rasterState);
		}
		else
		{
			// COLOR
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			if (ActualVertexBuffer->TypeVB==2)
			{
				VBEFF=&effect_hll_diffuse_nomap;
				VBEFF->setMatrixWorldViewProj("MODEL");
			}

			// COLORTEX
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			if ((ActualVertexBuffer->TypeVB==0)||(ActualVertexBuffer->TypeVB==1)||(ActualVertexBuffer->TypeVB==3))  
			{
				if (set_alphatest) VBEFF=&effect_hll_diffuse_alphatest; else VBEFF=&effect_hll_diffuse;
				SetBUILTINVertexBuffer(VBEFF);

				if (!ActualVertexBuffer->Grouped) VBEFF->setTexture("Tex",aT);
				
				VBEFF->setMatrixWorld("WORLD");
				VBEFF->setMatrixViewProj("VIEWPROJ");
			}

			// TNL
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			if ((ActualVertexBuffer->TypeVB==5)&&((ActualVertexBuffer->Type&API3D_ENVMAPPING)==0))
			{
				if (!Lighting) return;
				TNL=true;
				if (Specular)
				{
					CMatrix M;
					CVector camera;
					M.Inverse4x4(VIEW);
					camera.Init(M.a[3][0],M.a[3][1],M.a[3][2]);

					if (ActualVertexBuffer->Type&API3D_MORPH)
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_specular_morph_alphatest;
						else VBEFF=&effect_hll_TNL_specular_morph;
						SetBUILTINVertexBuffer(VBEFF);

						VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
					}
					else
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_specular_alphatest;
						else VBEFF=&effect_hll_TNL_specular;
						SetBUILTINVertexBuffer(VBEFF);
					}
					VBEFF->setVector("CAMERA",camera);
				}
				else
				{
					if (ActualVertexBuffer->Type&API3D_MORPH)
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_morph_alphatest;
						else VBEFF=&effect_hll_TNL_morph;
						SetBUILTINVertexBuffer(VBEFF);

						VBEFF->setFloat("Interpolant",ActualVertexBuffer->stream_interpolant);
					}
					else
					{
						if (set_alphatest) VBEFF=&effect_hll_TNL_alphatest;
						else VBEFF=&effect_hll_TNL;
						SetBUILTINVertexBuffer(VBEFF);
					}
				}

				VBEFF->setMatrixWorld("WORLD");
				VBEFF->setMatrixViewProj("VIEWPROJ");
				if (!ActualVertexBuffer->Grouped) VBEFF->setTexture("Tex",aT);

				CVector u,vb_Pos,vv;
				int numLights[64];
				float rLights[64];
				int nbreLights;
				int n1,n2;

				vb_Pos.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);
			
				nbreLights=0;
				for (n=0;n<1024;n++)
				{
					if (Lights[n].enabled==1)
					{
						if (nbreLights<64)
						{
							if (Lights[n].directionnal)
							{
								u=Lights[n].Pos;
								rLights[nbreLights]=VECTORNORM(u);
								numLights[nbreLights]=n;
								nbreLights++;
							}
							else
							{
								VECTORSUB(u,Lights[n].Pos,vb_Pos);
								rLights[nbreLights]=VECTORNORM(u);
								numLights[nbreLights]=n;
								nbreLights++;
							}
						}
					}
				}

				for (n1=0;n1<nbreLights;n1++)
					for (n2=n1+1;n2<nbreLights;n2++)
					{
						if (rLights[n2]<rLights[n1])
						{
							float r=rLights[n2];
							rLights[n2]=rLights[n1];
							rLights[n1]=r;
							int num=numLights[n2];
							numLights[n2]=numLights[n1];
							numLights[n1]=num;
						}
					}

				if (nbreLights>8) nbreLights=8;

				static char * nameLIGHT[8]={ "LIGHT1","LIGHT2","LIGHT3","LIGHT4","LIGHT5","LIGHT6","LIGHT7","LIGHT8" };
				static char * nameCOUL[8]={ "COUL1","COUL2","COUL3","COUL4","COUL5","COUL6","COUL7","COUL8" };

				CVector tmp;

				for (n=0;n<nbreLights;n++)
				{
					int nl=numLights[n];
					tmp.Init(Lights[nl].r,Lights[nl].g,Lights[nl].b);
					if (Lights[nl].directionnal)
					{
						vv=vb_Pos - 100.0f*Lights[nl].Pos;
						VBEFF->setVector(nameLIGHT[n],vv);
					}
					else VBEFF->setVector(nameLIGHT[n],Lights[nl].Pos);
					VBEFF->setPoint(nameCOUL[n],tmp);
				}

				if (nbreLights<8)
					for (n=nbreLights;n<8;n++)
					{
						tmp.Init(0,0,0);
						VBEFF->setVector(nameLIGHT[n],vb_Pos);
						VBEFF->setVector(nameCOUL[n],tmp);
					}

				tmp.Init(Ambient.r,Ambient.g,Ambient.b);
				VBEFF->setVector("AMBIENT",tmp);
				if (set_alphatest) VBEFF->setFloat("ALPHA",val_alphatest);

				if ((!ActualVertexBuffer->Grouped)&&(Specular))
				{
					float POW=20.0f;
					if (aT>=0)
                    if (iTexture[aT])
						if (iTexture[aT]->Material) POW = (float) iTexture[aT]->Material->power;
					VBEFF->setFloat("POWER",POW);
				}
			}

			// MULTITEXTURE
			///////////////////////////////////////////////////////////////////////////////////////////////////////////

			if ((ActualVertexBuffer->TypeVB==4)||(ActualVertexBuffer->TypeVB==6))
			{
				if (set_alphatest)
				{
					if ((LevelTexture0==0)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi00_at;
					if ((LevelTexture0==1)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi10_at;
					if ((LevelTexture0==0)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi01_at;
					if ((LevelTexture0==1)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi11_at;
				}
				else
				{					
					if ((LevelTexture0==0)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi00;
					if ((LevelTexture0==1)&&(LevelTexture1==0)) VBEFF=&effect_hll_multi10;
					if ((LevelTexture0==0)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi01;
					if ((LevelTexture0==1)&&(LevelTexture1==1)) VBEFF=&effect_hll_multi11;
				}

				SetBUILTINVertexBuffer(VBEFF);

				if (!ActualVertexBuffer->Grouped)
				{
					if (lT<0) VBEFF->setTexture("Tex1",aT); else VBEFF->setLightmap("Tex1",lT);
					if (lT<0) VBEFF->setTexture("Tex2",aT2); else VBEFF->setLightmap("Tex2",lT2);
				}

				VBEFF->setMatrixWorldViewProj("MODEL");
				if (set_alphatest) VBEFF->setFloat("ALPHA",val_alphatest);
			}
		}
	}

	int changeblend=PreviousBlend;
	int state_blending=states(BLENDING);
	int state_culling=states(CULLING);

	CVertexBuffer * vbeffect=NULL;

	PreviousRS.ZBuffer=PreviousRS.ZBufferWrite=_UNDEFINED;

	if (!ActualVertexBuffer->Grouped)
	{
		PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;

		if ((ActualVertexBuffer->Type&API3D_VERTEXPROGRAM)||(ActualEffect)||(VBEFF))
		{
			if (ActualEffect) vbeffect=ActualEffect;
			else vbeffect=ActualVertexBuffer;

			if (VBEFF) vbeffect=VBEFF;

			if (!vbeffect->layout)
			{
				D3D10_INPUT_ELEMENT_DESC LayoutDesc[16];
				int num=SetLayouts(ActualVertexBuffer,LayoutDesc);
				D3D10_PASS_DESC passDesc;
				vbeffect->tech->GetPassByIndex(0)->GetDesc(&passDesc);
				device->CreateInputLayout(LayoutDesc, num, passDesc.pIAInputSignature, passDesc.IAInputSignatureSize, &vbeffect->layout);
			}

			ID3D10Buffer* vbs[2];
			int nbvbs=1;

			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				nbvbs=2;

				if (ActualVertexBuffer->Type&API3D_STREAMS)
				{
					if (ActualVertexBuffer->stream1>=0) vbs[0]=ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream1];
					else vbs[0]=ActualVertexBuffer->D3DVB;

					if (ActualVertexBuffer->stream2>=0) vbs[1]=ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream2];
					else vbs[1]=ActualVertexBuffer->D3DVB;
				}
				else
				{
					vbs[0]=ActualVertexBuffer->D3DVB;
					vbs[1]=ActualVertexBuffer->STREAMS[0];
				}
			}
			else
			{
				vbs[0]=ActualVertexBuffer->D3DVB;
			}

			unsigned int strides[2];
			unsigned int offsets[2]={0,0};

			strides[0] = ActualVertexBuffer->_sizeVB;
			strides[1] = ActualVertexBuffer->_sizeVB;

			if (vbdraw_line)
			{
				device->IASetInputLayout(vbeffect->layout);
				device->IASetVertexBuffers(0, nbvbs, vbs, strides, offsets);
				device->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_LINELIST);

				D3D10_TECHNIQUE_DESC techniqueDesc;
				vbeffect->tech->GetDesc(&techniqueDesc);

				for(int p=0; p<(int)techniqueDesc.Passes; ++p)
				{
					vbeffect->tech->GetPassByIndex(p)->Apply(0);
					device->Draw(ActualVertexBuffer->nVerticesActif, 0);
				}
			}
			else
			{
				device->IASetInputLayout(vbeffect->layout);
				device->IASetVertexBuffers(0, nbvbs, vbs, strides, offsets);
				device->IASetIndexBuffer(ActualVertexBuffer->D3DINDEX, DXGI_FORMAT_R32_UINT, 0);
				device->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

				D3D10_TECHNIQUE_DESC techniqueDesc;
				vbeffect->tech->GetDesc(&techniqueDesc);

				for(int p=0; p<(int)techniqueDesc.Passes; ++p)
				{
					PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
					PreviousRS.RenderTarget=_UNDEFINED;
					SetRenderState(&vbeffect->vp->RenderState[vbeffect->vp->selected_tech][p],1);
					vbeffect->tech->GetPassByIndex(p)->Apply(0);
					device->DrawIndexed(ActualVertexBuffer->nIndicesActif, 0, 0);
				}

				if (state_culling==1) SetParams(API3D_CULL,CCW);
				else SetParams(API3D_CULL,CW);

				if (ActualVertexBuffer->Type&API3D_EDGESDG)
				{
					blendStateDesc.BlendEnable[0]=false;
					blendStateDesc.SrcBlend=D3D10_BLEND_ONE;
					blendStateDesc.DestBlend=D3D10_BLEND_ZERO;
					blendStateDesc.BlendOp=D3D10_BLEND_OP_ADD;
					blendStateDesc.BlendOpAlpha=D3D10_BLEND_OP_ADD;
					blendStateDesc.SrcBlendAlpha=D3D10_BLEND_ONE;
					blendStateDesc.DestBlendAlpha=D3D10_BLEND_ZERO;
				}
			}
		}
	}
	else
	{
		bool draw=true;
		// GROUPED

		int ra,rb;
		switch(states(ALPHA_MULTI_GROUP_DRAW))
		{
		case 0:
			ra=0;rb=0;
			break;
		case 1:
			ra=0;rb=2;
			break;
		case 2:
			ra=1;rb=2;
			break;
		};

		if (!ActualVertexBuffer->HasRef) ra=rb=0;

		if ((ActualVertexBuffer->Type&API3D_VERTEXPROGRAM)||(ActualEffect)||(VBEFF))
		{
			if (ActualEffect) vbeffect=ActualEffect;
			else vbeffect=ActualVertexBuffer;

			if (VBEFF) vbeffect=VBEFF;

			if (!vbeffect->layout)
			{
				D3D10_INPUT_ELEMENT_DESC LayoutDesc[16];
				int num=SetLayouts(ActualVertexBuffer,LayoutDesc);
				D3D10_PASS_DESC passDesc;
				vbeffect->tech->GetPassByIndex(0)->GetDesc(&passDesc);
				device->CreateInputLayout(LayoutDesc, num, passDesc.pIAInputSignature, passDesc.IAInputSignatureSize, &vbeffect->layout);
			}

			ID3D10Buffer* vbs[2];
			int nbvbs=1;

			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				nbvbs=2;
				if (ActualVertexBuffer->Type&API3D_STREAMS)
				{
					if (ActualVertexBuffer->stream1>=0) vbs[0]=ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream1];
					else vbs[0]=ActualVertexBuffer->D3DVB;

					if (ActualVertexBuffer->stream2>=0) vbs[1]=ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream2];
					else vbs[1]=ActualVertexBuffer->D3DVB;
				}
				else
				{
					vbs[0]=ActualVertexBuffer->D3DVB;
					vbs[1]=ActualVertexBuffer->STREAMS[0];
				}
			}
			else
			{
				vbs[0]=ActualVertexBuffer->D3DVB;
			}

			unsigned int strides[2];
			unsigned int offsets[2]={0,0};

			strides[0] = ActualVertexBuffer->_sizeVB;
			strides[1] = ActualVertexBuffer->_sizeVB;

			device->IASetInputLayout(vbeffect->layout);
			device->IASetVertexBuffers(0, nbvbs, vbs, strides, offsets);
			device->IASetIndexBuffer(ActualVertexBuffer->D3DINDEX, DXGI_FORMAT_R32_UINT, 0);
			device->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

			PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
			if ((ra==0)&&(state_blending!=0)&&(state_blending<3)) device->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);

			for (ref_value=ra;ref_value<=rb;ref_value++)
			{
				if (state_blending<3)
				{
					if (ref_value==1)
					{ 
						device->OMSetBlendState(blendStateON,factors,0xFFFFFFFF); changeblend=-1;
						PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
					}
					else
					if (ref_value==2)
					{ 
						device->OMSetBlendState(blendStateGOURAUD,factors,0xFFFFFFFF); changeblend=-1;
						PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;
					}
				}

				nfo=ActualVertexBuffer->ListeSE.GetFirst();
				while (nfo)
				{
					if ((nfo->ref==ref_value)&&(nfo->flag==valueflag))
					{

						if (ActualVertexBuffer->TypeVB==9)
						{
							draw=true;
							if (fn_stage_draw) 
								if (fn_stage_draw(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)==0) draw=false;

							if (states(RENDER_TARGET_OPTIONS)!=STENCIL)
							{
								if (draw)
								{
									if (fn_stage0) vbeffect->setLightmap("lightmap",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setLightmap("lightmap",nfo->nL);
								
									if (fn_stage1) vbeffect->setTexture("tex",fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setTexture("tex",nfo->nT+Decal_nt);
								
									if (fn_stage2) vbeffect->setLightmap("vectors",fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setLightmap("vectors",nfo->nLV);

									if (fn_stage3) vbeffect->setTexture("bump",fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setTexture("bump",nfo->nT+bumpmap_settexture);

									if (fn_stage4) vbeffect->setTexture("displace",fn_stage4(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setTexture("displace",nfo->nT+bump_displace);

									if (fn_stage5) vbeffect->setTexture("horizon",fn_stage5(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setTexture("horizon",nfo->nT+bump_horizon);
								}
							}
						}
						else
						if (ActualVertexBuffer->TypeVB==7)
						{
							draw=true;
							if (fn_stage_draw) 
								if (fn_stage_draw(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)==0) draw=false;

							if (states(RENDER_TARGET_OPTIONS)!=STENCIL)
							{
								if (draw)
								{	
									if (fn_stage0) vbeffect->setLightmap("lightmap",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setLightmap("lightmap",nfo->nL);
								
									if (fn_stage1) vbeffect->setTexture("tex",fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setTexture("tex",nfo->nT+Decal_nt);
								
									if (fn_stage2) vbeffect->setLightmap("vectors",fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setLightmap("vectors",nfo->nLV);

									if (fn_stage3) vbeffect->setTexture("bump",fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else vbeffect->setTexture("bump",nfo->nT+bumpmap_settexture);
								}
							}
						}
						else
						if (TNL)
						{
							vbeffect->setTexture("Tex",nfo->nT+Decal_nt);
							if (Specular)
							{
								float POW=20.0f;
                                if (iTexture[nfo->nT])
								if (iTexture[nfo->nT]->Material) POW = (float) iTexture[nfo->nT]->Material->power;
								vbeffect->setFloat("POWER",POW);
							}
						}
						else
						if ((ActualVertexBuffer->TypeVB==4)||(ActualVertexBuffer->TypeVB==6)||(ActualVertexBuffer->Type&API3D_ENVMAPPING))
						{
							if (ContextEffect)
							{
								draw=ContextEffect->update(vbeffect,nfo->nT,nfo->nT2,nfo->tag);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_NL]) vbeffect->setLightmap(vbeffect->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeffect->setLightmap(vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0], aT);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1], aT2);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2], aT3);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3], aT4);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4], aT5);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5], aT6);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6], aT7);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7], aT8);
							}
							else MultiTextureShaders(nfo,vbeffect);
						}
						else
						{
							if (ContextEffect)
							{
								draw=ContextEffect->update(vbeffect,nfo->nT,nfo->nT2,nfo->tag);

								DrawVertexBufferSetupSizeDest(vbeffect,nfo);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_NL]) if (nfo->nL>=0) vbeffect->res[TEXTURE_FROM_NL]->SetResource(Lightmap[nfo->nL]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS]) if (nfo->nLV>=0) vbeffect->res[TEXTURE_FROM_NLVECTORS]->SetResource(Lightmap[nfo->nLV]);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0]) if (aT>=0) vbeffect->res[TEXTURE_FROM_RENDER_0]->SetResource(Texture[aT]); else vbeffect->res[TEXTURE_FROM_RENDER_0]->SetResource(shaderResourceView[-(aT+1)]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1]) if (aT2>=0) vbeffect->res[TEXTURE_FROM_RENDER_1]->SetResource(Texture[aT2]); else vbeffect->res[TEXTURE_FROM_RENDER_1]->SetResource(shaderResourceView[-(aT2+1)]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2]) if (aT3>=0) vbeffect->res[TEXTURE_FROM_RENDER_2]->SetResource(Texture[aT3]); else vbeffect->res[TEXTURE_FROM_RENDER_2]->SetResource(shaderResourceView[-(aT3+1)]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3]) if (aT4>=0) vbeffect->res[TEXTURE_FROM_RENDER_3]->SetResource(Texture[aT4]); else vbeffect->res[TEXTURE_FROM_RENDER_3]->SetResource(shaderResourceView[-(aT4+1)]);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4]) if (aT5>=0) vbeffect->res[TEXTURE_FROM_RENDER_4]->SetResource(Texture[aT5]); else vbeffect->res[TEXTURE_FROM_RENDER_4]->SetResource(shaderResourceView[-(aT5+1)]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5]) if (aT6>=0) vbeffect->res[TEXTURE_FROM_RENDER_5]->SetResource(Texture[aT6]); else vbeffect->res[TEXTURE_FROM_RENDER_5]->SetResource(shaderResourceView[-(aT6+1)]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6]) if (aT7>=0) vbeffect->res[TEXTURE_FROM_RENDER_6]->SetResource(Texture[aT7]); else vbeffect->res[TEXTURE_FROM_RENDER_6]->SetResource(shaderResourceView[-(aT7+1)]);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7]) if (aT8>=0) vbeffect->res[TEXTURE_FROM_RENDER_7]->SetResource(Texture[aT8]); else vbeffect->res[TEXTURE_FROM_RENDER_7]->SetResource(shaderResourceView[-(aT8+1)]);
							}
							else
							{
								if (((ActualVertexBuffer->TypeVB==0)||(ActualVertexBuffer->TypeVB==1)||(ActualVertexBuffer->TypeVB==3))&&(VBEFF))
								{
									//vbeffect->setTexture("Tex",nfo->nT+Decal_nt);
									if (fn_stage0) vbeffect->setTexture("Tex",fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else
									{
										if ((nfo->nT+Decal_nt>=0)&&(nfo->nT+Decal_nt<NBRE_MAX_TEXTURES))
										if (cTexture[nfo->nT+Decal_nt]) vbeffect->setTexture("Tex",nfo->nT+Decal_nt);
									}
								}
								else
								{
									DrawVertexBufferSetupSizeDest(vbeffect,nfo);

									if (vbeffect->AssignedTexture[TEXTURE_FROM_NT]) vbeffect->res[TEXTURE_FROM_NT]->SetResource(Texture[nfo->nT+Decal_nt]);
                                    if (vbeffect->AssignedTexture[TEXTURE_FROM_NTPLUSONE]) vbeffect->res[TEXTURE_FROM_NTPLUSONE]->SetResource(Texture[nfo->nT+1+Decal_nt]);
									if (vbeffect->AssignedTexture[TEXTURE_FROM_NT2]) vbeffect->res[TEXTURE_FROM_NT2]->SetResource(Texture[nfo->nT2]);
									if (vbeffect->AssignedTexture[TEXTURE_FROM_BUMP]) vbeffect->res[TEXTURE_FROM_BUMP]->SetResource(Texture[nfo->nT+bumpmap_settexture]);
                                    if (vbeffect->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE]) vbeffect->res[TEXTURE_FROM_BUMPPLUSONE]->SetResource(Texture[nfo->nT+1+bumpmap_settexture]);

									if (vbeffect->AssignedTexture[TEXTURE_FROM_DISPLACE]) vbeffect->res[TEXTURE_FROM_DISPLACE]->SetResource(Texture[nfo->nT+bump_displace]);
									if (vbeffect->AssignedTexture[TEXTURE_FROM_HORIZON]) vbeffect->res[TEXTURE_FROM_HORIZON]->SetResource(Texture[nfo->nT+bump_horizon]);

									if (vbeffect->AssignedTexture[TEXTURE_FROM_NL]) if (nfo->nL>=0) vbeffect->res[TEXTURE_FROM_NL]->SetResource(Lightmap[nfo->nL]);
									if (vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS]) if (nfo->nLV>=0) vbeffect->res[TEXTURE_FROM_NLVECTORS]->SetResource(Lightmap[nfo->nLV]);

									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0])&&(vbeffect->res[TEXTURE_FROM_RENDER_0])) if (aT>=0) vbeffect->res[TEXTURE_FROM_RENDER_0]->SetResource(Texture[aT]); else vbeffect->res[TEXTURE_FROM_RENDER_0]->SetResource(shaderResourceView[-(aT+1)]);
									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1])&&(vbeffect->res[TEXTURE_FROM_RENDER_1])) if (aT2>=0) vbeffect->res[TEXTURE_FROM_RENDER_1]->SetResource(Texture[aT2]); else vbeffect->res[TEXTURE_FROM_RENDER_1]->SetResource(shaderResourceView[-(aT2+1)]);
									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2])&&(vbeffect->res[TEXTURE_FROM_RENDER_2])) if (aT3>=0) vbeffect->res[TEXTURE_FROM_RENDER_2]->SetResource(Texture[aT3]); else vbeffect->res[TEXTURE_FROM_RENDER_2]->SetResource(shaderResourceView[-(aT3+1)]);
									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3])&&(vbeffect->res[TEXTURE_FROM_RENDER_3])) if (aT4>=0) vbeffect->res[TEXTURE_FROM_RENDER_3]->SetResource(Texture[aT4]); else vbeffect->res[TEXTURE_FROM_RENDER_3]->SetResource(shaderResourceView[-(aT4+1)]);

									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4])&&(vbeffect->res[TEXTURE_FROM_RENDER_4])) if (aT5>=0) vbeffect->res[TEXTURE_FROM_RENDER_4]->SetResource(Texture[aT5]); else vbeffect->res[TEXTURE_FROM_RENDER_4]->SetResource(shaderResourceView[-(aT5+1)]);
									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5])&&(vbeffect->res[TEXTURE_FROM_RENDER_5])) if (aT6>=0) vbeffect->res[TEXTURE_FROM_RENDER_5]->SetResource(Texture[aT6]); else vbeffect->res[TEXTURE_FROM_RENDER_5]->SetResource(shaderResourceView[-(aT6+1)]);
									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6])&&(vbeffect->res[TEXTURE_FROM_RENDER_6])) if (aT7>=0) vbeffect->res[TEXTURE_FROM_RENDER_6]->SetResource(Texture[aT7]); else vbeffect->res[TEXTURE_FROM_RENDER_6]->SetResource(shaderResourceView[-(aT7+1)]);
									if ((vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7])&&(vbeffect->res[TEXTURE_FROM_RENDER_7])) if (aT8>=0) vbeffect->res[TEXTURE_FROM_RENDER_7]->SetResource(Texture[aT8]); else vbeffect->res[TEXTURE_FROM_RENDER_7]->SetResource(shaderResourceView[-(aT8+1)]);
								}
							}
						}

						if ((vbeffect->effect)&&(draw))
						{
							D3D10_TECHNIQUE_DESC techniqueDesc;
							vbeffect->tech->GetDesc(&techniqueDesc);

							for(int p=0; p<(int)techniqueDesc.Passes; ++p)
							{
								SetRenderState(&vbeffect->vp->RenderState[vbeffect->vp->selected_tech][p],0);
								vbeffect->tech->GetPassByIndex(p)->Apply(0);
								device->DrawIndexed((nfo->iEnd-nfo->iStart), nfo->iStart, 0);
							}
						}
					}
					nfo=ActualVertexBuffer->ListeSE.GetNext();
				}
			}
		}
	}

	if ((MachineState==0)||(PreviousBlend!=changeblend))
	{
		PreviousRS.Blend=PreviousRS.SrcBlend=PreviousRS.DstBlend=_UNDEFINED;

		switch (state_blending)
		{
		case 0:
			device->OMSetBlendState(blendStateOFF,factors,0xFFFFFFFF);
			break;
		case 1:
			device->OMSetBlendState(blendStateON,factors,0xFFFFFFFF);
			break;
		case 2:
			device->OMSetBlendState(blendStateGOURAUD,factors,0xFFFFFFFF);
			break;
		case 3:
			device->OMSetBlendState(blendStateCOLOR,factors,0xFFFFFFFF);
			break;
		case 4:
			device->OMSetBlendState(blendStateINVERSE,factors,0xFFFFFFFF);
			break;
		case 5:
			device->OMSetBlendState(blendStateADD,factors,0xFFFFFFFF);
			break;
		};

		*states[BLENDING]=state_blending;
	}

	if (MachineState==0)
	{
		if (state_culling==1) SetParams(API3D_CULL,CCW);
		else SetParams(API3D_CULL,CW);
	}

	return;
#else

#ifdef API3D_OPENGL
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// OPEN GL 1.0
	int type,n,nl;
	int temp;
	CVector u,Pos,vb_Pos;
	CMatrix M;
	float color[]={1.0f,1.0f,1.0f,1.0f};
	float position[4];
	float color2[4];
	int numLights[64];
	float rLights[64];
	int nbreLights;
	int n1,n2;
	int num;
	float r;
	float *pVertices,*pNormals,*pColor,*pColor2,*pTexCoo,*pTexCoo2,*pTexCoo3,*pWeights,*pVertices2,*pNormals2;
	unsigned char *pMatrixIndices;
	int sizec,sizec2;

	if ((!SecondarySurface)&&(SelectedRenderTarget>0)) return;	

	type=ActualVertexBuffer->Type;

	if (ActualVertexBuffer->vbo)
	{
		glBindBufferARB(GL_ARRAY_BUFFER,ActualVertexBuffer->VB);
		glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER,ActualVertexBuffer->IB);
	}

	if (!((type&API3D_VERTEXPROGRAM)||(ActualEffect)))
	{
		if (Lighting)
		{
			color2[0]=Ambient.r;
			color2[1]=Ambient.g;
			color2[2]=Ambient.b;
			color2[3]=1;
			
			glLightModelfv(GL_LIGHT_MODEL_AMBIENT,color2);
#ifndef GLES
			glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,0);
			
			if (Specular)
				glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL,GL_SEPARATE_SPECULAR_COLOR);
			else
				glLightModeli(GL_LIGHT_MODEL_COLOR_CONTROL,GL_SINGLE_COLOR);
#endif

			glEnable(GL_NORMALIZE);
			//glEnable(GL_RESCALE_NORMAL);

			vb_Pos.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);
			
			M.Inverse4x4(WORLD);

			nbreLights=0;
			for (n=0;n<64;n++)
			{
				if (Lights[n].enabled==1)
				{
					u=Lights[n].Pos - vb_Pos;
					rLights[nbreLights]=u.Norme();
					numLights[nbreLights]=n;
					nbreLights++;
				}
			}


			for (n1=0;n1<nbreLights;n1++)
				for (n2=n1+1;n2<nbreLights;n2++)
				{
					if (rLights[n2]<rLights[n1])
					{
						r=rLights[n2];
						rLights[n2]=rLights[n1];
						rLights[n1]=r;

						num=numLights[n2];
						numLights[n2]=numLights[n1];
						numLights[n1]=num;
							
					}
				}

			if (nbreLights>8) nbreLights=8;
			
			nl=0;
			for (n1=0;n1<nbreLights;n1++)
			{
				n=numLights[n1];
				Pos=Lights[n].Pos*M;


				if (Lights[n].directionnal) 
				{
					position[3]=0.0f;
					position[0]=Pos.x;
					position[1]=Pos.y;
					position[2]=-Pos.z;	// BUG

				}
				else 
				{
					position[0]=Pos.x;
					position[1]=Pos.y;
					position[2]=Pos.z;
					position[3]=M.a[0][3]*Lights[n].Pos.x + M.a[1][3]*Lights[n].Pos.y + M.a[2][3]*Lights[n].Pos.z + M.a[3][3];
				}

				glLightfv(GL_LIGHT0+nl,GL_AMBIENT,Lights[n].color);
				glLightfv(GL_LIGHT0+nl,GL_DIFFUSE,Lights[n].color);
				glLightfv(GL_LIGHT0+nl,GL_SPECULAR,Lights[n].specular);
				glLightfv(GL_LIGHT0+nl,GL_POSITION,position);
				glEnable(GL_LIGHT0+nl);
				
				glLightf(GL_LIGHT0+nl,GL_CONSTANT_ATTENUATION,1);
				glLightf(GL_LIGHT0+nl,GL_LINEAR_ATTENUATION,0.1f*Lights[n].Attenuation);
				glLightf(GL_LIGHT0+nl,GL_QUADRATIC_ATTENUATION,0);
				nl++;
			}

			for (n=nl;n<8;n++) glDisable(GL_LIGHT0+n);
			glEnable(GL_LIGHTING);

			glDisable(GL_COLOR_MATERIAL);

			temp=0;
			if ((aT>=0)&&(aT<NBRE_MAX_TEXTURES))
			{
				if ((iTexture[aT])&&(cTexture[aT]))
				{
					if (iTexture[aT]->Material)
					{
						glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,iTexture[aT]->Material->specular);
						glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,iTexture[aT]->Material->diffuse);
						glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,iTexture[aT]->Material->ambient);
#ifndef GLES
						glMateriali(GL_FRONT_AND_BACK,GL_SHININESS,iTexture[aT]->Material->power);	
#endif
						temp=1;
					}
				}
			}
			
			if (temp==0)
			{
				glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,color);
				glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,color);
				glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,color2);
#ifndef GLES
				glMateriali(GL_FRONT_AND_BACK,GL_SHININESS,20);
#endif
			}

		}
		else
		{
			for (n=0;n<8;n++) glDisable(GL_LIGHT0+n);
			glDisable(GL_LIGHTING);
			glDisable(GL_COLOR_MATERIAL);
		}

		if (type&API3D_COLORDATAS) 
		{
			glEnableClientState(GL_COLOR_ARRAY);
			glColorPointer(4,GL_FLOAT,0,ActualVertexBuffer->Color_Array);
		}
		else
		{
#ifndef GLES
				glColor3f(1,1,1);
#endif
		}

	
		if (!(type&API3D_TEXCOODATAS2))
		{
			if (type&API3D_TEXCOO2LIGHTMAP)
			{
#ifndef GLES
				if ((type&API3D_TEXCOODATAS)&&(MultiTexture))
				{
					glClientActiveTextureARB(GL_TEXTURE1_ARB);
					glEnableClientState(GL_TEXTURE_COORD_ARRAY);
					glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);
				}
#endif
				if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE0_ARB);
				glEnableClientState(GL_TEXTURE_COORD_ARRAY);
				glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo2_Array);

				if (MultiTexture) glActiveTextureARB(GL_TEXTURE0_ARB);
				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,LevelTexture0);
				glEnable(GL_TEXTURE_2D);
				if (MultiTexture) 
				{
					glActiveTextureARB(GL_TEXTURE1_ARB);
					glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,LevelTexture1);
					glEnable(GL_TEXTURE_2D);
				}
			}
			else
			{
				if (type&API3D_TEXCOODATAS)
				{
					if (type&API3D_EDGESDG)
					{
						float t=ActualVertexBuffer->stream_interpolant;
						float s,d;
						CVector N,L,u,p,pp,p1,p2,r;
						CMatrix M;
						unsigned int adr;
						float znear=Front+0.1f;
#ifndef GLES
						if (G_VertexProgram_ShadowVolume)
						{
							if (vp_stencilshadow==0)
							{
#ifdef OPENGL_GLSL
								glslprogram_sv = glCreateProgramObjectARB();
								int ok=0;
								vert_shader_sv = glCreateShaderObjectARB(GL_VERTEX_SHADER);
								glShaderSourceARB(vert_shader_sv,1,(const GLcharARB**)&vertexprogram_stencilshadow,0);
								glCompileShaderARB(vert_shader_sv);
								glGetObjectParameterivARB(vert_shader_sv, GL_OBJECT_COMPILE_STATUS_ARB, &ok);
								if (ok)
								{
									glAttachObjectARB(glslprogram_sv,vert_shader_sv);
									glLinkProgramARB(glslprogram_sv);
									glValidateProgramARB(glslprogram_sv);
									vp_stencilshadow=1;
								}
								else G_VertexProgram_ShadowVolume=false;
#endif
							}
						}
#endif

						if (!G_VertexProgram_ShadowVolume)
						{
							M.Inverse4x4(WORLD);

							L=Lights[ActualVertexBuffer->iValue1].Pos*M;
							d=ActualVertexBuffer->fValue1;

							if (states(ALGO_STENCIL_SHADOWING)==1)
							{
								
								adr=0;
								for (n=0;n<ActualVertexBuffer->nVerticesActif;n++)
								{
									getVertexFromBuffer(n,ActualVertexBuffer,p,N);
									VECTORSUB(u,p,L);
									DOTPRODUCT(s,u,N);
									s=s*ActualVertexBuffer->TexCoo_Array[n*2+0];
									VECTORMUL(u,u,(s<=0)*d);
									VECTORADD(p,p,u);
									ActualVertexBuffer->Vertex2_Array[adr+0]=p.x;
									ActualVertexBuffer->Vertex2_Array[adr+1]=p.y;
									ActualVertexBuffer->Vertex2_Array[adr+2]=p.z;
									adr+=3;
								}

							}
							else
							{

								if (states(ALGO_STENCIL_SHADOWING)==2)
								{
								
									CVertexBuffer *vb=ActualVertexBuffer;

									adr=0;
									for (n=0;n<vb->nVerticesActif;n++)
									{
										getVertexFromBuffer(n,vb,p,N);
										VECTORSUB(u,p,L);
										DOTPRODUCT(s,u,N);
										s=s*vb->TexCoo_Array[(n<<1)+0];
										VECTORMUL(u,u,(s<0)*d);
										VECTORADD(p,p,u);
										vb->Vertex2_Array[adr+0]=p.x;
										vb->Vertex2_Array[adr+1]=p.y;
										vb->Vertex2_Array[adr+2]=p.z;
										adr+=3;
									}
								}
								else
								{
									
									CVertexBuffer *vb=ActualVertexBuffer;

									// glalternative

									CMatrix Mplane;
									CPlane plane;
									CMatrix mm;
									CVector view;
									CVector camera;
									CVector4 v4light,v1,v2;
									CVector posObject;

									posObject.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);

									n=ActualVertexBuffer->iValue1;

									v4light.Init(Lights[n].Pos);

									M.Inverse4x4(VIEW);	
									
									camera.Init(M.a[3][0],M.a[3][1],M.a[3][2]);

									view.Init(M.a[2][0],M.a[2][1],M.a[2][2]);
									view.Normalise();

									camera=camera+znear*view;

									plane.a=view.x;
									plane.b=view.y;
									plane.c=view.z;
									plane.d=-(view||camera);

									if (states(TRIVIAL_ELIMINATION_STENCIL))
									{					
										if ((plane.Distance(posObject)<0)&&(plane.Distance(Lights[n].Pos)>0))
										{
											if (ActualVertexBuffer->vbo)
											{
												glBindBufferARB(GL_ARRAY_BUFFER,0);
												glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER,0);
											}

											return;
										}
									}

									if (plane.Distance(Lights[n].Pos)<0)
									{
										plane.a=-view.x;
										plane.b=-view.y;
										plane.c=-view.z;
										plane.d=(view||camera);
									}

									Mplane.Id();
									Mplane.ShadowProjection(v4light,plane);

									if (vb->Type&API3D_MORPH)
									{										
										adr=0;
										for (n=0;n<vb->nVerticesActif;n++)
										{
											getVertexFromBuffer_m(n,vb,&p,&N,t);
											VECTORSUB(u,p,L);
											DOTPRODUCT(s,u,N);
											s=s*vb->TexCoo_Array[(n<<1)+0];
											VECTORMUL(r,u,(s<0)*d);

											VECTORADD(pp,p,r);
											VECTOR3MATRIX(p,pp,WORLD);
											VECTOR3MATRIX(p1,p,VIEW);
											if (p1.z<znear) 
											{
												v2.Init(p);
												VECTOR4MATRIX(v1,v2,Mplane);
												p.Init(v1.x,v1.y,v1.z);
											}
											vb->Vertex2_Array[adr+0]=p.x;
											vb->Vertex2_Array[adr+1]=p.y;
											vb->Vertex2_Array[adr+2]=p.z;
											adr+=3;
										}

									}
									else
									{
										// ALTERNATIVE NO MORPH

										if (vb->nIndicesActif<vb->nIndices)
										{
											adr=0;
											for (n=0;n<vb->secondary_vertex_pos;n++)
											{
												getVertexFromBuffer(n,vb,p,N);
												VECTORSUB(u,p,L);
												DOTPRODUCT(s,u,N);
												s=s*vb->TexCoo_Array[(n<<1)+0];
												VECTORMUL(r,u,(s<0)*d);
												VECTORADD(pp,p,r);
												VECTOR3MATRIX(p,pp,WORLD);
												vb->Vertex2_Array[adr+0]=p.x;
												vb->Vertex2_Array[adr+1]=p.y;
												vb->Vertex2_Array[adr+2]=p.z;
												adr+=3;
											}
										}
										else
										{
										
											adr=0;
											for (n=0;n<vb->nVerticesActif;n++)
											{
												getVertexFromBuffer(n,vb,p,N);
												VECTORSUB(u,p,L);
												DOTPRODUCT(s,u,N);
												s=s*vb->TexCoo_Array[(n<<1)+0];
												VECTORMUL(r,u,(s<0)*d);
												VECTORADD(pp,p,r);
												VECTOR3MATRIX(p,pp,WORLD);
												VECTOR3MATRIX(p1,p,VIEW);
												if (p1.z<znear) 
												{
													v2.x=p.x; v2.y=p.y; v2.z=p.z; v2.w=1.0f;
													VECTOR4MATRIX(v1,v2,Mplane);
													p.Init(v1.x,v1.y,v1.z);
													vb->Vertex2_Array[adr+0]=v1.x;
													vb->Vertex2_Array[adr+1]=v1.y;
													vb->Vertex2_Array[adr+2]=v1.z;
												}
												else
												{
													vb->Vertex2_Array[adr+0]=p.x;
													vb->Vertex2_Array[adr+1]=p.y;
													vb->Vertex2_Array[adr+2]=p.z;
												}
												adr+=3;
											}
										}
									}
								}
							}
						}
					}
					else
					if (type&API3D_ENVMAPPING)
					{
						float s,s1,s2;
						
						CVector N,v,cpos;
						CVector p,u,ldir,ldir2,u2;
						CMatrix ML,W3x3;

						M.Inverse4x4(VIEW);
						cpos.Init(M.a[3][0],M.a[3][1],M.a[3][2]);

						if (states(SHADERS)==1)
						{
							u2.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);


							n=GetCloserLight(this,u2);
							if (n>=0)
							{
								u2=u2-Lights[n].Pos;
								u2.Normalise();
							}
							else
							{
								u2.Init(0,0,0);
							}
							ldir.x=u2.x;	
							ldir.y=u2.y;
							ldir.z=u2.z;
							
							u2.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);

							n=GetSecondCloserLight(this,n,u2);
							if (n>=0)
							{
								u2=u2-Lights[n].Pos;
								u2.Normalise();
							}
							else
							{
								u2.Init(0,0,0);
							}
							ldir2.x=u2.x;	
							ldir2.y=u2.y;
							ldir2.z=u2.z;
						}
						else
						{

							ldir.Init(WORLD.a[3][0] - ActualVertexBuffer->L.x,WORLD.a[3][1] - ActualVertexBuffer->L.y,WORLD.a[3][2]- ActualVertexBuffer->L.z);
							ldir.Normalise();
							ldir2.Init(0,0,0);
						}


						u.Init(WORLD.a[3][0] - ActualVertexBuffer->L.x,WORLD.a[3][1] - ActualVertexBuffer->L.y,WORLD.a[3][2] - ActualVertexBuffer->L.z);

						CVector pz;

						pz.Init(0,0,0);

						ML.Id();
						ML.View(pz,-1*u,0);
				
						W3x3=WORLD;
						W3x3.a[3][0]=0;
						W3x3.a[3][1]=0;
						W3x3.a[3][2]=0;

						M=W3x3;

						if (aT>=0)
						{
							if (states(SHADERS)==1)
							{

								for (n=0;n<ActualVertexBuffer->nVerticesActif;n++)
								{
									p.Init(ActualVertexBuffer->Vertex_Array[n*3+0],ActualVertexBuffer->Vertex_Array[n*3+1],ActualVertexBuffer->Vertex_Array[n*3+2]);
									N.Init(-ActualVertexBuffer->Normal_Array[n*3+0],-ActualVertexBuffer->Normal_Array[n*3+1],-ActualVertexBuffer->Normal_Array[n*3+2]);
									VECTOR3MATRIX(v,N,M);
       								VECTOR3MATRIX(u,p,WORLD);
									VECTORSUB(u,u,ActualVertexBuffer->L);
									VECTORNORMALISE(u);
									u=2*v+u;
									VECTORNORMALISE(u);
									VECTORNEG(u);
									VECTOR3MATRIX(u,u,ML);
									ActualVertexBuffer->TexCoo2_Array[n*2+0]=u.x*0.5f + 0.5f;
									ActualVertexBuffer->TexCoo2_Array[n*2+1]=(u.y*0.5f + 0.5f);
									VECTOR3MATRIX(v,N,W3x3);
									s1=DOT(v,ldir);
									s2=DOT(v,ldir2);
									if (s1<0) s1=0;
									if (s2<0) s2=0;
									s=s1+s2;
									if (s>1) s=1;
									ActualVertexBuffer->Color_Array[n*4 + 0]=s;
									ActualVertexBuffer->Color_Array[n*4 + 1]=s;
									ActualVertexBuffer->Color_Array[n*4 + 2]=s;
									ActualVertexBuffer->Color_Array[n*4 + 3]=1.0f;
								}
							}
							else
							{

								for (n=0;n<ActualVertexBuffer->nVerticesActif;n++)
								{
									N.Init(-ActualVertexBuffer->Normal_Array[n*3+0],-ActualVertexBuffer->Normal_Array[n*3+1],-ActualVertexBuffer->Normal_Array[n*3+2]);
									VECTOR3MATRIX(v,N,M);
									CVector vt=v;
									VECTOR3MATRIX(v,N,W3x3);
									s=DOT(v,ldir);
									if (s<0) { s=-s; }
									
									s=1;
									
									ActualVertexBuffer->TexCoo2_Array[n*2+0]=vt.z*0.5f + 0.5f;
									ActualVertexBuffer->TexCoo2_Array[n*2+1]=(vt.y*0.5f + 0.5f);

									ActualVertexBuffer->Color_Array[n*4 + 0]=s;
									ActualVertexBuffer->Color_Array[n*4 + 1]=s;
									ActualVertexBuffer->Color_Array[n*4 + 2]=s;
									ActualVertexBuffer->Color_Array[n*4 + 3]=1.0f;
								}
							}

						}
						else
						{
							if (states(SHADERS)==1)
							{
								for (n=0;n<ActualVertexBuffer->nVerticesActif;n++)
								{
									p.Init(ActualVertexBuffer->Vertex_Array[n*3+0],ActualVertexBuffer->Vertex_Array[n*3+1],ActualVertexBuffer->Vertex_Array[n*3+2]);
									N.Init(-ActualVertexBuffer->Normal_Array[n*3+0],-ActualVertexBuffer->Normal_Array[n*3+1],-ActualVertexBuffer->Normal_Array[n*3+2]);
									
									VECTOR3MATRIX(v,N,M);
       								VECTOR3MATRIX(u,p,WORLD);
									VECTORSUB(u,u,ActualVertexBuffer->L);
									VECTORNORMALISE(u);
									u=2*v+u;
									VECTORNORMALISE(u);
									VECTORNEG(u);
									VECTOR3MATRIX(u,u,ML);
									
									
									ActualVertexBuffer->TexCoo2_Array[n*2+0]=(u.x*0.5f + 0.5f);
									ActualVertexBuffer->TexCoo2_Array[n*2+1]=1-(u.y*0.5f + 0.5f);
									
									VECTOR3MATRIX(v,N,W3x3);
									
									s1=DOT(v,ldir);
									s2=DOT(v,ldir2);
									if (s1<0) s1=0;
									if (s2<0) s2=0;
									s=s1+s2;
									if (s>1) s=1;
							
									ActualVertexBuffer->Color_Array[n*4 + 0]=s;
									ActualVertexBuffer->Color_Array[n*4 + 1]=s;
									ActualVertexBuffer->Color_Array[n*4 + 2]=s;
									ActualVertexBuffer->Color_Array[n*4 + 3]=1.0f;
								}
							}
							else
							{

								for (n=0;n<ActualVertexBuffer->nVerticesActif;n++)
								{
									N.Init(-ActualVertexBuffer->Normal_Array[n*3+0],-ActualVertexBuffer->Normal_Array[n*3+1],-ActualVertexBuffer->Normal_Array[n*3+2]);
									v=N*M;
									ActualVertexBuffer->TexCoo2_Array[n*2+0]=v.x*0.5f + 0.5f;
									ActualVertexBuffer->TexCoo2_Array[n*2+1]=1-(v.y*0.5f + 0.5f);
									
									VECTOR3MATRIX(v,N,W3x3);
									s=DOT(v,ldir);
									if (s<0) s=0;
									ActualVertexBuffer->Color_Array[n*4 + 0]=s;
									ActualVertexBuffer->Color_Array[n*4 + 1]=s;
									ActualVertexBuffer->Color_Array[n*4 + 2]=s;
									ActualVertexBuffer->Color_Array[n*4 + 3]=1.0f;
								}
							}

						}

						int nt1,nt2;

						nt1=aT;
						nt2=aT2;
						SetTexture(nt2);
						SetTexture2(nt1);
						

						glEnableClientState(GL_COLOR_ARRAY);
						glColorPointer(4,GL_FLOAT,0,ActualVertexBuffer->Color_Array);

						if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE0_ARB);
						glEnableClientState(GL_TEXTURE_COORD_ARRAY);
						glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);

						
						if (MultiTexture) glActiveTextureARB(GL_TEXTURE0_ARB);
						glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
						glEnable(GL_TEXTURE_2D);

						if (MultiTexture) 
						{
							glClientActiveTextureARB(GL_TEXTURE1_ARB);
							glEnableClientState(GL_TEXTURE_COORD_ARRAY);
							glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo2_Array);
							glEnable(GL_TEXTURE_2D);
							glActiveTextureARB(GL_TEXTURE1_ARB);
							glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_ADD);
						}


					}
					else
					{

						if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE0_ARB);
						glEnableClientState(GL_TEXTURE_COORD_ARRAY);
						glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);

						
						if (MultiTexture) glActiveTextureARB(GL_TEXTURE0_ARB);
						glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
						glEnable(GL_TEXTURE_2D);

						if (MultiTexture) 
						{
							glActiveTextureARB(GL_TEXTURE1_ARB);
							glDisable(GL_TEXTURE_2D);
						}
					}
				}
			}
		}
		else
		{
			if (type&API3D_TEXCOODATAS)
			{
				if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE0_ARB);
				glEnableClientState(GL_TEXTURE_COORD_ARRAY);
				glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);
				glEnable(GL_TEXTURE_2D);
			}

			if (MultiTexture) 
			{
				glClientActiveTextureARB(GL_TEXTURE1_ARB);
				glEnableClientState(GL_TEXTURE_COORD_ARRAY);
				glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo2_Array);
			
				glActiveTextureARB(GL_TEXTURE0_ARB);
			}

			glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,LevelTexture0);
			if (MultiTexture) 
			{
				glActiveTextureARB(GL_TEXTURE1_ARB);
				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,LevelTexture1);
			}
		}

#if (!defined(GLES))&&(!defined(GLES2))
		if ((type&API3D_EDGESDG)&&(G_VertexProgram_ShadowVolume))
		{
			if (vp_stencilshadow)
			{
				int vertex,normal,texcoo0,loc;

				glUseProgramObjectARB(glslprogram_sv);

				loc=vertex=glGetAttribLocationARB(glslprogram_sv, "VertexPosition");
				glEnableVertexAttribArrayARB(loc);
				glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,ActualVertexBuffer->Vertex_Array);

				loc=normal=glGetAttribLocationARB(glslprogram_sv, "VertexNormal");
				glEnableVertexAttribArrayARB(loc);
				glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,ActualVertexBuffer->Normal_Array);

				loc=texcoo0=glGetAttribLocationARB(glslprogram_sv, "MultiTexCoord0");
				glEnableVertexAttribArrayARB(loc);
				glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,ActualVertexBuffer->TexCoo_Array);


				float znear=Front+0.1f;
				CMatrix Mplane;
				CPlane plane;
				CMatrix mm;
				CVector view;
				CVector camera;
				CVector4 v4light,v1,v2;
				CVector posObject;

				posObject.Init(WORLD.a[3][0],WORLD.a[3][1],WORLD.a[3][2]);

				n=ActualVertexBuffer->iValue1;

				v4light.Init(Lights[n].Pos);

				M.Inverse4x4(VIEW);	
									
				camera.Init(M.a[3][0],M.a[3][1],M.a[3][2]);

				view.Init(M.a[2][0],M.a[2][1],M.a[2][2]);
				view.Normalise();

				camera=camera+znear*view;

				plane.a=view.x;
				plane.b=view.y;
				plane.c=view.z;
				plane.d=-(view||camera);

				if (states(TRIVIAL_ELIMINATION_STENCIL))
				{					
					if ((plane.Distance(posObject)<0)&&(plane.Distance(Lights[n].Pos)>0))
					{
						if (ActualVertexBuffer->vbo)
						{
							glBindBufferARB(GL_ARRAY_BUFFER,0);
							glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER,0);
						}

						return;
					}
				}

				if (plane.Distance(Lights[n].Pos)<0)
				{
					plane.a=-view.x;
					plane.b=-view.y;
					plane.c=-view.z;
					plane.d=(view||camera);
				}

				Mplane.Id();
				Mplane.ShadowProjection(v4light,plane);

				float d=ActualVertexBuffer->fValue1;

				loc=glGetUniformLocationARB(glslprogram_sv,"Light");
				glUniform4f(loc,v4light.x,v4light.y,v4light.z,v4light.w);

				loc=glGetUniformLocationARB(glslprogram_sv,"VAR");
				glUniform4f(loc,d,0.0f,znear,0.0f);


				GLfloat _mm[16],m[16],proj[16];
				CMatrix M;

				int i,j,k;

				M=pVIEW;
				for (i=0;i<4;i++)
					for (j=0;j<4;j++) _mm[i+4*j]=M.a[j][i];

				glGetFloatv(GL_PROJECTION_MATRIX, proj);

				for (i=0;i<4;i++)
					for (j=0;j<4;j++) 
					{
						m[i+4*j]=0.0f;
						for (k=0;k<4;k++) m[i+4*j]+=proj[i+4*k]*_mm[k+4*j];
					}


				loc=glGetUniformLocationARB(glslprogram_sv,"VIEWPROJ");
				glUniformMatrix4fv(loc,1,false,m);
				loc=glGetUniformLocationARB(glslprogram_sv,"VIEW");
				glUniformMatrix4fv(loc,1,false,cnv_matrix(VIEW));
				loc=glGetUniformLocationARB(glslprogram_sv,"WORLD");
				glUniformMatrix4fv(loc,1,false,cnv_matrix(WORLD));
				loc=glGetUniformLocationARB(glslprogram_sv,"PROJNEARPLANE");
				glUniformMatrix4fv(loc,1,false,cnv_matrix(Mplane));
				
				SetParams(API3D_RENDERTARGET,STENCIL);
				SetParams(API3D_ZBUFFER,ON);
				SetParams(API3D_ZBUFFER,WRITEOFF);
				SetParams(API3D_CULL,CW);
				SetParams(API3D_STENCIL,INCREMENT);
				
				glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);

				SetParams(API3D_RENDERTARGET,STENCIL);
				SetParams(API3D_ZBUFFER,ON);
				SetParams(API3D_ZBUFFER,WRITEOFF);
				SetParams(API3D_CULL,CCW);
				SetParams(API3D_STENCIL,DECREMENT);
				
				glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);


				glDisableVertexAttribArrayARB(vertex);
				glDisableVertexAttribArrayARB(normal);
				glDisableVertexAttribArrayARB(texcoo0);

				glUseProgramObjectARB(0);

			}
		}
		else
#endif
		{
			float t=ActualVertexBuffer->stream_interpolant;

			if ((type&API3D_NORMALDATAS)&&(!(type&API3D_ENVMAPPING)))
			{
				if (type&API3D_STREAMS)
				{
				}
				else
				{
					if (type&API3D_MORPH)
					{
						for (n=0;n<ActualVertexBuffer->nVerticesActif*3;n++) ActualVertexBuffer->temp_normals[n]=ActualVertexBuffer->Normal_Array[n]*(1-t) + ActualVertexBuffer->streams_norms[0][n]*t;
						glEnableClientState(GL_NORMAL_ARRAY);
						glNormalPointer(GL_FLOAT,0,ActualVertexBuffer->temp_normals);
					}
					else
					{
						glEnableClientState(GL_NORMAL_ARRAY);
						glNormalPointer(GL_FLOAT,0,ActualVertexBuffer->Normal_Array);
					}
				}
			}


			if (type&API3D_VERTEXDATAS)
			{
				if (type&API3D_EDGESDG)
				{
					glEnableClientState(GL_VERTEX_ARRAY);
					glVertexPointer(3,GL_FLOAT,0,ActualVertexBuffer->Vertex2_Array);
				}
				else
				{
					if (type&API3D_STREAMS)
					{
					}
					else
					{
						if (type&API3D_MORPH)
						{
							for (n=0;n<ActualVertexBuffer->nVerticesActif*3;n++) ActualVertexBuffer->temp_vertices[n]=ActualVertexBuffer->Vertex_Array[n]*(1-t) + ActualVertexBuffer->streams[0][n]*t;
							glEnableClientState(GL_VERTEX_ARRAY);
							glVertexPointer(3,GL_FLOAT,0,ActualVertexBuffer->temp_vertices);
						}
						else
						{
							glEnableClientState(GL_VERTEX_ARRAY);
							glVertexPointer(3,GL_FLOAT,0,ActualVertexBuffer->Vertex_Array);
						}
					}
				}
			}
		}
	}

	if (!ActualVertexBuffer->Grouped)
	{

		if ((type&API3D_VERTEXPROGRAM)||(ActualEffect))
		{
#ifndef GLES
			glPushAttrib(GL_ALL_ATTRIB_BITS);
#endif
			CVertexBuffer *vb=ActualVertexBuffer;	
			CVertexBuffer *vbeff;

			if (ActualEffect) vbeff=ActualEffect;
			else vbeff=vb;

			int nn,res;
#ifndef GLES
			if (vbeff->vp->shadermodel)
			{
				int vertex,vertex2,color,normal,normal2,weights,texcoo0,texcoo1,texcoo2;
				int texture_stage0=aT;
				int texture_stage1=aT2;
				int ntmax=0;

				for (int p=0;p<vbeff->vp->get_pass_count();p++)
				{
					glUseProgramObjectARB(vbeff->glslprograms[p]);

					if (type&API3D_STREAMS)
					{
						if (ActualVertexBuffer->stream1>=0)
						{
							int loc=vertex=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams[ActualVertexBuffer->stream1]);
						}
						else
						{
							int loc=vertex=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
						}

						if (ActualVertexBuffer->stream2>=0)
						{
							int loc=vertex2=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition2");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams[ActualVertexBuffer->stream2]);
						}

					}
					else
					{
						int loc=vertex=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition");
						glEnableVertexAttribArrayARB(loc);
						glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
					}


					if ((type&API3D_STREAMS)&&(type&API3D_NORMALDATAS))
					{
						if (ActualVertexBuffer->stream1>=0)
						{
							int loc=normal=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams_norms[ActualVertexBuffer->stream1]);
						}
						else
						{
							int loc=normal=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Normal_Array);
						}

						if (ActualVertexBuffer->stream2>=0)
						{
							int loc=normal2=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal2");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams_norms[ActualVertexBuffer->stream2]);
						}					
					}
					else
					if (type&API3D_NORMALDATAS)
					{
						int loc=normal=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal");
						glEnableVertexAttribArrayARB(loc);
						glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Normal_Array);
					}

					if (type&API3D_COLORDATAS)
					{
						int loc=color=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexColor");
						glEnableVertexAttribArrayARB(loc);
						glVertexAttribPointerARB(loc, 4,GL_FLOAT,GL_FALSE,0,vb->Color_Array);
					}

					if (type&API3D_BLENDING)
					{
						int loc=weights=glGetAttribLocationARB(vbeff->glslprograms[p], "IWeights");
										
						glEnableVertexAttribArrayARB(loc);
						glVertexAttribPointerARB(loc,4,GL_FLOAT,GL_FALSE,0,vb->WeightsIndices_Array);
					}


					for (n=0;n<3;n++)
					{
						if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
						{
							int loc;
							switch (n)
							{
							case 0:
								loc=texcoo0=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord0");
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
								}
								break;
							case 1:
								loc=texcoo1=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord1");
												
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
								}
								break;
							case 2:
								loc=texcoo2=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord2");
												
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
								{
									glEnableVertexAttribArrayARB(loc);
									glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
								}
								break;
							};

											
						}
					}

					int nt=0;
					Env *e=vbeff->vp->listenv.GetFirst();
					while (e)
					{
						int loc=glGetUniformLocationARB(vbeff->glslprograms[p],e->name);

						if (e->type==TYPE_TEXTURE)
						{
							glActiveTextureARB(GL_TEXTURE0_ARB+nt);
							glEnable(GL_TEXTURE_2D);
							glBindTexture(GL_TEXTURE_2D,e->tex);
							glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
	#ifndef GLES
							glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE_ARB,1);
	#endif
							glUniform1i(loc,nt++);
							if (nt>ntmax) ntmax=nt;
						}
										
						if (e->type==TYPE_VECTOR) glUniform4f(loc,e->v[0],e->v[1],e->v[2],e->v[3]);
										
						if (e->type==TYPE_MATRIX) glUniformMatrix4fv(loc,1,false,e->m);

						if (e->type==TYPE_MATRIXLIST) glUniformMatrix4fv(loc,e->nb+1,false,e->mm);

						if (e->type==TYPE_VECTORLIST) glUniform4fv(loc,e->nb+1,e->vv);
										
						e=vbeff->vp->listenv.GetNext();
					}

					glSetRenderState(&vbeff->vp->RenderState[vbeff->vp->selected_tech][p],this);
					// TITI
					glDrawElements(GL_TRIANGLES,vb->nIndicesActif,LIB3D_TYPE_INDEX,vb->Index_Array);
					

					glDisableVertexAttribArrayARB(vertex);
					if (type&API3D_NORMALDATAS) glDisableVertexAttribArrayARB(normal);
					if (type&API3D_STREAMS)
					{
						glDisableVertexAttribArrayARB(vertex2);
						if (type&API3D_NORMALDATAS) glDisableVertexAttribArrayARB(normal2);
					}
					if (type&API3D_COLORDATAS) glDisableVertexAttribArrayARB(color);
					if (type&API3D_COLORDATAS4) glDisableVertexAttribArrayARB(color);
					if (type&API3D_BLENDING) glDisableVertexAttribArrayARB(weights);

					for (n=0;n<3;n++)
					{
						if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
						{
							switch (n)
							{
							case 0:
								glDisableVertexAttribArrayARB(texcoo0);
								break;
							case 1:
								glDisableVertexAttribArrayARB(texcoo1);
								break;
							case 2:
								glDisableVertexAttribArrayARB(texcoo2);
								break;
							};

						}
					}		

				}

				for (n=0;n<ntmax;n++)
				{
					if (n==0)
					{
						SetTexture(texture_stage0);
					}
					else
					if (n==1)
					{
						SetTexture2(texture_stage1);
					}
					else
					{
						glActiveTextureARB(GL_TEXTURE0_ARB+n);
						glDisable(GL_TEXTURE_2D);
					}
				}

				glUseProgramObjectARB(0);

			}
			else /////////////////////////////////////////////////////////////////////////////////////////////////////// VERTEXPROGRAM
			if (G_VertexProgram)
			{
				glEnableVertexAttribArrayARB(GL_GA_VERTEX_POSITION);
				glVertexAttribPointerARB(GL_GA_VERTEX_POSITION, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
				if (type&API3D_NORMALDATAS)
				{
					glEnableVertexAttribArrayARB(GL_GA_NORMAL);
					glVertexAttribPointerARB(GL_GA_NORMAL, 3,GL_FLOAT,GL_TRUE,0,vb->Normal_Array);
				}

				if (type&API3D_MORPH)
				{
					glEnableVertexAttribArrayARB(GL_GA_VERTEX_POSITION2);
					glVertexAttribPointerARB(GL_GA_VERTEX_POSITION2, 3,GL_FLOAT,GL_FALSE,0,vb->streams[0]);
					if (type&API3D_NORMALDATAS)
					{
						glEnableVertexAttribArrayARB(GL_GA_NORMAL2);
						glVertexAttribPointerARB(GL_GA_NORMAL2, 3,GL_FLOAT,GL_TRUE,0,vb->streams_norms[0]);
					}
				}
				
				if (type&API3D_COLORDATAS)
				{
					glEnableVertexAttribArrayARB(GL_GA_PRIMARY_COLOR);
					glVertexAttribPointerARB(GL_GA_PRIMARY_COLOR, 4,GL_FLOAT,GL_FALSE,0,vb->Color_Array);
				}

				if (type&API3D_BLENDING)
				{
					glEnableVertexAttribArrayARB(GL_GA_MATRIX_INDEX);
					glVertexAttribPointerARB(GL_GA_MATRIX_INDEX,4,GL_BYTE,GL_FALSE,0,vb->Indices_Array);

					glEnableVertexAttribArrayARB(GL_GA_WEIGHTS);
					glVertexAttribPointerARB(GL_GA_WEIGHTS,4,GL_FLOAT,GL_FALSE,0,vb->Weights_Array);
				}


				if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);

				for (int p=0;p<vbeff->vp->get_pass_count();p++)
				{

					if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[0])
					{
						res=-1;
						nn=0;
						while ((nn<16)&&(res==-1))
						{
							if (vbeff->vp->texture[nn])
								if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[0])==0) res=nn;
							nn++;
						}
						if (res!=-1) SetTexture(vbeff->numTexture[res]);
					}
					
					if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[1])
					{
						res=-1;
						nn=0;
						while ((nn<16)&&(res==-1))
						{
							if (vbeff->vp->texture[nn])
								if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[1])==0) res=nn;
							nn++;
						}
						if (res!=-1) SetTexture2(vbeff->numTexture[res]);
					}

					if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[2])
					{
						res=-1;
						nn=0;
						while ((nn<16)&&(res==-1))
						{
							if (vbeff->vp->texture[nn])
								if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[2])==0) res=nn;
							nn++;
						}
						if (res!=-1) SetTexture3(vbeff->numTexture[res]);
					}

					if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[3])
					{
						res=-1;
						nn=0;
						while ((nn<16)&&(res==-1))
						{
							if (vbeff->vp->texture[nn])
								if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[3])==0) res=nn;
							nn++;
						}
						if (res!=-1) SetTexture4(vbeff->numTexture[res]);
					}


					glSetRenderState(&vbeff->vp->RenderState[vbeff->vp->selected_tech][p],this);

					if (MultiTexture)
					{
						for (n=0;n<2;n++)
						{
							if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
							{
								// BUG ?
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
								{						
									glEnableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0+n);
									glVertexAttribPointerARB(GL_GA_TEXTURE_COORD0+n, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
								}

								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
								{
									
									glEnableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0+n);
									glVertexAttribPointerARB(GL_GA_TEXTURE_COORD0+n, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
								}
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
								{
									
									glEnableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0+n);
									glVertexAttribPointerARB(GL_GA_TEXTURE_COORD0+n, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
								}

							}
						}
					}
					else
					{
						if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
						{
							glEnableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0);
							glVertexAttribPointerARB(GL_GA_TEXTURE_COORD0, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
						}

						if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
						{
							glEnableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0);
							glVertexAttribPointerARB(GL_GA_TEXTURE_COORD0, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
						}
						if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
						{
							glEnableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0);
							glVertexAttribPointerARB(GL_GA_TEXTURE_COORD0, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
						}

					}

					if (glIsProgramARB(vbeff->programs[p])) 
					{

						int prg=vbeff->programs[p];

						glEnable(GL_VERTEX_PROGRAM_ARB);
						glBindProgramARB(GL_VERTEX_PROGRAM_ARB,prg);

						if (vbeff->fp[p])
						{
							glEnable(GL_FRAGMENT_PROGRAM_ARB);
							glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB,vbeff->fprograms[p]);
						}

						for (int ne=0;ne<vbeff->vp->n_env;ne++)
						{
							glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,ne,vbeff->vp->env[ne][0],vbeff->vp->env[ne][1],vbeff->vp->env[ne][2],vbeff->vp->env[ne][3]);
							if (vbeff->fp[p]) glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,ne,vbeff->vp->env[ne][0],vbeff->vp->env[ne][1],vbeff->vp->env[ne][2],vbeff->vp->env[ne][3]);
						}

						if (replace)
						{
							if (p+1==vbeff->vp->get_pass_count()) glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
							else glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);
						}

						glDrawElements(GL_TRIANGLES,vb->nIndicesActif,LIB3D_TYPE_INDEX,vb->Index_Array);

						if (vbeff->fp[p]) glDisable(GL_FRAGMENT_PROGRAM_ARB);
						glDisable(GL_VERTEX_PROGRAM_ARB);
					}
					

					if (MultiTexture)
					{
						for (n=0;n<2;n++)
						{
							if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
							{
								glDisableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0+n);

							}
						}
					}
					else
					{
						glDisableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0);
					}
				
				}

				if (type&API3D_BLENDING)
				{
					glDisableVertexAttribArrayARB(GL_GA_MATRIX_INDEX);
					glDisableVertexAttribArrayARB(GL_GA_WEIGHTS);
				}

				glDisableVertexAttribArrayARB(GL_GA_VERTEX_POSITION);
				if (type&API3D_NORMALDATAS) glDisableVertexAttribArrayARB(GL_GA_NORMAL);

				if (type&API3D_MORPH)
				{
					glDisableVertexAttribArrayARB(GL_GA_VERTEX_POSITION2);
					if (type&API3D_NORMALDATAS) glDisableVertexAttribArrayARB(GL_GA_NORMAL2);
				}

				if (type&API3D_COLORDATAS) glDisableVertexAttribArrayARB(GL_GA_PRIMARY_COLOR);
				if (type&API3D_COLORDATAS4) glDisableVertexAttribArrayARB(GL_GA_PRIMARY_COLOR);

			}
			else
#endif
			{

				
				GLfloat modelview[16],m[16];
				glGetFloatv(GL_MODELVIEW_MATRIX, modelview);
				glMatrixMode(GL_MODELVIEW);
				glLoadIdentity();

				for (n=0;n<16;n++) m[n]=0.0f;
				m[0+4*0]=1.0f;
				m[1+4*1]=-1.0f;
				m[2+4*2]=-1.0f;
				m[3+4*3]=1.0f;

				glLoadMatrixf(m);

				pVertices=vb->Vertex_Array;

				if (type&API3D_NORMALDATAS)
				{
					pNormals=vb->Normal_Array;
				}
				else pNormals=NULL;


				if (type&API3D_MORPH)
				{
					pVertices2=vb->streams[0];
					if (type&API3D_NORMALDATAS) pNormals2=vb->streams_norms[0];
					else pNormals2=NULL;
				}
				else pNormals2=pVertices2=NULL;

				pColor=NULL;

				if (type&API3D_COLORDATAS)
				{
					pColor=vb->Color_Array;
					sizec=4;
				}
				

				pColor2=NULL;
				sizec2=0;

				pMatrixIndices=NULL;
				pWeights=NULL;

				if (type&API3D_BLENDING)
				{
					pMatrixIndices=vb->Indices_Array;
					pWeights=vb->Weights_Array;
				}

				if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);

				for (int p=0;p<vbeff->vp->get_pass_count();p++)
				{

					if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[0])
					{
						res=-1;
						nn=0;
						while ((nn<16)&&(res==-1))
						{
							if (vbeff->vp->texture[nn])
								if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[0])==0) res=nn;
							nn++;
						}
						if (res!=-1) SetTexture(vbeff->numTexture[res]);
					}
					
					if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[1])
					{
						res=-1;
						nn=0;
						while ((nn<16)&&(res==-1))
						{
							if (vbeff->vp->texture[nn])
								if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[1])==0) res=nn;
							nn++;
						}
						if (res!=-1) SetTexture2(vbeff->numTexture[res]);
					}

					if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[2])
					{
						res=-1;
						nn=0;
						while ((nn<16)&&(res==-1))
						{
							if (vbeff->vp->texture[nn])
								if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[2])==0) res=nn;
							nn++;
						}
						if (res!=-1) SetTexture3(vbeff->numTexture[res]);
					}

					if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[3])
					{
						res=-1;
						nn=0;
						while ((nn<16)&&(res==-1))
						{
							if (vbeff->vp->texture[nn])
								if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[3])==0) res=nn;
							nn++;
						}
						if (res!=-1) SetTexture4(vbeff->numTexture[res]);
					}

					glSetRenderState(&vbeff->vp->RenderState[vbeff->vp->selected_tech][p],this);

					pTexCoo=NULL;
					pTexCoo2=NULL;
					pTexCoo3=NULL;

					if (MultiTexture)
					{
						for (n=0;n<2;n++)
						{
							if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
							{
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
								{
									if (n==0) pTexCoo=vb->TexCoo_Array;
									if (n==1) pTexCoo2=vb->TexCoo_Array;
								}
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
								{
									if (n==0) pTexCoo=vb->TexCoo2_Array;
									if (n==1) pTexCoo2=vb->TexCoo2_Array;
								}
								if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
								{
									if (n==0) pTexCoo=vb->TexCoo3_Array;
									if (n==1) pTexCoo2=vb->TexCoo3_Array;
								}
							}
						}
					}
					else
					{
						if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
						{
							pTexCoo=vb->TexCoo_Array;
						}

						if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
						{
							pTexCoo=vb->TexCoo2_Array;
						}

						if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
						{
							pTexCoo=vb->TexCoo3_Array;
						}

					}

					vbeff->vp->emvp[p]->Exec(vb->nVerticesActif,pVertices,pNormals,pVertices2,pNormals2,pColor,pColor2,pTexCoo,pTexCoo2,sizec,0,pMatrixIndices,pWeights,vbeff->vp->fvf_output[p]);

					glEnableClientState(GL_VERTEX_ARRAY);
					glVertexPointer(3,GL_FLOAT,0,vbeff->vp->emvp[p]->Vertex_Array);

					if (vbeff->vp->fvf_output[p]&DIFFUSE) 
					{
						glEnableClientState(GL_COLOR_ARRAY);
						glColorPointer(4,GL_FLOAT,0,vbeff->vp->emvp[p]->Color_Array);
					}

					if (vbeff->vp->fvf_output[p]&_TEX0) 
					{
						if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE0_ARB);
						glEnableClientState(GL_TEXTURE_COORD_ARRAY);
						glTexCoordPointer(2,GL_FLOAT,0,vbeff->vp->emvp[p]->TexCoo_Array);
					}

					if (vbeff->vp->fvf_output[p]&_TEX1) 
					{
						if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE1_ARB);
						glEnableClientState(GL_TEXTURE_COORD_ARRAY);
						glTexCoordPointer(2,GL_FLOAT,0,vbeff->vp->emvp[p]->TexCoo2_Array);
					}

					if (replace)
					{
						if (p+1==vbeff->vp->get_pass_count()) glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
						else glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);
					}
#ifndef GLES
					glDisable(GL_VERTEX_PROGRAM_ARB);
#endif
					glDrawElements(GL_TRIANGLES,vb->nIndicesActif,LIB3D_TYPE_INDEX,vb->Index_Array);
						
					
					
					glDisableClientState(GL_COLOR_ARRAY);
					glDisableClientState(GL_VERTEX_ARRAY);
					glDisableClientState(GL_NORMAL_ARRAY);
					if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE0_ARB);
					glDisableClientState(GL_TEXTURE_COORD_ARRAY);

					if (MultiTexture) 
					{
						glClientActiveTextureARB(GL_TEXTURE1_ARB);
						glDisableClientState(GL_TEXTURE_COORD_ARRAY);
					}
				}

				glMatrixMode(GL_MODELVIEW);
				glLoadIdentity();
				glLoadMatrixf(modelview);
			}
#ifndef GLES
			glPopAttrib();
#endif
		}
		else
		{
			if (type&API3D_EDGESDG)	// EDGESDG
			{
				if (states(ALGO_STENCIL_SHADOWING)==1)
				{
#ifndef GLES
					if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE0_ARB);
#endif
					glEnableClientState(GL_TEXTURE_COORD_ARRAY);
					glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);

					glEnableClientState(GL_NORMAL_ARRAY);
					glNormalPointer(GL_FLOAT,0,ActualVertexBuffer->Normal_Array);

					glEnableClientState(GL_VERTEX_ARRAY);
					glVertexPointer(3,GL_FLOAT,0,ActualVertexBuffer->Vertex2_Array);
					

					SetParams(API3D_RENDERTARGET,STENCIL);
					SetParams(API3D_SHADING,OFF);
					SetParams(API3D_CULL,ON);
					SetParams(API3D_CULL,CW);
					glStencilFunc(GL_ALWAYS,1,0xffffffff);
					glStencilMask(0xffffffff);
					glStencilOp(GL_KEEP,GL_INCR,GL_KEEP);

					glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);


					if (ActualVertexBuffer->secondary)
					{
						if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE0_ARB);
						glEnableClientState(GL_TEXTURE_COORD_ARRAY);
						glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->secondary->TexCoo_Array);

						glEnableClientState(GL_NORMAL_ARRAY);
						glNormalPointer(GL_FLOAT,0,ActualVertexBuffer->secondary->Normal_Array);

						glEnableClientState(GL_VERTEX_ARRAY);
						glVertexPointer(3,GL_FLOAT,0,ActualVertexBuffer->secondary->Vertex2_Array);

						SetParams(API3D_RENDERTARGET,STENCIL);
						SetParams(API3D_SHADING,OFF);
						SetParams(API3D_CULL,ON);
						SetParams(API3D_CULL,CCW);
						glStencilFunc(GL_ALWAYS,1,0xffffffff);
						glStencilMask(0xffffffff);
						glStencilOp(GL_KEEP,GL_INCR,GL_KEEP);

						glDrawElements(GL_TRIANGLES,ActualVertexBuffer->secondary->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->secondary->Index_Array);
					}



					if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE0_ARB);
					glEnableClientState(GL_TEXTURE_COORD_ARRAY);
					glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);

					glEnableClientState(GL_NORMAL_ARRAY);
					glNormalPointer(GL_FLOAT,0,ActualVertexBuffer->Normal_Array);

					glEnableClientState(GL_VERTEX_ARRAY);
					glVertexPointer(3,GL_FLOAT,0,ActualVertexBuffer->Vertex2_Array);
					

					SetParams(API3D_RENDERTARGET,STENCIL);
					SetParams(API3D_SHADING,OFF);
					SetParams(API3D_CULL,ON);
					SetParams(API3D_CULL,CCW);
					glStencilFunc(GL_ALWAYS,1,0xffffffff);
					glStencilMask(0xffffffff);
					glStencilOp(GL_KEEP,GL_DECR,GL_KEEP);

					glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);


					if (ActualVertexBuffer->secondary)
					{

						if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE0_ARB);
						glEnableClientState(GL_TEXTURE_COORD_ARRAY);
						glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->secondary->TexCoo_Array);

						glEnableClientState(GL_NORMAL_ARRAY);
						glNormalPointer(GL_FLOAT,0,ActualVertexBuffer->secondary->Normal_Array);

						glEnableClientState(GL_VERTEX_ARRAY);
						glVertexPointer(3,GL_FLOAT,0,ActualVertexBuffer->secondary->Vertex2_Array);

						SetParams(API3D_RENDERTARGET,STENCIL);
						SetParams(API3D_SHADING,OFF);
						SetParams(API3D_CULL,ON);
						SetParams(API3D_CULL,CW);
						glStencilFunc(GL_ALWAYS,1,0xffffffff);
						glStencilMask(0xffffffff);
						glStencilOp(GL_KEEP,GL_DECR,GL_KEEP);

						glDrawElements(GL_TRIANGLES,ActualVertexBuffer->secondary->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->secondary->Index_Array);
					}

					SetParams(API3D_SHADING,ON);
					SetParams(API3D_RENDERTARGET,RENDER);
					if (states(CULLING)==0) SetParams(API3D_CULL,CW);
					else SetParams(API3D_CULL,CCW);
				}

				if (states(ALGO_STENCIL_SHADOWING)==2)
				{
					SetParams(API3D_RENDERTARGET,STENCIL);
					SetParams(API3D_SHADING,OFF);
					SetParams(API3D_CULL,ON);
					SetParams(API3D_CULL,CCW);
					SetParams(API3D_STENCIL,INCREMENT);

					glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);

					SetParams(API3D_RENDERTARGET,STENCIL);
					SetParams(API3D_SHADING,OFF);
					SetParams(API3D_CULL,ON);
					SetParams(API3D_CULL,CW);
					SetParams(API3D_STENCIL,DECREMENT);

					glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);
				}
				
				if (states(ALGO_STENCIL_SHADOWING)==0) // glalternative
				{
					
					CMatrix M,MWO;

					MWO=WORLD;
					M.Id();
					LoadWorldMatrix(M);
					
					SetParams(API3D_SHADING,ON);
					SetParams(API3D_CULL,ON);

#ifdef glStencilOpSeparate
					if (glStencilOpSeparate)
					{
						glEnableClientState(GL_VERTEX_ARRAY);
						glVertexPointer(3,GL_FLOAT,0,ActualVertexBuffer->Vertex2_Array);

						SetParams(API3D_RENDERTARGET,STENCIL);
						SetParams(API3D_ZBUFFER,ON);
						SetParams(API3D_ZBUFFER,WRITEOFF);
						SetParams(API3D_CULL,OFF);
				
						glStencilMaskSeparate(GL_FRONT_AND_BACK,0xff);
						glStencilFuncSeparate(GL_FRONT_AND_BACK,GL_ALWAYS,1,0xff);

						if (*states[ZBUFFER_TEST_STENCIL]==0)
						{
							glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_KEEP,GL_INCR_WRAP);
							glStencilOpSeparate(GL_BACK,GL_KEEP,GL_KEEP,GL_DECR_WRAP);
						}
						else
						{
							glStencilOpSeparate(GL_FRONT,GL_KEEP,GL_REPLACE,GL_INCR_WRAP);
							glStencilOpSeparate(GL_BACK,GL_KEEP,GL_REPLACE,GL_DECR_WRAP);
						}
						

						glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);

						if (ActualVertexBuffer->secondary)
						{
							glEnableClientState(GL_VERTEX_ARRAY);
							glVertexPointer(3,GL_FLOAT,0,ActualVertexBuffer->secondary->Vertex2_Array);
							glDrawElements(GL_TRIANGLES,ActualVertexBuffer->secondary->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->secondary->Index_Array);
						}
					}
					else
#endif
					{

						glEnableClientState(GL_VERTEX_ARRAY);
						glVertexPointer(3,GL_FLOAT,0,ActualVertexBuffer->Vertex2_Array);

						SetParams(API3D_RENDERTARGET,STENCIL);
						SetParams(API3D_ZBUFFER,ON);
						SetParams(API3D_ZBUFFER,WRITEOFF);
						SetParams(API3D_CULL,CCW);
						SetParams(API3D_STENCIL,INCREMENT);

						glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);
	
						if (ActualVertexBuffer->secondary)
						{
							glEnableClientState(GL_VERTEX_ARRAY);
							glVertexPointer(3,GL_FLOAT,0,ActualVertexBuffer->secondary->Vertex2_Array);

							SetParams(API3D_RENDERTARGET,STENCIL);
							SetParams(API3D_ZBUFFER,ON);
							SetParams(API3D_ZBUFFER,WRITEOFF);
							SetParams(API3D_CULL,CCW);
							SetParams(API3D_STENCIL,INCREMENT);

							glDrawElements(GL_TRIANGLES,ActualVertexBuffer->secondary->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->secondary->Index_Array);
						}


						glEnableClientState(GL_VERTEX_ARRAY);
						glVertexPointer(3,GL_FLOAT,0,ActualVertexBuffer->Vertex2_Array);

						SetParams(API3D_RENDERTARGET,STENCIL);
						SetParams(API3D_ZBUFFER,ON);
						SetParams(API3D_ZBUFFER,WRITEOFF);
						SetParams(API3D_CULL,CW);
						SetParams(API3D_STENCIL,DECREMENT);

						glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);
	
						if (ActualVertexBuffer->secondary)
						{
							glEnableClientState(GL_VERTEX_ARRAY);
							glVertexPointer(3,GL_FLOAT,0,ActualVertexBuffer->secondary->Vertex2_Array);

							SetParams(API3D_RENDERTARGET,STENCIL);
							SetParams(API3D_ZBUFFER,ON);
							SetParams(API3D_ZBUFFER,WRITEOFF);
							SetParams(API3D_CULL,CW);
							SetParams(API3D_STENCIL,DECREMENT);

							glDrawElements(GL_TRIANGLES,ActualVertexBuffer->secondary->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->secondary->Index_Array);
						}
					}
					
					SetParams(API3D_SHADING,ON);
					SetParams(API3D_RENDERTARGET,RENDER);
					if (states(CULLING)==0) SetParams(API3D_CULL,CW);
					else SetParams(API3D_CULL,CCW);

					LoadWorldMatrix(MWO);
				}
			}
			else
			{

				if ((((type&API3D_TEXCOO2LIGHTMAP)||(type&API3D_TEXCOODATAS2))&&(!MultiTexture))||((type&API3D_ENVMAPPING)&&(!MultiTexture)))
				{
					if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);
				}
				else
				{
					if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
				}

				glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);
			}


			if (((type&API3D_TEXCOO2LIGHTMAP)||(type&API3D_TEXCOODATAS2))&&(!MultiTexture))
			{
				glDisableClientState(GL_COLOR_ARRAY);

				glEnableClientState(GL_TEXTURE_COORD_ARRAY);
				if (type&API3D_TEXCOODATAS2) glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo2_Array);
				else glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);

				n=aT2;
				if (n>=0)
				{
					glEnable(GL_TEXTURE_2D);
					glBindTexture(GL_TEXTURE_2D,Texture[n]);
				}
				else
				if (SecondarySurface)
				{
					glEnable(GL_TEXTURE_2D);
#ifdef OPENGL_PBUFFERS
					pbufferBind(-(n+1));
#endif
#ifdef OPENGL_FRAMEBUFFERS
					glBindTexture(GL_TEXTURE_2D,renderedTexture[-(n+1)]);
#endif
				}

				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);

				glEnable(GL_BLEND);
				if (LevelTexture1==GL_MODULATE)
				{
					glBlendFunc(GL_DST_COLOR,GL_ZERO);
				}

				if (LevelTexture1==GL_ADD)
				{
					glBlendFunc(GL_ONE,GL_ONE);
				}


				if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
#ifndef GLES
				glColor3f(1,1,1);
#endif
				glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);

				n=aT;
				if (n>=0)
				{
					glEnable(GL_TEXTURE_2D);
					glBindTexture(GL_TEXTURE_2D,Texture[n]);
				}
				else
				if (SecondarySurface)
				{
					glEnable(GL_TEXTURE_2D);
#ifdef OPENGL_PBUFFERS
					pbufferBind(-(n+1));
#endif
#ifdef OPENGL_FRAMEBUFFERS
					glBindTexture(GL_TEXTURE_2D,renderedTexture[-(n+1)]);
#endif
				}

				switch(BLEND_GL)
				{
				case 0:
					glDisable(GL_BLEND);
					break;
				case 1:
					glEnable(GL_BLEND);
					glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
					break;
				case 3:
					glEnable(GL_BLEND);
					glBlendFunc(GL_SRC_ALPHA,GL_ONE);
					break;

				case 4:
					glEnable(GL_BLEND);
					glBlendFunc(GL_DST_COLOR,GL_ZERO);
					break;

				};
			}

			if ((type&API3D_ENVMAPPING)&&(!MultiTexture))
			{
				glDisableClientState(GL_COLOR_ARRAY);

				glEnableClientState(GL_TEXTURE_COORD_ARRAY);
				glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo2_Array);


				n=aT2;
				if (n>=0)
				{
					glEnable(GL_TEXTURE_2D);
					glBindTexture(GL_TEXTURE_2D,Texture[n]);
				}
				else
				if (SecondarySurface)
				{
					glEnable(GL_TEXTURE_2D);
#ifdef OPENGL_PBUFFERS
					pbufferBind(-(n+1));
#endif
#ifdef OPENGL_FRAMEBUFFERS
					glBindTexture(GL_TEXTURE_2D,renderedTexture[-(n+1)]);
#endif
				}

				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);

				glEnable(GL_BLEND);
				glBlendFunc(GL_ONE,GL_ONE);

				if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
#ifndef GLES
				glColor3f(1,1,1);
#endif
				glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);

				n=aT;
				if (n>=0)
				{
					glEnable(GL_TEXTURE_2D);
					glBindTexture(GL_TEXTURE_2D,Texture[n]);
				}
				else
				if (SecondarySurface)
				{
					glEnable(GL_TEXTURE_2D);
#ifdef OPENGL_PBUFFERS
					pbufferBind(-(n+1));
#endif
#ifdef OPENGL_FRAMEBUFFERS
					glBindTexture(GL_TEXTURE_2D,renderedTexture[-(n+1)]);
#endif
				}

				switch(BLEND_GL)
				{
				case 0:
					glDisable(GL_BLEND);
					break;
				case 1:
					glEnable(GL_BLEND);
					glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
					break;
				case 3:
					glEnable(GL_BLEND);
					glBlendFunc(GL_SRC_ALPHA,GL_ONE);
					break;
				case 4:
					glEnable(GL_BLEND);
					glBlendFunc(GL_DST_COLOR,GL_ZERO);
					break;

				};
			}
		}
	}
	else
	{
		if ((ActualVertexBuffer->TypeVB!=7)&&(ActualVertexBuffer->TypeVB!=9))
		{
			if ((type&API3D_VERTEXPROGRAM)||(ActualEffect))
			{
#ifndef GLES
				//glPushAttrib(GL_ALL_ATTRIB_BITS);
#endif	
				CVertexBuffer *vb=ActualVertexBuffer;
				CVertexBuffer *vbeff;

				if (ActualEffect) vbeff=ActualEffect;
				else vbeff=vb;

				int nn,res;

				int ra,rb;

				switch (states(ALPHA_MULTI_GROUP_DRAW))
				{
				case 0:
					ra=0;rb=0;
					break;
				case 1:
					ra=0;rb=2;
					break;
				case 2:
					ra=1;rb=2;
					break;
				};

				int texture_stage0=aT;
				int texture_stage1=aT2;

				// HERE
				// streams				
#ifndef GLES
				
				if (vbeff->vp->shadermodel)
				{
					//////////////////////////////////////////////////////////////////////////////////////////////////////////// SHADERMODEL
					for (int p=0;p<vbeff->vp->get_pass_count();p++)
					{
						int vertex,vertex2,color,normal,normal2,weights,texcoo0,texcoo1,texcoo2;
						int ntmax=0;

						glUseProgramObjectARB(vbeff->glslprograms[p]);

						if (type&API3D_STREAMS)
						{
							if (ActualVertexBuffer->stream1>=0)
							{
								int loc=vertex=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition");
								glEnableVertexAttribArrayARB(loc);
								glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams[ActualVertexBuffer->stream1]);
							}
							else
							{
								int loc=vertex=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition");
								glEnableVertexAttribArrayARB(loc);
								glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
							}

							if (ActualVertexBuffer->stream2>=0)
							{
								int loc=vertex2=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition2");
								glEnableVertexAttribArrayARB(loc);
								glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams[ActualVertexBuffer->stream2]);
							}
						}
						else
						{
							int loc=vertex=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexPosition");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
						}

						if ((type&API3D_STREAMS)&&(type&API3D_NORMALDATAS))
						{
							if (ActualVertexBuffer->stream1>=0)
							{
								int loc=normal=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal");
								glEnableVertexAttribArrayARB(loc);
								glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams_norms[ActualVertexBuffer->stream1]);
							}
							else
							{
								int loc=normal=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal");
								glEnableVertexAttribArrayARB(loc);
								glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Normal_Array);
							}

							if (ActualVertexBuffer->stream2>=0)
							{
								int loc=normal2=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal2");
								glEnableVertexAttribArrayARB(loc);
								glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->streams_norms[ActualVertexBuffer->stream2]);
							}
						}
						else
						if (type&API3D_NORMALDATAS)
						{
							int loc=normal=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexNormal");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 3,GL_FLOAT,GL_FALSE,0,vb->Normal_Array);
						}

						if (type&API3D_COLORDATAS)
						{
							int loc=color=glGetAttribLocationARB(vbeff->glslprograms[p], "VertexColor");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc, 4,GL_FLOAT,GL_FALSE,0,vb->Color_Array);
						}
				
						if (type&API3D_BLENDING)
						{
							int loc=weights=glGetAttribLocationARB(vbeff->glslprograms[p], "IWeights");
							glEnableVertexAttribArrayARB(loc);
							glVertexAttribPointerARB(loc,4,GL_FLOAT,GL_FALSE,0,vb->WeightsIndices_Array);
						}


						for (n=0;n<3;n++)
						{
							if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
							{
								int loc;
								switch (n)
								{
								case 0:
									loc=texcoo0=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord0");
									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
									{
										glEnableVertexAttribArrayARB(loc);
										glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
									}

									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
									{
										glEnableVertexAttribArrayARB(loc);
										glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
									}

									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
									{
										glEnableVertexAttribArrayARB(loc);
										glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
									}
									break;
								case 1:
									loc=texcoo1=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord1");
												
									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
									{
										glEnableVertexAttribArrayARB(loc);
										glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
									}

									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
									{
										glEnableVertexAttribArrayARB(loc);
										glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
									}

									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
									{
										glEnableVertexAttribArrayARB(loc);
										glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
									}
									break;
								case 2:
									loc=texcoo2=glGetAttribLocationARB(vbeff->glslprograms[p], "MultiTexCoord2");
												
									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
									{
										glEnableVertexAttribArrayARB(loc);
										glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
									}

									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
									{
										glEnableVertexAttribArrayARB(loc);
										glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
									}

									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
									{
										glEnableVertexAttribArrayARB(loc);
										glVertexAttribPointerARB(loc, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
									}
									break;
								};				
							}
						}

						Env *e=vbeff->vp->listenv.GetFirst();
						while (e)
						{
							if (e->type!=TYPE_TEXTURE)
							{
								int loc;

								if (e->loc<0) e->loc=loc=glGetUniformLocationARB(vbeff->glslprograms[p],e->name);
								else loc=e->loc;

								if (e->type==TYPE_VECTOR) glUniform4f(loc,e->v[0],e->v[1],e->v[2],e->v[3]);

								if (e->type==TYPE_MATRIX) glUniformMatrix4fv(loc,1,false,e->m);

								if (e->type==TYPE_MATRIXLIST)
								{
									glUniformMatrix4fv(loc,e->nb+1,false,e->mm);
								}

								if (e->type==TYPE_VECTORLIST) glUniform4fv(loc,e->nb+1,e->vv);
							}
							e=vbeff->vp->listenv.GetNext();
						}						
						
						bool draw=true;

						for (ref_value=ra;ref_value<=rb;ref_value++)
						{
							nfo=ActualVertexBuffer->ListeSE.GetFirst();
							while (nfo)
							{
								if (nfo->ref==ref_value)
								{
									if (nfo->ref==1)
									{
										glEnable(GL_BLEND);
										glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
									}
									else
									if (nfo->ref==2)
									{
										glEnable(GL_BLEND);
										glBlendFunc(GL_ONE,GL_ONE);
									}
									else
									{
										glDisable(GL_BLEND);
									}


									glSetRenderState(&vbeff->vp->RenderState[vbeff->vp->selected_tech][p],this);
									
									if (ContextEffect)
									{
										draw=ContextEffect->update(vbeff,nfo->nT,nfo->nT2,nfo->tag);

										if (draw)
										{
											Env *e=vbeff->vp->listenv.GetFirst();
											while (e)
											{
												if (e->type!=TYPE_TEXTURE)
												{
													int loc;

													if (e->loc<0) e->loc=loc=glGetUniformLocationARB(vbeff->glslprograms[p],e->name);
													else loc=e->loc;

													if (e->type==TYPE_VECTOR) glUniform4f(loc,e->v[0],e->v[1],e->v[2],e->v[3]);

													if (e->type==TYPE_MATRIX) glUniformMatrix4fv(loc,1,false,e->m);

													if (e->type==TYPE_MATRIXLIST)
													{
														glUniformMatrix4fv(loc,e->nb+1,false,e->mm);
													}

													if (e->type==TYPE_VECTORLIST) glUniform4fv(loc,e->nb+1,e->vv);
												}
												e=vbeff->vp->listenv.GetNext();
											}
										}


										if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
										if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0],aT);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1],aT2);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2],aT3);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3],aT4);

										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4],aT5);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5],aT6);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6],aT7);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7],aT8);
									}
									else
									{
										draw=true;
										
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0],aT);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1],aT2);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2],aT3);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3],aT4);

										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4],aT5);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5],aT6);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6],aT7);
										if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7],aT8);

                                        if (vbeff->AssignedTexture[TEXTURE_FROM_NT]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_NT],nfo->nT+Decal_nt);
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_NTPLUSONE]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_NTPLUSONE],nfo->nT+1+Decal_nt);
										if (vbeff->AssignedTexture[TEXTURE_FROM_NT2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_NT2],nfo->nT2);
										if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
										if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);
										if (vbeff->AssignedTexture[TEXTURE_FROM_BUMP]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_BUMP],nfo->nT+bumpmap_settexture);
                                        if (vbeff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE],nfo->nT+1+bumpmap_settexture);
										
										if (vbeff->AssignedTexture[TEXTURE_FROM_DISPLACE]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_DISPLACE],nfo->nT+bump_displace);
										if (vbeff->AssignedTexture[TEXTURE_FROM_HORIZON]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_HORIZON],nfo->nT+bump_horizon);
									}
									
									if (draw)
									{	
									
										int nt=0;
										Env *e=vbeff->vp->listenv.GetFirst();
										while (e)
										{
											if (e->type==TYPE_TEXTURE)
											{
												int loc=glGetUniformLocationARB(vbeff->glslprograms[p],e->name);

												glActiveTextureARB(GL_TEXTURE0_ARB+nt);
												glEnable(GL_TEXTURE_2D);
												glBindTexture(GL_TEXTURE_2D,e->tex);
												glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
#ifndef GLES
												glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE_ARB,1);
#endif
												glUniform1i(loc,nt++);
												if (nt>ntmax) ntmax=nt;
											}
										
											e=vbeff->vp->listenv.GetNext();
										}
									
										if ((nfo->iEnd-nfo->iStart)>0)
										{
											glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(vb->Index_Array[nfo->iStart]));
										}
										
									}
								}
							
								nfo=ActualVertexBuffer->ListeSE.GetNext();
							}
						}
					
						for (n=0;n<3;n++)
						{	
							if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
							{
								switch (n)
								{
								case 0:
									glDisableVertexAttribArrayARB(texcoo0);
									break;
								case 1:
									glDisableVertexAttribArrayARB(texcoo1);
									break;
								case 2:
									glDisableVertexAttribArrayARB(texcoo2);
									break;
								};
							}
						}

						glDisableVertexAttribArrayARB(vertex);
						if (type&API3D_NORMALDATAS) glDisableVertexAttribArrayARB(normal);
						if (type&API3D_STREAMS)
						{
							glDisableVertexAttribArrayARB(vertex2);
							if (type&API3D_NORMALDATAS) glDisableVertexAttribArrayARB(normal2);
						}
						if (type&API3D_COLORDATAS) glDisableVertexAttribArrayARB(color);
						if (type&API3D_COLORDATAS4) glDisableVertexAttribArrayARB(color);
						if (type&API3D_BLENDING) glDisableVertexAttribArrayARB(weights);


						for (n=0;n<ntmax;n++)
						{
							if (n==0)
							{
								SetTexture(texture_stage0);
							}
							else
							if (n==1)
							{
								SetTexture2(texture_stage1);
							}
							else
							{
								glActiveTextureARB(GL_TEXTURE0_ARB+n);
								glDisable(GL_TEXTURE_2D);
							}
						}

						glUseProgramObjectARB(0);
					}
				}
				else /////////////////////////////////////////////////////////////////////////////////////////////////////// VERTEXPROGRAM
				if (G_VertexProgram)
				{

					glEnableVertexAttribArrayARB(GL_GA_VERTEX_POSITION);
					glVertexAttribPointerARB(GL_GA_VERTEX_POSITION, 3,GL_FLOAT,GL_FALSE,0,vb->Vertex_Array);
								
					if (type&API3D_NORMALDATAS)
					{
						glEnableVertexAttribArrayARB(GL_GA_NORMAL);
						glVertexAttribPointerARB(GL_GA_NORMAL, 3,GL_FLOAT,GL_TRUE,0,vb->Normal_Array);
					}

					if (type&API3D_COLORDATAS)
					{
						glEnableVertexAttribArrayARB(GL_GA_PRIMARY_COLOR);
						glVertexAttribPointerARB(GL_GA_PRIMARY_COLOR, 4,GL_FLOAT,GL_FALSE,0,vb->Color_Array);
					}

					if (type&API3D_BLENDING)
					{
						glEnableVertexAttribArrayARB(GL_GA_MATRIX_INDEX);
						glVertexAttribPointerARB(GL_GA_MATRIX_INDEX,4,GL_BYTE,GL_FALSE,0,vb->Indices_Array);

						glEnableVertexAttribArrayARB(GL_GA_WEIGHTS);
						glVertexAttribPointerARB(GL_GA_WEIGHTS,4,GL_FLOAT,GL_FALSE,0,vb->Weights_Array);
					}


					for (ref_value=ra;ref_value<=rb;ref_value++)
					{
						nfo=ActualVertexBuffer->ListeSE.GetFirst();
						while (nfo)
						{
							if (nfo->ref==ref_value)
							{
								if (nfo->ref==1)
								{
									glEnable(GL_BLEND);
									glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
								}
								else
								if (nfo->ref==2)
								{
									glEnable(GL_BLEND);
									glBlendFunc(GL_ONE,GL_ONE);
								}
								else
								{
									glDisable(GL_BLEND);
								}

								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0],aT);
								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1],aT2);
								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2],aT3);
								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3],aT4);

								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4],aT5);
								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5],aT6);
								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6],aT7);
								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7],aT8);

								if (vbeff->AssignedTexture[TEXTURE_FROM_NT]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_NT],nfo->nT+Decal_nt);
                                if (vbeff->AssignedTexture[TEXTURE_FROM_NTPLUSONE]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_NTPLUSONE],nfo->nT+1+Decal_nt);
								if (vbeff->AssignedTexture[TEXTURE_FROM_NT2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_NT2],nfo->nT2);
								if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
								if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);
								if (vbeff->AssignedTexture[TEXTURE_FROM_BUMP]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_BUMP],nfo->nT+bumpmap_settexture);
                                if (vbeff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE],nfo->nT+1+bumpmap_settexture);

								if (vbeff->AssignedTexture[TEXTURE_FROM_DISPLACE]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_DISPLACE],nfo->nT+bump_displace);
								if (vbeff->AssignedTexture[TEXTURE_FROM_HORIZON]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_HORIZON],nfo->nT+bump_horizon);

								if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);
								
								for (int p=0;p<vbeff->vp->get_pass_count();p++)
								{
									
									
									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[0])
									{
										res=-1;
										nn=0;
										while ((nn<16)&&(res==-1))
										{
											if (vbeff->vp->texture[nn])
												if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[0])==0) res=nn;
											nn++;
										}
										if (res!=-1) SetTexture(vbeff->numTexture[res]);
									}
									
									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[1])
									{
										res=-1;
										nn=0;
										while ((nn<16)&&(res==-1))
										{
											if (vbeff->vp->texture[nn])
												if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[1])==0) res=nn;
											nn++;
										}
										if (res!=-1) SetTexture2(vbeff->numTexture[res]);
									}
									
									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[2])
									{
										res=-1;
										nn=0;
										while ((nn<16)&&(res==-1))
										{
											if (vbeff->vp->texture[nn])
												if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[2])==0) res=nn;
											nn++;
										}
										if (res!=-1) SetTexture3(vbeff->numTexture[res]);
									}
									
									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[3])
									{
										res=-1;
										nn=0;
										while ((nn<16)&&(res==-1))
										{
											if (vbeff->vp->texture[nn])
												if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[3])==0) res=nn;
											nn++;
										}
										if (res!=-1) SetTexture4(vbeff->numTexture[res]);
									}
									
									glSetRenderState(&vbeff->vp->RenderState[vbeff->vp->selected_tech][p],this);

									if (MultiTexture)
									{
										for (n=0;n<3;n++)
										{
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
											{
												// BUG ?

												if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
												{
													glEnableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0+n);
													glVertexAttribPointerARB(GL_GA_TEXTURE_COORD0+n, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
												}

												if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
												{
													glEnableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0+n);
													glVertexAttribPointerARB(GL_GA_TEXTURE_COORD0+n, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
												}

												if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
												{
													glEnableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0+n);
													glVertexAttribPointerARB(GL_GA_TEXTURE_COORD0+n, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
												}

											}
										}
									}
									else
									{
										if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
										{
											glEnableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0);
											glVertexAttribPointerARB(GL_GA_TEXTURE_COORD0, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo_Array);
										}

										if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
										{
											glEnableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0);
											glVertexAttribPointerARB(GL_GA_TEXTURE_COORD0, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo2_Array);
										}
										if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
										{
											glEnableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0);
											glVertexAttribPointerARB(GL_GA_TEXTURE_COORD0, 2,GL_FLOAT,GL_FALSE,0,vb->TexCoo3_Array);
										}

									}

									if (glIsProgramARB(vbeff->programs[p])) 
									{

										int prg=vbeff->programs[p];

										glEnable(GL_VERTEX_PROGRAM_ARB);
										glBindProgramARB(GL_VERTEX_PROGRAM_ARB,prg);

										if (vbeff->fp[p])
										{
											glEnable(GL_FRAGMENT_PROGRAM_ARB);
											glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB,vbeff->fprograms[p]);
										}

										for (int ne=0;ne<vbeff->vp->n_env;ne++)
										{
											glProgramEnvParameter4fARB(GL_VERTEX_PROGRAM_ARB,ne,vbeff->vp->env[ne][0],vbeff->vp->env[ne][1],vbeff->vp->env[ne][2],vbeff->vp->env[ne][3]);
											if (vbeff->fp[p]) glProgramEnvParameter4fARB(GL_FRAGMENT_PROGRAM_ARB,ne,vbeff->vp->env[ne][0],vbeff->vp->env[ne][1],vbeff->vp->env[ne][2],vbeff->vp->env[ne][3]);
										}

										if (replace) 
										{
											if (p==vbeff->vp->get_pass_count()-1) glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
											else glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);
										}

										if ((nfo->iEnd-nfo->iStart)>0)
										glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(vb->Index_Array[nfo->iStart]));

										if (vbeff->fp[p]) glDisable(GL_FRAGMENT_PROGRAM_ARB);
										glDisable(GL_VERTEX_PROGRAM_ARB);
									}
									
								

									if (MultiTexture)
									{
										for (n=0;n<2;n++)
										{
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
											{
												glDisableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0+n);
											}
										}
									}
									else
									{
										glDisableVertexAttribArrayARB(GL_GA_TEXTURE_COORD0);
									}
								}
							}

							nfo=ActualVertexBuffer->ListeSE.GetNext();
						}
					}


					if (type&API3D_BLENDING)
					{
						glDisableVertexAttribArrayARB(GL_GA_MATRIX_INDEX);
						glDisableVertexAttribArrayARB(GL_GA_WEIGHTS);
					}

					glDisableVertexAttribArrayARB(GL_GA_VERTEX_POSITION);
					if (type&API3D_NORMALDATAS) glDisableVertexAttribArrayARB(GL_GA_NORMAL);
					if (type&API3D_COLORDATAS) glDisableVertexAttribArrayARB(GL_GA_PRIMARY_COLOR);
					if (type&API3D_COLORDATAS4) glDisableVertexAttribArrayARB(GL_GA_PRIMARY_COLOR);


				}
				else
#endif
				{
					for (ref_value=ra;ref_value<=rb;ref_value++)
					{
						nfo=ActualVertexBuffer->ListeSE.GetFirst();
						while (nfo)
						{
							if (nfo->ref==ref_value)
							{
								if (nfo->ref==1)
								{
									glEnable(GL_BLEND);
									glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
								}
								else
								if (nfo->ref==2)
								{
									glEnable(GL_BLEND);
									glBlendFunc(GL_ONE,GL_ONE);
								}
								else
								{
									glDisable(GL_BLEND);
								}

								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_0],aT);
								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_1],aT2);
								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_2],aT3);
								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_3],aT4);

								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_4],aT5);
								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_5],aT6);
								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_6],aT7);
								if (vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_RENDER_7],aT8);

								if (vbeff->AssignedTexture[TEXTURE_FROM_NT]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_NT],nfo->nT+Decal_nt);
                                if (vbeff->AssignedTexture[TEXTURE_FROM_NTPLUSONE]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_NTPLUSONE],nfo->nT+1+Decal_nt);
								if (vbeff->AssignedTexture[TEXTURE_FROM_NT2]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_NT2],nfo->nT2);
								if (vbeff->AssignedTexture[TEXTURE_FROM_NL]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
								if (vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeff->setLightmap(vbeff->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);
								if (vbeff->AssignedTexture[TEXTURE_FROM_BUMP]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_BUMP],nfo->nT+bumpmap_settexture);
                                if (vbeff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE],nfo->nT+1+bumpmap_settexture);

								if (vbeff->AssignedTexture[TEXTURE_FROM_DISPLACE]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_DISPLACE],nfo->nT+bump_displace);
								if (vbeff->AssignedTexture[TEXTURE_FROM_HORIZON]) vbeff->setTexture(vbeff->AssignedTexture[TEXTURE_FROM_HORIZON],nfo->nT+bump_horizon);
								
								GLfloat modelview[16],m[16];
								glGetFloatv(GL_MODELVIEW_MATRIX, modelview);
								glMatrixMode(GL_MODELVIEW);
								glLoadIdentity();

								for (n=0;n<16;n++) m[n]=0.0f;
								m[0+4*0]=1.0f;
								m[1+4*1]=-1.0f;
								m[2+4*2]=-1.0f;
								m[3+4*3]=1.0f;

								glLoadMatrixf(m);

								pVertices=vb->Vertex_Array;

								if (type&API3D_NORMALDATAS)
								{
									pNormals=vb->Normal_Array;
								}
								else pNormals=NULL;

								pColor=NULL;
								
								if (type&API3D_COLORDATAS)
								{
									pColor=vb->Color_Array;
									sizec=4;
								}
								

								pColor2=NULL;
								sizec2=0;

								pMatrixIndices=NULL;
								pWeights=NULL;

								if (type&API3D_BLENDING)
								{
									pMatrixIndices=vb->Indices_Array;
									pWeights=vb->Weights_Array;
								}

								if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);

								for (int p=0;p<vbeff->vp->get_pass_count();p++)
								{								
									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[0])
									{
										res=-1;
										nn=0;
										while ((nn<16)&&(res==-1))
										{
											if (vbeff->vp->texture[nn])
												if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[0])==0) res=nn;
											nn++;
										}
										if (res!=-1) SetTexture(vbeff->numTexture[res]);
									}
									
									if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[1])
									{
										res=-1;
										nn=0;
										while ((nn<16)&&(res==-1))
										{
											if (vbeff->vp->texture[nn])
												if (strcmp(vbeff->vp->texture[nn],vbeff->vp->RenderState[vbeff->vp->selected_tech][p].Texture[1])==0) res=nn;
											nn++;
										}
										if (res!=-1) SetTexture2(vbeff->numTexture[res]);
									}
									
									glSetRenderState(&vbeff->vp->RenderState[vbeff->vp->selected_tech][p],this);

									pTexCoo=NULL;
									pTexCoo2=NULL;
									pTexCoo3=NULL;

									if (MultiTexture)
									{
										for (n=0;n<2;n++)
										{
											if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]!=_UNDEFINED)
											{
												if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
												{
													if (n==0) pTexCoo=vb->TexCoo_Array;
													if (n==1) pTexCoo2=vb->TexCoo_Array;
												}

												if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
												{
													if (n==0) pTexCoo=vb->TexCoo2_Array;
													if (n==1) pTexCoo2=vb->TexCoo2_Array;
												}
												if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
												{
													if (n==0) pTexCoo=vb->TexCoo3_Array;
													if (n==1) pTexCoo2=vb->TexCoo3_Array;
												}

											}
										}
									}
									else
									{
										if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO0)
										{
											pTexCoo=vb->TexCoo_Array;
										}

										if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO1)
										{
											pTexCoo=vb->TexCoo2_Array;
										}
										if (vbeff->vp->RenderState[vbeff->vp->selected_tech][p].TextCoord[n]==_TEXCOO2)
										{
											pTexCoo=vb->TexCoo3_Array;
										}

									}

									vbeff->vp->emvp[p]->Exec(vb->nVerticesActif,pVertices,pNormals,NULL,NULL,pColor,pColor2,pTexCoo,pTexCoo2,sizec,0,pMatrixIndices,pWeights,vbeff->vp->fvf_output[p]);

									glEnableClientState(GL_VERTEX_ARRAY);
									glVertexPointer(3,GL_FLOAT,0,vbeff->vp->emvp[p]->Vertex_Array);

									if (vb->vp->fvf_output[p]&DIFFUSE) 
									{
										glEnableClientState(GL_COLOR_ARRAY);
										glColorPointer(4,GL_FLOAT,0,vbeff->vp->emvp[p]->Color_Array);
									}

									if (vb->vp->fvf_output[p]&_TEX0) 
									{
										if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE0_ARB);
										glEnableClientState(GL_TEXTURE_COORD_ARRAY);
										glTexCoordPointer(2,GL_FLOAT,0,vbeff->vp->emvp[p]->TexCoo_Array);
									}

									if (vb->vp->fvf_output[p]&_TEX1) 
									{
										if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE1_ARB);
										glEnableClientState(GL_TEXTURE_COORD_ARRAY);
										glTexCoordPointer(2,GL_FLOAT,0,vbeff->vp->emvp[p]->TexCoo2_Array);
									}
#ifndef GLES
									glDisable(GL_VERTEX_PROGRAM_ARB);
#endif
									if (replace) 
									{
										if (p==vbeff->vp->get_pass_count()-1) glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
										else glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);
									}

									if ((nfo->iEnd-nfo->iStart)>0)
									glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(vb->Index_Array[nfo->iStart]));
									
									glDisableClientState(GL_COLOR_ARRAY);
									glDisableClientState(GL_VERTEX_ARRAY);
									glDisableClientState(GL_NORMAL_ARRAY);
									if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE0_ARB);
									glDisableClientState(GL_TEXTURE_COORD_ARRAY);

									if (MultiTexture) 
									{
										glClientActiveTextureARB(GL_TEXTURE1_ARB);
										glDisableClientState(GL_TEXTURE_COORD_ARRAY);
									}
								}

								glMatrixMode(GL_MODELVIEW);
								glLoadIdentity();
								glLoadMatrixf(modelview);
							}

							nfo=ActualVertexBuffer->ListeSE.GetNext();
						}

					}
				}

				SetTexture(texture_stage0);
				SetTexture2(texture_stage1);

				switch(BLEND_GL)
				{
				case 0:
					glDisable(GL_BLEND);
					break;
				case 1:
					glEnable(GL_BLEND);
					glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
					break;
				case 3:
					glEnable(GL_BLEND);
					glBlendFunc(GL_SRC_ALPHA,GL_ONE);
					break;
				case 4:
					glEnable(GL_BLEND);
					glBlendFunc(GL_DST_COLOR,GL_ZERO);
					break;

				};
#ifndef GLES
				glPopAttrib();
#endif
			}
			else
			{
				glFlush();

				int ra,rb;

				switch(states(ALPHA_MULTI_GROUP_DRAW))
				{
				case 0:
					ra=0;rb=0;
					break;
				case 1:
					ra=0;rb=2;
					break;
				case 2:
					ra=1;rb=2;
					break;
				};

				for (ref_value=ra;ref_value<=rb;ref_value++)
				{
					nfo=ActualVertexBuffer->ListeSE.GetFirst();
					while (nfo)
					{
						if (nfo->ref==ref_value)
						{
							if (nfo->ref==1)
							{
								glEnable(GL_BLEND);
								glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
							}
							else
							if (nfo->ref==2)
							{
								glEnable(GL_BLEND);
								glBlendFunc(GL_ONE,GL_ONE);
							}
							else
							{
								glDisable(GL_BLEND);
							}

							if (ActualVertexBuffer->TypeVB==6)
							{
								glActiveTextureARB(GL_TEXTURE0_ARB);
								glEnable(GL_TEXTURE_2D);
								glBindTexture(GL_TEXTURE_2D,Lightmap[nfo->nL]);
								if (Decal_nt==-1)
								{
									glActiveTextureARB(GL_TEXTURE1_ARB);
									glEnable(GL_TEXTURE_2D);
									glBindTexture(GL_TEXTURE_2D,Blanc);
								}
								else 
								{
									if (fn_stage1) SetTexture2(fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else SetTexture2(nfo->nT+Decal_nt);
								}
							}
							else
							if (ActualVertexBuffer->TypeVB==4)
							{
								if (fn_stage0) SetTexture(fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
								else SetTexture(nfo->nT);
								if (fn_stage1) SetTexture2(fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
								else SetTexture2(nfo->nT2);
							}
							else
							{
								if (fn_stage0) SetTexture(fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
								else SetTexture(nfo->nT+Decal_nt);

								if ((type&API3D_ENVMAPPING)&&(MultiTexture)&&(states(ENV_SHADERS)==0)) 
								{
									if (fn_stage1) SetTexture2(fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else SetTexture2(nfo->nT2);
								}
							}

							if ((Lighting)&&(ActualVertexBuffer->TypeVB==5))
							{

								temp=0;
								if ((nfo->nT>=0)&&(nfo->nT<NBRE_MAX_TEXTURES))
								{
									if ((iTexture[nfo->nT])&&(cTexture[nfo->nT]))
									{
										if (iTexture[nfo->nT]->Material)
										{
											glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,iTexture[nfo->nT]->Material->specular);
											glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,iTexture[nfo->nT]->Material->diffuse);
											glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,iTexture[nfo->nT]->Material->ambient);
#ifndef GLES
											glMateriali(GL_FRONT_AND_BACK,GL_SHININESS,iTexture[nfo->nT]->Material->power);	
#endif
											temp=1;
										}
									}
								}
								
								if (temp==0)
								{
									glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,color);
									glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,color);
									glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,color2);
#ifndef GLES
									glMateriali(GL_FRONT_AND_BACK,GL_SHININESS,32);
#endif
								}
							}
#ifndef GLES
							if ((((type&API3D_TEXCOO2LIGHTMAP)||(type&API3D_TEXCOODATAS2))&&(!MultiTexture))||((type&API3D_ENVMAPPING)&&(!MultiTexture)))
							{
								if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);
							}
							else
							{
								if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
							}
#endif
							
							if ((nfo->iEnd-nfo->iStart)>0)
							glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(ActualVertexBuffer->Index_Array[nfo->iStart]));


							// gestion des vieilles cartes 3D

							if (((type&API3D_TEXCOO2LIGHTMAP)||(type&API3D_TEXCOODATAS2))&&(!MultiTexture))
							{
								glDisableClientState(GL_COLOR_ARRAY);

								glEnableClientState(GL_TEXTURE_COORD_ARRAY);
								if (type&API3D_TEXCOODATAS2) glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo2_Array);
								else glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);


								if (Decal_nt==-1)
								{
									glEnable(GL_TEXTURE_2D);
									glBindTexture(GL_TEXTURE_2D,Blanc);
								}
								else
								{
									if (fn_stage1) SetTexture(fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else
									{
										n=aT2;
										if (n>=0)
										{
											glEnable(GL_TEXTURE_2D);
											glBindTexture(GL_TEXTURE_2D,Texture[n]);
										}
										else
										if (SecondarySurface)
										{
											glEnable(GL_TEXTURE_2D);
#ifdef OPENGL_PBUFFERS
											pbufferBind(-(n+1));
#endif
#ifdef OPENGL_FRAMEBUFFERS
											glBindTexture(GL_TEXTURE_2D,renderedTexture[-(n+1)]);
#endif
										}
									}
								}

								glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);

								glEnable(GL_BLEND);
								if (LevelTexture1==GL_MODULATE)
								{
									glBlendFunc(GL_DST_COLOR,GL_ZERO);
								}

								if (LevelTexture1==GL_ADD)
								{
									glBlendFunc(GL_ONE,GL_ONE);
								}

#ifndef GLES
								if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);

								glColor3f(1,1,1);
#endif
								//glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);
								glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(ActualVertexBuffer->Index_Array[nfo->iStart]));

								n=aT;
								if (n>=0)
								{
									glEnable(GL_TEXTURE_2D);
									glBindTexture(GL_TEXTURE_2D,Texture[n]);
								}
								else
								if (SecondarySurface)
								{
									glEnable(GL_TEXTURE_2D);
#ifdef OPENGL_PBUFFERS
									pbufferBind(-(n+1));
#endif
#ifdef OPENGL_FRAMEBUFFERS
									glBindTexture(GL_TEXTURE_2D,renderedTexture[-(n+1)]);
#endif
								}

								switch(BLEND_GL)
								{
								case 0:
									glDisable(GL_BLEND);
									break;
								case 1:
									glEnable(GL_BLEND);
									glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
									break;
								case 3:
									glEnable(GL_BLEND);
									glBlendFunc(GL_SRC_ALPHA,GL_ONE);
									break;
								case 4:
									glEnable(GL_BLEND);
									glBlendFunc(GL_DST_COLOR,GL_ZERO);
									break;

								};
							}

							if ((type&API3D_ENVMAPPING)&&(!MultiTexture))
							{
								glDisableClientState(GL_COLOR_ARRAY);

								glEnableClientState(GL_TEXTURE_COORD_ARRAY);
								glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);

								if (states(ENV_SHADERS)==1)
								{
									if (fn_stage1) SetTexture(fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else
									{
										n=aT2;
										if (n>=0)
										{
											glEnable(GL_TEXTURE_2D);
											glBindTexture(GL_TEXTURE_2D,Texture[n]);
										}
										else
										if (SecondarySurface)
										{
											glEnable(GL_TEXTURE_2D);
#ifdef OPENGL_PBUFFERS
											pbufferBind(-(n+1));
#endif
#ifdef OPENGL_FRAMEBUFFERS
											glBindTexture(GL_TEXTURE_2D,renderedTexture[-(n+1)]);
#endif
										}
									}
								}
								else
								{
									if (fn_stage1) SetTexture(fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else
									{
										n=nfo->nT2;
										if (n>=0)
										{
											glEnable(GL_TEXTURE_2D);
											glBindTexture(GL_TEXTURE_2D,Texture[n]);
										}
										else
										if (SecondarySurface)
										{
											glEnable(GL_TEXTURE_2D);
#ifdef OPENGL_PBUFFERS
											pbufferBind(-(n+1));
#endif
#ifdef OPENGL_FRAMEBUFFERS
											glBindTexture(GL_TEXTURE_2D,renderedTexture[-(n+1)]);
#endif
										}
									}
								}

								glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);

								glEnable(GL_BLEND);
								glBlendFunc(GL_ONE,GL_ONE);

								if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
#ifndef GLES
								glColor3f(1,1,1);
#endif
								//glDrawElements(GL_TRIANGLES,ActualVertexBuffer->nIndicesActif,LIB3D_TYPE_INDEX,ActualVertexBuffer->Index_Array);
								glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(ActualVertexBuffer->Index_Array[nfo->iStart]));

								n=aT;
								if (n>=0)
								{
									glEnable(GL_TEXTURE_2D);
									glBindTexture(GL_TEXTURE_2D,Texture[n]);
								}
								else
								if (SecondarySurface)
								{
									glEnable(GL_TEXTURE_2D);
#ifdef OPENGL_PBUFFERS
									pbufferBind(-(n+1));
#endif
#ifdef OPENGL_FRAMEBUFFERS
									glBindTexture(GL_TEXTURE_2D,renderedTexture[-(n+1)]);
#endif
								}

							}
						}
						nfo=ActualVertexBuffer->ListeSE.GetNext();
					}
				}

			}

			switch(BLEND_GL)
			{
			case 0:
				glDisable(GL_BLEND);
				break;
			case 1:
				glEnable(GL_BLEND);
				glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
				break;
			case 3:
				glEnable(GL_BLEND);
				glBlendFunc(GL_SRC_ALPHA,GL_ONE);
				break;
			case 4:
				glEnable(GL_BLEND);
				glBlendFunc(GL_DST_COLOR,GL_ZERO);
				break;

			};

		}
		else
		{
			// 7 et 9
			
			glFlush();
			int ra,rb;

			switch(states(ALPHA_MULTI_GROUP_DRAW))
			{
			case 0:
				ra=0;rb=0;
				break;
			case 1:
				ra=0;rb=2;
				break;
			case 2:
				ra=1;rb=2;
				break;
			};

			for (ref_value=ra;ref_value<=rb;ref_value++)
			{
				nfo=ActualVertexBuffer->ListeSE.GetFirst();
				while (nfo)
				{
					if ((nfo->ref==ref_value)&&(nfo->flag==valueflag))
					{
						SetParams(API3D_ZBUFFER,states(ZBUFFERING));

						if (nfo->ref!=0)
						{
							glEnable(GL_BLEND);
							glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
						}
						else
						{
							glDisable(GL_BLEND);
						}

						int draw=0;
						if (fn_stage_draw) draw=fn_stage_draw(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag); else draw=1;
						
						if (states(RENDER_TARGET_OPTIONS)==STENCIL)
						{
							glColorMask(GL_TRUE,GL_TRUE,GL_TRUE,GL_TRUE);
							glDisable(GL_BLEND);
							SetTexture(Noir);
							glEnableClientState(GL_TEXTURE_COORD_ARRAY);
							glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);
							glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
							glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(ActualVertexBuffer->Index_Array[nfo->iStart]));
							glColorMask(GL_FALSE,GL_FALSE,GL_FALSE,GL_FALSE);
						}
						else
						if (draw)
						{
#ifndef GLES
							if ((G_PS2X)&&(fp_renderbml!=0xFFFFFFFF))
							{
								glActiveTextureARB(GL_TEXTURE0_ARB);
								glEnable(GL_TEXTURE_2D);
								if (fn_stage0) glBindTexture(GL_TEXTURE_2D,Lightmap[fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else glBindTexture(GL_TEXTURE_2D,Lightmap[nfo->nL]);

								glActiveTextureARB(GL_TEXTURE1_ARB);
								glEnable(GL_TEXTURE_2D);
								if (fn_stage1) glBindTexture(GL_TEXTURE_2D,Texture[fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else glBindTexture(GL_TEXTURE_2D,Texture[(nfo->nT+Decal_nt)]);

								glActiveTextureARB(GL_TEXTURE2_ARB);
								glEnable(GL_TEXTURE_2D);
								if (fn_stage2) glBindTexture(GL_TEXTURE_2D,Lightmap[fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else glBindTexture(GL_TEXTURE_2D,Lightmap[nfo->nLV]);
								
								glActiveTextureARB(GL_TEXTURE3_ARB);
								glEnable(GL_TEXTURE_2D);
								if (fn_stage3) glBindTexture(GL_TEXTURE_2D,Texture[fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else glBindTexture(GL_TEXTURE_2D,Texture[(nfo->nT+bumpmap_settexture)]);

								glClientActiveTextureARB(GL_TEXTURE0_ARB);
								glEnableClientState(GL_TEXTURE_COORD_ARRAY);
								glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);

								glClientActiveTextureARB(GL_TEXTURE1_ARB);
								glEnableClientState(GL_TEXTURE_COORD_ARRAY);
								glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo2_Array);

								glClientActiveTextureARB(GL_TEXTURE2_ARB);
								glEnableClientState(GL_TEXTURE_COORD_ARRAY);
								glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo3_Array);

								if (fp_renderbml==0)
								{
									const char fp_bml[]=
										"!!ARBfp1.0\n"
										"PARAM zerocinq = { 0.5, 0.5, 0.5, 0.0 };\n"
										"TEMP col;\n"
										"TEMP tex;\n"
										"TEMP LV;\n"
										"TEMP bump;\n"
										"TEMP light;\n"
										"TEX tex,fragment.texcoord[0],texture[1],2D;\n"
										"TEX bump,fragment.texcoord[0],texture[3],2D;\n"
										"TEX col,fragment.texcoord[1],texture[0],2D;\n"
										"TEX LV,fragment.texcoord[2],texture[2],2D;\n"
										"SUB bump,bump,zerocinq;\n"
										"ADD bump,bump,bump;\n"
										"SUB LV,LV,zerocinq;\n"
										"ADD LV,LV,LV;\n"
										"DP3_SAT light,bump,LV;\n"
										"MUL col,col,light;\n"
										"MUL col,col,tex;\n"
										"ADD col,col,col;\n"
										"MOV result.color,col;\n"
										"END\n";
									GLint errorPos,isNative;
									
									glEnable(GL_FRAGMENT_PROGRAM_ARB);
									int len=strlen(fp_bml);
									glGenProgramsARB(1,&fp_renderbml);
									glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB,fp_renderbml);
									glProgramStringARB(GL_FRAGMENT_PROGRAM_ARB,GL_PROGRAM_FORMAT_ASCII_ARB,len,(const void*)fp_bml);
									glGetIntegerv(GL_PROGRAM_ERROR_POSITION_ARB,&errorPos);
									glGetProgramivARB(GL_FRAGMENT_PROGRAM_ARB,GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB,&isNative);
									if (!((errorPos==-1)&&(isNative==1)))
									{
										glDeleteProgramsARB(1,&fp_renderbml); 
										fp_renderbml=0xFFFFFFFF;
									}
									glDisable(GL_FRAGMENT_PROGRAM_ARB);		
								}

								if ((fp_renderbml!=0xFFFFFFFF)&&(fp_renderbml!=0))
								{
									if (nfo->ref!=0)
									{
										glEnable(GL_BLEND);
										glBlendFunc(GL_ONE_MINUS_SRC_ALPHA,GL_SRC_ALPHA);
									}
									else
									{
										glDisable(GL_BLEND);
									}

									if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);

									glEnable(GL_FRAGMENT_PROGRAM_ARB);
									glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB,fp_renderbml);

									glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(ActualVertexBuffer->Index_Array[nfo->iStart]));
									
									glDisable(GL_FRAGMENT_PROGRAM_ARB);
								}

		
								glActiveTextureARB(GL_TEXTURE0_ARB);
								glDisable(GL_TEXTURE_2D);
								
								glActiveTextureARB(GL_TEXTURE1_ARB);
								glDisable(GL_TEXTURE_2D);
								
								glActiveTextureARB(GL_TEXTURE2_ARB);
								glDisable(GL_TEXTURE_2D);
								
								glActiveTextureARB(GL_TEXTURE3_ARB);
								glDisable(GL_TEXTURE_2D);

								
								glClientActiveTextureARB(GL_TEXTURE0_ARB);
								glDisableClientState(GL_TEXTURE_COORD_ARRAY);
								
								glClientActiveTextureARB(GL_TEXTURE1_ARB);
								glDisableClientState(GL_TEXTURE_COORD_ARRAY);
								
								glClientActiveTextureARB(GL_TEXTURE2_ARB);
								glDisableClientState(GL_TEXTURE_COORD_ARRAY);
								
								glClientActiveTextureARB(GL_TEXTURE3_ARB);
								glDisableClientState(GL_TEXTURE_COORD_ARRAY);
								
								
								
							}
							else
#endif
#ifndef GLES
							if ((MultiTexture)&&(dot3))
							{
								glActiveTextureARB(GL_TEXTURE0_ARB);
								glEnable(GL_TEXTURE_2D);

								if (fn_stage0) glBindTexture(GL_TEXTURE_2D,Lightmap[fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else glBindTexture(GL_TEXTURE_2D,Lightmap[nfo->nL]);

								if (fn_stage1) SetTexture2(fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
								else SetTexture2(nfo->nT+Decal_nt);

								glClientActiveTextureARB(GL_TEXTURE0_ARB);
								glEnableClientState(GL_TEXTURE_COORD_ARRAY);
								glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo2_Array);

								glClientActiveTextureARB(GL_TEXTURE1_ARB);
								glEnableClientState(GL_TEXTURE_COORD_ARRAY);
								glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);

								glActiveTextureARB(GL_TEXTURE0_ARB);
								glEnable(GL_TEXTURE_2D);

								glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE_ARB);

								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB,GL_TEXTURE);
								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB,GL_PRIMARY_COLOR_ARB);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_RGB_ARB,GL_SRC_COLOR);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_RGB_ARB,GL_SRC_COLOR);

								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_ALPHA_ARB,GL_TEXTURE);
								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_ALPHA_ARB,GL_PRIMARY_COLOR_ARB);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_ALPHA_ARB,GL_SRC_ALPHA);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_ALPHA_ARB,GL_SRC_ALPHA);

								glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB_ARB,GL_MODULATE);
								glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_ALPHA_ARB,GL_MODULATE);

								glActiveTextureARB(GL_TEXTURE1_ARB);
								glEnable(GL_TEXTURE_2D);

								glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE_ARB);

								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB,GL_TEXTURE);
								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB,GL_PREVIOUS_ARB);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_RGB_ARB,GL_SRC_COLOR);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_RGB_ARB,GL_SRC_COLOR);

								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_ALPHA_ARB,GL_TEXTURE);
								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_ALPHA_ARB,GL_PREVIOUS_ARB);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_ALPHA_ARB,GL_SRC_ALPHA);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_ALPHA_ARB,GL_SRC_ALPHA);

								glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB_ARB,GL_MODULATE);
								glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_ALPHA_ARB,GL_REPLACE);

								//ARG

								if (nfo->ref!=0)
								{
									glEnable(GL_BLEND);
									glBlendFunc(GL_ONE_MINUS_SRC_ALPHA,GL_SRC_ALPHA);
								}
								else
								{
									glDisable(GL_BLEND);
								}

								if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);

								glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(ActualVertexBuffer->Index_Array[nfo->iStart]));
							

								glActiveTextureARB(GL_TEXTURE0_ARB);
								glEnable(GL_TEXTURE_2D);

								if (fn_stage2) glBindTexture(GL_TEXTURE_2D,Lightmap[fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else glBindTexture(GL_TEXTURE_2D,Lightmap[nfo->nLV]);
								
								if (fn_stage3) SetTexture2(fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
								else SetTexture2(nfo->nT+bumpmap_settexture);

								glClientActiveTextureARB(GL_TEXTURE0_ARB);
								glEnableClientState(GL_TEXTURE_COORD_ARRAY);
								glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo3_Array);

								glClientActiveTextureARB(GL_TEXTURE1_ARB);
								glEnableClientState(GL_TEXTURE_COORD_ARRAY);
								glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);


								glActiveTextureARB(GL_TEXTURE0_ARB);
								glEnable(GL_TEXTURE_2D);

								glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE_ARB);

								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB,GL_TEXTURE);
								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB,GL_TEXTURE);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_RGB_ARB,GL_SRC_COLOR);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_RGB_ARB,GL_SRC_COLOR);

								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_ALPHA_ARB,GL_TEXTURE);
								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_ALPHA_ARB,GL_PRIMARY_COLOR_ARB);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_ALPHA_ARB,GL_SRC_ALPHA);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_ALPHA_ARB,GL_SRC_ALPHA);

								glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB_ARB,GL_REPLACE);
								glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_ALPHA_ARB,GL_REPLACE);


								glActiveTextureARB(GL_TEXTURE1_ARB);
								glEnable(GL_TEXTURE_2D);

								glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE_ARB);

								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB,GL_TEXTURE);
								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB,GL_PREVIOUS_ARB);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_RGB_ARB,GL_SRC_COLOR);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_RGB_ARB,GL_SRC_COLOR);

								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_ALPHA_ARB,GL_TEXTURE);
								glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_ALPHA_ARB,GL_PREVIOUS_ARB);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_ALPHA_ARB,GL_SRC_ALPHA);
								glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_ALPHA_ARB,GL_SRC_ALPHA);

								glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB_ARB,GL_DOT3_RGB_ARB);
								glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_ALPHA_ARB,GL_MODULATE);


								glEnable(GL_BLEND);
								glBlendFunc(GL_DST_COLOR,GL_SRC_COLOR);
								if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);

								glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(ActualVertexBuffer->Index_Array[nfo->iStart]));
							

							}
							else
#endif
							{
								if (MultiTexture)
								{
									glActiveTextureARB(GL_TEXTURE0_ARB);
									glEnable(GL_TEXTURE_2D);
									
									if (fn_stage0) glBindTexture(GL_TEXTURE_2D,Lightmap[fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
									else glBindTexture(GL_TEXTURE_2D,Lightmap[nfo->nL]);

									if (fn_stage1) SetTexture2(fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else SetTexture2(nfo->nT+Decal_nt);

									glClientActiveTextureARB(GL_TEXTURE0_ARB);
									glEnableClientState(GL_TEXTURE_COORD_ARRAY);
									glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo2_Array);

									glClientActiveTextureARB(GL_TEXTURE1_ARB);
									glEnableClientState(GL_TEXTURE_COORD_ARRAY);
									glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);


									glActiveTextureARB(GL_TEXTURE0_ARB);
									glEnable(GL_TEXTURE_2D);

									glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE_ARB);

									glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB,GL_TEXTURE);
									glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB,GL_PRIMARY_COLOR_ARB);
									glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_RGB_ARB,GL_SRC_COLOR);
									glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_RGB_ARB,GL_SRC_COLOR);

									glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_ALPHA_ARB,GL_TEXTURE);
									glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_ALPHA_ARB,GL_PRIMARY_COLOR_ARB);
									glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_ALPHA_ARB,GL_SRC_ALPHA);
									glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_ALPHA_ARB,GL_SRC_ALPHA);

									glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB_ARB,GL_MODULATE);
									glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_ALPHA_ARB,GL_MODULATE);


									glActiveTextureARB(GL_TEXTURE1_ARB);
									glEnable(GL_TEXTURE_2D);

									glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_COMBINE_ARB);

									glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_RGB_ARB,GL_TEXTURE);
									glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_RGB_ARB,GL_PREVIOUS_ARB);
									glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_RGB_ARB,GL_SRC_COLOR);
									glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_RGB_ARB,GL_SRC_COLOR);

									glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE0_ALPHA_ARB,GL_TEXTURE);
									glTexEnvi(GL_TEXTURE_ENV,GL_SOURCE1_ALPHA_ARB,GL_PREVIOUS_ARB);
									glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND0_ALPHA_ARB,GL_SRC_ALPHA);
									glTexEnvi(GL_TEXTURE_ENV,GL_OPERAND1_ALPHA_ARB,GL_SRC_ALPHA);

									glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_RGB_ARB,GL_MODULATE);
									glTexEnvi(GL_TEXTURE_ENV,GL_COMBINE_ALPHA_ARB,GL_REPLACE);
#ifndef GLES
									glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE_ARB,2);
#endif
									if (nfo->ref!=0)
									{
										glEnable(GL_BLEND);
										glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
									}
									else
									{
										glDisable(GL_BLEND);
									}


									if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);
									
									glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(ActualVertexBuffer->Index_Array[nfo->iStart]));
#ifndef GLES
									glTexEnvi(GL_TEXTURE_ENV,GL_RGB_SCALE_ARB,1);
#endif					
								}
								else
								{
									if (nfo->ref!=0)
									{
										glEnable(GL_BLEND);
										glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
									}
									else
									{
										glDisable(GL_BLEND);
									}

									if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_KEEP);
									if (fn_stage1) SetTexture(fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else SetTexture(nfo->nT+Decal_nt);

									glEnableClientState(GL_TEXTURE_COORD_ARRAY);
									glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo_Array);
									glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
									glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(ActualVertexBuffer->Index_Array[nfo->iStart]));


									glEnable(GL_BLEND);
									glBlendFunc(GL_DST_COLOR,GL_ZERO);
				
									
									glEnable(GL_TEXTURE_2D);
									if (fn_stage0) glBindTexture(GL_TEXTURE_2D,Lightmap[fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
									else glBindTexture(GL_TEXTURE_2D,Lightmap[nfo->nL]);
									
									
									glEnableClientState(GL_TEXTURE_COORD_ARRAY);
									glTexCoordPointer(2,GL_FLOAT,0,ActualVertexBuffer->TexCoo2_Array);
									glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);


									if (replace) glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);

									
									glDrawElements(GL_TRIANGLES,(nfo->iEnd-nfo->iStart),LIB3D_TYPE_INDEX,&(ActualVertexBuffer->Index_Array[nfo->iStart]));
								
								}
							}
						}

						switch(BLEND_GL)
						{
						case 0:
							glDisable(GL_BLEND);
							break;
						case 1:
							glEnable(GL_BLEND);
							glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
							break;
						case 3:
							glEnable(GL_BLEND);
							glBlendFunc(GL_SRC_ALPHA,GL_ONE);
							break;
						case 4:
							glEnable(GL_BLEND);
							glBlendFunc(GL_DST_COLOR,GL_ZERO);
							break;

						};
						
					}
					
					nfo=ActualVertexBuffer->ListeSE.GetNext();
				}
			}

			if (MultiTexture)
			{
				glActiveTextureARB(GL_TEXTURE1_ARB);
				glEnable(GL_TEXTURE_2D);
				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_DECAL);
				glActiveTextureARB(GL_TEXTURE0_ARB);
				glEnable(GL_TEXTURE_2D);
				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
				SetParams(API3D_TEXTURING2,OFF);
			}
			else
			{
				glEnable(GL_TEXTURE_2D);
				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
			}
		}
	}

	if ((!(type&API3D_VERTEXPROGRAM))&&(!ActualEffect))
	{
	
		glDisable(GL_LIGHTING);
		glDisable(GL_COLOR_MATERIAL);
		
		glDisableClientState(GL_COLOR_ARRAY);
		glDisableClientState(GL_VERTEX_ARRAY);
		glDisableClientState(GL_NORMAL_ARRAY);
		if (MultiTexture) glClientActiveTextureARB(GL_TEXTURE0_ARB);
		glDisableClientState(GL_TEXTURE_COORD_ARRAY);

		if (MultiTexture) 
		{
			glClientActiveTextureARB(GL_TEXTURE1_ARB);
			glDisableClientState(GL_TEXTURE_COORD_ARRAY);
		}

	}

	if (ActualVertexBuffer->vbo)
	{
		glBindBufferARB(GL_ARRAY_BUFFER,0);
		glBindBufferARB(GL_ELEMENT_ARRAY_BUFFER,0);
	}


	return;

#endif


	// D3D DRAWVB DIRECTX

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// DIRECT3D
	D3DXMATRIX matView, matWorld,matProj,matViewProj,matViewInv,mat;
	D3DXVECTOR4 vect;
	CMatrix M,M0;
	int n;
	int temp;
//------------------------------------------------------------------------------------------------ DIRECT3D ----------

#ifdef API3D_DIRECT3D9
	D3DVERTEXELEMENT9 decltweening[] =
	{
		{ 0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_POSITION, 0}, 
		{ 0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_NORMAL,   0}, 
		{ 0, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_TEXCOORD, 0}, 
		{ 1,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_POSITION, 1}, 
		{ 1, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_NORMAL,   1}, 
		{ 1, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_TEXCOORD, 1}, 
		D3DDECL_END()
	};
#endif

	Flush();

	D3DDevice->SetRenderState( D3DRS_VERTEXBLEND, D3DVBF_DISABLE );
	
#ifdef API3D_DIRECT3D9
	D3DMATERIAL9 m;
	D3DDevice->SetVertexDeclaration(NULL);
#else
	D3DMATERIAL8 m;
#endif

	if ((!SecondarySurface)&&(SelectedRenderTarget!=PRIMARY)) return;

	DWORD c0,c1;

	switch (ActualVertexBuffer->TypeVB)
	{
	case 0:
		// texturage normal
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZCOLORTEX));
		D3DDevice->SetFVF( D3DFVF_XYZCOLORTEX );
#else
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZCOLORTEX));
		D3DDevice->SetVertexShader(D3DFVF_XYZCOLORTEX);
#endif
		break;
	case 1:
		// texturage normal
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZCOLORTEX));
		D3DDevice->SetFVF( D3DFVF_XYZCOLORTEX );
#else
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZCOLORTEX));
		D3DDevice->SetVertexShader(D3DFVF_XYZCOLORTEX);
#endif
		break;
	case 2:
		// gouraud simple
		D3DDevice->SetTexture(0,NULL);
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZCOLOR));
		D3DDevice->SetFVF( D3DFVF_XYZCOLOR );
#else
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZCOLOR));
		D3DDevice->SetVertexShader(D3DFVF_XYZCOLOR);
#endif
		break;
	case 3:
		// texturage normal
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZCOLORTEX));
		D3DDevice->SetFVF( D3DFVF_XYZCOLORTEX );
#else
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZCOLORTEX));
		D3DDevice->SetVertexShader(D3DFVF_XYZCOLORTEX);
#endif
		break;
	case 4:
		// double texturage
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZCOLORTEX2));
		D3DDevice->SetFVF( D3DFVF_XYZCOLORTEX2 );
#else
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZCOLORTEX2));
		D3DDevice->SetVertexShader(D3DFVF_XYZCOLORTEX2);
#endif	
		c0=0;
		c1=1;

		break;
	case 5:
		// TNL

		if (ActualVertexBuffer->Type&API3D_EDGESDG)
		{
#ifdef API3D_DIRECT3D9
			D3DDevice->SetFVF( D3DFVF_XYZNORMALTEX );
			D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
#else

			D3DDevice->SetVertexShader(D3DFVF_XYZNORMALTEX);
			D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZNORMALTEX));
#endif

		}
		else
		{
#ifdef API3D_DIRECT3D9
		
			D3DDevice->SetFVF( D3DFVF_XYZNORMALTEX );
			
			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				if (TNL_VD==NULL) D3DDevice->CreateVertexDeclaration( decltweening, &TNL_VD );

				D3DDevice->SetVertexDeclaration(TNL_VD);

				D3DDevice->SetRenderState( D3DRS_VERTEXBLEND, D3DVBF_TWEENING );
				D3DDevice->SetRenderState( D3DRS_TWEENFACTOR, *(DWORD*) &ActualVertexBuffer->stream_interpolant );

				if (ActualVertexBuffer->Type&API3D_STREAMS)
				{
					if (ActualVertexBuffer->stream1>=0) D3DDevice->SetStreamSource( 0, ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream1],0, sizeof(XYZNORMALTEX));
					else D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
					if (ActualVertexBuffer->stream2>=0) D3DDevice->SetStreamSource( 1, ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream2],0, sizeof(XYZNORMALTEX));
					else D3DDevice->SetStreamSource( 1, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
				}
				else
				{
					D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
					D3DDevice->SetStreamSource( 1, ActualVertexBuffer->STREAMS[0],0, sizeof(XYZNORMALTEX));
				}
			}
			else
			{
				 D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
			}
#else
			D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZNORMALTEX));
			

			if (ActualVertexBuffer->Type&API3D_MORPH)
			{
				if (handle_morph==0)
				{
					DWORD decl[]={
						D3DVSD_STREAM(0),
						D3DVSD_REG( D3DVSDE_POSITION, D3DVSDT_FLOAT3 ),
						D3DVSD_REG( D3DVSDE_NORMAL, D3DVSDT_FLOAT3 ),
						D3DVSD_REG( D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2 ),

						D3DVSD_STREAM(1),
						D3DVSD_REG( D3DVSDE_POSITION2, D3DVSDT_FLOAT3),
						D3DVSD_REG( D3DVSDE_NORMAL2, D3DVSDT_FLOAT3 ),
						D3DVSD_END()
					};

					D3DDevice->CreateVertexShader(decl,NULL,&handle_morph,0);
				}

				D3DDevice->SetVertexShader(handle_morph);

				D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZNORMALTEX));
				D3DDevice->SetStreamSource( 1, ActualVertexBuffer->STREAMS[0], sizeof(XYZNORMALTEX));

				D3DDevice->SetRenderState( D3DRS_VERTEXBLEND, D3DVBF_TWEENING );
				D3DDevice->SetRenderState( D3DRS_TWEENFACTOR, *(DWORD*) &ActualVertexBuffer->stream_interpolant );
			}
			else D3DDevice->SetVertexShader(D3DFVF_XYZNORMALTEX);


#endif
			temp=0;

			if (aT>=0)
			{
				if (iTexture[aT])
				{
					if (iTexture[aT]->Material)
					{
#ifdef API3D_DIRECT3D9
						ZeroMemory( &m, sizeof(D3DMATERIAL9) );
#else
						ZeroMemory( &m, sizeof(D3DMATERIAL8) );
#endif
						
						m.Ambient.r = iTexture[aT]->Material->ambient[0];
						m.Ambient.g = iTexture[aT]->Material->ambient[1];
						m.Ambient.b = iTexture[aT]->Material->ambient[2];
						m.Ambient.a = iTexture[aT]->Material->ambient[3];
						
						m.Diffuse.r = iTexture[aT]->Material->diffuse[0];
						m.Diffuse.g = iTexture[aT]->Material->diffuse[1];
						m.Diffuse.b = iTexture[aT]->Material->diffuse[2];
						m.Diffuse.a = iTexture[aT]->Material->diffuse[3];

						m.Specular.r = iTexture[aT]->Material->specular[0];
						m.Specular.g = iTexture[aT]->Material->specular[1];
						m.Specular.b = iTexture[aT]->Material->specular[2];
						m.Specular.a = iTexture[aT]->Material->specular[3];
						m.Power = (float) iTexture[aT]->Material->power;

						D3DDevice->SetMaterial( &m );
						temp=1;
					}
				}
			}
			
			if (temp==0)
			{
#ifdef API3D_DIRECT3D9
				ZeroMemory( &m, sizeof(D3DMATERIAL9) );
#else
				ZeroMemory( &m, sizeof(D3DMATERIAL8) );
#endif
				m.Diffuse.r = m.Ambient.r = 1.0f;
				m.Diffuse.g = m.Ambient.g = 1.0f;
				m.Diffuse.b = m.Ambient.b = 1.0f;
				m.Diffuse.a = m.Ambient.a = 1.0f;

				m.Specular.r = 1.0f;
				m.Specular.g = 1.0f;
				m.Specular.b = 1.0f;
				m.Specular.a = 1.0f;

				m.Power = 20;
				D3DDevice->SetMaterial( &m );

			}

		}

		break;
	case 6:
		// lightmap
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZCOLORTEX2));
		D3DDevice->SetFVF( D3DFVF_XYZCOLORTEX2 );
#else
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZCOLORTEX2));
		D3DDevice->SetVertexShader(D3DFVF_XYZCOLORTEX2);
#endif
		c0=1;
		c1=0;

		break;
	case 7:
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSU,D3DTADDRESS_WRAP);
		D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSV,D3DTADDRESS_WRAP);
		D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);

		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZCOLORTEX3));
		D3DDevice->SetFVF( D3DFVF_XYZCOLORTEX3 );
#else
		D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSU,D3DTADDRESS_WRAP);
		D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSV,D3DTADDRESS_WRAP);
		D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);

		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZCOLORTEX3));
		D3DDevice->SetVertexShader(D3DFVF_XYZCOLORTEX3);
#endif
		break;


	case 9:
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSU,D3DTADDRESS_WRAP);
		D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSV,D3DTADDRESS_WRAP);
		D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);

		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALCOLORTEX4));
		D3DDevice->SetFVF( D3DFVF_XYZNORMALCOLORTEX4 );
#else
		D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSU,D3DTADDRESS_WRAP);
		D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSV,D3DTADDRESS_WRAP);
		D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);

		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZNORMALCOLORTEX4));
		D3DDevice->SetVertexShader(D3DFVF_XYZNORMALCOLORTEX4);
#endif
		break;



	case 32+0:
		// texturage normal
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(BLENDXYZCOLORTEX));
		D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX );
#else
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(BLENDXYZCOLORTEX));
		D3DDevice->SetVertexShader(D3DFVF_BLENDXYZCOLORTEX);
#endif
		break;
	case 32+1:
		// texturage normal
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(BLENDXYZCOLORTEX));
		D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX );
#else
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(BLENDXYZCOLORTEX));
		D3DDevice->SetVertexShader(D3DFVF_BLENDXYZCOLORTEX);
#endif
		break;
	case 32+2:
		// gouraud simple
		D3DDevice->SetTexture(0,NULL);
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(BLENDXYZCOLOR));
		D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLOR );
#else
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(BLENDXYZCOLOR));
		D3DDevice->SetVertexShader(D3DFVF_BLENDXYZCOLOR);
#endif
		break;
	case 32+3:
		// texturage normal
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(BLENDXYZCOLORTEX));
		D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX );
#else
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(BLENDXYZCOLORTEX));
		D3DDevice->SetVertexShader(D3DFVF_BLENDXYZCOLORTEX);
#endif
		break;
	case 32+4:
		// double texturage
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(BLENDXYZCOLORTEX2));
		D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX2 );
#else
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(BLENDXYZCOLORTEX2));
		D3DDevice->SetVertexShader(D3DFVF_BLENDXYZCOLORTEX2);
#endif
		c0=0;
		c1=1;

		break;
	case 32+5:
		// TNL
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(BLENDXYZNORMALTEX));
		D3DDevice->SetFVF( D3DFVF_BLENDXYZNORMALTEX );
#else
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(BLENDXYZNORMALTEX));
		D3DDevice->SetVertexShader(D3DFVF_BLENDXYZNORMALTEX);
#endif
		temp=0;

		if (aT>=0)
		{
			if (iTexture[aT])
			{
				if (iTexture[aT]->Material)
				{
#ifdef API3D_DIRECT3D9
					ZeroMemory( &m, sizeof(D3DMATERIAL9) );
#else
					ZeroMemory( &m, sizeof(D3DMATERIAL8) );
#endif					
					m.Ambient.r = iTexture[aT]->Material->ambient[0];
					m.Ambient.g = iTexture[aT]->Material->ambient[1];
					m.Ambient.b = iTexture[aT]->Material->ambient[2];
					m.Ambient.a = iTexture[aT]->Material->ambient[3];
					
					m.Diffuse.r = iTexture[aT]->Material->diffuse[0];
					m.Diffuse.g = iTexture[aT]->Material->diffuse[1];
					m.Diffuse.b = iTexture[aT]->Material->diffuse[2];
					m.Diffuse.a = iTexture[aT]->Material->diffuse[3];

					m.Specular.r = iTexture[aT]->Material->specular[0];
					m.Specular.g = iTexture[aT]->Material->specular[1];
					m.Specular.b = iTexture[aT]->Material->specular[2];
					m.Specular.a = iTexture[aT]->Material->specular[3];
					m.Power = (float) iTexture[aT]->Material->power;

					D3DDevice->SetMaterial( &m );
					temp=1;
				}
			}
		}
		
		if (temp==0)
		{
#ifdef API3D_DIRECT3D9
			ZeroMemory( &m, sizeof(D3DMATERIAL9) );
#else
			ZeroMemory( &m, sizeof(D3DMATERIAL8) );
#endif
			m.Diffuse.r = m.Ambient.r = 1.0f;
			m.Diffuse.g = m.Ambient.g = 1.0f;
			m.Diffuse.b = m.Ambient.b = 1.0f;
			m.Diffuse.a = m.Ambient.a = 1.0f;

			m.Specular.r = 1.0f;
			m.Specular.g = 1.0f;
			m.Specular.b = 1.0f;
			m.Specular.a = 1.0f;

			m.Power = 20;
			D3DDevice->SetMaterial( &m );

		}

		break;
	case 32+6:
		// lightmap
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(BLENDXYZCOLORTEX2));
		D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX2 );
#else
		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(BLENDXYZCOLORTEX2));
		D3DDevice->SetVertexShader(D3DFVF_BLENDXYZCOLORTEX2);
#endif
		c0=1;
		c1=0;

		break;
	case 32+7:

		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSU,D3DTADDRESS_WRAP);
		D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSV,D3DTADDRESS_WRAP);
		D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);

		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(BLENDXYZCOLORTEX3));
		D3DDevice->SetFVF( D3DFVF_BLENDXYZCOLORTEX3 );
#else
		D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSU,D3DTADDRESS_WRAP);
		D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSV,D3DTADDRESS_WRAP);
		D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);

		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(BLENDXYZCOLORTEX3));
		D3DDevice->SetVertexShader(D3DFVF_BLENDXYZCOLORTEX3);
#endif
		break;

	case 32+9:
		
#ifdef API3D_DIRECT3D9
		D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSU,D3DTADDRESS_WRAP);
		D3DDevice->SetSamplerState(1,D3DSAMP_ADDRESSV,D3DTADDRESS_WRAP);
		D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);

		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(BLENDXYZNORMALCOLORTEX4));
		D3DDevice->SetFVF( D3DFVF_BLENDXYZNORMALCOLORTEX4 );
#else
		D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSU,D3DTADDRESS_WRAP);
		D3DDevice->SetTextureStageState(1,D3DTSS_ADDRESSV,D3DTADDRESS_WRAP);
		D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);

		D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(BLENDXYZNORMALCOLORTEX4));
		D3DDevice->SetVertexShader(D3DFVF_BLENDXYZNORMALCOLORTEX4);
#endif
		break;

	};

#ifdef API3D_DIRECT3D9
	D3DXHANDLE hndl;
#endif


	D3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   LevelTexture0);
	D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);

	D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   LevelTexture0);
	D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );


	CVertexBuffer *vbeffect;

	// DXVB

	if (!ActualVertexBuffer->Grouped)
	{
		
		if ((ActualVertexBuffer->Type&API3D_VERTEXPROGRAM)||(ActualEffect))
		{
			if (ActualEffect) vbeffect=ActualEffect;
			else vbeffect=ActualVertexBuffer;

			UINT uPasses=1;

			if (vbeffect->effect)
			{

				D3DDevice->SetRenderState( D3DRS_VERTEXBLEND, D3DVBF_DISABLE );

#ifdef API3D_DIRECT3D9

				if (ActualVertexBuffer->Type&API3D_MORPH)
				{
					D3DDevice->SetFVF(D3DFVF_XYZNORMALTEX);

					D3DVERTEXELEMENT9 declShdMorph[] =
					{
						{ 0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_POSITION, 0}, 
						{ 0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_NORMAL,   0}, 
						{ 0, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_TEXCOORD, 0}, 
						{ 1,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_POSITION, 1}, 
						{ 1, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_NORMAL,   1}, 
						{ 1, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_TEXCOORD, 1}, 
						D3DDECL_END()
					};


					if (CR_VD==NULL) D3DDevice->CreateVertexDeclaration( declShdMorph, &CR_VD );

					D3DDevice->SetVertexDeclaration(CR_VD);

					if (ActualVertexBuffer->Type&API3D_STREAMS)
					{
						if (ActualVertexBuffer->stream1>=0) D3DDevice->SetStreamSource( 0, ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream1],0, sizeof(XYZNORMALTEX));
						else D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
						if (ActualVertexBuffer->stream2>=0) D3DDevice->SetStreamSource( 1, ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream2],0, sizeof(XYZNORMALTEX));
						else D3DDevice->SetStreamSource( 1, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
					}
					else
					{
						D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
						D3DDevice->SetStreamSource( 1, ActualVertexBuffer->STREAMS[0],0, sizeof(XYZNORMALTEX));
					}

				}
				D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else

				if (ActualVertexBuffer->Type&API3D_MORPH)
				{
					D3DDevice->SetVertexShader(D3DFVF_XYZNORMALTEX);
					D3DDevice->SetStreamSource(0,ActualVertexBuffer->D3D8VB,sizeof(XYZNORMALTEX));
					D3DDevice->SetStreamSource(1,ActualVertexBuffer->STREAMS[0],sizeof(XYZNORMALTEX));
				}

				D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif

				vbeffect->effect->Begin( &uPasses, 0);
				for( UINT iPass = 0; iPass < uPasses; iPass++ )
				{
					if (replace) 
					{
						if (iPass==uPasses-1) D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_REPLACE);
						else D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_KEEP);
					}
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c

					vbeffect->effect->BeginPass( iPass );
					vbeffect->effect->CommitChanges();
					D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
					vbeffect->effect->EndPass();

#else
					vbeffect->effect->Pass( iPass );
					D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
#endif
#else
					vbeffect->effect->Pass( iPass );
					D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
#endif
				}
				vbeffect->effect->End();

				for (n=0;n<6;n++)
				{
					if (vbeffect->Texture[n]) vbeffect->Texture[n]->Release();
					vbeffect->Texture[n]=NULL;
				}

				if (aT!=-555) SetTexture(aT);
				
				vbeffect->pos_texture=0;
#ifdef API3D_DIRECT3D9
				D3DDevice->SetVertexDeclaration(NULL);
#endif
			}
		}
		else
		if (ActualVertexBuffer->Type&API3D_EDGESDG)
		{
			UINT uPasses=1;
					
			
#ifdef API3D_DIRECT3D9

			//LPD3DXBUFFER errors;

			if ((SHDVOLUME==NULL)||(SHDVOLUMEm==NULL)||(SHDVOLUME_CR1==NULL)||(SHDVOLUME_CR2==NULL)||(SHDVOLUME_CR1m==NULL)||(SHDVOLUME_CR2m==NULL))
			{
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SH, len_SHADOW_VOLUME_SH,NULL,NULL,0,NULL, &SHDVOLUME, NULL ) ) ) return;
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SHc, len_SHADOW_VOLUME_SHc,NULL,NULL,0,NULL, &SHDVOLUMEc, NULL ) ) ) return;
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SHm, len_SHADOW_VOLUME_SHm,NULL,NULL,0,NULL, &SHDVOLUMEm, NULL) ) ) return;
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SHmc, len_SHADOW_VOLUME_SHmc,NULL,NULL,0,NULL, &SHDVOLUMEmc, NULL ) ) ) return;

				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SHn, len_SHADOW_VOLUME_SHn,NULL,NULL,0,NULL, &SHDVOLUMEn, NULL ) ) ) return;
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SHcn, len_SHADOW_VOLUME_SHcn,NULL,NULL,0,NULL, &SHDVOLUMEcn, NULL ) ) ) return;
				
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SH_CarmackReverse1, len_SHADOW_VOLUME_SH_CarmackReverse1,NULL,NULL,0,NULL, &SHDVOLUME_CR1, NULL ) ) ) return;
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SH_CarmackReverse2, len_SHADOW_VOLUME_SH_CarmackReverse2,NULL,NULL,0,NULL, &SHDVOLUME_CR2, NULL) ) ) return;
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SH_CarmackReverse1m, len_SHADOW_VOLUME_SH_CarmackReverse1m,NULL,NULL,0,NULL, &SHDVOLUME_CR1m, NULL ) ) ) return;
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SH_CarmackReverse2m, len_SHADOW_VOLUME_SH_CarmackReverse2m,NULL,NULL,0,NULL, &SHDVOLUME_CR2m, NULL ) ) ) return;

				if (FAILED(SHDVOLUME->FindNextValidTechnique(NULL,&hndl))) return;
				SHDVOLUME->SetTechnique(hndl);
				if (FAILED(SHDVOLUMEc->FindNextValidTechnique(NULL,&hndl))) return;
				SHDVOLUMEc->SetTechnique(hndl);

				if (FAILED(SHDVOLUMEn->FindNextValidTechnique(NULL,&hndl))) return;
				SHDVOLUMEn->SetTechnique(hndl);
				if (FAILED(SHDVOLUMEcn->FindNextValidTechnique(NULL,&hndl))) return;
				SHDVOLUMEcn->SetTechnique(hndl);
				
				if (FAILED(SHDVOLUMEm->FindNextValidTechnique(NULL,&hndl))) return;
				SHDVOLUMEm->SetTechnique(hndl);
				if (FAILED(SHDVOLUMEmc->FindNextValidTechnique(NULL,&hndl))) return;
				SHDVOLUMEmc->SetTechnique(hndl);

				if (FAILED(SHDVOLUME_CR1->FindNextValidTechnique(NULL,&hndl))) return;
				SHDVOLUME_CR1->SetTechnique(hndl);
				if (FAILED(SHDVOLUME_CR2->FindNextValidTechnique(NULL,&hndl))) return;
				SHDVOLUME_CR2->SetTechnique(hndl);
					
				if (FAILED(SHDVOLUME_CR1m->FindNextValidTechnique(NULL,&hndl))) return;
				SHDVOLUME_CR1m->SetTechnique(hndl);
				if (FAILED(SHDVOLUME_CR2m->FindNextValidTechnique(NULL,&hndl))) return;
				SHDVOLUME_CR2m->SetTechnique(hndl);

			}
#else			
			if ((SHDVOLUME==NULL)||(SHDVOLUMEm==NULL)||(SHDVOLUME_CR1==NULL)||(SHDVOLUME_CR2==NULL)||(SHDVOLUME_CR1m==NULL)||(SHDVOLUME_CR2m==NULL))
			{
				D3DXTECHNIQUE_DESC tt;

				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SH, len_SHADOW_VOLUME_SH, &SHDVOLUME, NULL ) ) )  return;
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SHc, len_SHADOW_VOLUME_SHc, &SHDVOLUMEc, NULL ) ) )  return;

				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SHn, len_SHADOW_VOLUME_SHn, &SHDVOLUMEn, NULL ) ) )  return;
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SHcn, len_SHADOW_VOLUME_SHcn, &SHDVOLUMEcn, NULL ) ) )  return;
				
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SHm, len_SHADOW_VOLUME_SHm, &SHDVOLUMEm, NULL ) ) )  return;
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SHmc, len_SHADOW_VOLUME_SHmc, &SHDVOLUMEmc, NULL ) ) )  return;

				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SH_CarmackReverse1, len_SHADOW_VOLUME_SH_CarmackReverse1, &SHDVOLUME_CR1, NULL ) ) ) return;
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SH_CarmackReverse2, len_SHADOW_VOLUME_SH_CarmackReverse2, &SHDVOLUME_CR2, NULL ) ) ) return;
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SH_CarmackReverse1m, len_SHADOW_VOLUME_SH_CarmackReverse1m, &SHDVOLUME_CR1m, NULL ) ) ) return;
				if (FAILED(D3DXCreateEffect( D3DDevice, SHADOW_VOLUME_SH_CarmackReverse2m, len_SHADOW_VOLUME_SH_CarmackReverse2m, &SHDVOLUME_CR2m, NULL ) ) ) return;

				if (FAILED(SHDVOLUME->FindNextValidTechnique(NULL,&tt))) return;
				SHDVOLUME->SetTechnique(tt.Index);
				if (FAILED(SHDVOLUMEc->FindNextValidTechnique(NULL,&tt))) return;
				SHDVOLUMEc->SetTechnique(tt.Index);

				if (FAILED(SHDVOLUMEn->FindNextValidTechnique(NULL,&tt))) return;
				SHDVOLUMEn->SetTechnique(tt.Index);
				if (FAILED(SHDVOLUMEcn->FindNextValidTechnique(NULL,&tt))) return;
				SHDVOLUMEcn->SetTechnique(tt.Index);
				
				if (FAILED(SHDVOLUMEm->FindNextValidTechnique(NULL,&tt))) return;
				SHDVOLUMEm->SetTechnique(tt.Index);
				if (FAILED(SHDVOLUMEmc->FindNextValidTechnique(NULL,&tt))) return;
				SHDVOLUMEmc->SetTechnique(tt.Index);
			
				if (FAILED(SHDVOLUME_CR1->FindNextValidTechnique(NULL,&tt))) return;
				SHDVOLUME_CR1->SetTechnique(tt.Index);
				if (FAILED(SHDVOLUME_CR2->FindNextValidTechnique(NULL,&tt))) return;
				SHDVOLUME_CR2->SetTechnique(tt.Index);

				if (FAILED(SHDVOLUME_CR1m->FindNextValidTechnique(NULL,&tt))) return;
				SHDVOLUME_CR1m->SetTechnique(tt.Index);
				if (FAILED(SHDVOLUME_CR2m->FindNextValidTechnique(NULL,&tt))) return;
				SHDVOLUME_CR2m->SetTechnique(tt.Index);	
			}

#endif
			int state=states(ALGO_STENCIL_SHADOWING);
			if (state==1)
			{
				// REVERSE

				D3DXVECTOR4 Len(ActualVertexBuffer->fValue1,ActualVertexBuffer->fValue1,ActualVertexBuffer->fValue1,0);
				
				n=ActualVertexBuffer->iValue1;
				D3DXVECTOR4 Light(Lights[n].Pos.x,Lights[n].Pos.y,Lights[n].Pos.z,0.0f);

				D3DDevice->GetTransform( D3DTS_VIEW, &matView );
				D3DDevice->GetTransform( D3DTS_WORLD, &matWorld );
				D3DDevice->GetTransform( D3DTS_PROJECTION, &matProj );

				D3DXMatrixMultiply( &matViewProj, &matView, &matProj );

				if ((ActualVertexBuffer->Type&API3D_MORPH)==0)
				{
					SHDVOLUME_CR1->SetMatrix( "matWorld", &matWorld );
					SHDVOLUME_CR1->SetMatrix( "matViewProj", &matViewProj );
					SHDVOLUME_CR1->SetVector( "Light", &Light);
					SHDVOLUME_CR1->SetVector( "Len", &Len);

					SHDVOLUME_CR2->SetMatrix( "matWorld", &matWorld );
					SHDVOLUME_CR2->SetMatrix( "matViewProj", &matViewProj );
					SHDVOLUME_CR2->SetVector( "Light", &Light);
					SHDVOLUME_CR2->SetVector( "Len", &Len);
				}
				else
				{
					D3DXVECTOR4 T(ActualVertexBuffer->stream_interpolant,ActualVertexBuffer->stream_interpolant,ActualVertexBuffer->stream_interpolant,ActualVertexBuffer->stream_interpolant);

					SHDVOLUME_CR1m->SetMatrix( "matWorld", &matWorld );
					SHDVOLUME_CR1m->SetMatrix( "matViewProj", &matViewProj );
					SHDVOLUME_CR1m->SetVector( "Light", &Light);
					SHDVOLUME_CR1m->SetVector( "Len", &Len);
					SHDVOLUME_CR1m->SetVector( "Interpolant", &T);

					SHDVOLUME_CR2m->SetMatrix( "matWorld", &matWorld );
					SHDVOLUME_CR2m->SetMatrix( "matViewProj", &matViewProj );
					SHDVOLUME_CR2m->SetVector( "Light", &Light);
					SHDVOLUME_CR2m->SetVector( "Len", &Len);
					SHDVOLUME_CR2m->SetVector( "Interpolant", &T);
				}

				if ((ActualVertexBuffer->Type&API3D_MORPH)==0)
				{
#ifdef API3D_DIRECT3D9
					D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
					D3DDevice->SetFVF(D3DFVF_XYZNORMALTEX);
					D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else
					D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZNORMALTEX));
					D3DDevice->SetVertexShader(D3DFVF_XYZNORMALTEX);
					D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif

					SHDVOLUME_CR1->Begin( &uPasses, 0);
					for( UINT iPass = 0; iPass < uPasses; iPass++ )
					{
						
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
						SHDVOLUME_CR1->BeginPass( iPass );
						SHDVOLUME_CR1->CommitChanges();
						D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
						SHDVOLUME_CR1->EndPass();
#else
						SHDVOLUME_CR1->Pass( iPass );
						D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
#endif
#else
						SHDVOLUME_CR1->Pass( iPass );
						D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
#endif
					}
					SHDVOLUME_CR1->End();

					if (ActualVertexBuffer->secondary)
					{						
#ifdef API3D_DIRECT3D9
						D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->D3D9VB,0, sizeof(XYZNORMALTEX));
						D3DDevice->SetFVF(D3DFVF_XYZNORMALTEX);
						D3DDevice->SetIndices(ActualVertexBuffer->secondary->D3D9INDEX);
#else
						D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->D3D8VB, sizeof(XYZNORMALTEX));
						D3DDevice->SetVertexShader(D3DFVF_XYZNORMALTEX);
						D3DDevice->SetIndices(ActualVertexBuffer->secondary->D3D8INDEX,0);
#endif	
						SHDVOLUME_CR2->Begin( &uPasses, 0);
						for( UINT iPass = 0; iPass < uPasses; iPass++ )
						{

#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
							SHDVOLUME_CR2->BeginPass( iPass );
							SHDVOLUME_CR2->CommitChanges();
							D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->secondary->nVerticesActif,0,ActualVertexBuffer->secondary->nIndicesActif/3); 
							SHDVOLUME_CR2->EndPass();
#else
							SHDVOLUME_CR2->Pass( iPass );
							D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->secondary->nVerticesActif,0,ActualVertexBuffer->secondary->nIndicesActif/3); 
#endif
#else
							SHDVOLUME_CR2->Pass( iPass );
							D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,ActualVertexBuffer->secondary->nVerticesActif,0,ActualVertexBuffer->secondary->nIndicesActif/3); 
#endif
						}
						SHDVOLUME_CR2->End();
					}

				}
				else
				{

#ifdef API3D_DIRECT3D9
					D3DDevice->SetFVF(D3DFVF_XYZNORMALTEX);

					D3DVERTEXELEMENT9 declShdMorph[] =
					{
						{ 0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_POSITION, 0}, 
						{ 0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_NORMAL,   0}, 
						{ 0, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_TEXCOORD, 0}, 
						{ 1,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_POSITION, 1}, 
						{ 1, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_NORMAL,   1}, 
						{ 1, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_TEXCOORD, 1}, 
						D3DDECL_END()
					};


					if (CR_VD==NULL) D3DDevice->CreateVertexDeclaration( declShdMorph, &CR_VD );

					D3DDevice->SetVertexDeclaration(CR_VD);

					if (ActualVertexBuffer->Type&API3D_STREAMS)
					{
						if (ActualVertexBuffer->stream1>=0) D3DDevice->SetStreamSource( 0, ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream1],0, sizeof(XYZNORMALTEX));
						else D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
						if (ActualVertexBuffer->stream2>=0) D3DDevice->SetStreamSource( 1, ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream2],0, sizeof(XYZNORMALTEX));
						else D3DDevice->SetStreamSource( 1, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
					}
					else
					{
						D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
						D3DDevice->SetStreamSource( 1, ActualVertexBuffer->STREAMS[0],0, sizeof(XYZNORMALTEX));
					}

					D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else
					D3DDevice->SetVertexShader(D3DFVF_XYZNORMALTEX);
					D3DDevice->SetStreamSource(0,ActualVertexBuffer->D3D8VB,sizeof(XYZNORMALTEX));
					D3DDevice->SetStreamSource(1,ActualVertexBuffer->STREAMS[0],sizeof(XYZNORMALTEX));
					D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif


					SHDVOLUME_CR1m->Begin( &uPasses, 0);
					for( UINT iPass = 0; iPass < uPasses; iPass++ )
					{
						
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
						SHDVOLUME_CR1m->BeginPass( iPass );
						SHDVOLUME_CR1m->CommitChanges();
						D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
						SHDVOLUME_CR1m->EndPass();
#else
						SHDVOLUME_CR1m->Pass( iPass );
						D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
#endif
#else
						SHDVOLUME_CR1m->Pass( iPass );
						D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
#endif
					}
					SHDVOLUME_CR1m->End();


					if (ActualVertexBuffer->secondary)
					{	
#ifdef API3D_DIRECT3D9
						D3DDevice->SetFVF(D3DFVF_XYZNORMALTEX);
						D3DDevice->SetVertexDeclaration(CR_VD);

						if (ActualVertexBuffer->Type&API3D_STREAMS)
						{
							if (ActualVertexBuffer->stream1>=0) D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->STREAMS[ActualVertexBuffer->stream1],0, sizeof(XYZNORMALTEX));
							else D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->D3D9VB,0, sizeof(XYZNORMALTEX));
							if (ActualVertexBuffer->stream2>=0) D3DDevice->SetStreamSource( 1, ActualVertexBuffer->secondary->STREAMS[ActualVertexBuffer->stream2],0, sizeof(XYZNORMALTEX));
							else D3DDevice->SetStreamSource( 1, ActualVertexBuffer->secondary->D3D9VB,0, sizeof(XYZNORMALTEX));

						}
						else
						{
							D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->D3D9VB,0, sizeof(XYZNORMALTEX));
							D3DDevice->SetStreamSource( 1, ActualVertexBuffer->secondary->STREAMS[0],0, sizeof(XYZNORMALTEX));
						}

//						D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->D3D9VB,0, sizeof(XYZNORMALTEX));
//						D3DDevice->SetStreamSource( 1, ActualVertexBuffer->secondary->STREAMS[0],0, sizeof(XYZNORMALTEX));
						D3DDevice->SetIndices(ActualVertexBuffer->secondary->D3D9INDEX);
#else
						D3DDevice->SetVertexShader(D3DFVF_XYZNORMALTEX);
						D3DDevice->SetIndices(ActualVertexBuffer->secondary->D3D8INDEX,0);
						D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->D3D8VB, sizeof(XYZNORMALTEX));
						D3DDevice->SetStreamSource( 1, ActualVertexBuffer->secondary->STREAMS[0], sizeof(XYZNORMALTEX));
#endif
						SHDVOLUME_CR2m->Begin( &uPasses, 0);
						for( UINT iPass = 0; iPass < uPasses; iPass++ )
						{
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
							SHDVOLUME_CR2m->BeginPass( iPass );
							SHDVOLUME_CR2m->CommitChanges();
							D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->secondary->nVerticesActif,0,ActualVertexBuffer->secondary->nIndicesActif/3); 
							SHDVOLUME_CR2m->EndPass();
#else
							SHDVOLUME_CR2m->Pass( iPass );
							D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->secondary->nVerticesActif,0,ActualVertexBuffer->secondary->nIndicesActif/3); 
#endif
#else
							SHDVOLUME_CR2m->Pass( iPass );
							D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,ActualVertexBuffer->secondary->nVerticesActif,0,ActualVertexBuffer->secondary->nIndicesActif/3); 
#endif
						}
						SHDVOLUME_CR2m->End();
					}

				}
			}
			else
			{
				// SIMPLE / ALTERNATIVE

				LPD3DXEFFECT shd,shdc;

				if (state==0)
				{
					shd=SHDVOLUME;
					shdc=SHDVOLUMEc;
				}
				else
				{
					shd=SHDVOLUMEn;
					shdc=SHDVOLUMEcn;
					shdc=NULL;
				}

				D3DDevice->GetTransform( D3DTS_VIEW, &matView );
				D3DDevice->GetTransform( D3DTS_WORLD, &matWorld );
				D3DDevice->GetTransform( D3DTS_PROJECTION, &matProj );

				CMatrix Mplane;
				CPlane plane;
				D3DXMATRIX mm;
				CVector view;
				CVector camera;
				float decal=Front+0.1f;
				CVector4 v4light;
				CVector posObject;

				posObject.Init(matWorld._41,matWorld._42,matWorld._43);

				n=ActualVertexBuffer->iValue1;

				v4light.Init(Lights[n].Pos);

				D3DXMatrixInverse( &mm, NULL, &matView );

				camera.Init(mm._41,mm._42,mm._43);
				view.Init(mm._31,mm._32,mm._33);

				view.Normalise();

				camera=camera+decal*view;

				plane.a=view.x;
				plane.b=view.y;
				plane.c=view.z;
				plane.d=-(view||camera);

				if (states(TRIVIAL_ELIMINATION_STENCIL))
				{					
					if ((plane.Distance(posObject)<0)&&(plane.Distance(Lights[n].Pos)>0)) return;
				}

				if (plane.Distance(Lights[n].Pos)<0)
				{					
					plane.a=-view.x;
					plane.b=-view.y;
					plane.c=-view.z;
					plane.d=(view||camera);
				}

				Mplane.Id();
				Mplane.ShadowProjection(v4light,plane);

				mm._11=Mplane.a[0][0]; mm._12=Mplane.a[0][1]; mm._13=Mplane.a[0][2]; mm._14=Mplane.a[0][3];
				mm._21=Mplane.a[1][0]; mm._22=Mplane.a[1][1]; mm._23=Mplane.a[1][2]; mm._24=Mplane.a[1][3];
				mm._31=Mplane.a[2][0]; mm._32=Mplane.a[2][1]; mm._33=Mplane.a[2][2]; mm._34=Mplane.a[2][3];
				mm._41=Mplane.a[3][0]; mm._42=Mplane.a[3][1]; mm._43=Mplane.a[3][2]; mm._44=Mplane.a[3][3];

				D3DXVECTOR4 ZNEAR(decal,decal,decal,1.0f);
				D3DXVECTOR4 Len(ActualVertexBuffer->fValue1,ActualVertexBuffer->fValue1,ActualVertexBuffer->fValue1,0);
				D3DXVECTOR4 Light(Lights[n].Pos.x,Lights[n].Pos.y,Lights[n].Pos.z,0);
				D3DXMatrixMultiply( &matViewProj, &matView, &matProj );

				if ((ActualVertexBuffer->Type&API3D_MORPH)==0)
				{
					shd->SetMatrix( "matProjNearPlane", &mm);
					shd->SetMatrix( "matWorld", &matWorld );
					shd->SetMatrix( "matViewProj", &matViewProj );
					shd->SetMatrix( "matView", &matView );
					shd->SetVector( "Light", &Light);
					shd->SetVector( "Len", &Len);
					shd->SetVector( "ZNear", &ZNEAR);

#ifdef API3D_DIRECT3D9
					D3DDevice->SetFVF(D3DFVF_XYZNORMALTEX);
					D3DDevice->SetStreamSource(0,ActualVertexBuffer->D3D9VB,0,sizeof(XYZNORMALTEX));
					D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else
					D3DDevice->SetVertexShader(D3DFVF_XYZNORMALTEX);
					D3DDevice->SetStreamSource(0,ActualVertexBuffer->D3D8VB,sizeof(XYZNORMALTEX));
					D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif
					shd->Begin( &uPasses, 0);
					for( UINT iPass = 0; iPass < uPasses; iPass++ )
					{
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
						shd->BeginPass( iPass );
						shd->CommitChanges();
						D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3);
						shd->EndPass();
#else
						shd->Pass( iPass );
						D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3);
#endif
#else
						shd->Pass( iPass );
						D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3);
#endif
					}
					shd->End();

					if ((ActualVertexBuffer->secondary)&&(shdc))
					{						
						shdc->SetMatrix( "matProjNearPlane", &mm);
						shdc->SetMatrix( "matWorld", &matWorld );
						shdc->SetMatrix( "matView", &matView );
						shdc->SetMatrix( "matViewProj", &matViewProj );
						shdc->SetVector( "Light", &Light);
						shdc->SetVector( "Len", &Len);
						shdc->SetVector( "ZNear", &ZNEAR);
						
#ifdef API3D_DIRECT3D9
						D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->D3D9VB,0, sizeof(XYZNORMALTEX));
						D3DDevice->SetFVF(D3DFVF_XYZNORMALTEX);
						D3DDevice->SetIndices(ActualVertexBuffer->secondary->D3D9INDEX);
#else
						D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->D3D8VB, sizeof(XYZNORMALTEX));
						D3DDevice->SetVertexShader(D3DFVF_XYZNORMALTEX);
						D3DDevice->SetIndices(ActualVertexBuffer->secondary->D3D8INDEX,0);
#endif	
						shdc->Begin( &uPasses, 0);
						for( UINT iPass = 0; iPass < uPasses; iPass++ )
						{
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
							shdc->BeginPass( iPass );
							shdc->CommitChanges();
							D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->secondary->nVerticesActif,0,ActualVertexBuffer->secondary->nIndicesActif/3); 
							shdc->EndPass();
#else
							shdc->Pass( iPass );
							D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->secondary->nVerticesActif,0,ActualVertexBuffer->secondary->nIndicesActif/3); 
#endif
#else
							shdc->Pass( iPass );
							D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,ActualVertexBuffer->secondary->nVerticesActif,0,ActualVertexBuffer->secondary->nIndicesActif/3); 
#endif
						}
						shdc->End();
					}
				}
				else
				{
					D3DXVECTOR4 T(ActualVertexBuffer->stream_interpolant,ActualVertexBuffer->stream_interpolant,ActualVertexBuffer->stream_interpolant,ActualVertexBuffer->stream_interpolant);

					SHDVOLUMEm->SetMatrix( "matWorld", &matWorld );
					SHDVOLUMEm->SetMatrix( "matViewProj", &matViewProj );
					SHDVOLUMEm->SetMatrix( "matProjNearPlane", &mm);
					SHDVOLUMEm->SetVector( "Light", &Light);
					SHDVOLUMEm->SetVector( "Len", &Len);
					SHDVOLUMEm->SetVector( "ZNear", &ZNEAR);
					SHDVOLUMEm->SetVector( "Interpolant", &T);
					SHDVOLUMEm->SetMatrix( "matView", &matView );

#ifdef API3D_DIRECT3D9
					D3DDevice->SetFVF(D3DFVF_XYZNORMALTEX);

					D3DVERTEXELEMENT9 declShdMorph[] =
					{
						{ 0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_POSITION, 0}, 
						{ 0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_NORMAL,   0}, 
						{ 0, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_TEXCOORD, 0}, 
						{ 1,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_POSITION, 1}, 
						{ 1, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_NORMAL,   1}, 
						{ 1, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_TEXCOORD, 1}, 
						D3DDECL_END()
					};

					if (CR_VD==NULL) D3DDevice->CreateVertexDeclaration( declShdMorph, &CR_VD );

					D3DDevice->SetVertexDeclaration(CR_VD);

					if (ActualVertexBuffer->Type&API3D_STREAMS)
					{
						if (ActualVertexBuffer->stream1>=0) D3DDevice->SetStreamSource( 0, ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream1],0, sizeof(XYZNORMALTEX));
						else D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
						if (ActualVertexBuffer->stream2>=0) D3DDevice->SetStreamSource( 1, ActualVertexBuffer->STREAMS[ActualVertexBuffer->stream2],0, sizeof(XYZNORMALTEX));
						else D3DDevice->SetStreamSource( 1, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
					}
					else
					{
						D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
						D3DDevice->SetStreamSource( 1, ActualVertexBuffer->STREAMS[0],0, sizeof(XYZNORMALTEX));
					}

//					D3DDevice->SetStreamSource(0,ActualVertexBuffer->D3D9VB,0,sizeof(XYZNORMALTEX));
//					D3DDevice->SetStreamSource(1,ActualVertexBuffer->STREAMS[0],0,sizeof(XYZNORMALTEX));
					D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else
					D3DDevice->SetVertexShader(D3DFVF_XYZNORMALTEX);
					D3DDevice->SetStreamSource(0,ActualVertexBuffer->D3D8VB,sizeof(XYZNORMALTEX));
					D3DDevice->SetStreamSource(1,ActualVertexBuffer->STREAMS[0],sizeof(XYZNORMALTEX));
					D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif
				
					SHDVOLUMEm->Begin( &uPasses, 0);
					for( UINT iPass = 0; iPass < uPasses; iPass++ )
					{
						
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
						SHDVOLUMEm->BeginPass( iPass );
						SHDVOLUMEm->CommitChanges();
						D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
						SHDVOLUMEm->EndPass();
#else
						SHDVOLUMEm->Pass( iPass );
						D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
#endif
#else
						SHDVOLUMEm->Pass( iPass );
						D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
#endif
					}
					SHDVOLUMEm->End();

/**/

					if ((ActualVertexBuffer->secondary)&&(states(ALGO_STENCIL_SHADOWING)==0))
					{	
						SHDVOLUMEmc->SetMatrix( "matWorld", &matWorld );
						SHDVOLUMEmc->SetMatrix( "matView", &matView );
						SHDVOLUMEmc->SetMatrix( "matViewProj", &matViewProj );
						SHDVOLUMEmc->SetMatrix( "matProjNearPlane", &mm);
						SHDVOLUMEmc->SetVector( "Light", &Light);
						SHDVOLUMEmc->SetVector( "Len", &Len);
						SHDVOLUMEmc->SetVector( "ZNear", &ZNEAR);
						SHDVOLUMEmc->SetVector( "Interpolant", &T);

#ifdef API3D_DIRECT3D9
						D3DDevice->SetFVF(D3DFVF_XYZNORMALTEX);
						D3DDevice->SetVertexDeclaration(CR_VD);


						if (ActualVertexBuffer->Type&API3D_STREAMS)
						{
							if (ActualVertexBuffer->stream1>=0) D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->STREAMS[ActualVertexBuffer->stream1],0, sizeof(XYZNORMALTEX));
							else D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->D3D9VB,0, sizeof(XYZNORMALTEX));
							if (ActualVertexBuffer->stream2>=0) D3DDevice->SetStreamSource( 1, ActualVertexBuffer->secondary->STREAMS[ActualVertexBuffer->stream2],0, sizeof(XYZNORMALTEX));
							else D3DDevice->SetStreamSource( 1, ActualVertexBuffer->secondary->D3D9VB,0, sizeof(XYZNORMALTEX));
						}
						else
						{
							D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->D3D9VB,0, sizeof(XYZNORMALTEX));
							D3DDevice->SetStreamSource( 1, ActualVertexBuffer->secondary->STREAMS[0],0, sizeof(XYZNORMALTEX));
						}

//						D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->D3D9VB,0, sizeof(XYZNORMALTEX));
//						D3DDevice->SetStreamSource( 1, ActualVertexBuffer->secondary->STREAMS[0],0, sizeof(XYZNORMALTEX));
						D3DDevice->SetIndices(ActualVertexBuffer->secondary->D3D9INDEX);
#else
						D3DDevice->SetVertexShader(D3DFVF_XYZNORMALTEX);
						D3DDevice->SetIndices(ActualVertexBuffer->secondary->D3D8INDEX,0);
						D3DDevice->SetStreamSource( 0, ActualVertexBuffer->secondary->D3D8VB, sizeof(XYZNORMALTEX));
						D3DDevice->SetStreamSource( 1, ActualVertexBuffer->secondary->STREAMS[0], sizeof(XYZNORMALTEX));
#endif
						SHDVOLUMEmc->Begin( &uPasses, 0);
						for( UINT iPass = 0; iPass < uPasses; iPass++ )
						{
							
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
							SHDVOLUMEmc->BeginPass( iPass );
							SHDVOLUMEmc->CommitChanges();
							D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->secondary->nVerticesActif,0,ActualVertexBuffer->secondary->nIndicesActif/3); 
							SHDVOLUMEmc->EndPass();
#else
							SHDVOLUMEmc->Pass( iPass );
							D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->secondary->nVerticesActif,0,ActualVertexBuffer->secondary->nIndicesActif/3); 
#endif
#else
							SHDVOLUMEmc->Pass( iPass );
							D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,ActualVertexBuffer->secondary->nVerticesActif,0,ActualVertexBuffer->secondary->nIndicesActif/3); 
#endif
						}
						SHDVOLUMEmc->End();
					}
/**/
				}
			}
		}
		else
		if ((ActualVertexBuffer->TypeVB==4)||(ActualVertexBuffer->TypeVB==6))
		{

#ifdef API3D_DIRECT3D9
			if (MULTI00==NULL)
			{
				if (FAILED(D3DXCreateEffect( D3DDevice, MULTI00_SH, len_MULTI00_SH,NULL,NULL,0,NULL, &MULTI00, NULL ) ) ) return;
				if (FAILED(MULTI00->FindNextValidTechnique(NULL,&hndl))) return;
				MULTI00->SetTechnique(hndl);

			}
			if (MULTI01==NULL)
			{
				if (FAILED(D3DXCreateEffect( D3DDevice, MULTI01_SH, len_MULTI01_SH,NULL,NULL,0,NULL, &MULTI01, NULL ) ) ) return;
				if (FAILED(MULTI01->FindNextValidTechnique(NULL,&hndl))) return;
				MULTI01->SetTechnique(hndl);

			}
			if (MULTI10==NULL)
			{
				if (FAILED(D3DXCreateEffect( D3DDevice, MULTI10_SH, len_MULTI10_SH,NULL,NULL,0,NULL, &MULTI10, NULL ) ) ) return;
				if (FAILED(MULTI10->FindNextValidTechnique(NULL,&hndl))) return;
				MULTI10->SetTechnique(hndl);

			}
			if (MULTI11==NULL)
			{
				if (FAILED(D3DXCreateEffect( D3DDevice, MULTI11_SH, len_MULTI11_SH,NULL,NULL,0,NULL, &MULTI11, NULL ) ) ) return;
				if (FAILED(MULTI11->FindNextValidTechnique(NULL,&hndl))) return;
				MULTI11->SetTechnique(hndl);

			}
#else
			D3DXTECHNIQUE_DESC tt;
			if (MULTI00==NULL)
			{
				if (FAILED(D3DXCreateEffect( D3DDevice, MULTI00_SH, len_MULTI00_SH, &MULTI00, NULL ) ) ) return;
				if (FAILED(MULTI00->FindNextValidTechnique(NULL,&tt))) return;
				MULTI00->SetTechnique(tt.Index);
			}
			if (MULTI01==NULL)
			{
				if (FAILED(D3DXCreateEffect( D3DDevice, MULTI01_SH, len_MULTI01_SH, &MULTI01, NULL ) ) ) return;
				if (FAILED(MULTI01->FindNextValidTechnique(NULL,&tt))) return;
				MULTI01->SetTechnique(tt.Index);
			}
			if (MULTI10==NULL)
			{
				if (FAILED(D3DXCreateEffect( D3DDevice, MULTI10_SH, len_MULTI10_SH, &MULTI10, NULL ) ) ) return;
				if (FAILED(MULTI10->FindNextValidTechnique(NULL,&tt))) return;
				MULTI10->SetTechnique(tt.Index);
			}
			if (MULTI11==NULL)
			{
				if (FAILED(D3DXCreateEffect( D3DDevice, MULTI11_SH, len_MULTI11_SH, &MULTI11, NULL ) ) ) return;
				if (FAILED(MULTI11->FindNextValidTechnique(NULL,&tt))) return;
				MULTI11->SetTechnique(tt.Index);
			}

								
#endif
		
			D3DDevice->GetTexture(0,&Texture0);
			D3DDevice->GetTexture(1,&Texture1);

			LPD3DXEFFECT MULTI;

			if ((LevelTexture0==D3DTOP_MODULATE)&&(LevelTexture1==D3DTOP_MODULATE)) MULTI=MULTI00;
			if ((LevelTexture0==D3DTOP_MODULATE)&&(LevelTexture1==D3DTOP_ADD)) MULTI=MULTI01;
			if ((LevelTexture0==D3DTOP_ADD)&&(LevelTexture1==D3DTOP_MODULATE)) MULTI=MULTI10;
			if ((LevelTexture0==D3DTOP_ADD)&&(LevelTexture1==D3DTOP_ADD)) MULTI=MULTI11;

			MULTI->SetTexture( "tex1", Texture0 );
			MULTI->SetTexture( "tex2", Texture1 );

#ifdef API3D_DIRECT3D9
			MULTI->SetInt( "coord0", c0);
			MULTI->SetInt( "coord1", c1);
			D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else
			MULTI->SetDword( "coord0", c0);
			MULTI->SetDword( "coord1", c1);
			D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif

            UINT uPasses=1;
			
            MULTI->Begin( &uPasses, 0);//D3DXFX_DONOTSAVESTATE );
	        for( UINT iPass = 0; iPass < uPasses; iPass++ )
            {
				if (replace) 
				{
					if (iPass==uPasses-1) D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_REPLACE);
					else D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_KEEP);
				}
                
				
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
				MULTI->BeginPass( iPass );
				MULTI->CommitChanges();
				D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
				MULTI->EndPass();
#else
				MULTI->Pass( iPass );
				D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
#endif
#else
				MULTI->Pass( iPass );
                D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
#endif
            }
            MULTI->End();

			Texture0->Release();
			Texture1->Release();
			

		}
		else
		if (ActualVertexBuffer->Type&API3D_ENVMAPPING)
		{

//ENVIRO

#ifdef API3D_DIRECT3D9
			if (!ENV_VSH_activated)
			{
				Effect_ENV_VSH=NULL;
				if (FAILED(D3DXCreateEffect( D3DDevice, ENV_VSH, len_ENV_VSH,NULL,NULL,0,NULL, &Effect_ENV_VSH, NULL ) ) )  return;

				Effect_ENV2_VSH=NULL;
				if (FAILED(D3DXCreateEffect( D3DDevice, ENV2_VSH, len_ENV2_VSH,NULL,NULL,0,NULL, &Effect_ENV2_VSH, NULL ) ) ) return;
				
				ENV_VSH_activated=true;
			}
#else
			if (!ENV_VSH_activated)
			{
				Effect_ENV_VSH=NULL;
				if (FAILED(D3DXCreateEffect( D3DDevice, ENV_VSH, len_ENV_VSH, &Effect_ENV_VSH, NULL ) ) ) return;

				Effect_ENV2_VSH=NULL;
				if (FAILED(D3DXCreateEffect( D3DDevice, ENV2_VSH, len_ENV2_VSH, &Effect_ENV2_VSH, NULL ) ) ) return;
				
				ENV_VSH_activated=true;
			}

			D3DXTECHNIQUE_DESC tt;
#endif
			
			LPD3DXEFFECT Effect;

			if (states(SHADERS)==1) Effect=Effect_ENV2_VSH;
			else Effect=Effect_ENV_VSH;
			
#ifdef API3D_DIRECT3D9
			if (FAILED(Effect->FindNextValidTechnique(NULL,&hndl))) return;
			Effect->SetTechnique(hndl);
#else
			if (FAILED(Effect->FindNextValidTechnique(NULL,&tt))) return;
			Effect->SetTechnique(tt.Index);
#endif		
			D3DDevice->GetTransform( D3DTS_VIEW, &matView );
			D3DDevice->GetTransform( D3DTS_WORLD, &matWorld );
			D3DDevice->GetTransform( D3DTS_PROJECTION, &matProj );

            D3DXMatrixMultiply( &matViewProj, &matView, &matProj );
			
			D3DDevice->GetTexture(0,&Texture0);
			D3DDevice->GetTexture(1,&Texture1);

			D3DXMatrixInverse( &matViewInv, NULL, &matView );
            D3DXVECTOR4 v( matViewInv._41, matViewInv._42, matViewInv._43, 0.0f );

		
			CVector u,u2,pz;

			pz.Init(0,0,0);
			u.Init(matWorld._41 - ActualVertexBuffer->L.x,matWorld._42 - ActualVertexBuffer->L.y,matWorld._43 - ActualVertexBuffer->L.z);

			u.Normalise();

			u2.Init(matWorld._41,matWorld._42,matWorld._43);
			D3DXVECTOR4 ldir,ldir2;
			if (states(SHADERS)==1)
			{
				n=GetCloserLight(this,u2);
				if (n>=0)
				{
					u2=u2-Lights[n].Pos;
					u2.Normalise();
				}
				else
				{
					u2.Init(0,0,0);
				}
				ldir.x=u2.x;	
				ldir.y=u2.y;
				ldir.z=u2.z;
				ldir.w=1.0f;

				u2.Init(matWorld._41,matWorld._42,matWorld._43);
				n=GetSecondCloserLight(this,n,u2);
				if (n>=0)
				{
					u2=u2-Lights[n].Pos;
					u2.Normalise();
				}
				else
				{
					u2.Init(0,0,0);
				}
				ldir2.x=u2.x;	
				ldir2.y=u2.y;
				ldir2.z=u2.z;
				ldir2.w=1.0f;
			}
			else
			{
				ldir.x=u.x;
				ldir.y=u.y;
				ldir.z=u.z;
				ldir.w=1.0f;
			}
			
			ActualVertexBuffer->Ldir=-1*u;

			CVector N;
			M.Id();
			M.View(pz,-1*u,0);
	
			mat._11=M.a[0][0];	mat._12=M.a[0][1];	mat._13=M.a[0][2];	mat._14=M.a[0][3];
			mat._21=M.a[1][0];	mat._22=M.a[1][1];	mat._23=M.a[1][2];	mat._24=M.a[1][3];
			mat._31=M.a[2][0];	mat._32=M.a[2][1];	mat._33=M.a[2][2];	mat._34=M.a[2][3];
			mat._41=M.a[3][0];	mat._42=M.a[3][1];	mat._43=M.a[3][2];	mat._44=M.a[3][3];
						
            Effect->SetMatrix( "matWorld", &matWorld );
            Effect->SetMatrix( "matViewProj", &matViewProj );
			Effect->SetMatrix( "matLight", &mat );
			Effect->SetVector( "vecLight", &ldir);
			
			Effect->SetVector( "posCamera", &v );
			Effect->SetTexture( "texMap", Texture1 );
			Effect->SetTexture( "texEnvMap", Texture0 );

			if (states(SHADERS)==1)
			{
				D3DXVECTOR4 amb(Ambient.r,Ambient.g,Ambient.b,0.0f);
				Effect->SetVector( "ambient", &amb );
				Effect->SetVector( "vecLight2", &ldir2);
			}
	
#ifdef API3D_DIRECT3D9
			D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
			D3DDevice->SetFVF(D3DFVF_XYZNORMALTEX);
#else
			D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZNORMALTEX));
			D3DDevice->SetVertexShader(D3DFVF_XYZNORMALTEX);
#endif

#ifdef API3D_DIRECT3D9
			D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else
			D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif

            UINT uPasses=1;
			
            Effect->Begin( &uPasses, 0);//D3DXFX_DONOTSAVESTATE );

	        for( UINT iPass = 0; iPass < uPasses; iPass++ )
            {
				if (replace) 
				{
					if (iPass==uPasses-1) D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_REPLACE);
					else D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_KEEP);
				}

                
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
				Effect->BeginPass( iPass );
				Effect->CommitChanges();
				D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
				Effect->EndPass();
#else
				Effect->Pass( iPass );
				D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
#endif
#else
				Effect->Pass( iPass );
                D3DDevice->DrawIndexedPrimitive( D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3); 
#endif
            }

            Effect->End();

			Texture0->Release();
			Texture1->Release();


		}
		else
		{
#ifdef API3D_DIRECT3D9
			D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
			D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3);
#else
			D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
			D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,0,ActualVertexBuffer->nIndicesActif/3);
#endif
			
		}
	}
	else
	{
		bool draw=true;
		// GROUPED

		int ra,rb;

		switch(states(ALPHA_MULTI_GROUP_DRAW))
		{
		case 0:
			ra=0;rb=0;
			break;
		case 1:
			ra=0;rb=2;
			break;
		case 2:
			ra=1;rb=2;
			break;
		};

		if ((ActualVertexBuffer->TypeVB!=7)&&(ActualVertexBuffer->TypeVB!=9))
		{
			if ((ActualVertexBuffer->Type&API3D_VERTEXPROGRAM)||(ActualEffect))
			{

				if (ActualEffect) vbeffect=ActualEffect;
				else vbeffect=ActualVertexBuffer;

#ifdef API3D_DIRECT3D9
				D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else
				D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif
				// DINGUE

				for (ref_value=ra;ref_value<=rb;ref_value++)
				{
					nfo=ActualVertexBuffer->ListeSE.GetFirst();
					while (nfo)
					{
						if ((nfo->ref==ref_value)&&(nfo->flag==valueflag))
						{
							if (states(BLENDING)<3)
							{
								if (nfo->ref==1)
								{
									D3DDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,TRUE);
									D3DDevice->SetRenderState(D3DRS_SRCBLEND,D3DBLEND_SRCALPHA);
									D3DDevice->SetRenderState(D3DRS_DESTBLEND,D3DBLEND_INVSRCALPHA);
								
								}
								else
								if (nfo->ref==2)
								{
									D3DDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,TRUE);
									D3DDevice->SetRenderState(D3DRS_SRCBLEND,D3DBLEND_SRCALPHA);
									D3DDevice->SetRenderState(D3DRS_DESTBLEND,D3DBLEND_ONE);
								}
								else
								{
									D3DDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);
								}
							}

							if (ContextEffect)
							{
								draw=ContextEffect->update(vbeffect,nfo->nT,nfo->nT2,nfo->tag);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_NL]) vbeffect->setLightmap(vbeffect->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeffect->setLightmap(vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0], aT);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1], aT2);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2], aT3);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3], aT4);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4], aT5);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5], aT6);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6], aT7);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7], aT8);
							}
							else
							{
						
								draw=true;

								if (vbeffect->AssignedTexture[TEXTURE_FROM_NT]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_NT],nfo->nT+Decal_nt);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_NTPLUSONE]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_NTPLUSONE],nfo->nT+1+Decal_nt);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_NT2]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_NT2],nfo->nT2);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_BUMP]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_BUMP],nfo->nT+bumpmap_settexture);
                                if (vbeffect->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_BUMPPLUSONE],nfo->nT+1+bumpmap_settexture);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_DISPLACE]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_DISPLACE],nfo->nT+bump_displace);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_HORIZON]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_HORIZON],nfo->nT+bump_horizon);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_NL]) vbeffect->setLightmap(vbeffect->AssignedTexture[TEXTURE_FROM_NL],nfo->nL);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS]) vbeffect->setLightmap(vbeffect->AssignedTexture[TEXTURE_FROM_NLVECTORS],nfo->nLV);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_0],aT);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_1],aT2);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_2], aT3);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_3], aT4);

								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_4], aT5);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_5], aT6);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_6], aT7);
								if (vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7]) vbeffect->setTexture(vbeffect->AssignedTexture[TEXTURE_FROM_RENDER_7], aT8);
							}
							
							UINT uPasses=1;

							if ((vbeffect->effect)&&(draw))
							{
#ifdef API3D_DIRECT3D9
								D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else
								D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif
								if (vbeffect->effect->Begin( &uPasses, 0)==D3D_OK)
								for( UINT iPass = 0; iPass < uPasses; iPass++ )
								{
									if (replace) 
									{
										if (iPass==uPasses-1) D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_REPLACE);
										else D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_KEEP);
									}
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
									vbeffect->effect->BeginPass( iPass );
									vbeffect->effect->CommitChanges();
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									vbeffect->effect->EndPass();
#else
									vbeffect->effect->Pass( iPass );
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#endif
#else
									vbeffect->effect->Pass( iPass );
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#endif
								}
								vbeffect->effect->End();
							}

							for (n=0;n<6;n++)
							{
								if (vbeffect->Texture[n]) vbeffect->Texture[n]->Release();
								vbeffect->Texture[n]=NULL;
							}
							
							vbeffect->pos_texture=0;
							
							D3DDevice->SetRenderState(D3DRS_ZWRITEENABLE,1);

						}
						nfo=ActualVertexBuffer->ListeSE.GetNext();
					}

				}
				
				if (aT!=-555) SetTexture(aT);
			}
			else
			{
#ifdef API3D_DIRECT3D9
				D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else
				D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif
				
				int ra,rb;

				switch(states(ALPHA_MULTI_GROUP_DRAW))
				{
				case 0:
					ra=0;rb=0;
					break;
				case 1:
					ra=0;rb=2;
					break;
				case 2:
					ra=1;rb=2;
					break;
				};

				for (ref_value=ra;ref_value<=rb;ref_value++)
				{
					nfo=ActualVertexBuffer->ListeSE.GetFirst();
					while (nfo)
					{
						if (nfo->ref==ref_value)
						{
							if (states(BLENDING)<3)
							{
								if (nfo->ref==1)
								{
									D3DDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,TRUE);
									D3DDevice->SetRenderState(D3DRS_SRCBLEND,D3DBLEND_SRCALPHA);
									D3DDevice->SetRenderState(D3DRS_DESTBLEND,D3DBLEND_INVSRCALPHA);
								}
								else
								if (nfo->ref==2)
								{
									D3DDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,TRUE);
									D3DDevice->SetRenderState(D3DRS_SRCBLEND,D3DBLEND_SRCALPHA);
									D3DDevice->SetRenderState(D3DRS_DESTBLEND,D3DBLEND_ONE);
								}
								else
								{
									D3DDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);
								}
							}

							if (ActualVertexBuffer->TypeVB==6)
							{
								if (fn_stage0) D3DDevice->SetTexture(0,Lightmap[fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else D3DDevice->SetTexture(0,Lightmap[nfo->nL]);

								if (Decal_nt==-1)
								{
									D3DDevice->SetTexture(1,Blanc);
								}
								else
								{
									if (fn_stage1) SetTexture2(fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else
									{
										if ((nfo->nT+Decal_nt>=0)&&(nfo->nT+Decal_nt<NBRE_MAX_TEXTURES))
										if (cTexture[nfo->nT+Decal_nt]) SetTexture2(nfo->nT+Decal_nt);
									}
								}
							}
							else
							if (ActualVertexBuffer->TypeVB==4)
							{
								if (fn_stage0) SetTexture(fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
								else
								{
									if ((nfo->nT+Decal_nt>=0)&&(nfo->nT+Decal_nt<NBRE_MAX_TEXTURES))
									if (cTexture[nfo->nT+Decal_nt]) SetTexture(nfo->nT+Decal_nt);
								}

								if (fn_stage1) SetTexture2(fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
								else
								{
									if ((nfo->nT2>=0)&&(nfo->nT2<NBRE_MAX_TEXTURES))
									if (cTexture[nfo->nT2]) SetTexture2(nfo->nT2);
								}
							}
							else
							{
								if (ActualVertexBuffer->Type&API3D_ENVMAPPING)
								{
									if (fn_stage1) SetTexture2(fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else
									{
										if ((nfo->nT+Decal_nt>=0)&&(nfo->nT+Decal_nt<NBRE_MAX_TEXTURES))
										if (cTexture[nfo->nT+Decal_nt]) SetTexture2(nfo->nT+Decal_nt);
									}

									if (states(ENV_SHADERS)==0)
									{
										if (fn_stage0) SetTexture(fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
										else
										{
											if ((nfo->nT2+Decal_nt2>=0)&&(nfo->nT2+Decal_nt2<NBRE_MAX_TEXTURES))
											if (cTexture[nfo->nT2+Decal_nt2]) SetTexture(nfo->nT2+Decal_nt2);
										}
									}
								}
								else
								{
									if (fn_stage0) SetTexture(fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag));
									else
									{
										if ((nfo->nT+Decal_nt>=0)&&(nfo->nT+Decal_nt<NBRE_MAX_TEXTURES))
										if (cTexture[nfo->nT+Decal_nt]) SetTexture(nfo->nT+Decal_nt);
									}
								}
							}

							if (ActualVertexBuffer->TypeVB==5)
							{
								temp=0;
												
								if ((nfo->nT>=0)&&(nfo->nT<NBRE_MAX_TEXTURES))
								if ((cTexture[nfo->nT])&&(iTexture[nfo->nT]))
								{
									if (iTexture[nfo->nT]->Material)
									{
										temp=1;
#ifdef API3D_DIRECT3D9
										ZeroMemory( &m, sizeof(D3DMATERIAL9) );
#else
										ZeroMemory( &m, sizeof(D3DMATERIAL8) );
#endif
										
										m.Ambient.r = iTexture[nfo->nT]->Material->ambient[0];
										m.Ambient.g = iTexture[nfo->nT]->Material->ambient[1];
										m.Ambient.b = iTexture[nfo->nT]->Material->ambient[2];
										m.Ambient.a = iTexture[nfo->nT]->Material->ambient[3];
										
										m.Diffuse.r = iTexture[nfo->nT]->Material->diffuse[0];
										m.Diffuse.g = iTexture[nfo->nT]->Material->diffuse[1];
										m.Diffuse.b = iTexture[nfo->nT]->Material->diffuse[2];
										m.Diffuse.a = iTexture[nfo->nT]->Material->diffuse[3];

										m.Specular.r = iTexture[nfo->nT]->Material->specular[0];
										m.Specular.g = iTexture[nfo->nT]->Material->specular[1];
										m.Specular.b = iTexture[nfo->nT]->Material->specular[2];
										m.Specular.a = iTexture[nfo->nT]->Material->specular[3];
										m.Power = (float) iTexture[nfo->nT]->Material->power;

										D3DDevice->SetMaterial( &m );
									}
								}
								
								if (temp==0)
								{
#ifdef API3D_DIRECT3D9
									ZeroMemory( &m, sizeof(D3DMATERIAL9) );
#else
									ZeroMemory( &m, sizeof(D3DMATERIAL8) );
#endif
									m.Diffuse.r = m.Ambient.r = 1.0f;
									m.Diffuse.g = m.Ambient.g = 1.0f;
									m.Diffuse.b = m.Ambient.b = 1.0f;
									m.Diffuse.a = m.Ambient.a = 1.0f;

									m.Specular.r = 1.0f;
									m.Specular.g = 1.0f;
									m.Specular.b = 1.0f;
									m.Specular.a = 1.0f;
									m.Power = 20;
									D3DDevice->SetMaterial( &m );
								}
							}
						
							if (ActualVertexBuffer->Type&API3D_ENVMAPPING)
							{
#ifdef API3D_DIRECT3D9
								if (!ENV_VSH_activated)
								{
									Effect_ENV_VSH=NULL;
									if (FAILED(D3DXCreateEffect( D3DDevice, ENV_VSH, len_ENV_VSH,NULL,NULL,0,NULL, &Effect_ENV_VSH, NULL ) ) )
									{
										return;
									}
								
									Effect_ENV2_VSH=NULL;
									if (FAILED(D3DXCreateEffect( D3DDevice, ENV2_VSH, len_ENV2_VSH,NULL,NULL,0,NULL, &Effect_ENV2_VSH, NULL ) ) )
									{
										return;
									}
									ENV_VSH_activated=true;
								}

								
								LPD3DXEFFECT Effect;

								if (states(SHADERS)==1) Effect=Effect_ENV2_VSH;
								else Effect=Effect_ENV_VSH;

								if (FAILED(Effect->FindNextValidTechnique(NULL,&hndl))) return;
								Effect->SetTechnique(hndl);
#else

								if (!ENV_VSH_activated)
								{
									Effect_ENV_VSH=NULL;
									if (FAILED(D3DXCreateEffect( D3DDevice, ENV_VSH, len_ENV_VSH, &Effect_ENV_VSH, NULL ) ) ) return;
									Effect_ENV2_VSH=NULL;
									if (FAILED(D3DXCreateEffect( D3DDevice, ENV2_VSH, len_ENV2_VSH, &Effect_ENV2_VSH, NULL ) ) ) return;
									ENV_VSH_activated=true;
								}

								D3DXTECHNIQUE_DESC tt;
								LPD3DXEFFECT Effect;

								if (states(SHADERS)==1) Effect=Effect_ENV2_VSH;
								else Effect=Effect_ENV_VSH;

								if (FAILED(Effect->FindNextValidTechnique(NULL,&tt))) return;
								Effect->SetTechnique(tt.Index);
#endif

								D3DXMATRIX matView, matWorld,matProj,matViewProj,matViewInv,mat;
								CMatrix M,M0;

								
								D3DDevice->GetTransform( D3DTS_VIEW, &matView );
								D3DDevice->GetTransform( D3DTS_WORLD, &matWorld );
								D3DDevice->GetTransform( D3DTS_PROJECTION, &matProj );

								D3DXMatrixMultiply( &matViewProj, &matView, &matProj );
								
								D3DDevice->GetTexture(0,&Texture0);
								D3DDevice->GetTexture(1,&Texture1);

								D3DXMatrixInverse( &matViewInv, NULL, &matView );
								D3DXVECTOR4 v( matViewInv._41, matViewInv._42, matViewInv._43, 0.0f );

								CVector u,u2,pz;
								pz.Init(0,0,0);

								u.Init(matWorld._41 - ActualVertexBuffer->L.x,matWorld._42 - ActualVertexBuffer->L.y,matWorld._43 - ActualVertexBuffer->L.z);


								u.Normalise();

								u2.Init(matWorld._41,matWorld._42,matWorld._43);
								D3DXVECTOR4 ldir,ldir2;
								if (states(SHADERS)==1)
								{
									n=GetCloserLight(this,u2);
									if (n>=0)
									{
										u2=u2-Lights[n].Pos;
										u2.Normalise();
									}
									else
									{
										u2.Init(0,0,0);
									}
									ldir.x=u2.x;	
									ldir.y=u2.y;
									ldir.z=u2.z;
									ldir.w=1.0f;

									u2.Init(matWorld._41,matWorld._42,matWorld._43);
									n=GetSecondCloserLight(this,n,u2);
									if (n>=0)
									{
										u2=u2-Lights[n].Pos;
										u2.Normalise();
									}
									else
									{
										u2.Init(0,0,0);
									}
									ldir2.x=u2.x;	
									ldir2.y=u2.y;
									ldir2.z=u2.z;
									ldir2.w=1.0f;
								
								}
								else
								{
									ldir.x=u.x;
									ldir.y=u.y;
									ldir.z=u.z;
									ldir.w=1.0f;
								}


								ActualVertexBuffer->Ldir=-1*u;

								
								CVector N;

								M.Id();
								M.View(pz,-1*u,0);
								

								mat._11=M.a[0][0];	mat._12=M.a[0][1];	mat._13=M.a[0][2];	mat._14=M.a[0][3];
								mat._21=M.a[1][0];	mat._22=M.a[1][1];	mat._23=M.a[1][2];	mat._24=M.a[1][3];
								mat._31=M.a[2][0];	mat._32=M.a[2][1];	mat._33=M.a[2][2];	mat._34=M.a[2][3];
								mat._41=M.a[3][0];	mat._42=M.a[3][1];	mat._43=M.a[3][2];	mat._44=M.a[3][3];

											
								Effect->SetMatrix( "matWorld", &matWorld );
								Effect->SetMatrix( "matViewProj", &matViewProj );
								Effect->SetMatrix( "matLight", &mat );
								Effect->SetVector( "vecLight", &ldir);
								
								Effect->SetVector( "posCamera", &v );
								Effect->SetTexture( "texMap", Texture1 );
								Effect->SetTexture( "texEnvMap", Texture0 );

								if (states(SHADERS)==1)
								{
									D3DXVECTOR4 amb(Ambient.r,Ambient.g,Ambient.b,0.0f);
									Effect->SetVector( "ambient", &amb );
									Effect->SetVector( "vecLight2", &ldir2);
								}

#ifdef API3D_DIRECT3D9
								D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D9VB,0, sizeof(XYZNORMALTEX));
								D3DDevice->SetFVF(D3DFVF_XYZNORMALTEX);
								D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else
								D3DDevice->SetStreamSource( 0, ActualVertexBuffer->D3D8VB, sizeof(XYZNORMALTEX));
								D3DDevice->SetVertexShader(D3DFVF_XYZNORMALTEX);
								D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif
								UINT uPasses=1;
								
								Effect->Begin( &uPasses, 0);//D3DXFX_DONOTSAVESTATE );

								for( UINT iPass = 0; iPass < uPasses; iPass++ )
								{

									if (replace) 
									{
										if (iPass==uPasses-1) D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_REPLACE);
										else D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_KEEP);
									}
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
									Effect->BeginPass( iPass );
									Effect->CommitChanges();
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									Effect->EndPass();

#else
									Effect->Pass( iPass );
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#endif
#else
									Effect->Pass( iPass );
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#endif

									
								}

								Effect->End();

								Texture0->Release();
								Texture1->Release();
							
							}
							else
							if ((ActualVertexBuffer->TypeVB==4)||(ActualVertexBuffer->TypeVB==6))
							{

#ifdef API3D_DIRECT3D9
								if (MULTI00==NULL)
								{
									if (FAILED(D3DXCreateEffect( D3DDevice, MULTI00_SH, len_MULTI00_SH,NULL,NULL,0,NULL, &MULTI00, NULL ) ) ) return;
									if (FAILED(MULTI00->FindNextValidTechnique(NULL,&hndl))) return;
									MULTI00->SetTechnique(hndl);

								}
								if (MULTI01==NULL)
								{
									if (FAILED(D3DXCreateEffect( D3DDevice, MULTI01_SH, len_MULTI01_SH,NULL,NULL,0,NULL, &MULTI01, NULL ) ) ) return;
									if (FAILED(MULTI01->FindNextValidTechnique(NULL,&hndl))) return;
									MULTI01->SetTechnique(hndl);

								}
								if (MULTI10==NULL)
								{
									if (FAILED(D3DXCreateEffect( D3DDevice, MULTI10_SH, len_MULTI10_SH,NULL,NULL,0,NULL, &MULTI10, NULL ) ) ) return;
									if (FAILED(MULTI10->FindNextValidTechnique(NULL,&hndl))) return;
									MULTI10->SetTechnique(hndl);

								}
								if (MULTI11==NULL)
								{
									if (FAILED(D3DXCreateEffect( D3DDevice, MULTI11_SH, len_MULTI11_SH,NULL,NULL,0,NULL, &MULTI11, NULL ) ) ) return;
									if (FAILED(MULTI11->FindNextValidTechnique(NULL,&hndl))) return;
									MULTI11->SetTechnique(hndl);

								}
#else
								D3DXTECHNIQUE_DESC tt;

								if (MULTI00==NULL)
								{
									if (FAILED(D3DXCreateEffect( D3DDevice, MULTI00_SH, len_MULTI00_SH, &MULTI00, NULL ) ) ) return;
									if (FAILED(MULTI00->FindNextValidTechnique(NULL,&tt))) return;
									MULTI00->SetTechnique(tt.Index);
								}
								if (MULTI01==NULL)
								{
									if (FAILED(D3DXCreateEffect( D3DDevice, MULTI01_SH, len_MULTI01_SH, &MULTI01, NULL ) ) ) return;
									if (FAILED(MULTI01->FindNextValidTechnique(NULL,&tt))) return;
									MULTI01->SetTechnique(tt.Index);
								}
								if (MULTI10==NULL)
								{
									if (FAILED(D3DXCreateEffect( D3DDevice, MULTI10_SH, len_MULTI10_SH, &MULTI10, NULL ) ) ) return;
									if (FAILED(MULTI10->FindNextValidTechnique(NULL,&tt))) return;
									MULTI10->SetTechnique(tt.Index);
								}
								if (MULTI11==NULL)
								{
									if (FAILED(D3DXCreateEffect( D3DDevice, MULTI11_SH, len_MULTI11_SH, &MULTI11, NULL ) ) ) return;
									if (FAILED(MULTI11->FindNextValidTechnique(NULL,&tt))) return;
									MULTI11->SetTechnique(tt.Index);
								}
			
#endif
								if (states(RENDER_TARGET_OPTIONS)==STENCIL)
								{
									D3DDevice->SetTexture(1,Noir);
									D3DDevice->SetTexture(0,Noir);
									D3DDevice->SetRenderState(D3DRS_ALPHABLENDENABLE,FALSE);
								}

								D3DDevice->GetTexture(0,&Texture0);
								D3DDevice->GetTexture(1,&Texture1);

								LPD3DXEFFECT MULTI;

								if ((LevelTexture0==D3DTOP_MODULATE)&&(LevelTexture1==D3DTOP_MODULATE)) MULTI=MULTI00;
								if ((LevelTexture0==D3DTOP_MODULATE)&&(LevelTexture1==D3DTOP_ADD)) MULTI=MULTI01;
								if ((LevelTexture0==D3DTOP_ADD)&&(LevelTexture1==D3DTOP_MODULATE)) MULTI=MULTI10;
								if ((LevelTexture0==D3DTOP_ADD)&&(LevelTexture1==D3DTOP_ADD)) MULTI=MULTI11;


								MULTI->SetTexture( "tex1", Texture0 );
								MULTI->SetTexture( "tex2", Texture1 );

#ifdef API3D_DIRECT3D9
								MULTI->SetInt( "coord0", c0);
								MULTI->SetInt( "coord1", c1);

								D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else
								MULTI->SetDword( "coord0", c0);
								MULTI->SetDword( "coord1", c1);

								D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif

								UINT uPasses=1;
								
								MULTI->Begin( &uPasses, 0);
								for( UINT iPass = 0; iPass < uPasses; iPass++ )
								{
									if (replace) 
									{
										if (iPass==uPasses-1) D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_REPLACE);
										else D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_KEEP);
									}
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
									MULTI->BeginPass( iPass );
									MULTI->CommitChanges();
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									MULTI->EndPass();
#else
									MULTI->Pass( iPass );
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#endif
#else
									MULTI->Pass( iPass );
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#endif

								}
								MULTI->End();

								Texture0->Release();
								Texture1->Release();

							}
							else
							{

								if (replace) D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_REPLACE);
									
#ifdef API3D_DIRECT3D9
								if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
								else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#else
								if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
								else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#endif

							}
						}
						/**/		
						nfo=ActualVertexBuffer->ListeSE.GetNext();
					}
				}
			}	
		}
		else
		{

			if (ActualVertexBuffer->TypeVB==7)
			{
				UINT uPasses=1;

#ifdef API3D_DIRECT3D9
				if (BML==NULL)
				{
					if (FAILED(D3DXCreateEffect(D3DDevice,BUMP_MAPPING_LIGHTMAP_SH_s,len_BUMP_MAPPING_LIGHTMAP_SH_s,NULL,NULL,0,NULL,&BMLa,NULL))) return;
					if (FAILED(D3DXCreateEffect(D3DDevice,BUMP_MAPPING_LIGHTMAP_SH,len_BUMP_MAPPING_LIGHTMAP_SH,NULL,NULL,0,NULL,&BML,NULL))) return;
				}
#else
				if (BML==NULL)
				{
					if (FAILED(D3DXCreateEffect(D3DDevice,BUMP_MAPPING_LIGHTMAP_SH_s,len_BUMP_MAPPING_LIGHTMAP_SH_s,&BMLa,NULL))) return;
					if (FAILED(D3DXCreateEffect(D3DDevice,BUMP_MAPPING_LIGHTMAP_SH,len_BUMP_MAPPING_LIGHTMAP_SH,&BML,NULL))) return;
				}
				D3DXTECHNIQUE_DESC tt;
#endif
				LPD3DXEFFECT eff;

				if (states(RENDER_TARGET_OPTIONS)==STENCIL) 
				{
					eff=BML;

#ifdef API3D_DIRECT3D9
					D3DXHANDLE base=eff->GetTechniqueByName("T5");
					eff->SetTechnique(base);
#else
					eff->GetTechniqueDesc("T5",&tt);
					eff->SetTechnique(tt.Index);
#endif
					EffectBumpMapping=NULL;
				}
				else
				{
					if (EffectBumpMapping)
					{
						eff=EffectBumpMapping;
					}
					else
					{

/*
						if (states(SPECIAL_ANIMATED)) eff=BMLa;
						else eff=BML;

#ifdef API3D_DIRECT3D9
						D3DXHANDLE base;

						if (states(SPECIAL_FASTDRAW)==1) base=eff->GetTechniqueByName("T1");
						else
						if (states(SPECIAL_FASTDRAW)==2) base=eff->GetTechniqueByName("T2");
						else base=NULL;
					
						eff->SetTechnique(base);

						if (FAILED(eff->FindNextValidTechnique(base,&hndl))) return;
						if (eff->GetCurrentTechnique()!=hndl) eff->SetTechnique(hndl);

#else
						if (states(SPECIAL_FASTDRAW)==1)
						{
							if (FAILED(eff->FindNextValidTechnique("T1",&tt))) return;
							eff->SetTechnique(tt.Index);
						}
						else
						if (states(SPECIAL_FASTDRAW)==2)
						{
							if (FAILED(eff->FindNextValidTechnique("T2",&tt))) return;
							eff->SetTechnique(tt.Index);
						}
						else
						{
							if (FAILED(eff->FindNextValidTechnique(NULL,&tt))) return;
							eff->SetTechnique(tt.Index);
						}
#endif
/**/

#ifdef API3D_DIRECT3D9
						D3DXHANDLE base;
#endif
						if (states(SPECIAL_ANIMATED)) 
						{
							eff=BMLa;

#ifdef API3D_DIRECT3D9

							if (states(SPECIAL_FASTDRAW)==1) 
							{
								if (G_Multitexture) base=eff->GetTechniqueByName("T2");
								else base=eff->GetTechniqueByName("T3");
							}
							else
							if (states(SPECIAL_FASTDRAW)==2) 
							{
								if (G_Multitexture) base=eff->GetTechniqueByName("T2");
								else base=eff->GetTechniqueByName("T3");
							}
							else
							{
								if (G_PS) base=eff->GetTechniqueByName("T0");
								else
								{
									if (G_Dot3) base=eff->GetTechniqueByName("T1");
									else 
									{
										if (G_Multitexture) base=eff->GetTechniqueByName("T2");
										else base=eff->GetTechniqueByName("T3");
									}
								}
							}

							eff->SetTechnique(base);
#else

							if (states(SPECIAL_FASTDRAW)==1) 
							{
								if (G_Multitexture) eff->GetTechniqueDesc("T2",&tt);
								else eff->GetTechniqueDesc("T3",&tt);
							}
							else
							if (states(SPECIAL_FASTDRAW)==2) 
							{
								if (G_Multitexture) eff->GetTechniqueDesc("T2",&tt);
								else eff->GetTechniqueDesc("T3",&tt);
							}
							else
							{
								if (G_PS) eff->GetTechniqueDesc("T0",&tt);
								else
								{
									if (G_Dot3) eff->GetTechniqueDesc("T1",&tt);
									else 
									{
										if (G_Multitexture) eff->GetTechniqueDesc("T2",&tt);
										else eff->GetTechniqueDesc("T3",&tt);
									}
								}
							}
							eff->SetTechnique(tt.Index);
#endif
						}
						else 
						{
							eff=BML;
#ifdef API3D_DIRECT3D9

							if (states(SPECIAL_FASTDRAW)==1) 
							{
								if (G_Multitexture) base=eff->GetTechniqueByName("T2");
								else base=eff->GetTechniqueByName("T3");
							}
							else
							if (states(SPECIAL_FASTDRAW)==2) 
							{
								if (G_Multitexture) base=eff->GetTechniqueByName("T2");
								else base=eff->GetTechniqueByName("T3");
							}
							else
							{
								if (G_PS) base=eff->GetTechniqueByName("T0");
								else
								{
									if (G_Dot3) base=eff->GetTechniqueByName("T1");
									else 
									{
										if (G_Multitexture) base=eff->GetTechniqueByName("T2");
										else base=eff->GetTechniqueByName("T3");
									}
								}
							}
							eff->SetTechnique(base);

#else
							if (states(SPECIAL_FASTDRAW)==1) 
							{
								if (G_Multitexture) eff->GetTechniqueDesc("T2",&tt);
								else eff->GetTechniqueDesc("T3",&tt);
							}
							else
							if (states(SPECIAL_FASTDRAW)==2) 
							{
								if (G_Multitexture) eff->GetTechniqueDesc("T2",&tt);
								else eff->GetTechniqueDesc("T3",&tt);
							}
							else
							{
								if (G_PS) eff->GetTechniqueDesc("T0",&tt);
								else
								{
									if (G_Dot3) eff->GetTechniqueDesc("T1",&tt);
									else 
									{
										if (G_Multitexture) eff->GetTechniqueDesc("T2",&tt);
										else eff->GetTechniqueDesc("T3",&tt);
									}
								}
							}
							eff->SetTechnique(tt.Index);
#endif
						}

						EffectBumpMapping=eff;
					}
				}
				
#ifdef API3D_DIRECT3D9
				D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else
				D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif

				D3DDevice->GetTransform( D3DTS_VIEW, &matView );
				D3DDevice->GetTransform( D3DTS_WORLD, &matWorld );
				D3DDevice->GetTransform( D3DTS_PROJECTION, &matProj );

				D3DXMatrixMultiply( &matViewProj, &matView, &matProj );
				
				if ((states(SPECIAL_ANIMATED))&&(states(RENDER_TARGET)!=STENCIL))
				{
					vect.w=0;
					vect.x=Lights[ActualVertexBuffer->Lights[0]].Pos.x;
					vect.y=Lights[ActualVertexBuffer->Lights[0]].Pos.y;
					vect.z=Lights[ActualVertexBuffer->Lights[0]].Pos.z;

					eff->SetVector("vecLight1",&vect);
					
					vect.x=Lights[ActualVertexBuffer->Lights[1]].Pos.x;
					vect.y=Lights[ActualVertexBuffer->Lights[1]].Pos.y;
					vect.z=Lights[ActualVertexBuffer->Lights[1]].Pos.z;
					eff->SetVector("vecLight2",&vect);
					
					vect.x=Lights[ActualVertexBuffer->Lights[2]].Pos.x;
					vect.y=Lights[ActualVertexBuffer->Lights[2]].Pos.y;
					vect.z=Lights[ActualVertexBuffer->Lights[2]].Pos.z;
					eff->SetVector("vecLight3",&vect);

					vect.x=Lights[ActualVertexBuffer->Lights[0]].variation;
					vect.y=vect.z=vect.x;
					eff->SetVector("vecVar1",&vect);
					vect.x=Lights[ActualVertexBuffer->Lights[1]].variation;
					vect.y=vect.z=vect.x;
					eff->SetVector("vecVar2",&vect);
					vect.x=Lights[ActualVertexBuffer->Lights[2]].variation;
					vect.y=vect.z=vect.x;
					eff->SetVector("vecVar3",&vect);
				}

				eff->SetMatrix( "matWorld", &matWorld );
				eff->SetMatrix( "matViewProj", &matViewProj );

				if (states(RENDER_TARGET_OPTIONS)==STENCIL)
				{
					D3DDevice->SetTexture(1,Noir);
					D3DDevice->SetTexture(0,Noir);
					D3DDevice->GetTexture(1,&Texture0);
					D3DDevice->GetTexture(0,&Texture1);
					D3DDevice->GetTexture(1,&Texture2);
					D3DDevice->GetTexture(0,&Texture3);

					eff->SetTexture( "tex", Texture0 );
					eff->SetTexture( "lightmap", Texture1 );
					eff->SetTexture( "vectors", Texture2 );
					eff->SetTexture( "bump", Texture3 );
#ifdef API3D_DIRECT3D9
					eff->SetBool( "transparent", false );
#else
					eff->SetDword( "transparent", false );
#endif
					for (ref_value=ra;ref_value<=rb;ref_value++)
					{
						nfo=ActualVertexBuffer->ListeSE.GetFirst();
						while (nfo)
						{
							if (nfo->ref==ref_value)
							{
								eff->Begin( &uPasses, 0);
								for( UINT iPass = 0; iPass < uPasses; iPass++ )
								{
									if (replace) 
									{
										if (iPass==uPasses-1) D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_REPLACE);
										else D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_KEEP);
									}
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
									eff->BeginPass( iPass );
									eff->CommitChanges();
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									eff->EndPass();
#else
									eff->Pass( iPass );
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#endif
#else
									eff->Pass( iPass );
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#endif
								}
								eff->End();
							}
							nfo=ActualVertexBuffer->ListeSE.GetNext();
						}
					}

					Texture0->Release();
					Texture1->Release();
					Texture2->Release();
					Texture3->Release();
				}
				else
				{
					for (ref_value=ra;ref_value<=rb;ref_value++)
					{
						nfo=ActualVertexBuffer->ListeSE.GetFirst();
						while (nfo)
						{
							int draw=0;
							if (fn_stage_draw) draw=fn_stage_draw(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag); else draw=1;

							if ((nfo->ref==ref_value)&&(draw))
							{	
								if (fn_stage0) D3DDevice->SetTexture(1,Lightmap[fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else D3DDevice->SetTexture(1,Lightmap[nfo->nL]);
								D3DDevice->GetTexture(1,&Texture0);

								if (fn_stage1) D3DDevice->SetTexture(0,Texture[fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else D3DDevice->SetTexture(0,Texture[nfo->nT+Decal_nt]);
								D3DDevice->GetTexture(0,&Texture1);

								if (fn_stage2) D3DDevice->SetTexture(0,Lightmap[fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else D3DDevice->SetTexture(0,Lightmap[nfo->nLV]);
								D3DDevice->GetTexture(0,&Texture2);

								if (fn_stage3) D3DDevice->SetTexture(1,Texture[fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else D3DDevice->SetTexture(1,Texture[nfo->nT+bumpmap_settexture]);
								D3DDevice->GetTexture(1,&Texture3);

								eff->SetTexture("tex", Texture0);
								eff->SetTexture("lightmap",Texture1);
								eff->SetTexture("vectors",Texture2);
								eff->SetTexture("bump",Texture3);

#ifdef API3D_DIRECT3D9
								if ((nfo->ref==0)||(states(RENDER_TARGET_OPTIONS)==STENCIL)) eff->SetBool( "transparent", false );
								else eff->SetBool( "transparent", true );
#else
								if ((nfo->ref==0)||(states(RENDER_TARGET_OPTIONS)==STENCIL)) eff->SetDword( "transparent", false );
								else eff->SetDword( "transparent", true );
#endif
								eff->Begin( &uPasses, 0);
								for( UINT iPass = 0; iPass < uPasses; iPass++ )
								{
									if (replace) 
									{
										if (iPass==uPasses-1) D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_REPLACE);
										else D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_KEEP);
									}
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
									eff->BeginPass( iPass );
									eff->CommitChanges();
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									eff->EndPass();
#else
									eff->Pass( iPass );
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#endif
#else
									eff->Pass( iPass );
									if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
									else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#endif
								}
								eff->End();

								Texture0->Release();
								Texture1->Release();
								Texture2->Release();
								Texture3->Release();


							}
							nfo=ActualVertexBuffer->ListeSE.GetNext();

						}
/**/
					}
				}
			}
			else	// bump displacement mapping
			{

				UINT uPasses=1;

#ifdef API3D_DIRECT3D9
				if (BMLD==NULL)
				{
					LPD3DXBUFFER err;

					int lenstr=strlen(BUMP_MAPPING_LIGHTMAP_SH_D0)+strlen(BUMP_MAPPING_LIGHTMAP_SH_D1)+strlen(BUMP_MAPPING_LIGHTMAP_SH_D2)+strlen(BUMP_MAPPING_LIGHTMAP_SH_D3);
					char *str=(char*)malloc(lenstr+1);
					//sprintf(str,"%s",BUMP_MAPPING_LIGHTMAP_SH_D0);
					sprintf(str,"%s%s%s%s",BUMP_MAPPING_LIGHTMAP_SH_D0,BUMP_MAPPING_LIGHTMAP_SH_D1,BUMP_MAPPING_LIGHTMAP_SH_D2,BUMP_MAPPING_LIGHTMAP_SH_D3);
					if (FAILED(D3DXCreateEffect(D3DDevice,str,lenstr,NULL,NULL,0,NULL,&BMLD,&err))) 
					{
						LOG("error");
						LOG((char*)err->GetBufferPointer());
						return;
					}
				}
#else
				if (BMLD==NULL)
				{
					int lenstr=strlen(BUMP_MAPPING_LIGHTMAP_SH_D0)+strlen(BUMP_MAPPING_LIGHTMAP_SH_D1)+strlen(BUMP_MAPPING_LIGHTMAP_SH_D2)+strlen(BUMP_MAPPING_LIGHTMAP_SH_D3);
					char *str=(char*)malloc(lenstr+1);
					sprintf(str,"%s%s%s%s",BUMP_MAPPING_LIGHTMAP_SH_D0,BUMP_MAPPING_LIGHTMAP_SH_D1,BUMP_MAPPING_LIGHTMAP_SH_D2,BUMP_MAPPING_LIGHTMAP_SH_D3);
					if (FAILED(D3DXCreateEffect(D3DDevice,str,lenstr,&BMLD,NULL))) return;
				}

#endif
				LPD3DXEFFECT eff;


				if (EffectBumpMappingDisplaceSS==NULL) BumpMappingStates();
				
				eff=EffectBumpMappingDisplaceSS;

				
#ifdef API3D_DIRECT3D9
				D3DDevice->SetIndices(ActualVertexBuffer->D3D9INDEX);
#else
				D3DDevice->SetIndices(ActualVertexBuffer->D3D8INDEX,0);
#endif

				

				D3DDevice->GetTransform( D3DTS_VIEW, &matView );
				D3DDevice->GetTransform( D3DTS_WORLD, &matWorld );
				D3DDevice->GetTransform( D3DTS_PROJECTION, &matProj );

				D3DXMatrixMultiply( &matViewProj, &matView, &matProj );

				
				D3DXMatrixInverse( &matViewInv, NULL, &matView );
				D3DXVECTOR4 v( matViewInv._41, matViewInv._42, matViewInv._43, 0.0f );

				eff->SetVector("Eye",&v);

				vect.w=0;
				vect.x=Lights[ActualVertexBuffer->Lights[0]].Pos.x;
				vect.y=Lights[ActualVertexBuffer->Lights[0]].Pos.y;
				vect.z=Lights[ActualVertexBuffer->Lights[0]].Pos.z;

				eff->SetVector("vecLight1",&vect);
				
				vect.x=Lights[ActualVertexBuffer->Lights[1]].Pos.x;
				vect.y=Lights[ActualVertexBuffer->Lights[1]].Pos.y;
				vect.z=Lights[ActualVertexBuffer->Lights[1]].Pos.z;
				eff->SetVector("vecLight2",&vect);
				
				vect.x=Lights[ActualVertexBuffer->Lights[2]].Pos.x;
				vect.y=Lights[ActualVertexBuffer->Lights[2]].Pos.y;
				vect.z=Lights[ActualVertexBuffer->Lights[2]].Pos.z;
				eff->SetVector("vecLight3",&vect);

				if (ActualVertexBuffer->Type&API3D_STYLEBUMP1)
				{
					vect.x=0.0f;//75f;
					vect.y=vect.z=vect.x;
					eff->SetVector("vecVar1",&vect);
					eff->SetVector("vecVar2",&vect);
					eff->SetVector("vecVar3",&vect);
				}
				else
				{
			
					vect.x=Lights[ActualVertexBuffer->Lights[0]].variation;
					vect.y=vect.z=vect.x;
					eff->SetVector("vecVar1",&vect);
					vect.x=Lights[ActualVertexBuffer->Lights[1]].variation;
					vect.y=vect.z=vect.x;
					eff->SetVector("vecVar2",&vect);
					vect.x=Lights[ActualVertexBuffer->Lights[2]].variation;
					vect.y=vect.z=vect.x;
					eff->SetVector("vecVar3",&vect);
				}

				eff->SetMatrix( "matWorld", &matWorld );
				eff->SetMatrix( "matViewProj", &matViewProj );

				tmp_iSE.nT=-1;
				tmp_iSE.nL=-1;
				tmp_iSE.nLV=-1;
				
				for (ref_value=ra;ref_value<=rb;ref_value++)
				{
					nfo=ActualVertexBuffer->ListeSE.GetFirst();
					while (nfo)
					{
						if (nfo->ref==ref_value)
						{
							if (states(RENDER_TARGET_OPTIONS)==STENCIL)
							{
								D3DDevice->SetTexture(1,Noir);
								D3DDevice->SetTexture(0,Noir);

								D3DDevice->GetTexture(1,&Texture0);
								D3DDevice->GetTexture(0,&Texture1);

								D3DDevice->GetTexture(1,&Texture2);
								D3DDevice->GetTexture(0,&Texture3);
								D3DDevice->GetTexture(0,&Texture4);
								D3DDevice->GetTexture(0,&Texture5);
							}
							else
							{
								if (fn_stage0) D3DDevice->SetTexture(1,Lightmap[fn_stage0(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else D3DDevice->SetTexture(1,Lightmap[nfo->nL]);
								D3DDevice->GetTexture(1,&Texture0);

								if (fn_stage1) D3DDevice->SetTexture(0,Texture[fn_stage1(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else D3DDevice->SetTexture(0,Texture[nfo->nT+Decal_nt]);
								D3DDevice->GetTexture(0,&Texture1);

								if (fn_stage2) D3DDevice->SetTexture(0,Lightmap[fn_stage2(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else D3DDevice->SetTexture(0,Lightmap[nfo->nLV]);
								D3DDevice->GetTexture(0,&Texture2);

								if (fn_stage3) D3DDevice->SetTexture(1,Texture[fn_stage3(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else D3DDevice->SetTexture(1,Texture[nfo->nT+bumpmap_settexture]);

								D3DDevice->GetTexture(1,&Texture3);

								if (fn_stage4) D3DDevice->SetTexture(0,Texture[fn_stage4(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else D3DDevice->SetTexture(0,Texture[nfo->nT+bump_displace]);
								D3DDevice->GetTexture(0,&Texture4);

								if (fn_stage5) D3DDevice->SetTexture(0,Texture[fn_stage5(nfo->nT,nfo->nT2,nfo->nL,nfo->nLV,nfo->tag)]);
								else D3DDevice->SetTexture(0,Texture[nfo->nT+bump_horizon]);
								D3DDevice->GetTexture(0,&Texture5);
							}
						
#ifdef API3D_DIRECT3D9
							if (ActualVertexBuffer->Type&API3D_STYLEBUMP1)
							{
								eff->SetBool( "transparent", false );
							}
							else
							{
								if ((nfo->ref==0)||(states(RENDER_TARGET_OPTIONS)==STENCIL)) eff->SetBool( "transparent", false );
								else eff->SetBool( "transparent", true );
							}
#else
							if (ActualVertexBuffer->Type&API3D_STYLEBUMP1)
							{
								eff->SetDword( "transparent", false );
							}
							else
							{
								if ((nfo->ref==0)||(states(RENDER_TARGET_OPTIONS)==STENCIL)) eff->SetDword( "transparent", false );
								else eff->SetDword( "transparent", true );
							}
#endif
						
							eff->SetTexture( "tex", Texture0 );
							eff->SetTexture( "lightmap", Texture1 );
							eff->SetTexture( "vectors", Texture2 );
							eff->SetTexture( "bump", Texture3 );
							eff->SetTexture( "displace", Texture4 );
							eff->SetTexture( "horizon", Texture5 );
							

							eff->Begin( &uPasses, 0);
							for( UINT iPass = 0; iPass < uPasses; iPass++ )
							{
								if (replace) 
								{
									if (iPass==uPasses-1) D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_REPLACE);
									else D3DDevice->SetRenderState( D3DRS_STENCILPASS,D3DSTENCILOP_KEEP);
								}
#ifdef API3D_DIRECT3D9
#ifdef API3D_VERSION_DX9c
								eff->BeginPass( iPass );
								eff->CommitChanges();
								if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
								else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
								eff->EndPass();
#else
								eff->Pass( iPass );
								if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
								else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#endif
#else
								eff->Pass( iPass );
								if (nfo->vEnd>=0) D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,nfo->vStart,nfo->vEnd-nfo->vStart,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
								else D3DDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST,0,ActualVertexBuffer->nVerticesActif,nfo->iStart,(nfo->iEnd-nfo->iStart)/3);
#endif
							}
							eff->End();

							
							Texture0->Release();
							Texture1->Release();
							Texture2->Release();
							Texture3->Release();
							Texture4->Release();
							Texture5->Release();
							
						}
						nfo=ActualVertexBuffer->ListeSE.GetNext();
					}
					
				}

			}
		}
/**/
	}
#ifdef API3D_DIRECT3D9
	if (ActualVertexBuffer->TypeVB==5)
	{
		if (!(ActualVertexBuffer->Type&API3D_EDGESDG))
			if (ActualVertexBuffer->Type&API3D_MORPH) D3DDevice->SetVertexDeclaration(NULL);
	}
#endif

	D3DDevice->SetTextureStageState( 0,D3DTSS_TEXCOORDINDEX ,0);
	D3DDevice->SetTextureStageState( 1,D3DTSS_TEXCOORDINDEX ,1);

	D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
	D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
	D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );

	D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
	D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
	D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG2, D3DTA_CURRENT );

	// END DRAWVERTEXBUFFER
#endif
#endif
#endif
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function:

	
		matrice d'affichage

		void C3DAPIBASE::LoadModelViewMatrix(CMatrix M)

		(obsolete)
	  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::LoadModelViewMatrix(CMatrix M)
{

#ifdef API3D_OPENGL
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	GLfloat m[16];

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	m[0 + 4* 0]=M.a[0][0];
	m[1 + 4* 0]=-M.a[0][1];
	m[2 + 4* 0]=-M.a[0][2];
	m[3 + 4* 0]=M.a[0][3];


	m[0 + 4* 1]=M.a[1][0];
	m[1 + 4* 1]=-M.a[1][1];
	m[2 + 4* 1]=-M.a[1][2];
	m[3 + 4* 1]=M.a[1][3];

	m[0 + 4* 2]=M.a[2][0];
	m[1 + 4* 2]=-M.a[2][1];
	m[2 + 4* 2]=-M.a[2][2];
	m[3 + 4* 2]=M.a[2][3];

	m[0 + 4* 3]=M.a[3][0];
	m[1 + 4* 3]=-M.a[3][1];
	m[2 + 4* 3]=-M.a[3][2];
	m[3 + 4* 3]=M.a[3][3];

	/*
	m[0 + 4* 0]=M.a[0][0];
	m[1 + 4* 0]=M.a[0][1];
	m[2 + 4* 0]=M.a[0][2];
	m[3 + 4* 0]=M.a[0][3];


	m[0 + 4* 1]=M.a[1][0];
	m[1 + 4* 1]=M.a[1][1];
	m[2 + 4* 1]=M.a[1][2];
	m[3 + 4* 1]=M.a[1][3];

	m[0 + 4* 2]=M.a[2][0];
	m[1 + 4* 2]=M.a[2][1];
	m[2 + 4* 2]=M.a[2][2];
	m[3 + 4* 2]=M.a[2][3];

	m[0 + 4* 3]=M.a[3][0];
	m[1 + 4* 3]=M.a[3][1];
	m[2 + 4* 3]=M.a[3][2];
	m[3 + 4* 3]=M.a[3][3];

  */
	glLoadMatrixf(m);


#endif

#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -------------

	viewMatrix.a[0][0]=M.a[0][0];
	viewMatrix.a[0][1]=-M.a[0][1];
	viewMatrix.a[0][2]=M.a[0][2];
	viewMatrix.a[0][3]=M.a[0][3];

	viewMatrix.a[1][0]=M.a[1][0];
	viewMatrix.a[1][1]=-M.a[1][1];
	viewMatrix.a[1][2]=M.a[1][2];
	viewMatrix.a[1][3]=M.a[1][3];

	viewMatrix.a[2][0]=M.a[2][0];
	viewMatrix.a[2][1]=-M.a[2][1];
	viewMatrix.a[2][2]=M.a[2][2];
	viewMatrix.a[2][3]=M.a[2][3];

	viewMatrix.a[3][0]=M.a[3][0];
	viewMatrix.a[3][1]=-M.a[3][1];
	viewMatrix.a[3][2]=M.a[3][2];
	viewMatrix.a[3][3]=M.a[3][3];

#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#if defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)

	viewMatrix.a[0][0]=M.a[0][0];
	viewMatrix.a[0][1]=-M.a[0][1];
	viewMatrix.a[0][2]=M.a[0][2];
	viewMatrix.a[0][3]=M.a[0][3];

	viewMatrix.a[1][0]=M.a[1][0];
	viewMatrix.a[1][1]=-M.a[1][1];
	viewMatrix.a[1][2]=M.a[1][2];
	viewMatrix.a[1][3]=M.a[1][3];

	viewMatrix.a[2][0]=M.a[2][0];
	viewMatrix.a[2][1]=-M.a[2][1];
	viewMatrix.a[2][2]=M.a[2][2];
	viewMatrix.a[2][3]=M.a[2][3];

	viewMatrix.a[3][0]=M.a[3][0];
	viewMatrix.a[3][1]=-M.a[3][1];
	viewMatrix.a[3][2]=M.a[3][2];
	viewMatrix.a[3][3]=M.a[3][3];

#else
	D3DXMATRIX m;

	m._11=M.a[0][0];
	m._12=-M.a[0][1];
	m._13=M.a[0][2];
	m._14=M.a[0][3];

	m._21=M.a[1][0];
	m._22=-M.a[1][1];
	m._23=M.a[1][2];
	m._24=M.a[1][3];

	m._31=M.a[2][0];
	m._32=-M.a[2][1];
	m._33=M.a[2][2];
	m._34=M.a[2][3];

	m._41=M.a[3][0];
	m._42=-M.a[3][1];
	m._43=M.a[3][2];
	m._44=M.a[3][3];

#ifdef API3D_DIRECT3D10
	viewMatrix=m;
#else

	D3DDevice->SetTransform(D3DTS_VIEW,&m);
#endif
#endif
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function:

	
		matrice d'affichage

		LoadModelMatrixGL(CMatrix M)

	  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

#ifdef API3D_OPENGL

void LoadModelMatrixGL(CMatrix M)
{
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	GLfloat m[16];

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	m[0 + 4* 0]=M.a[0][0];
	m[1 + 4* 0]=M.a[0][1];
	m[2 + 4* 0]=M.a[0][2];
	m[3 + 4* 0]=M.a[0][3];

	m[0 + 4* 1]=M.a[1][0];
	m[1 + 4* 1]=M.a[1][1];
	m[2 + 4* 1]=M.a[1][2];
	m[3 + 4* 1]=M.a[1][3];

	m[0 + 4* 2]=M.a[2][0];
	m[1 + 4* 2]=M.a[2][1];
	m[2 + 4* 2]=M.a[2][2];
	m[3 + 4* 2]=M.a[2][3];

	m[0 + 4* 3]=M.a[3][0];
	m[1 + 4* 3]=M.a[3][1];
	m[2 + 4* 3]=M.a[3][2];
	m[3 + 4* 3]=M.a[3][3];

	glLoadMatrixf(m);

}
#endif

#ifdef API3D_OPENGL20
void LoadModelMatrixGL(CMatrix M,GLfloat *m)
{
//------------------------------------------------------------------------------------------------ OPEN GL -----------

	m[0 + 4* 0]=M.a[0][0];
	m[1 + 4* 0]=M.a[0][1];
	m[2 + 4* 0]=M.a[0][2];
	m[3 + 4* 0]=M.a[0][3];

	m[0 + 4* 1]=M.a[1][0];
	m[1 + 4* 1]=M.a[1][1];
	m[2 + 4* 1]=M.a[1][2];
	m[3 + 4* 1]=M.a[1][3];

	m[0 + 4* 2]=M.a[2][0];
	m[1 + 4* 2]=M.a[2][1];
	m[2 + 4* 2]=M.a[2][2];
	m[3 + 4* 2]=M.a[2][3];

	m[0 + 4* 3]=M.a[3][0];
	m[1 + 4* 3]=M.a[3][1];
	m[2 + 4* 3]=M.a[3][2];
	m[3 + 4* 3]=M.a[3][3];

}
#endif


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function:

	
		matrice d'affichage

		void C3DAPIBASE::LoadReflectionMatrix(CMatrix M)

		see D3D convention
	  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::LoadReflectionMatrix(CMatrix M)
{
	REFLECTION=M;
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function:

	
		matrice d'affichage

		void C3DAPIBASE::LoadWorldMatrix(CMatrix M)

		see D3D convention
	  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::LoadWorldMatrixId()
{
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif

	CMatrix M;
	M.Id();
	LoadWorldMatrix(M);
}

void C3DAPIBASE::LoadWorldMatrix(CMatrix M)
{
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif

    WORLDWITHOUT=M;
#ifdef API3D_OPENGL20
	CMatrix Mt;
	Mt=M*REFLECTION;
	WORLD=Mt;
	CMatrix MM=Mt*pVIEW;
	LoadModelMatrixGL(MM,modelview);
#endif

#ifdef API3D_OPENGL
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	CMatrix MM;
	CMatrix Mt;

	Mt=M*REFLECTION;
	WORLD=Mt;
	MM=Mt*pVIEW;
	LoadModelMatrixGL(MM);
#endif

#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -------------

	CMatrix Mt;

	Mt=M*REFLECTION;

	worldMatrix.a[0][0]=Mt.a[0][0];
	worldMatrix.a[0][1]=Mt.a[0][1];
	worldMatrix.a[0][2]=Mt.a[0][2];
	worldMatrix.a[0][3]=Mt.a[0][3];

	worldMatrix.a[1][0]=Mt.a[1][0];
	worldMatrix.a[1][1]=Mt.a[1][1];
	worldMatrix.a[1][2]=Mt.a[1][2];
	worldMatrix.a[1][3]=Mt.a[1][3];

	worldMatrix.a[2][0]=Mt.a[2][0];
	worldMatrix.a[2][1]=Mt.a[2][1];
	worldMatrix.a[2][2]=Mt.a[2][2];
	worldMatrix.a[2][3]=Mt.a[2][3];

	worldMatrix.a[3][0]=Mt.a[3][0];
	worldMatrix.a[3][1]=Mt.a[3][1];
	worldMatrix.a[3][2]=Mt.a[3][2];
	worldMatrix.a[3][3]=Mt.a[3][3];

    WORLD=M;
    
#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#if defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)
	CMatrix Mt;

	Mt=M*REFLECTION;

	worldMatrix.a[0][0]=Mt.a[0][0];
	worldMatrix.a[0][1]=Mt.a[0][1];
	worldMatrix.a[0][2]=Mt.a[0][2];
	worldMatrix.a[0][3]=Mt.a[0][3];

	worldMatrix.a[1][0]=Mt.a[1][0];
	worldMatrix.a[1][1]=Mt.a[1][1];
	worldMatrix.a[1][2]=Mt.a[1][2];
	worldMatrix.a[1][3]=Mt.a[1][3];

	worldMatrix.a[2][0]=Mt.a[2][0];
	worldMatrix.a[2][1]=Mt.a[2][1];
	worldMatrix.a[2][2]=Mt.a[2][2];
	worldMatrix.a[2][3]=Mt.a[2][3];

	worldMatrix.a[3][0]=Mt.a[3][0];
	worldMatrix.a[3][1]=Mt.a[3][1];
	worldMatrix.a[3][2]=Mt.a[3][2];
	worldMatrix.a[3][3]=Mt.a[3][3];

#else
	D3DXMATRIX m;
	CMatrix Mt;

	Mt=M*REFLECTION;

	m._11=Mt.a[0][0];
	m._12=Mt.a[0][1];
	m._13=Mt.a[0][2];
	m._14=Mt.a[0][3];

	m._21=Mt.a[1][0];
	m._22=Mt.a[1][1];
	m._23=Mt.a[1][2];
	m._24=Mt.a[1][3];

	m._31=Mt.a[2][0];
	m._32=Mt.a[2][1];
	m._33=Mt.a[2][2];
	m._34=Mt.a[2][3];

	m._41=Mt.a[3][0];
	m._42=Mt.a[3][1];
	m._43=Mt.a[3][2];
	m._44=Mt.a[3][3];

#ifdef API3D_DIRECT3D10
	worldMatrix=m;
#else
	D3DDevice->SetTransform(D3DTS_WORLD,&m);
#endif
#endif

	WORLD=M;
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function:

	
		matrice d'affichage

		
		void C3DAPIBASE::LoadViewMatrix(CMatrix M)

		see D3D convention
	  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */



void C3DAPIBASE::LoadViewMatrix(CMatrix M)
{
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif

#ifdef API3D_OPENGL
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	CMatrix MM;

	pVIEW.a[0][0]=M.a[0][0];
	pVIEW.a[0][1]=-M.a[0][1];
	pVIEW.a[0][2]=-M.a[0][2];
	pVIEW.a[0][3]=M.a[0][3];
	
	pVIEW.a[1][0]=M.a[1][0];
	pVIEW.a[1][1]=-M.a[1][1];
	pVIEW.a[1][2]=-M.a[1][2];
	pVIEW.a[1][3]=M.a[1][3];
	
	pVIEW.a[2][0]=M.a[2][0];
	pVIEW.a[2][1]=-M.a[2][1];
	pVIEW.a[2][2]=-M.a[2][2];
	pVIEW.a[2][3]=M.a[2][3];

	pVIEW.a[3][0]=M.a[3][0];
	pVIEW.a[3][1]=-M.a[3][1];
	pVIEW.a[3][2]=-M.a[3][2];
	pVIEW.a[3][3]=M.a[3][3];


	VIEW=M;
	MM=WORLD*pVIEW;

	LoadModelMatrixGL(MM);

#endif

#ifdef API3D_OPENGL20
//------------------------------------------------------------------------------------------------ OPEN GL -----------

	pVIEW.a[0][0]=M.a[0][0];
	pVIEW.a[0][1]=-M.a[0][1];
	pVIEW.a[0][2]=-M.a[0][2];
	pVIEW.a[0][3]=M.a[0][3];
	
	pVIEW.a[1][0]=M.a[1][0];
	pVIEW.a[1][1]=-M.a[1][1];
	pVIEW.a[1][2]=-M.a[1][2];
	pVIEW.a[1][3]=M.a[1][3];
	
	pVIEW.a[2][0]=M.a[2][0];
	pVIEW.a[2][1]=-M.a[2][1];
	pVIEW.a[2][2]=-M.a[2][2];
	pVIEW.a[2][3]=M.a[2][3];

	pVIEW.a[3][0]=M.a[3][0];
	pVIEW.a[3][1]=-M.a[3][1];
	pVIEW.a[3][2]=-M.a[3][2];
	pVIEW.a[3][3]=M.a[3][3];

	VIEW=M;
	
	CMatrix MM=WORLD*pVIEW;

	LoadModelMatrixGL(MM,modelview);

#endif

#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -------------

	viewMatrix.a[0][0]=M.a[0][0];
	viewMatrix.a[0][1]=-M.a[0][1];
	viewMatrix.a[0][2]=M.a[0][2];
	viewMatrix.a[0][3]=M.a[0][3];

	viewMatrix.a[1][0]=M.a[1][0];
	viewMatrix.a[1][1]=-M.a[1][1];
	viewMatrix.a[1][2]=M.a[1][2];
	viewMatrix.a[1][3]=M.a[1][3];

	viewMatrix.a[2][0]=M.a[2][0];
	viewMatrix.a[2][1]=-M.a[2][1];
	viewMatrix.a[2][2]=M.a[2][2];
	viewMatrix.a[2][3]=M.a[2][3];

	viewMatrix.a[3][0]=M.a[3][0];
	viewMatrix.a[3][1]=-M.a[3][1];
	viewMatrix.a[3][2]=M.a[3][2];
	viewMatrix.a[3][3]=M.a[3][3];
    
    pVIEW=viewMatrix;
    VIEW=M;

#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#if defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)

	viewMatrix.a[0][0]=M.a[0][0];
	viewMatrix.a[0][1]=-M.a[0][1];
	viewMatrix.a[0][2]=M.a[0][2];
	viewMatrix.a[0][3]=M.a[0][3];

	viewMatrix.a[1][0]=M.a[1][0];
	viewMatrix.a[1][1]=-M.a[1][1];
	viewMatrix.a[1][2]=M.a[1][2];
	viewMatrix.a[1][3]=M.a[1][3];

	viewMatrix.a[2][0]=M.a[2][0];
	viewMatrix.a[2][1]=-M.a[2][1];
	viewMatrix.a[2][2]=M.a[2][2];
	viewMatrix.a[2][3]=M.a[2][3];

	viewMatrix.a[3][0]=M.a[3][0];
	viewMatrix.a[3][1]=-M.a[3][1];
	viewMatrix.a[3][2]=M.a[3][2];
	viewMatrix.a[3][3]=M.a[3][3];
    
    pVIEW=viewMatrix;

#else
	D3DXMATRIX m;
    
    pVIEW.a[0][0]=M.a[0][0];
    pVIEW.a[0][1]=-M.a[0][1];
    pVIEW.a[0][2]=M.a[0][2];
    pVIEW.a[0][3]=M.a[0][3];

    pVIEW.a[1][0]=M.a[1][0];
    pVIEW.a[1][1]=-M.a[1][1];
    pVIEW.a[1][2]=M.a[1][2];
    pVIEW.a[1][3]=M.a[1][3];

    pVIEW.a[2][0]=M.a[2][0];
    pVIEW.a[2][1]=-M.a[2][1];
    pVIEW.a[2][2]=M.a[2][2];
    pVIEW.a[2][3]=M.a[2][3];

    pVIEW.a[3][0]=M.a[3][0];
    pVIEW.a[3][1]=-M.a[3][1];
    pVIEW.a[3][2]=M.a[3][2];
    pVIEW.a[3][3]=M.a[3][3];


	m._11=M.a[0][0];
	m._12=-M.a[0][1];
	m._13=M.a[0][2];
	m._14=M.a[0][3];


	m._21=M.a[1][0];
	m._22=-M.a[1][1];
	m._23=M.a[1][2];
	m._24=M.a[1][3];


	m._31=M.a[2][0];
	m._32=-M.a[2][1];
	m._33=M.a[2][2];
	m._34=M.a[2][3];

	m._41=M.a[3][0];
	m._42=-M.a[3][1];
	m._43=M.a[3][2];
	m._44=M.a[3][3];
#ifdef API3D_DIRECT3D10
	viewMatrix=m;
#else
	D3DDevice->SetTransform(D3DTS_VIEW,&m);
#endif
#endif

	VIEW=M;

#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function:

    
        retrieves ViewProj Transform

        void C3DAPIBASE::GetViewProj();

        
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

CMatrix C3DAPIBASE::GetViewProj()
{
    CMatrix ViewProj;
    
#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -----------
    MATRIXMATRIX(ViewProj,viewMatrix,projectionMatrix);
#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#ifdef API3D_DIRECT3D12
        MATRIXMATRIX(ViewProj,viewMatrix,projectionMatrix);
#else
#ifdef API3D_DIRECT3D11
        MATRIXMATRIX(ViewProj,viewMatrix,projectionMatrix);
#else
#ifdef API3D_DIRECT3D10
        D3DXMatrixMultiply( (D3DXMATRIX*)&ViewProj, &viewMatrix,&projectionMatrix );
#else
        D3DXMATRIX matView,matProj;
        D3DDevice->GetTransform( D3DTS_VIEW, &matView );
        D3DDevice->GetTransform( D3DTS_PROJECTION, &matProj );
        D3DXMatrixMultiply( (D3DXMATRIX*)&ViewProj, &matView, &matProj );
#endif
#endif
#endif
#endif
    
#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ OPEN GL -----------
    int i,j,k;
    GLfloat mm[16];
    GLfloat *m=(float*)&ViewProj;
    
#ifdef OPENGL_GLSL
#ifdef API3D_OPENGL
    GLfloat proj[16];
    
    for (i=0;i<4;i++)
        for (j=0;j<4;j++) mm[i+4*j]=pVIEW.a[j][i];

    glGetFloatv(GL_PROJECTION_MATRIX, proj);

    for (i=0;i<4;i++)
        for (j=0;j<4;j++)
        {
            m[i+4*j]=0.0f;
            for (k=0;k<4;k++) m[i+4*j]+=proj[i+4*k]*mm[k+4*j];
        }
#else
    for (i=0;i<4;i++)
        for (j=0;j<4;j++) mm[i+4*j]=pVIEW.a[j][i];

    for (i=0;i<4;i++)
        for (j=0;j<4;j++)
        {
            m[i+4*j]=0.0f;
            for (k=0;k<4;k++) m[i+4*j]+=projection[i+4*k]*mm[k+4*j];
        }
#endif
#endif
#endif

    return ViewProj;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function:

	
		ambient color fo TnL

		void C3DAPIBASE::SetAmbient(float r,float g,float b)

		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */
	
void C3DAPIBASE::SetAmbient(float r,float g,float b)
{
#if defined(API3D_OPENGL)||defined(API3D_OPENGL20)
	float color[4];
	Ambient.r=r;
	Ambient.g=g;
	Ambient.b=b;
	color[0]=r;
	color[1]=g;
	color[2]=b;
	color[3]=1;
#if defined(API3D_OPENGL)
	glLightModelfv(GL_LIGHT_MODEL_AMBIENT,color);
#endif
#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#if defined(API3D_DIRECT3D12) || defined(API3D_DIRECT3D11) || defined (API3D_METAL)
	Ambient.r=r;
	Ambient.g=g;
	Ambient.b=b;
#else
#ifdef API3D_DIRECT3D10

#else

	DWORD color;
	color=D3DCOLOR_COLORVALUE(r,g,b,0);
	D3DDevice->SetRenderState(D3DRS_AMBIENT,color);
#endif
	Ambient.r=r;
	Ambient.g=g;
	Ambient.b=b;
#endif
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function:

	
		set light point (omnidirectionnal)


		void C3DAPIBASE::SetLightPoint(int n,CVector p,float r,float g,float b,float A,float R)
		
		A = Attenuation 
		R = Range
		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::SetLightPoint(int n,CVector p,float r,float g,float b,float A,float R)
{
	tagLights[n]=1;

	Lights[n].Pos=p;
	Lights[n].r=r;
	Lights[n].g=g;
	Lights[n].b=b;

	Lights[n].color[0]=r;
	Lights[n].color[1]=g;
	Lights[n].color[2]=b;
	Lights[n].color[3]=1.0f;
	Lights[n].colorsave[0]=r;
	Lights[n].colorsave[1]=g;
	Lights[n].colorsave[2]=b;
	Lights[n].colorsave[3]=1.0f;

	Lights[n].specular[0]=1.0f;
	Lights[n].specular[1]=1.0f;
	Lights[n].specular[2]=1.0f;
	Lights[n].specular[3]=1.0f;

	Lights[n].directionnal=false;
	Lights[n].Attenuation=A;
	Lights[n].Range=R;

#ifdef API3D_DIRECT3D

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DLIGHT8 D3DLight;
	
	ZeroMemory(&D3DLight, sizeof(D3DLIGHT8));

	D3DLight.Type = D3DLIGHT_POINT;
	D3DLight.Diffuse.r  = r;
	D3DLight.Diffuse.g  = g;
	D3DLight.Diffuse.b  = b;
	D3DLight.Ambient.r  = Ambient.r*0;
	D3DLight.Ambient.g  = Ambient.g*0;
	D3DLight.Ambient.b  = Ambient.b*0;
	D3DLight.Specular.r = 1.0f;
	D3DLight.Specular.g = 1.0f;
	D3DLight.Specular.b = 1.0f;

	D3DLight.Position.x = p.x;
	D3DLight.Position.y = p.y;
	D3DLight.Position.z = p.z;

	D3DLight.Attenuation0 = 1; 
	D3DLight.Attenuation1 = A; 
	D3DLight.Attenuation2 = 0; 
	D3DLight.Range        = R;


	D3DDevice->SetLight(n, &D3DLight);
#endif		


#ifdef API3D_DIRECT3D9

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DLIGHT9 D3DLight;
	
	ZeroMemory(&D3DLight, sizeof(D3DLIGHT9));

	D3DLight.Type = D3DLIGHT_POINT;
	D3DLight.Diffuse.r  = r;
	D3DLight.Diffuse.g  = g;
	D3DLight.Diffuse.b  = b;
	D3DLight.Ambient.r  = Ambient.r*0;
	D3DLight.Ambient.g  = Ambient.g*0;
	D3DLight.Ambient.b  = Ambient.b*0;
	D3DLight.Specular.r = 1.0f;
	D3DLight.Specular.g = 1.0f;
	D3DLight.Specular.b = 1.0f;

	D3DLight.Position.x = p.x;
	D3DLight.Position.y = p.y;
	D3DLight.Position.z = p.z;

	D3DLight.Attenuation0 = 1; 
	D3DLight.Attenuation1 = A; 
	D3DLight.Attenuation2 = 0; 
	D3DLight.Range        = R;


	D3DDevice->SetLight(n, &D3DLight);
#endif		

}



void C3DAPIBASE::SetLightPoint(int n,CVector p,float r,float g,float b,float sr,float sg,float sb,float A,float R)
{
	tagLights[n]=1;

	Lights[n].Pos=p;
	Lights[n].r=r;
	Lights[n].g=g;
	Lights[n].b=b;

	Lights[n].color[0]=r;
	Lights[n].color[1]=g;
	Lights[n].color[2]=b;
	Lights[n].color[3]=1.0f;
	Lights[n].colorsave[0]=r;
	Lights[n].colorsave[1]=g;
	Lights[n].colorsave[2]=b;
	Lights[n].colorsave[3]=1.0f;

	Lights[n].specular[0]=sr;
	Lights[n].specular[1]=sg;
	Lights[n].specular[2]=sb;
	Lights[n].specular[3]=1.0f;

	Lights[n].directionnal=false;
	Lights[n].Attenuation=A;
	Lights[n].Range=R;

#ifdef API3D_DIRECT3D

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DLIGHT8 D3DLight;
	
	ZeroMemory(&D3DLight, sizeof(D3DLIGHT8));

	D3DLight.Type = D3DLIGHT_POINT;
	D3DLight.Diffuse.r  = r;
	D3DLight.Diffuse.g  = g;
	D3DLight.Diffuse.b  = b;
	D3DLight.Ambient.r  = Ambient.r*0;
	D3DLight.Ambient.g  = Ambient.g*0;
	D3DLight.Ambient.b  = Ambient.b*0;
	D3DLight.Specular.r = sr;
	D3DLight.Specular.g = sg;
	D3DLight.Specular.b = sb;

	D3DLight.Position.x = p.x;
	D3DLight.Position.y = p.y;
	D3DLight.Position.z = p.z;

	D3DLight.Attenuation0 = 1; 
	D3DLight.Attenuation1 = A; 
	D3DLight.Attenuation2 = 0; 
	D3DLight.Range        = R;


	D3DDevice->SetLight(n, &D3DLight);
#endif		

#ifdef API3D_DIRECT3D9

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DLIGHT9 D3DLight;
	
	ZeroMemory(&D3DLight, sizeof(D3DLIGHT9));

	D3DLight.Type = D3DLIGHT_POINT;
	D3DLight.Diffuse.r  = r;
	D3DLight.Diffuse.g  = g;
	D3DLight.Diffuse.b  = b;
	D3DLight.Ambient.r  = Ambient.r*0;
	D3DLight.Ambient.g  = Ambient.g*0;
	D3DLight.Ambient.b  = Ambient.b*0;
	D3DLight.Specular.r = sr;
	D3DLight.Specular.g = sg;
	D3DLight.Specular.b = sb;

	D3DLight.Position.x = p.x;
	D3DLight.Position.y = p.y;
	D3DLight.Position.z = p.z;

	D3DLight.Attenuation0 = 1; 
	D3DLight.Attenuation1 = A; 
	D3DLight.Attenuation2 = 0; 
	D3DLight.Range        = R;


	D3DDevice->SetLight(n, &D3DLight);
#endif
}



/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function:

	
		set light vector (directionnal)

		void C3DAPIBASE::SetLightDirectionnal(int n,CVector p,float r,float g,float b)
		
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetLightDirectionnal(int n,CVector p,float r,float g,float b)
{
	CVector u;

	tagLights[n]=1;

	Lights[n].r=r;
	Lights[n].g=g;
	Lights[n].b=b;

	u=p;
	u.Normalise();
	Lights[n].Pos=u;
	Lights[n].color[0]=r;
	Lights[n].color[1]=g;
	Lights[n].color[2]=b;
	Lights[n].color[3]=1.0f;
	Lights[n].colorsave[0]=r;
	Lights[n].colorsave[1]=g;
	Lights[n].colorsave[2]=b;
	Lights[n].colorsave[3]=1.0f;
	Lights[n].directionnal=true;
	Lights[n].Attenuation=0;
	Lights[n].specular[0]=1.0f;
	Lights[n].specular[1]=1.0f;
	Lights[n].specular[2]=1.0f;
	Lights[n].specular[3]=1.0f;

#ifdef API3D_DIRECT3D

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DLIGHT8 D3DLight;

	ZeroMemory(&D3DLight, sizeof(D3DLIGHT8));

	D3DLight.Type = D3DLIGHT_DIRECTIONAL;
	D3DLight.Diffuse.r  = r;
	D3DLight.Diffuse.g  = g;
	D3DLight.Diffuse.b  = b;
	D3DLight.Ambient.r  = Ambient.r*0;
	D3DLight.Ambient.g  = Ambient.g*0;
	D3DLight.Ambient.b  = Ambient.b*0;
	D3DLight.Specular.r = 1.0f;
	D3DLight.Specular.g = 1.0f;
	D3DLight.Specular.b = 1.0f;

	D3DLight.Direction.x = u.x;
	D3DLight.Direction.y = u.y;
	D3DLight.Direction.z = u.z;

	D3DDevice->SetLight(n, &D3DLight);
#endif		

#ifdef API3D_DIRECT3D9

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DLIGHT9 D3DLight;

	ZeroMemory(&D3DLight, sizeof(D3DLIGHT9));

	D3DLight.Type = D3DLIGHT_DIRECTIONAL;
	D3DLight.Diffuse.r  = r;
	D3DLight.Diffuse.g  = g;
	D3DLight.Diffuse.b  = b;
	D3DLight.Ambient.r  = Ambient.r*0;
	D3DLight.Ambient.g  = Ambient.g*0;
	D3DLight.Ambient.b  = Ambient.b*0;
	D3DLight.Specular.r = 1.0f;
	D3DLight.Specular.g = 1.0f;
	D3DLight.Specular.b = 1.0f;

	D3DLight.Direction.x = u.x;
	D3DLight.Direction.y = u.y;
	D3DLight.Direction.z = u.z;

	D3DDevice->SetLight(n, &D3DLight);
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Lights : enable
	  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::EnableLight(int n)
{
#ifdef API3D_OPENGL
	glEnable(GL_LIGHT0+n);
	
#endif
#ifdef API3D_DIRECT3D
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DDevice->LightEnable(n,TRUE);
#endif

#ifdef API3D_DIRECT3D9
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DDevice->LightEnable(n,TRUE);
#endif

	Lights[n].enabled=1;
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Lights : enable shadow
	  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::EnableShadowLight(int n)
{
	Lights[n].emit_shadows=1;
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Lights : disable shadow
	  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::DisableShadowLight(int n)
{
	Lights[n].emit_shadows=0;
}



/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Lights : enable
	  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::EnableLightSpecular(int n)
{
	Lights[n].color[0]=0.0f;
	Lights[n].color[1]=0.0f;
	Lights[n].color[2]=0.0f;
	Lights[n].color[3]=0.0f;

	if (Lights[n].directionnal)
	{

#ifdef API3D_DIRECT3D
		D3DLIGHT8 D3DLight;
		ZeroMemory(&D3DLight, sizeof(D3DLIGHT8));
		D3DLight.Type = D3DLIGHT_DIRECTIONAL;
		D3DLight.Diffuse.r  = 0.0f;	D3DLight.Diffuse.g  = 0.0f;	D3DLight.Diffuse.b  = 0.0f;
		D3DLight.Ambient.r  = 0.0f;	D3DLight.Ambient.g  = 0.0f;	D3DLight.Ambient.b  = 0.0f;
		D3DLight.Specular.r = Lights[n].specular[0];	D3DLight.Specular.g = Lights[n].specular[1];	D3DLight.Specular.b = Lights[n].specular[2];
		D3DLight.Direction.x = Lights[n].Pos.x;
		D3DLight.Direction.y = Lights[n].Pos.y;
		D3DLight.Direction.z = Lights[n].Pos.z;
		D3DDevice->SetLight(n, &D3DLight);
#endif		

#ifdef API3D_DIRECT3D9
		D3DLIGHT9 D3DLight;
		ZeroMemory(&D3DLight, sizeof(D3DLIGHT9));
		D3DLight.Type = D3DLIGHT_DIRECTIONAL;
		D3DLight.Diffuse.r  = 0.0f;	D3DLight.Diffuse.g  = 0.0f;	D3DLight.Diffuse.b  = 0.0f;
		D3DLight.Ambient.r  = 0.0f;	D3DLight.Ambient.g  = 0.0f;	D3DLight.Ambient.b  = 0.0f;
		D3DLight.Specular.r = Lights[n].specular[0];	D3DLight.Specular.g = Lights[n].specular[1];	D3DLight.Specular.b = Lights[n].specular[2];
		D3DLight.Direction.x = Lights[n].Pos.x;
		D3DLight.Direction.y = Lights[n].Pos.y;
		D3DLight.Direction.z = Lights[n].Pos.z;
		D3DDevice->SetLight(n, &D3DLight);
#endif		

	}
	else
	{

#ifdef API3D_DIRECT3D
		D3DLIGHT8 D3DLight;
		ZeroMemory(&D3DLight, sizeof(D3DLIGHT8));
		D3DLight.Type = D3DLIGHT_POINT;
		D3DLight.Diffuse.r  = 0; D3DLight.Diffuse.g  = 0; D3DLight.Diffuse.b  = 0;
		D3DLight.Ambient.r  = 0; D3DLight.Ambient.g  = 0; D3DLight.Ambient.b  = 0;
		D3DLight.Specular.r = Lights[n].specular[0];	D3DLight.Specular.g = Lights[n].specular[1];	D3DLight.Specular.b = Lights[n].specular[2];
		D3DLight.Position.x = Lights[n].Pos.x;
		D3DLight.Position.y = Lights[n].Pos.y;
		D3DLight.Position.z = Lights[n].Pos.z;
		D3DLight.Attenuation0 = 1; 
		D3DLight.Attenuation1 = Lights[n].Attenuation; 
		D3DLight.Attenuation2 = 0; 
		D3DLight.Range        = Lights[n].Range;
		D3DDevice->SetLight(n, &D3DLight);
#endif		

#ifdef API3D_DIRECT3D9
		D3DLIGHT9 D3DLight;
		ZeroMemory(&D3DLight, sizeof(D3DLIGHT9));
		D3DLight.Type = D3DLIGHT_POINT;
		D3DLight.Diffuse.r  = 0; D3DLight.Diffuse.g  = 0; D3DLight.Diffuse.b  = 0;
		D3DLight.Ambient.r  = 0; D3DLight.Ambient.g  = 0; D3DLight.Ambient.b  = 0;
		D3DLight.Specular.r = Lights[n].specular[0];	D3DLight.Specular.g = Lights[n].specular[1];	D3DLight.Specular.b = Lights[n].specular[2];
		D3DLight.Position.x = Lights[n].Pos.x;
		D3DLight.Position.y = Lights[n].Pos.y;
		D3DLight.Position.z = Lights[n].Pos.z;
		D3DLight.Attenuation0 = 1; 
		D3DLight.Attenuation1 = Lights[n].Attenuation; 
		D3DLight.Attenuation2 = 0; 
		D3DLight.Range        = Lights[n].Range;
		D3DDevice->SetLight(n, &D3DLight);
#endif		

	}

#ifdef API3D_OPENGL
	glEnable(GL_LIGHT0+n);
	
#endif
#ifdef API3D_DIRECT3D
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DDevice->LightEnable(n,TRUE);
#endif

#ifdef API3D_DIRECT3D9
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DDevice->LightEnable(n,TRUE);
#endif

	Lights[n].enabled=1;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Lights :  disable

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::DisableLight(int n)
{
	Lights[n].color[0]=Lights[n].colorsave[0];
	Lights[n].color[1]=Lights[n].colorsave[1];
	Lights[n].color[2]=Lights[n].colorsave[2];
	Lights[n].color[3]=Lights[n].colorsave[3];

	if (Lights[n].directionnal)
	{

#ifdef API3D_DIRECT3D
		D3DLIGHT8 D3DLight;
		ZeroMemory(&D3DLight, sizeof(D3DLIGHT8));
		D3DLight.Type = D3DLIGHT_DIRECTIONAL;
		D3DLight.Diffuse.r  = Lights[n].color[0];	D3DLight.Diffuse.g  = Lights[n].color[1];	D3DLight.Diffuse.b  = Lights[n].color[2];
		D3DLight.Ambient.r  = 0.0f;	D3DLight.Ambient.g  = 0.0f;	D3DLight.Ambient.b  = 0.0f;
		D3DLight.Specular.r = Lights[n].specular[0];	D3DLight.Specular.g = Lights[n].specular[1];	D3DLight.Specular.b = Lights[n].specular[2];
		D3DLight.Direction.x = Lights[n].Pos.x;
		D3DLight.Direction.y = Lights[n].Pos.y;
		D3DLight.Direction.z = Lights[n].Pos.z;
		D3DDevice->SetLight(n, &D3DLight);
#endif		

#ifdef API3D_DIRECT3D9
		D3DLIGHT9 D3DLight;
		ZeroMemory(&D3DLight, sizeof(D3DLIGHT9));
		D3DLight.Type = D3DLIGHT_DIRECTIONAL;
		D3DLight.Diffuse.r  = Lights[n].color[0];	D3DLight.Diffuse.g  = Lights[n].color[1];	D3DLight.Diffuse.b  = Lights[n].color[2];
		D3DLight.Ambient.r  = 0.0f;	D3DLight.Ambient.g  = 0.0f;	D3DLight.Ambient.b  = 0.0f;
		D3DLight.Specular.r = Lights[n].specular[0];	D3DLight.Specular.g = Lights[n].specular[1];	D3DLight.Specular.b = Lights[n].specular[2];
		D3DLight.Direction.x = Lights[n].Pos.x;
		D3DLight.Direction.y = Lights[n].Pos.y;
		D3DLight.Direction.z = Lights[n].Pos.z;
		D3DDevice->SetLight(n, &D3DLight);
#endif		

	}
	else
	{

#ifdef API3D_DIRECT3D
		D3DLIGHT8 D3DLight;
		ZeroMemory(&D3DLight, sizeof(D3DLIGHT8));
		D3DLight.Type = D3DLIGHT_POINT;
		D3DLight.Diffuse.r  = Lights[n].color[0];	D3DLight.Diffuse.g  = Lights[n].color[1];	D3DLight.Diffuse.b  = Lights[n].color[2];
		D3DLight.Ambient.r  = 0; D3DLight.Ambient.g  = 0; D3DLight.Ambient.b  = 0;
		D3DLight.Specular.r = Lights[n].specular[0];	D3DLight.Specular.g = Lights[n].specular[1];	D3DLight.Specular.b = Lights[n].specular[2];
		D3DLight.Position.x = Lights[n].Pos.x;
		D3DLight.Position.y = Lights[n].Pos.y;
		D3DLight.Position.z = Lights[n].Pos.z;
		D3DLight.Attenuation0 = 1; 
		D3DLight.Attenuation1 = Lights[n].Attenuation; 
		D3DLight.Attenuation2 = 0; 
		D3DLight.Range        = Lights[n].Range;
		D3DDevice->SetLight(n, &D3DLight);
#endif		

#ifdef API3D_DIRECT3D9
		D3DLIGHT9 D3DLight;
		ZeroMemory(&D3DLight, sizeof(D3DLIGHT9));
		D3DLight.Type = D3DLIGHT_POINT;
		D3DLight.Diffuse.r  = Lights[n].color[0];	D3DLight.Diffuse.g  = Lights[n].color[1];	D3DLight.Diffuse.b  = Lights[n].color[2];
		D3DLight.Ambient.r  = 0; D3DLight.Ambient.g  = 0; D3DLight.Ambient.b  = 0;
		D3DLight.Specular.r = Lights[n].specular[0];	D3DLight.Specular.g = Lights[n].specular[1];	D3DLight.Specular.b = Lights[n].specular[2];
		D3DLight.Position.x = Lights[n].Pos.x;
		D3DLight.Position.y = Lights[n].Pos.y;
		D3DLight.Position.z = Lights[n].Pos.z;
		D3DLight.Attenuation0 = 1; 
		D3DLight.Attenuation1 = Lights[n].Attenuation; 
		D3DLight.Attenuation2 = 0; 
		D3DLight.Range        = Lights[n].Range;
		D3DDevice->SetLight(n, &D3DLight);
#endif		

	}

#ifdef API3D_OPENGL
	glDisable(GL_LIGHT0+n);
#endif
#ifdef API3D_DIRECT3D
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DDevice->LightEnable(n,FALSE);
#endif

#ifdef API3D_DIRECT3D9
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	D3DDevice->LightEnable(n,FALSE);
#endif

	Lights[n].enabled=0;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function:
        
        Get vectors frustum

        CVector C3DAPIBASE::PickVecteur(float x,float y)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

CVector* C3DAPIBASE::GetFrustum()
{
    CVector v,p,d;
    CMatrix m;
    CVector *fr=new CVector[5];
    
    m.Inverse4x4(VIEW);
    
    p.x = m.a[3][0];
    p.y = m.a[3][1];
    p.z = m.a[3][2];

    fr[0]=p;

    v.x = -1.0f / pPROJ.a[0][0];
    v.y = -1.0f / pPROJ.a[1][1];
    v.z = 1.0f;

    d.x  = v.x*m.a[0][0] + v.y*m.a[1][0] + v.z*m.a[2][0];
    d.y  = v.x*m.a[0][1] + v.y*m.a[1][1] + v.z*m.a[2][1];
    d.z  = v.x*m.a[0][2] + v.y*m.a[1][2] + v.z*m.a[2][2];

    fr[1]=p+d;

    v.x = 1.0f / pPROJ.a[0][0];
    v.y = -1.0f / pPROJ.a[1][1];
    v.z = 1.0f;

    d.x  = v.x*m.a[0][0] + v.y*m.a[1][0] + v.z*m.a[2][0];
    d.y  = v.x*m.a[0][1] + v.y*m.a[1][1] + v.z*m.a[2][1];
    d.z  = v.x*m.a[0][2] + v.y*m.a[1][2] + v.z*m.a[2][2];

    fr[2]=p+d;
    
    v.x = 1.0f / pPROJ.a[0][0];
    v.y = 1.0f / pPROJ.a[1][1];
    v.z = 1.0f;

    d.x  = v.x*m.a[0][0] + v.y*m.a[1][0] + v.z*m.a[2][0];
    d.y  = v.x*m.a[0][1] + v.y*m.a[1][1] + v.z*m.a[2][1];
    d.z  = v.x*m.a[0][2] + v.y*m.a[1][2] + v.z*m.a[2][2];

    fr[3]=p+d;

    v.x = -1.0f / pPROJ.a[0][0];
    v.y = 1.0f / pPROJ.a[1][1];
    v.z = 1.0f;

    d.x  = v.x*m.a[0][0] + v.y*m.a[1][0] + v.z*m.a[2][0];
    d.y  = v.x*m.a[0][1] + v.y*m.a[1][1] + v.z*m.a[2][1];
    d.z  = v.x*m.a[0][2] + v.y*m.a[1][2] + v.z*m.a[2][2];

    fr[4]=p+d;
    
    return fr;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function:
		
		Get vector camera to screen point

		CVector C3DAPIBASE::PickVecteur(float x,float y)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


CVector C3DAPIBASE::PickVecteur(float x,float y)
{
	CVector v,p,d,pick;

	pick.Init(0,0,0);

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)

//------------------------------------------------------------------------------------------------ DIRECT3D / METAL ----------
#if defined(API3D_DIRECT3D12) || defined(API3D_DIRECT3D11) || defined(API3D_METAL)

	v.x =  ( ( ( 2.0f * x ) / SCREEN_X ) - 1 ) / projectionMatrix.a[0][0];
    v.y = -( ( ( 2.0f * y ) / SCREEN_Y ) - 1 ) / projectionMatrix.a[1][1];
    v.z =  1.0f;

	CMatrix m;
	m.Inverse4x4(viewMatrix);

    d.x  = v.x*m.a[0][0] + v.y*m.a[1][0] + v.z*m.a[2][0];
    d.y  = v.x*m.a[0][1] + v.y*m.a[1][1] + v.z*m.a[2][1];
    d.z  = v.x*m.a[0][2] + v.y*m.a[1][2] + v.z*m.a[2][2];
    p.x = m.a[3][0];
    p.y = m.a[3][1];
    p.z = m.a[3][2];

	pick=p+d;

#else
	D3DXMATRIX matView, m,matProj;
#ifdef API3D_DIRECT3D10
	matProj=projectionMatrix;
	matView=viewMatrix;
#else
	D3DDevice->GetTransform( D3DTS_VIEW, &matView );
	D3DDevice->GetTransform( D3DTS_PROJECTION, &matProj );
#endif    
    v.x =  ( ( ( 2.0f * x ) / SCREEN_X ) - 1 ) / matProj._11;
    v.y = -( ( ( 2.0f * y ) / SCREEN_Y ) - 1 ) / matProj._22;
    v.z =  1.0f;

    D3DXMatrixInverse( &m, NULL, &matView );

    d.x  = v.x*m._11 + v.y*m._21 + v.z*m._31;
    d.y  = v.x*m._12 + v.y*m._22 + v.z*m._32;
    d.z  = v.x*m._13 + v.y*m._23 + v.z*m._33;
    p.x = m._41;
    p.y = m._42;
    p.z = m._43;

	pick=p+d;
#endif
#else
#ifdef API3D_OPENGL20
	CMatrix M;
	M.Inverse4x4(VIEW);
    
    v.x =  ( ( ( 2.0f * x ) / SCREEN_X ) - 1 ) / projection[0+4*0];
    v.y =  ( ( ( 2.0f * y ) / SCREEN_Y ) - 1 ) / projection[1+4*1];
    v.z =  1.0f;
	
	d.x  = (v.x*M.a[0][0] + v.y*M.a[1][0] + v.z*M.a[2][0]);
    d.y  = (v.x*M.a[0][1] + v.y*M.a[1][1] + v.z*M.a[2][1]);
    d.z  = (v.x*M.a[0][2] + v.y*M.a[1][2] + v.z*M.a[2][2]);
    p.x = M.a[3][0];
    p.y = M.a[3][1];
    p.z = M.a[3][2];
    
	pick=p+d;
#else
	float proj[16];
    
	glGetFloatv(GL_PROJECTION_MATRIX, proj);
    
	CMatrix M;
    
	M.Inverse4x4(VIEW);
    
    v.x =  ( ( ( 2.0f * x ) / SCREEN_X ) - 1 ) / proj[0+4*0];
    v.y =  -( ( ( 2.0f * y ) / SCREEN_Y ) - 1 ) / proj[1+4*1];
    v.z =  1.0f;
	
	d.x  = (v.x*M.a[0][0] + v.y*M.a[1][0] + v.z*M.a[2][0]);
    d.y  = (v.x*M.a[0][1] + v.y*M.a[1][1] + v.z*M.a[2][1]);
    d.z  = (v.x*M.a[0][2] + v.y*M.a[1][2] + v.z*M.a[2][2]);
    p.x = M.a[3][0];
    p.y = M.a[3][1];
    p.z = M.a[3][2];
    
	pick=p+d;
#endif
#endif

	return pick;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function:
		
		Get vector camera to screen point

		CVector C3DAPIBASE::PickVecteur(float x,float y,int SCX,int SCY)
 
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


CVector C3DAPIBASE::PickVecteur(float x,float y,int SCX,int SCY)
{
	CVector v,p,d,pick;

	pick.Init(0,0,0);

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#if defined(API3D_DIRECT3D12) || defined(API3D_DIRECT3D11) || defined(API3D_METAL)

	v.x =  ( ( ( 2.0f * (x+overscanX) ) / (SCX+2*overscanX) ) - 1 ) / projectionMatrix.a[0][0];
    v.y = -( ( ( 2.0f * y ) / SCY ) - 1 ) / projectionMatrix.a[1][1];
    v.z =  1.0f;

	CMatrix m;
	m.Inverse4x4(viewMatrix);

    d.x  = v.x*m.a[0][0] + v.y*m.a[1][0] + v.z*m.a[2][0];
    d.y  = v.x*m.a[0][1] + v.y*m.a[1][1] + v.z*m.a[2][1];
    d.z  = v.x*m.a[0][2] + v.y*m.a[1][2] + v.z*m.a[2][2];
    p.x = m.a[3][0];
    p.y = m.a[3][1];
    p.z = m.a[3][2];

	pick=p+d;

#else
	D3DXMATRIX matView, m,matProj;

#ifdef API3D_DIRECT3D10
	matProj=projectionMatrix;
	matView=viewMatrix;

    v.x =  ( ( ( 2.0f * (x+overscanX) ) / (SCX+2*overscanX) ) - 1 ) / matProj._11;
    v.y = -( ( ( 2.0f * (y) ) / SCY ) - 1 ) / matProj._22;
    v.z =  1.0f;

    D3DXMatrixInverse( &m, NULL, &matView );

    d.x  = v.x*m._11 + v.y*m._21 + v.z*m._31;
    d.y  = v.x*m._12 + v.y*m._22 + v.z*m._32;
    d.z  = v.x*m._13 + v.y*m._23 + v.z*m._33;
    p.x = m._41;
    p.y = m._42;
    p.z = m._43;

	pick=p+d;
#else

	D3DDevice->GetTransform( D3DTS_VIEW, &matView );
	D3DDevice->GetTransform( D3DTS_PROJECTION, &matProj );

    v.x =  ( ( ( 2.0f * (x+overscanX) ) / (SCX+2*overscanX) ) - 1 ) / matProj._11;
    v.y = -( ( ( 2.0f * y ) / SCY ) - 1 ) / matProj._22;
    v.z =  1.0f;

    D3DXMatrixInverse( &m, NULL, &matView );

    d.x  = v.x*m._11 + v.y*m._21 + v.z*m._31;
    d.y  = v.x*m._12 + v.y*m._22 + v.z*m._32;
    d.z  = v.x*m._13 + v.y*m._23 + v.z*m._33;
    p.x = m._41;
    p.y = m._42;
    p.z = m._43;

	pick=p+d;
#endif
#endif
#else
    
#ifdef API3D_OPENGL20
	CMatrix M;
	M.Inverse4x4(VIEW);
    
    v.x =  ( ( ( 2.0f * (x+overscanX) ) / (SCX+2*overscanX) ) - 1 ) / projection[0+4*0];
    v.y =  ( ( ( 2.0f * y ) / SCY ) - 1 ) / projection[1+4*1];
    v.z =  1.0f;
	
	d.x  = (v.x*M.a[0][0] + v.y*M.a[1][0] + v.z*M.a[2][0]);
    d.y  = (v.x*M.a[0][1] + v.y*M.a[1][1] + v.z*M.a[2][1]);
    d.z  = (v.x*M.a[0][2] + v.y*M.a[1][2] + v.z*M.a[2][2]);
    p.x = M.a[3][0];
    p.y = M.a[3][1];
    p.z = M.a[3][2];
    
	pick=p+d;
#else
	float proj[16];
    
	glGetFloatv(GL_PROJECTION_MATRIX, proj);
    
	CMatrix M;
    
	M.Inverse4x4(VIEW);
    
    v.x =  ( ( ( 2.0f * (x+overscanX) ) / (SCX+2*overscanX) ) - 1 ) / proj[0+4*0];
    v.y =  -( ( ( 2.0f * y ) / SCY ) - 1 ) / proj[1+4*1];
    v.z =  1.0f;
	
	d.x  = (v.x*M.a[0][0] + v.y*M.a[1][0] + v.z*M.a[2][0]);
    d.y  = (v.x*M.a[0][1] + v.y*M.a[1][1] + v.z*M.a[2][1]);
    d.z  = (v.x*M.a[0][2] + v.y*M.a[1][2] + v.z*M.a[2][2]);
    p.x = M.a[3][0];
    p.y = M.a[3][1];
    p.z = M.a[3][2];
    
	pick=p+d;
#endif

#endif

	return pick;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
extern int SIZE_LIGHTMAPS;
/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:


		Lightmaps : set : texture stage 0

		void C3DAPIBASE::SetLightmap(int n)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define NBRE_DE_LIGHTMAP_THAT_FIT	(TILE_LIGHTMAPS/SIZE_LIGHTMAPS)
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void C3DAPIBASE::SetLightmap(int n)
{
	int nl;

#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -------------
	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;
		
		if (Lightmap[nl])
		{
			lT=nl;
			ACTUAL_LIGHTMAP=n;
		}
	}
	
#endif

#if defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;
		
		if (Lightmap[nl])
		{
			lT=nl;
			ACTUAL_LIGHTMAP=n;
			Texture0=Lightmap[nl];
		}
	}
	
#endif

#ifdef API3D_DIRECT3D10
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;
		
		if (Lightmap[nl])
		{
			lT=nl;
			ACTUAL_LIGHTMAP=n;
			Texture0=Lightmap[nl];
		}
	}
	
#endif

#ifdef API3D_DIRECT3D
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;
		
		if (Lightmap[nl])
		{

			ACTUAL_LIGHTMAP=n;
			D3DDevice->SetTexture(0,Lightmap[nl]);
			
			D3DDevice->SetTextureStageState(0,D3DTSS_ADDRESSU,D3DTADDRESS_WRAP);
			D3DDevice->SetTextureStageState(0,D3DTSS_ADDRESSV,D3DTADDRESS_WRAP);
			D3DDevice->SetTextureStageState(0,D3DTSS_MIPFILTER,D3DTEXF_NONE);
		}
	}
	

#endif

#ifdef API3D_DIRECT3D9
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;
		
		if (Lightmap[nl])
		{

			ACTUAL_LIGHTMAP=n;
			D3DDevice->SetTexture(0,Lightmap[nl]);
			
			D3DDevice->SetSamplerState(0,D3DSAMP_ADDRESSU,D3DTADDRESS_WRAP);
			D3DDevice->SetSamplerState(0,D3DSAMP_ADDRESSV,D3DTADDRESS_WRAP);
			D3DDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
		}
	}
	

#endif

#ifdef API3D_OPENGL

//------------------------------------------------------------------------------------------------ OPEN GL -----------

	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;

		if (Lightmap[nl])
		{
			ACTUAL_LIGHTMAP=n;

			glActiveTextureARB(GL_TEXTURE0_ARB);
			glEnable(GL_TEXTURE_2D);
			
			glBindTexture(GL_TEXTURE_2D,Lightmap[nl]);
		}
	}
	//	glBindTexture(GL_TEXTURE_2D,Lightmap[n]);
#endif

#ifdef API3D_OPENGL20

//------------------------------------------------------------------------------------------------ OPEN GL -----------

	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;

		if (Lightmap[nl])
		{
			lT=nl;
			ACTUAL_LIGHTMAP=n;

			glActiveTextureARB(GL_TEXTURE0_ARB);
			glEnable(GL_TEXTURE_2D);
			
			glBindTexture(GL_TEXTURE_2D,Lightmap[nl]);
		}
	}
	//	glBindTexture(GL_TEXTURE_2D,Lightmap[n]);
#endif

}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:


		Lightmaps : set : texture stage 1

		void C3DAPIBASE::SetLightmap(int n)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetLightmap2(int n)
{
	int nl;

#ifdef API3D_METAL
//------------------------------------------------------------------------------------------------ METAL -------------
	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;
		
		if (Lightmap[nl])
		{
			ACTUAL_LIGHTMAP=n;
			lT2=nl;
		}
	}
	
#endif

#if defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;
		
		if (Lightmap[nl])
		{
			ACTUAL_LIGHTMAP=n;
			Texture1=Lightmap[nl];
			lT2=nl;
		}
	}
	
#endif

#ifdef API3D_DIRECT3D10
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;
		
		if (Lightmap[nl])
		{
			ACTUAL_LIGHTMAP=n;
			Texture1=Lightmap[nl];
			lT2=nl;
		}
	}
	
#endif

#ifdef API3D_DIRECT3D
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;
		
		if (Lightmap[nl])
		{

			ACTUAL_LIGHTMAP2=n;
			D3DDevice->SetTexture(1,Lightmap[nl]);
			
			D3DDevice->SetTextureStageState(0,D3DTSS_ADDRESSU,D3DTADDRESS_WRAP);
			D3DDevice->SetTextureStageState(0,D3DTSS_ADDRESSV,D3DTADDRESS_WRAP);
			D3DDevice->SetTextureStageState(0,D3DTSS_MIPFILTER,D3DTEXF_NONE);
		}
	}
	

#endif

#ifdef API3D_DIRECT3D9
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;
		
		if (Lightmap[nl])
		{

			ACTUAL_LIGHTMAP2=n;
			D3DDevice->SetTexture(1,Lightmap[nl]);
			
			D3DDevice->SetSamplerState(0,D3DSAMP_ADDRESSU,D3DTADDRESS_WRAP);
			D3DDevice->SetSamplerState(0,D3DSAMP_ADDRESSV,D3DTADDRESS_WRAP);
			D3DDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
		}
	}
	

#endif


#ifdef API3D_OPENGL

//------------------------------------------------------------------------------------------------ OPEN GL -----------

	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;

		if (Lightmap[nl])
		{
			ACTUAL_LIGHTMAP2=n;

			glActiveTextureARB(GL_TEXTURE1_ARB);
			glEnable(GL_TEXTURE_2D);
			
			glBindTexture(GL_TEXTURE_2D,Lightmap[nl]);
		}
	}
	//	glBindTexture(GL_TEXTURE_2D,Lightmap[n]);
#endif

#ifdef API3D_OPENGL20
//------------------------------------------------------------------------------------------------ OPEN GL -----------

	if ((*Lightmaps)[n])
	{
		nl=(*Lightmaps)[n]->nt;

		if (Lightmap[nl])
		{
			lT2=nl;
			ACTUAL_LIGHTMAP2=n;

			glActiveTextureARB(GL_TEXTURE1_ARB);
			glEnable(GL_TEXTURE_2D);
			
			glBindTexture(GL_TEXTURE_2D,Lightmap[nl]);
		}
	}
	//	glBindTexture(GL_TEXTURE_2D,Lightmap[n]);
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:


	Lightmaps : create (reserved)

	Lightmaps have their own allocation through SetLightmapSize(int size_in_pixel)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::CreateTextureLightmap(int n)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	char * ptrtex;
	int Tile=TILE_LIGHTMAPS;
	int p;

	ptrtex=(char*) malloc(Tile*Tile*4);
	for (p=0;p<Tile*Tile*4;p++) ptrtex[p]=0;
	LightmapContainer->create(n,Tile,Tile,ptrtex,Tile,Tile,0);
	free(ptrtex);

#else
#ifdef API3D_OPENGL
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	char * ptrtex;
	int Tile=TILE_LIGHTMAPS;
	int p;

	ptrtex=(char*) malloc(Tile*Tile*3);

	for (p=0;p<Tile*Tile*3;p++) ptrtex[p]=0;
	

	glEnable(GL_TEXTURE_2D);
	glGenTextures(1,(GLuint*) &Lightmap[n]);			
	glBindTexture(GL_TEXTURE_2D,Lightmap[n]);
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_CLAMP);
	glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_CLAMP);
	glTexImage2D(GL_TEXTURE_2D,0,GL_RGB,Tile,Tile,0,GL_RGB,GL_UNSIGNED_BYTE,ptrtex);

	free(ptrtex);

#endif
#ifdef API3D_DIRECT3D

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	int nn;
	D3DFORMAT Formats[3]={
					    D3DFMT_R5G6B5,      
						D3DFMT_X1R5G5B5,    
						D3DFMT_A4R4G4B4
						};

	nn=0;
	while ((nn<3)&&(FAILED(D3DDevice->CreateTexture(TILE_LIGHTMAPS,TILE_LIGHTMAPS,0,0,Formats[nn],D3DPOOL_MANAGED,&Lightmap[n])))) nn++;

	iLightmap[n].Format=nn;

	char* ptr=(char*) malloc(TILE_LIGHTMAPS*TILE_LIGHTMAPS*3);
	memset(ptr,0,TILE_LIGHTMAPS*TILE_LIGHTMAPS*3);
	LightmapContainer->modifyRGB(n,0,0,TILE_LIGHTMAPS,TILE_LIGHTMAPS,ptr);
	free(ptr);
#endif

#ifdef API3D_DIRECT3D9

//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	int nn;
	D3DFORMAT Formats[3]={
					    D3DFMT_R5G6B5,      
						D3DFMT_X1R5G5B5,    
						D3DFMT_A4R4G4B4
						};

	nn=0;
	while ((nn<3)&&(FAILED(D3DDevice->CreateTexture(TILE_LIGHTMAPS,TILE_LIGHTMAPS,0,0,Formats[nn],D3DPOOL_MANAGED,&Lightmap[n],NULL)))) nn++;

	iLightmap[n].Format=nn;

	char* ptr=(char*) malloc(TILE_LIGHTMAPS*TILE_LIGHTMAPS*3);
	memset(ptr,0,TILE_LIGHTMAPS*TILE_LIGHTMAPS*3);
	LightmapContainer->modifyRGB(n,0,0,TILE_LIGHTMAPS,TILE_LIGHTMAPS,ptr);
	free(ptr);

#endif

#endif

#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_

	int dim=(4*TILE_LIGHTMAPS)/SIZE_LIGHTMAPS;
	grids[n]=(unsigned char*) malloc(dim*dim);
	memset(grids[n],0,dim*dim);

#endif
}


void C3DAPIBASE::CreateTextureLightmapCache(int n,float r,float g,float b)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	char * ptrtex;
	int Tile=16;

	ptrtex=(char*) malloc(Tile*Tile*4);
	for (int x=0;x<Tile;x++)
		for (int y=0;y<Tile;y++)
		{
			ptrtex[4*(x+y*Tile)+0]=(int) (255*r);
			ptrtex[4*(x+y*Tile)+1]=(int) (255*g);
			ptrtex[4*(x+y*Tile)+2]=(int) (255*b);
			ptrtex[4*(x+y*Tile)+3]=(char) 255;
		}
	LightmapContainer->create(n,Tile,Tile,ptrtex,Tile,Tile,0);
	free(ptrtex);
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:


		Lightmaps : basic grid functions

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_
void setLMG(unsigned char *grid,int x,int y,int sx,int sy)
{
	int dim=(4*TILE_LIGHTMAPS)/SIZE_LIGHTMAPS;
	int adr=x+y*dim;

	switch (sx)
	{
	case 1:
		grid[adr]=1;
		break;
	case 2:
		*(unsigned short int *)(&grid[adr])=0x0101;
		*(unsigned short int *)(&grid[adr+dim])=0x0101;
		break;
	case 4:
		*(unsigned int *)(&grid[adr])=0x01010101;
		*(unsigned int *)(&grid[adr+dim])=0x01010101;
		*(unsigned int *)(&grid[adr+(dim<<1)])=0x01010101;
		*(unsigned int *)(&grid[adr+dim+(dim<<1)])=0x01010101;
		break;
	}
}

void clearLMG(unsigned char *grid,int x,int y,int sx,int sy)
{
	int dim=(4*TILE_LIGHTMAPS)/SIZE_LIGHTMAPS;
	int adr=x+y*dim;

	switch (sx)
	{
	case 1:
		grid[adr]=0;
		break;
	case 2:
		*(unsigned short int *)(&grid[adr])=0;
		*(unsigned short int *)(&grid[adr+dim])=0;
		break;
	case 4:
		*(unsigned int *)(&grid[adr])=0;
		*(unsigned int *)(&grid[adr+dim])=0;
		*(unsigned int *)(&grid[adr+(dim<<1)])=0;
		*(unsigned int *)(&grid[adr+dim+(dim<<1)])=0;
		break;

	}

}

unsigned int seekLMG(unsigned char *grid,int sx,int sy)
{
	unsigned int pos;
	int x,y;
	int dim=(4*TILE_LIGHTMAPS)/SIZE_LIGHTMAPS;
	int add=sy*dim;

	pos=0;
	y=0;
	while (y<dim)
	{
		x=0;
		while (x<dim)
		{
			if (grid[pos+x]==0) return (x+(y<<16));
			x+=sx;
		}
		y+=sy;
		pos+=add;
	}
	return 0xFFFFFFFF;
}

#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:


		Lightmaps : create new

		Lightmaps are allocated in big textures as a portion of them

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

int C3DAPIBASE::CreateNewLightmap()
{
//------------------------------------------------------------------------------------------------ DIRECT3D/OPEN GL --
	int nt,x,y;
	CLightmap L;

#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_
	unsigned int adr;

	int nbl=states(LIGHTMAP_LAYERS);

	if (nbl==1)
	{
		nt=0;
		while (grids[nt+1]) nt++;

#ifdef _DEFINES_API_CODE_NO_LIGHTMAP_LEAKS_
		if (nt>0)
		{
			adr=seekLMG(grids[nt-1],4,4);
			if (adr!=0xFFFFFFFF) nt--;
		}
		else adr=0xFFFFFFFF;
		
		if (adr==0xFFFFFFFF)
		{
#endif		
			adr=seekLMG(grids[nt],4,4);
			if (adr==0xFFFFFFFF)
			{
				nt++;
				CreateTextureLightmap(nt);
				adr=seekLMG(grids[nt],4,4);
			}
#ifdef _DEFINES_API_CODE_NO_LIGHTMAP_LEAKS_
		}
#endif
	}
	else
	{
		nt=lm_layers_nt[lm_layers_count];

#ifdef _DEFINES_API_CODE_NO_LIGHTMAP_LEAKS_
		if (nt>nbl)
		{
			adr=seekLMG(grids[nt-nbl],4,4);
			if (adr!=0xFFFFFFFF) nt-=nbl;
		}
		else adr=0xFFFFFFFF;
		
		if (adr==0xFFFFFFFF)
		{
#endif		
			adr=seekLMG(grids[nt],4,4);
			if (adr==0xFFFFFFFF)
			{
				nt+=nbl;
				lm_layers_nt[lm_layers_count]=nt;
				CreateTextureLightmap(nt);
				adr=seekLMG(grids[nt],4,4);
			}
#ifdef _DEFINES_API_CODE_NO_LIGHTMAP_LEAKS_
		}
#endif
	}

	lm_layers_count=(lm_layers_count+1)%nbl;

	x=adr&0xFFFF;
	y=(adr>>16)&0xFFFF;

	L.nt=nt;
	L.x=x/4;
	L.y=y/4;
	L.offx=0;
	L.offy=0;
	L.sizx=4;
	L.sizy=4;

	setLMG(grids[nt],x,y,4,4);

	Lightmaps->Add(L);
	return (Lightmaps->Length()-1);

#else
	x=Lightmaps->Last()->x;
	y=Lightmaps->Last()->y;
	nt=Lightmaps->Last()->nt;
	x++;
	if (x==NBRE_DE_LIGHTMAP_THAT_FIT)
	{
		x=0;
		y++;
		if (y==NBRE_DE_LIGHTMAP_THAT_FIT)
		{
			y=0;
			nt++;
			CreateTextureLightmap(nt);
		}
	}
	L.nt=nt;
	L.x=x;
	L.y=y;

	Lightmaps->Add(L);
	return (Lightmaps->Length()-1);
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:


		Lightmaps : create new

		Lightmaps are allocated in big textures as a portion of them

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

int C3DAPIBASE::CreateNewLightmap(int size)
{
//------------------------------------------------------------------------------------------------ DIRECT3D/OPEN GL --
	int nt,x,y;
	CLightmap L;
	
#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_
	unsigned int adr;

	int nbl=states(LIGHTMAP_LAYERS);

	if (nbl==1)
	{
		nt=0;
		while (grids[nt+1]) nt++;
#ifdef _DEFINES_API_CODE_NO_LIGHTMAP_LEAKS_
		if (nt>0)
		{
			adr=seekLMG(grids[nt-1],tag_grids[nt-1],size,size);
			if (adr!=0xFFFFFFFF) nt--;
		}
		else adr=0xFFFFFFFF;
		
		if (adr==0xFFFFFFFF)
		{
#endif
			adr=seekLMG(grids[nt],size,size);
			if (adr==0xFFFFFFFF)
			{
				nt++;
				CreateTextureLightmap(nt);
				adr=seekLMG(grids[nt],size,size);
			}
#ifdef _DEFINES_API_CODE_NO_LIGHTMAP_LEAKS_
		}
#endif
	}
	else
	{
		nt=lm_layers_nt[lm_layers_count];
#ifdef _DEFINES_API_CODE_NO_LIGHTMAP_LEAKS_
		if (nt>nbl)
		{
			adr=seekLMG(grids[nt-nbl],4,4);
			if (adr!=0xFFFFFFFF) nt-=nbl;
		}
		else adr=0xFFFFFFFF;

		if (adr==0xFFFFFFFF)
		{
#endif
			adr=seekLMG(grids[nt],size,size);
			if (adr==0xFFFFFFFF)
			{
				nt+=nbl;
				lm_layers_nt[lm_layers_count]=nt;
				CreateTextureLightmap(nt);
				adr=seekLMG(grids[nt],size,size);
			}
#ifdef _DEFINES_API_CODE_NO_LIGHTMAP_LEAKS_
		}
#endif
	}

	lm_layers_count=(lm_layers_count+1)%nbl;

	x=adr&0xFFFF;
	y=(adr>>16)&0xFFFF;

	setLMG(grids[nt],x,y,size,size);

	L.nt=nt;
	L.x=x/4;
	L.y=y/4;
	L.offx=x%4;
	L.offy=y%4;
	L.sizx=size;
	L.sizy=size;

	Lightmaps->Add(L);
	return (Lightmaps->Length()-1);

#else
	x=Lightmaps->Last()->x;
	y=Lightmaps->Last()->y;
	nt=Lightmaps->Last()->nt;
	x++;
	if (x==NBRE_DE_LIGHTMAP_THAT_FIT)
	{
		x=0;
		y++;
		if (y==NBRE_DE_LIGHTMAP_THAT_FIT)
		{
			y=0;
			nt++;
			CreateTextureLightmap(nt);
		}
	}
	L.nt=nt;
	L.x=x;
	L.y=y;

	Lightmaps->Add(L);
	return (Lightmaps->Length()-1);
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	
	 Lightmaps : release

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::ReleaseLightmaps()
{
	int n,nt;
	CLightmap *lm;

	nt=0;
	lm=Lightmaps->GetFirst();
	while (lm)
	{
		if (lm->nt>nt) nt=lm->nt;
		if (lm->pColors) free(lm->pColors);
		if (lm->pVectors) free(lm->pVectors);
		lm=Lightmaps->GetNext();
	}
	Lightmaps->Free();

#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_

	LightmapContainer->clean();

#else

#ifdef API3D_OPENGL
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	for (n=0;n<nt;n++)
		glDeleteTextures(1,(GLuint*) &Lightmap[n]);

#endif
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
	for (n=0;n<nt;n++) Lightmap[n]->Release();
#endif
#endif

#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_
	for (n=0;n<NBRE_MAX_TEXTURES;n++)
	{
		if (grids[n]) 
		{
			free(grids[n]);
			grids[n]=NULL;
		}
	}
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Lightmaps : init

		to be called before all other call to lightmap functions

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::BeginLightmaps()
{
	int n;
	CLightmap L;

	L.x=0;
	L.y=0;
	L.offx=0;
	L.offy=0;
	L.sizx=4;
	L.sizy=4;
	L.nt=0;

#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_
	for (n=0;n<NBRE_MAX_TEXTURES;n++)
	{
		if (grids[n]) 
		{
			free(grids[n]);
			grids[n]=NULL;
		}
	}

	int nbl=states(LIGHTMAP_LAYERS);

	for (n=0;n<nbl;n++)
	{		
		lm_layers_nt[n]=n;
		CreateTextureLightmap(n);
	}

	setLMG(grids[0],0,0,4,4);
	Lightmaps->Add(L);

	lm_layers_count=1%nbl;
#else
	CreateTextureLightmap(0);
	Lightmaps->Add(L);
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Lightmaps : init

		to be called before all other call to lightmap functions

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::BeginLightmapsCache(float r,float g,float b)
{
	int n;
	CLightmap L;

	L.x=0;
	L.y=0;
	L.offx=0;
	L.offy=0;
	L.sizx=4;
	L.sizy=4;
	L.nt=1;

#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_
	for (n=0;n<NBRE_MAX_TEXTURES;n++)
	{
		if (grids[n]) 
		{
			free(grids[n]);
			grids[n]=NULL;
		}
	}

	int nbl=states(LIGHTMAP_LAYERS);

	CreateTextureLightmapCache(0,r,g,b);

	for (n=0;n<nbl;n++)
	{		
		lm_layers_nt[n]=1+n;
		CreateTextureLightmap(1+n);
	}

	setLMG(grids[1],0,0,4,4);
	Lightmaps->Add(L);
	lm_layers_count=1%nbl;
#else
	CreateTextureLightmap(0);
	Lightmaps->Add(L);
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		Lightmaps : init

		to be called before all other call to lightmap functions

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::BeginLightmapsCache3(float r,float g,float b,
									  float r1,float g1,float b1,
									  float r2,float g2,float b2)
{
	int n;
	CLightmap L;	

#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_
	for (n=0;n<NBRE_MAX_TEXTURES;n++)
	{
		if (grids[n]) 
		{
			free(grids[n]);
			grids[n]=NULL;
		}
	}

	int nbl=states(LIGHTMAP_LAYERS);

	CreateTextureLightmapCache(0,r,g,b);	
	CreateTextureLightmapCache(1,r1,g1,b1);
	CreateTextureLightmapCache(2,1,1,1);
	CreateTextureLightmapCache(3,r2,g2,b2);
	CreateTextureLightmapCache(4,1,1,1);
	CreateTextureLightmapCache(5,1,1,1);
	CreateTextureLightmapCache(6,1,1,1);
	CreateTextureLightmapCache(7,1,1,1);

	lm_layers_count=0;

	for (n=0;n<nbl;n++)
	{		
		lm_layers_nt[n]=8+n;
		CreateTextureLightmap(8+n);
	}

	L.x=0;
	L.y=0;
	L.offx=0;
	L.offy=0;
	L.sizx=4;
	L.sizy=4;
	L.nt=8;
	setLMG(grids[8],0,0,4,4);
	Lightmaps->Add(L);

	lm_layers_count=1%nbl;
#else
	CreateTextureLightmap(0);
	Lightmaps->Add(L);
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		
		void C3DAPIBASE::ReleaseLightmapBackup()

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::ReleaseLightmapBackups()
{
	CLightmap *LM=Lightmaps->GetFirst();
	while (LM)
	{
		if (LM->pColors) free(LM->pColors);
		LM->pColors=NULL;
		if (LM->pVectors) free(LM->pVectors);
		LM->pVectors=NULL;
		LM=Lightmaps->GetNext();
	}
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:
		
		Lightmaps : patch

		set lightmap data to ptr[size_lightmap*size_lightmap]

		size_lightmap fixed with SetLightmapSize()
		default : 16x16

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::PatchLightmap(int nl,char * ptr)
{
	CLightmap *LM=(*Lightmaps)[nl];

#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_
	int sizex=(LM->sizx*SIZE_LIGHTMAPS)/4;
	int sizey=(LM->sizy*SIZE_LIGHTMAPS)/4;
#else
	int sizex=SIZE_LIGHTMAPS;
	int sizey=SIZE_LIGHTMAPS;
#endif

	if (states(LIGHTMAP_BACKUPS))
	{
		if (LM->pColors==NULL) LM->pColors=(char*) malloc(sizex*sizey*4);
		memcpy(LM->pColors,ptr,sizex*sizey*4);
	}

#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_

	int n;
	int x,y;
	int n1,n2;
	char * ptrrgb=(char*) malloc(sizex*sizey*3);

	n=LM->nt;
#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_
	x=LM->x*SIZE_LIGHTMAPS + LM->offx*SIZE_LIGHTMAPS/4;
	y=LM->y*SIZE_LIGHTMAPS + LM->offy*SIZE_LIGHTMAPS/4;
#else
	x=LM->x*SIZE_LIGHTMAPS;
	y=LM->y*SIZE_LIGHTMAPS;
#endif
	
	int adr3=0;
	int adr4=0;
	
	for (n2=0;n2<sizey;n2++)
		for (n1=0;n1<sizex;n1++)
		{
			ptrrgb[adr3+0]=ptr[adr4+0];
			ptrrgb[adr3+1]=ptr[adr4+1];
			ptrrgb[adr3+2]=ptr[adr4+2];
			adr3+=3;
			adr4+=4;
		}

	LightmapContainer->modifyRGB(n,x,y,sizex,sizey,ptrrgb);

	free(ptrrgb);

#else

#ifdef API3D_OPENGL
//------------------------------------------------------------------------------------------------ OPEN GL -----------
	int n,nn;
	int x,y;
	int n1,n2;
	char * ptrrgb=(char*) malloc(sizex*sizey*3);

	n=LM->nt;
#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_
	x=LM->x*SIZE_LIGHTMAPS + LM->offx*SIZE_LIGHTMAPS/4;
	y=LM->y*SIZE_LIGHTMAPS + LM->offy*SIZE_LIGHTMAPS/4;
#else
	x=LM->x*SIZE_LIGHTMAPS;
	y=LM->y*SIZE_LIGHTMAPS;
#endif

	for (n1=0;n1<sizex;n1++)
		for (n2=0;n2<sizey;n2++)
		{
			nn=n1+n2*sizex;
			ptrrgb[3*nn+0]=ptr[4*nn + 0];
			ptrrgb[3*nn+1]=ptr[4*nn + 1];
			ptrrgb[3*nn+2]=ptr[4*nn + 2];
		}

	glBindTexture(GL_TEXTURE_2D,Lightmap[n]);
	glPixelStorei(GL_UNPACK_ALIGNMENT,1);
	glTexSubImage2D(GL_TEXTURE_2D,0,x,y,sizex,sizey,GL_RGB,GL_UNSIGNED_BYTE,ptrrgb);

	free(ptrrgb);
#endif
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)

//------------------------------------------------------------------------------------------------ DIRECT3D ----------

	int r,g,b,a;
	int n1,n2;
	unsigned int adr,adr0,pitch;
	WORD * ptrdest;
	D3DLOCKED_RECT Locked;
	RECT DirtyRect;
	int n;
	int x,y;


	n=(*Lightmaps)[nl]->nt;
#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_
	x=(*Lightmaps)[nl]->x*SIZE_LIGHTMAPS + (*Lightmaps)[nl]->offx*SIZE_LIGHTMAPS/4;
	y=(*Lightmaps)[nl]->y*SIZE_LIGHTMAPS + (*Lightmaps)[nl]->offy*SIZE_LIGHTMAPS/4;
#else
	x=(*Lightmaps)[nl]->x*SIZE_LIGHTMAPS;
	y=(*Lightmaps)[nl]->y*SIZE_LIGHTMAPS;
#endif

	DirtyRect.top=y;
	DirtyRect.left=x;
	DirtyRect.right=x+sizex;
	DirtyRect.bottom=y+sizey;

	if (iLightmap[n].Format==0) // 565
	{

		Lightmap[n]->LockRect(0,&Locked,&DirtyRect,0);	// level 0

		ptrdest=(WORD *) Locked.pBits;

		pitch=Locked.Pitch/2;

		for (n2=0;n2<sizey;n2++)
		{
			adr0=4*(n2*sizex);
			adr=(n2)*pitch;
			for (n1=0;n1<sizex;n1++)
			{
				r=ptr[adr0+0]&255;
				g=ptr[adr0+1]&255;
				b=ptr[adr0+2]&255;

				ptrdest[adr]=((r>>3)<<11) +((g>>2)<<5) + (b>>3);
				adr0+=4;
				adr++;
			}
		}
		Lightmap[n]->UnlockRect(0);
	}


	if (iLightmap[n].Format==1) // 1555
	{
		Lightmap[n]->LockRect(0,&Locked,&DirtyRect,0);	// level 0
		ptrdest=(WORD *) Locked.pBits;

		pitch=Locked.Pitch/2;

		for (n2=0;n2<sizey;n2++)
		{
			adr0=4*(n2*sizex);
			adr=(n2)*pitch;
			for (n1=0;n1<sizex;n1++)
			{
				r=ptr[adr0+0]&255;
				g=ptr[adr0+1]&255;
				b=ptr[adr0+2]&255;

				ptrdest[adr]=((r>>3)<<10) +((g>>3)<<5) + (b>>3);
				adr0+=4;
				adr++;
			}
		}
		Lightmap[n]->UnlockRect(0);
	}

	if (iLightmap[n].Format==2) // 4444
	{
		Lightmap[n]->LockRect(0,&Locked,&DirtyRect,0);	// level 0
		ptrdest=(WORD *) Locked.pBits;

		pitch=Locked.Pitch/2;

		for (n2=0;n2<sizey;n2++)
		{
			adr0=4*(n2*sizex);
			adr=(n2)*pitch;
			for (n1=0;n1<sizex;n1++)
			{
				r=ptr[adr0+0]&255;
				g=ptr[adr0+1]&255;
				b=ptr[adr0+2]&255;
				a=ptr[adr0+3]&255;
				

				ptrdest[adr]=((a>>4)<<12) + ((r>>4)<<8) +((g>>4)<<4) + (b>>4);
				adr0+=4;
				adr++;
			}
		}
		Lightmap[n]->UnlockRect(0);
	}

#endif
#endif
}



void C3DAPIBASE::PatchLightmapRGB(int nl,char * ptr)
{
	int n;
	int x,y;
	CLightmap *LM=(*Lightmaps)[nl];

#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_
	int sizex=(LM->sizx*SIZE_LIGHTMAPS)/4;
	int sizey=(LM->sizy*SIZE_LIGHTMAPS)/4;
#else
	int sizex=SIZE_LIGHTMAPS;
	int sizey=SIZE_LIGHTMAPS;
#endif

	if (states(LIGHTMAP_BACKUPS))
	{
		if (LM->pColors==NULL) LM->pColors=(char*) malloc(sizex*sizey*4);
		char * ppp=LM->pColors;
		int adr4=0;
		int adr3=0;
		int len=sizex*sizey;
		for (int nk=0;nk<len;nk++) 
		{
			*((unsigned short int *) &ppp[adr4])=*((unsigned short int *) &ptr[adr3]);
			*((unsigned char *) &ppp[adr4+2])=*((unsigned char *) &ptr[adr3+2]);
			adr4+=4;
			adr3+=3;
		}
	}

	n=LM->nt;

#ifdef _DEFINES_API_CODE_MULTIPLE_SIZE_LIGHTMAP_
	x=LM->x*SIZE_LIGHTMAPS + LM->offx*SIZE_LIGHTMAPS/4;
	y=LM->y*SIZE_LIGHTMAPS + LM->offy*SIZE_LIGHTMAPS/4;
#else
	x=LM->x*SIZE_LIGHTMAPS;
	y=LM->y*SIZE_LIGHTMAPS;
#endif
	
	LightmapContainer->modifyRGB(n,x,y,sizex,sizey,ptr);
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	function:


		Vertex Buffer : Create from a CObject3D

		filter on:
			Faces[].tag :  mapping smoothing groups	/ 8 levels
			Faces[].ref : transparency (0:none , 1: normal alpha blending, 2: blend_gouraud (add))
			Faces[].nL :  if API3D_TEXCOO2LIGHTMAP specified
			Faces[].nT :  if API3D_TEXCOODATAS specified
			Faces[].nT2 :  if API3D_TEXCOO2DATAS specified
			Faces[].nLV :  if API3D_TEXCOO3BUMP specified


		+API3D_VERTEXDATAS			get .Stok 
		+
			API3D_COLORDATAS
			API3D_COLORDATAS4
		or
			API3D_NORMALDATAS
		+API3D_TEXCOODATAS
		+	
			API3D_TEXCOODATAS2
		or 
			API3D_TEXCOO2LIGHTMAP

		+API3D_TEXCOO3BUMP	(reserved)

		+API3D_TEXPERVERTEX
		+API3D_VERTEXCALC			get .Calc 
		
		+API3D_ENVMAPPING			set environment mapping shader to render
		+API3D_EDGESDG				(reserved)
		+API3D_ENABLEUPDATE			generate index list to enable modification

		+API3D_VERTEXPROGRAM		specifies th vertex buffer TnL (reserved)
		+API3D_BLENDING				enable 5x4 weighting values

	  
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

class TmpFaces
{
public:
	int * array[8];
	int narray[8];

	TmpFaces() 
	{ 
		int n;
		for (n=0;n<8;n++) array[n]=NULL;
		for (n=0;n<8;n++) narray[n]=0; 
	}
};

int GetListIndexGroupStrip(CObject3D *obj,int *list,int nf)
{
    int nb=0;
    int a,b;
    int n=nf;
    if (obj->Faces[n].tag==0)
    {
        list[0]=obj->Faces[n].v0;
        a=list[1]=obj->Faces[n].v1;
        b=list[2]=obj->Faces[n].v2;
        nb=3;
        
        int tag=0;
        int next=obj->Faces[n].f12;
        
        while (n>=0)
        {
            obj->Faces[n].tag=1;
            if (next>=0)
            {
                if (obj->Faces[next].tag==0)
                {
                    int ii=-1;
                    
                    n=next;
                    
                    if (tag==0)
                    {
                        if ((obj->Faces[n].v0==b)&&(obj->Faces[n].v1==a)) { ii=obj->Faces[n].v2; next=obj->Faces[n].f12; }
                        if ((obj->Faces[n].v1==b)&&(obj->Faces[n].v2==a)) { ii=obj->Faces[n].v0; next=obj->Faces[n].f20; }
                        if ((obj->Faces[n].v2==b)&&(obj->Faces[n].v0==a)) { ii=obj->Faces[n].v1; next=obj->Faces[n].f01; }
                    }
                    else
                    {
                        if ((obj->Faces[n].v0==a)&&(obj->Faces[n].v1==b)) { ii=obj->Faces[n].v2; next=obj->Faces[n].f12; }
                        if ((obj->Faces[n].v1==a)&&(obj->Faces[n].v2==b)) { ii=obj->Faces[n].v0; next=obj->Faces[n].f20; }
                        if ((obj->Faces[n].v2==a)&&(obj->Faces[n].v0==b)) { ii=obj->Faces[n].v1; next=obj->Faces[n].f01; }
                    }

                    if (ii>=0)
                    {
                        list[nb++]=ii;
                        
                        a=b;
                        b=ii;
                        
                        tag=(tag+1)&1;
                    }
                    else n=-1;
                }
                else n=-1;
            }
            else n=-1;
        }
    }
    
    return nb;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CVertexBuffer* C3DAPIBASE::CreatePointCloudVertexBuffer(CObject3D * obj,unsigned int typ)
{
	if (obj->nVertices>0)
	{
		int n;
		CVertexBuffer * vb=new CVertexBuffer;

		vb->SetAPI(this);
		vb->SetType(API3D_VERTEXDATAS|API3D_COLORDATAS4|API3D_TEXCOODATAS|API3D_TEXPERVERTEX|API3D_CONSTANT);
		vb->Init(obj->nVertices*3,obj->nVertices*3);
		vb->Grouped=false;

		vb->LockIndices();
		vb->LockVertices();
		int adr=0;

        float a=6.0f/sqrtf(3);
        float h=a*sqrtf(3.0f)/2.0f;

		CVector2 mp0(0,-2*h/3);
		CVector2 mp1(a/2,h/3);
		CVector2 mp2(-a/2,h/3);

		mp0.x=0.5f+0.5f*mp0.x;
		mp0.y=0.5f+0.5f*mp0.y;

		mp1.x=0.5f+0.5f*mp1.x;
		mp1.y=0.5f+0.5f*mp1.y;

		mp2.x=0.5f+0.5f*mp2.x;
		mp2.y=0.5f+0.5f*mp2.y;

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL) 	//////////////////////// DIRECT 3D

		DWORD size=vb->_sizeVB/4;

		float * xyzcoloruv=(float*)vb->pVertices;
		int * indices=(int*)vb->pIndices;

		for (n=0;n<obj->nVertices;n++)
		{
			DWORD color=D3DCOLOR_COLORVALUE(obj->Vertices[n].Diffuse.r,obj->Vertices[n].Diffuse.g,obj->Vertices[n].Diffuse.b,1);

			xyzcoloruv[0]=obj->Vertices[n].Stok.x;
			xyzcoloruv[1]=obj->Vertices[n].Stok.y;
			xyzcoloruv[2]=obj->Vertices[n].Stok.z;
			((DWORD*)xyzcoloruv)[3]=color;
			xyzcoloruv[4]=mp0.x;
			xyzcoloruv[5]=mp0.y;
			xyzcoloruv+=size;

			xyzcoloruv[0]=obj->Vertices[n].Stok.x;
			xyzcoloruv[1]=obj->Vertices[n].Stok.y;
			xyzcoloruv[2]=obj->Vertices[n].Stok.z;
			((DWORD*)xyzcoloruv)[3]=color;
			xyzcoloruv[4]=mp1.x;
			xyzcoloruv[5]=mp1.y;
			xyzcoloruv+=size;

			xyzcoloruv[0]=obj->Vertices[n].Stok.x;
			xyzcoloruv[1]=obj->Vertices[n].Stok.y;
			xyzcoloruv[2]=obj->Vertices[n].Stok.z;
			((DWORD*)xyzcoloruv)[3]=color;
			xyzcoloruv[4]=mp2.x;
			xyzcoloruv[5]=mp2.y;
			xyzcoloruv+=size;

			indices[0]=adr;
			indices[1]=adr+2;
			indices[2]=adr+1;
			indices+=3;
			adr+=3;
		}

#else

#if defined(API3D_METAL)	//////////////////////////////////////////////////////////////////////////////// METAL

		float *xyz=vb->Vertex_Array;
		float *uv=vb->TexCoo_Array;
		float *col=vb->Color_Array;
		unsigned int * inds=vb->Index_Array;

		for (n=0;n<obj->nVertices;n++)
		{
			xyz[0]=obj->Vertices[n].Stok.x;
			xyz[1]=obj->Vertices[n].Stok.y;
			xyz[2]=obj->Vertices[n].Stok.z;
			col[0]=obj->Vertices[n].Diffuse.r;
			col[1]=obj->Vertices[n].Diffuse.g;
			col[2]=obj->Vertices[n].Diffuse.b;
			col[3]=obj->Vertices[n].Diffuse.a;		
			uv[0]=mp0.x;
			uv[1]=mp0.y;
			xyz+=3; uv+=2; col+=4;
	
			xyz[0]=obj->Vertices[n].Stok.x;
			xyz[1]=obj->Vertices[n].Stok.y;
			xyz[2]=obj->Vertices[n].Stok.z;
			col[0]=obj->Vertices[n].Diffuse.r;
			col[1]=obj->Vertices[n].Diffuse.g;
			col[2]=obj->Vertices[n].Diffuse.b;
			col[3]=obj->Vertices[n].Diffuse.a;
			uv[0]=mp1.x;
			uv[1]=mp1.y;
			xyz+=3; uv+=2; col+=4;

			xyz[0]=obj->Vertices[n].Stok.x;
			xyz[1]=obj->Vertices[n].Stok.y;
			xyz[2]=obj->Vertices[n].Stok.z;
			col[0]=obj->Vertices[n].Diffuse.r;
			col[1]=obj->Vertices[n].Diffuse.g;
			col[2]=obj->Vertices[n].Diffuse.b;
			col[3]=obj->Vertices[n].Diffuse.a;	
			uv[0]=mp2.x;
			uv[1]=mp2.y;
			xyz+=3; uv+=2; col+=4;

			inds[0]=adr;
			inds[1]=adr+2;
			inds[2]=adr+1;
			inds+=3;
			adr+=3;
		}

#else	////////////////////////////////////////////////////////////////////////////////////////////////////// OPEN GL
#ifndef SHORTY
		if (LIB3D_TYPE_INDEX==GL_UNSIGNED_INT)
		{
			float *xyz=vb->BVertex_Array;
			float *uv=vb->BTexCoo_Array;
			float *col=vb->BColor_Array;
			unsigned int * inds=vb->BIndex_Array;

			for (n=0;n<obj->nVertices;n++)
			{
				xyz[0]=obj->Vertices[n].Stok.x;
				xyz[1]=obj->Vertices[n].Stok.y;
				xyz[2]=obj->Vertices[n].Stok.z;
				col[0]=obj->Vertices[n].Diffuse.r;
				col[1]=obj->Vertices[n].Diffuse.g;
				col[2]=obj->Vertices[n].Diffuse.b;
				col[3]=obj->Vertices[n].Diffuse.a;		
				uv[0]=mp0.x;
				uv[1]=mp0.x;
				xyz+=3; uv+=2; col+=4;
	
				xyz[0]=obj->Vertices[n].Stok.x;
				xyz[1]=obj->Vertices[n].Stok.y;
				xyz[2]=obj->Vertices[n].Stok.z;
				col[0]=obj->Vertices[n].Diffuse.r;
				col[1]=obj->Vertices[n].Diffuse.g;
				col[2]=obj->Vertices[n].Diffuse.b;
				col[3]=obj->Vertices[n].Diffuse.a;
				uv[0]=mp1.x;
				uv[1]=mp1.y;
				xyz+=3; uv+=2; col+=4;

				xyz[0]=obj->Vertices[n].Stok.x;
				xyz[1]=obj->Vertices[n].Stok.y;
				xyz[2]=obj->Vertices[n].Stok.z;
				col[0]=obj->Vertices[n].Diffuse.r;
				col[1]=obj->Vertices[n].Diffuse.g;
				col[2]=obj->Vertices[n].Diffuse.b;
				col[3]=obj->Vertices[n].Diffuse.a;	
				uv[0]=mp2.x;
				uv[1]=mp2.y;
				xyz+=3; uv+=2; col+=4;

				inds[0]=adr;
				inds[1]=adr+2;
				inds[2]=adr+1;
				inds+=3;
				adr+=3;
			} 
		}
#if defined(ANDROID)&&!defined(UNSIGNEDSHORTINDICES)
		else
#endif
#endif
#if defined(ANDROID)&&!defined(UNSIGNEDSHORTINDICES)
		{
			float *xyz=vb->BVertex_Array;
			float *uv=vb->BTexCoo_Array;
			float *col=vb->BColor_Array;
			unsigned short int * inds=vb->BIndex_Array16;

			for (n=0;n<obj->nVertices;n++)
			{
				xyz[0]=obj->Vertices[n].Stok.x;
				xyz[1]=obj->Vertices[n].Stok.y;
				xyz[2]=obj->Vertices[n].Stok.z;
				col[0]=obj->Vertices[n].Diffuse.r;
				col[1]=obj->Vertices[n].Diffuse.g;
				col[2]=obj->Vertices[n].Diffuse.b;
				col[3]=obj->Vertices[n].Diffuse.a;		
				uv[0]=mp0.x;
				uv[1]=mp0.y;
				xyz+=3; uv+=2; col+=4;
	
				xyz[0]=obj->Vertices[n].Stok.x;
				xyz[1]=obj->Vertices[n].Stok.y;
				xyz[2]=obj->Vertices[n].Stok.z;
				col[0]=obj->Vertices[n].Diffuse.r;
				col[1]=obj->Vertices[n].Diffuse.g;
				col[2]=obj->Vertices[n].Diffuse.b;
				col[3]=obj->Vertices[n].Diffuse.a;
				uv[0]=mp1.x;
				uv[1]=mp1.y;
				xyz+=3; uv+=2; col+=4;

				xyz[0]=obj->Vertices[n].Stok.x;
				xyz[1]=obj->Vertices[n].Stok.y;
				xyz[2]=obj->Vertices[n].Stok.z;
				col[0]=obj->Vertices[n].Diffuse.r;
				col[1]=obj->Vertices[n].Diffuse.g;
				col[2]=obj->Vertices[n].Diffuse.b;
				col[3]=obj->Vertices[n].Diffuse.a;	
				uv[0]=mp2.x;
				uv[1]=mp2.y;
				xyz+=3; uv+=2; col+=4;

				inds[0]=adr;
				inds[1]=adr+2;
				inds[2]=adr+1;
				inds+=3;
				adr+=3;
			}
		}
#endif
#endif
#endif

		vb->UnlockVertices();
		vb->UnlockIndices();
	
		return vb;
	}
	else return NULL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CVertexBuffer* C3DAPIBASE::CreateMultiGroupFrom(CObject3D * obj,unsigned int typ)
{
	return CreateMultiGroupFrom(obj,typ,NULL);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CVertexBuffer* C3DAPIBASE::CreateMultiGroupFrom(CObject3D * obj,unsigned int typ,CLightmap **LMs)
{
	CLightmap *LM,*LMV;
	CVertexBuffer * vb;
	int n;
	int i[3];
	int n0,n1,n2;
	int tg;
	int TAG=8;
	float size_texture_lightmap=(((float) SIZE_LIGHTMAPS)/TILE_LIGHTMAPS);
	float size_texture_lightmap4=(((float) SIZE_LIGHTMAPS)/TILE_LIGHTMAPS)/4;
	CFace * f;
	CMapSort <long long,TmpFaces> mapgroups;
	long long id;
	TmpFaces * tmp;
	float x0,y0;
	CIndicesSE nfo;
	int nv,tag;
	int * corres[8];
	int vmin,vmax;
    long long previd=-1;
	#define SFT 11

	if (obj->nFaces<=0) return NULL;
	if (obj->nVertices<=0) return NULL;
    
	if (LMs)
	{
		if (typ&API3D_NOREFTAGONE)
		{
			vb=new CVertexBuffer;
			vb->SetAPI(this);
			vb->SetType(typ-API3D_NOREFTAGONE);

			if (typ&API3D_ENABLEUPDATE) vb->CorresVertices=new int[obj->nVertices];
			
			nv=obj->nVertices;

			vb->Init(obj->nVertices,obj->nFaces*3);
			vb->LockVertices();

			if ((typ&API3D_TEXCOO3BUMP)&&((typ&API3D_TEXCOO4DATAS)==0))
			{
				for (n=0;n<obj->nVertices;n++)
				{
					vb->SetColor(n,1,1,1);
					vb->SetVertex(n,obj->Vertices[n].Stok);
					vb->SetTexCoo(n,obj->Vertices[n].Map);		
				}
			}
			else
			{
				for (n=0;n<obj->nVertices;n++)
				{		
					if (typ&API3D_COLORDATAS4) vb->SetColor(n,1,1,1,1);
					else if (typ&API3D_COLORDATAS) vb->SetColor(n,1,1,1);

					if (typ&API3D_NORMALDATAS)
					{ 
						if (typ&API3D_VERTEXCALC) vb->SetNormal(n,obj->Vertices[n].NormCalc); 
						else vb->SetNormal(n,obj->Vertices[n].Norm); 
					}

					if (typ&API3D_VERTEXCALC) vb->SetVertex(n,obj->Vertices[n].Calc);
					else vb->SetVertex(n,obj->Vertices[n].Stok);

					if (typ&API3D_ENABLEUPDATE) vb->CorresVertices[n]=n;
					if (typ&API3D_TEXCOODATAS) vb->SetTexCoo(n,obj->Vertices[n].Map);
					if (typ&API3D_TEXCOODATAS2) vb->SetTexCoo2(n,obj->Vertices[n].Map2);

					if (typ&API3D_BLENDING)
					{
						vb->SetWeights(n,0,obj->Vertices[n].Weight[0]);
						vb->SetWeights(n,1,obj->Vertices[n].Weight[1]);
						vb->SetWeights(n,2,obj->Vertices[n].Weight[2]);
						vb->SetWeights(n,3,obj->Vertices[n].Weight[3]);
						vb->SetMatrixIndex(n,0,obj->Vertices[n].Index[0]);
						vb->SetMatrixIndex(n,1,obj->Vertices[n].Index[1]);
						vb->SetMatrixIndex(n,2,obj->Vertices[n].Index[2]);
						vb->SetMatrixIndex(n,3,obj->Vertices[n].Index[3]);
					}
				}
			}

			for (n=0;n<obj->nFaces;n++)
			{
				f=&(obj->Faces[n]);
				n0=f->v0;
				n1=f->v1;
				n2=f->v2;
				LM=LMV=NULL;

				if (typ&API3D_TEXCOO2LIGHTMAP)
				{
					if (f->nL>=Lightmaps->Length()) LM=LMs[0]; else LM=LMs[f->nL];
					float stlm=LM->sizx*size_texture_lightmap4;
					x0=LM->x*size_texture_lightmap + LM->offx*size_texture_lightmap4;
					y0=LM->y*size_texture_lightmap + LM->offy*size_texture_lightmap4;
					vb->SetTexCoo2(n0,x0 + f->v[0]->Map2.x*stlm,y0 + f->v[0]->Map2.y*stlm);
					vb->SetTexCoo2(n1,x0 + f->v[1]->Map2.x*stlm,y0 + f->v[1]->Map2.y*stlm);
					vb->SetTexCoo2(n2,x0 + f->v[2]->Map2.x*stlm,y0 + f->v[2]->Map2.y*stlm);
				}

				if (typ&API3D_TEXCOO3BUMP)
				{
					if (f->nLVectors>=Lightmaps->Length()) LMV=LMs[0]; else LMV=LMs[f->nLVectors];
					float stlmv=LMV->sizx*size_texture_lightmap4;
					x0=LMV->x*size_texture_lightmap + LMV->offx*size_texture_lightmap4;
					y0=LMV->y*size_texture_lightmap + LMV->offy*size_texture_lightmap4;
					vb->SetTexCoo3(n0,x0 + f->v[0]->Map2.x*stlmv,y0 + f->v[0]->Map2.y*stlmv);
					vb->SetTexCoo3(n1,x0 + f->v[1]->Map2.x*stlmv,y0 + f->v[1]->Map2.y*stlmv);
					vb->SetTexCoo3(n2,x0 + f->v[2]->Map2.x*stlmv,y0 + f->v[2]->Map2.y*stlmv);
				}

				if (typ&API3D_TEXCOO4DATAS)
				{
					CVector2 mp1,mp2;
					float sg1=1.0f;
					float sg2=1.0f;
					float ss;
					mp1=f->v[1]->Map - f->v[0]->Map;
					mp2=f->v[2]->Map - f->v[0]->Map;
					ss=mp1.x*mp2.y - mp1.y*mp2.x;
					if (ss>0) sg1=1.0f;	else sg1=-1.0f;
					vb->SetTexCoo4(n0,sg1,sg2);
					vb->SetTexCoo4(n1,sg1,sg2);
					vb->SetTexCoo4(n2,sg1,sg2);
				}

				id=f->nT;
				id=id<<SFT;
				if (LM) if (typ&API3D_TEXCOO2LIGHTMAP) id+=LM->nt;
				if (typ&API3D_TEXCOODATAS2) id+=f->nT2;
				if (typ&API3D_ENVMAPPING) id+=f->nT2;
				if (typ&API3D_TEXTURE_NT2) id+=f->nT2;
				id=id<<SFT;
				if (LMV) if (typ&API3D_TEXCOO3BUMP) id+=LMV->nt;
				id=id<<2;
				id+=f->ref;

                if (id!=previd)
                {
                    tmp=mapgroups[id];
                    previd=id;
                }

				if (tmp->array[0]==NULL) tmp->array[0]=new int[obj->nFaces];
				tmp->array[0][tmp->narray[0]++]=n;
			}
			vb->UnlockVertices();

			vb->LockIndices();
			tmp=mapgroups.GetFirst();
			n=0;
			while (tmp)
			{
				id=mapgroups.GetId();

				nfo.iStart=n*3;
				nfo.tag=0;
				nfo.ref=(id&0x3);
				if (typ&API3D_TEXCOO3BUMP) nfo.nLV=((id>>2)&0x3FF);
				if (typ&API3D_TEXCOO2LIGHTMAP) nfo.nL=(id>>(SFT+2))&0x3FF;
				if (typ&API3D_TEXCOODATAS2) nfo.nT2=(id>>(SFT+2))&0x3FF;
				if (typ&API3D_TEXTURE_NT2) nfo.nT2=(id>>(SFT+2))&0x3FF;
				if (typ&API3D_ENVMAPPING) nfo.nT2=(id>>(SFT+2))&0x3FF;
				nfo.nT=(id>>(SFT+SFT+2))&0x3FF;
				vmin=100000000;
				vmax=-1;

				for (int k=0;k<tmp->narray[0];k++)
				{
					i[0]=obj->Faces[tmp->array[0][k]].v0;
					i[1]=obj->Faces[tmp->array[0][k]].v1;
					i[2]=obj->Faces[tmp->array[0][k]].v2;
                    if (i[0]>vmax) vmax=i[0];
                    if (i[0]<vmin) vmin=i[0];
                    if (i[1]>vmax) vmax=i[1];
                    if (i[1]<vmin) vmin=i[1];
                    if (i[2]>vmax) vmax=i[2];
                    if (i[2]<vmin) vmin=i[2];
					vb->SetIndices(n,i[0],i[1],i[2]);
					n++;
				}
				
				vmin-=1;
				if (vmin<0) vmin=0;
				vmax+=1;
				if (vmax>obj->nVertices) vmax=obj->nVertices;
				nfo.vStart=vmin;
				nfo.vEnd=vmax;
				nfo.iEnd=n*3;
				vb->ListeSE.Add(nfo);

				tmp=mapgroups.GetNext();
			}
			vb->UnlockIndices();

			tmp=mapgroups.GetFirst();
			while (tmp)
			{
				delete [] tmp->array[0];
				tmp=mapgroups.GetNext();
			}
			mapgroups.Free();

			vb->Grouped=true;
		}
		else
		{
			vb=new CVertexBuffer;
			vb->SetAPI(this);
			vb->SetType(typ);

			TAG=0;
			for (n=0;n<obj->nFaces;n++) { if (obj->Faces[n].tag>TAG) TAG=obj->Faces[n].tag; }
			if (TAG>8) TAG=8;

			nv=0;
			for (tag=0;tag<=TAG;tag++)
			{
				for (n=0;n<obj->nVertices;n++) obj->Vertices[n].tag=0;

				for (n=0;n<obj->nFaces;n++)
				{
					f=&(obj->Faces[n]);
					if (f->tag==tag) { f->v[0]->tag=1; f->v[1]->tag=1; f->v[2]->tag=1; }
				}

				for (n=0;n<obj->nVertices;n++)
					if (obj->Vertices[n].tag==1) nv++;
			}

			if (typ&API3D_ENABLEUPDATE) vb->CorresVertices=new int[nv];
			
			vb->Init(nv,obj->nFaces*3);
			vb->LockVertices();

			n0=0;
			for (tag=0;tag<=TAG;tag++)
			{
				corres[tag]=new int[obj->nVertices];
				for (n=0;n<obj->nVertices;n++) corres[tag][n]=-1;
				for (n=0;n<obj->nVertices;n++) obj->Vertices[n].tag=0;

				for (n=0;n<obj->nFaces;n++)
				{
					f=&(obj->Faces[n]);
					if (f->tag==tag) { f->v[0]->tag=1; f->v[1]->tag=1; f->v[2]->tag=1;	}
				}

				if ((typ&API3D_TEXCOO3BUMP)&&((typ&API3D_TEXCOO4DATAS)==0))
				{
					for (n=0;n<obj->nVertices;n++)
						if (obj->Vertices[n].tag==1) 
						{
                            if (typ&API3D_DIFFUSEASSTOK0) vb->SetColor(n0,obj->Vertices[n].Stok0.x,obj->Vertices[n].Stok0.y,obj->Vertices[n].Stok0.z);
							else vb->SetColor(n0,obj->Vertices[n].Diffuse.r,obj->Vertices[n].Diffuse.g,obj->Vertices[n].Diffuse.b);
							vb->SetVertex(n0,obj->Vertices[n].Stok);
							vb->SetTexCoo(n0,obj->Vertices[n].Map);		
							corres[tag][n]=n0;
							n0++;
						}
				}
				else
				{
					for (n=0;n<obj->nVertices;n++)
						if (obj->Vertices[n].tag==1) 
						{
                            if (typ&API3D_DIFFUSEASSTOK0)
                            {
                                if (typ&API3D_COLORDATAS4) vb->SetColor(n0,obj->Vertices[n].Stok0.x,obj->Vertices[n].Stok0.y,obj->Vertices[n].Stok0.z,obj->Vertices[n].coef1);
                                else if (typ&API3D_COLORDATAS) vb->SetColor(n0,obj->Vertices[n].Stok0.x,obj->Vertices[n].Stok0.y,obj->Vertices[n].Stok0.z);
                            }
                            else
                            {
                                if (typ&API3D_COLORDATAS4) vb->SetColor(n0,obj->Vertices[n].Diffuse.r,obj->Vertices[n].Diffuse.g,obj->Vertices[n].Diffuse.b,obj->Vertices[n].Diffuse.a);
                                else if (typ&API3D_COLORDATAS) vb->SetColor(n0,obj->Vertices[n].Diffuse.r,obj->Vertices[n].Diffuse.g,obj->Vertices[n].Diffuse.b);
                            }
							if (typ&API3D_NORMALDATAS)
							{ 
								if (typ&API3D_VERTEXCALC) vb->SetNormal(n0,obj->Vertices[n].NormCalc); 
								else vb->SetNormal(n0,obj->Vertices[n].Norm); 
							}
							if (typ&API3D_VERTEXCALC) vb->SetVertex(n0,obj->Vertices[n].Calc);
							else vb->SetVertex(n0,obj->Vertices[n].Stok);
							if (typ&API3D_ENABLEUPDATE) vb->CorresVertices[n0]=n;
							if (typ&API3D_TEXCOODATAS) vb->SetTexCoo(n0,obj->Vertices[n].Map);
							if (typ&API3D_TEXCOODATAS2) vb->SetTexCoo2(n0,obj->Vertices[n].Map2);
							if (typ&API3D_BLENDING)
							{
								vb->SetWeights(n0,0,obj->Vertices[n].Weight[0]);
								vb->SetWeights(n0,1,obj->Vertices[n].Weight[1]);
								vb->SetWeights(n0,2,obj->Vertices[n].Weight[2]);
								vb->SetWeights(n0,3,obj->Vertices[n].Weight[3]);
								vb->SetMatrixIndex(n0,0,obj->Vertices[n].Index[0]);
								vb->SetMatrixIndex(n0,1,obj->Vertices[n].Index[1]);
								vb->SetMatrixIndex(n0,2,obj->Vertices[n].Index[2]);
								vb->SetMatrixIndex(n0,3,obj->Vertices[n].Index[3]);
							}
							corres[tag][n]=n0;
							n0++;
						}
				}
			}

			for (n=0;n<obj->nFaces;n++)
			{
				f=&(obj->Faces[n]);
				n0=f->v0;
				n1=f->v1;
				n2=f->v2;
				int an1=corres[f->tag][n0];
				int an2=corres[f->tag][n1];
				int an3=corres[f->tag][n2];
				LM=LMV=NULL;

				if (typ&API3D_TEXCOO2LIGHTMAP)
				{
					if (f->nL>=Lightmaps->Length()) LM=LMs[0]; else LM=LMs[f->nL];
					float stlm=LM->sizx*size_texture_lightmap4;
					x0=LM->x*size_texture_lightmap + LM->offx*size_texture_lightmap4;
					y0=LM->y*size_texture_lightmap + LM->offy*size_texture_lightmap4;
					vb->SetTexCoo2(an1,x0 + f->v[0]->Map2.x*stlm,y0 + f->v[0]->Map2.y*stlm);
					vb->SetTexCoo2(an2,x0 + f->v[1]->Map2.x*stlm,y0 + f->v[1]->Map2.y*stlm);
					vb->SetTexCoo2(an3,x0 + f->v[2]->Map2.x*stlm,y0 + f->v[2]->Map2.y*stlm);
				}

				if (typ&API3D_TEXCOO3BUMP)
				{
					if (f->nLVectors>=Lightmaps->Length()) LMV=LMs[0]; else LMV=LMs[f->nLVectors];
					float stlmv=LMV->sizx*size_texture_lightmap4;
					x0=LMV->x*size_texture_lightmap + LMV->offx*size_texture_lightmap4;
					y0=LMV->y*size_texture_lightmap + LMV->offy*size_texture_lightmap4;
					vb->SetTexCoo3(an1,x0 + f->v[0]->Map2.x*stlmv,y0 + f->v[0]->Map2.y*stlmv);
					vb->SetTexCoo3(an2,x0 + f->v[1]->Map2.x*stlmv,y0 + f->v[1]->Map2.y*stlmv);
					vb->SetTexCoo3(an3,x0 + f->v[2]->Map2.x*stlmv,y0 + f->v[2]->Map2.y*stlmv);
				}

				if (typ&API3D_TEXCOO4DATAS)
				{
					CVector2 mp1,mp2;
					float sg1=1.0f;
					float sg2=1.0f;
					float ss;
					mp1=f->v[1]->Map - f->v[0]->Map;
					mp2=f->v[2]->Map - f->v[0]->Map;
					ss=mp1.x*mp2.y - mp1.y*mp2.x;
					if (ss>0) sg1=1.0f;	else sg1=-1.0f;
					vb->SetTexCoo4(an1,sg1,sg2);
					vb->SetTexCoo4(an2,sg1,sg2);
					vb->SetTexCoo4(an3,sg1,sg2);
				}

				id=f->nT;
				id=id<<SFT;
				if (LM) if (typ&API3D_TEXCOO2LIGHTMAP) id+=LM->nt;
				if (typ&API3D_TEXCOODATAS2) id+=f->nT2;
				if (typ&API3D_ENVMAPPING) id+=f->nT2;
				if (typ&API3D_TEXTURE_NT2) id+=f->nT2;
				id=id<<SFT;
				if (LMV) if (typ&API3D_TEXCOO3BUMP) id+=LMV->nt;
				id=id<<2;
				id+=f->ref;

                if (id!=previd)
                {
                    tmp=mapgroups[id];
                    previd=id;
                }

				if (tmp->array[f->tag]==NULL) tmp->array[f->tag]=new int[obj->nFaces];
				tmp->array[f->tag][tmp->narray[f->tag]++]=n;
			}
			vb->UnlockVertices();

			vb->LockIndices();
			tmp=mapgroups.GetFirst();
			n=0;
			while (tmp)
			{
				id=mapgroups.GetId();

				for (tg=0;tg<=TAG;tg++)
				{
					if (tmp->narray[tg]>0)
					{
						nfo.tag=tg;
						nfo.iStart=n*3;
						nfo.ref=(id&0x3);
						if (typ&API3D_TEXCOO3BUMP) nfo.nLV=((id>>2)&0x3FF);
						if (typ&API3D_TEXCOO2LIGHTMAP) nfo.nL=(id>>(SFT+2))&0x3FF;
						if (typ&API3D_TEXCOODATAS2) nfo.nT2=(id>>(SFT+2))&0x3FF;
						if (typ&API3D_TEXTURE_NT2) nfo.nT2=(id>>(SFT+2))&0x3FF;
						if (typ&API3D_ENVMAPPING) nfo.nT2=(id>>(SFT+2))&0x3FF;
						nfo.nT=(id>>(SFT+SFT+2))&0x3FF;
						vmin=100000000;
						vmax=-1;

						for (int k=0;k<tmp->narray[tg];k++)
						{
							i[0]=corres[obj->Faces[tmp->array[tg][k]].tag][obj->Faces[tmp->array[tg][k]].v0];
							i[1]=corres[obj->Faces[tmp->array[tg][k]].tag][obj->Faces[tmp->array[tg][k]].v1];
							i[2]=corres[obj->Faces[tmp->array[tg][k]].tag][obj->Faces[tmp->array[tg][k]].v2];
                            if (i[0]>vmax) vmax=i[0];
                            if (i[0]<vmin) vmin=i[0];
                            if (i[1]>vmax) vmax=i[1];
                            if (i[1]<vmin) vmin=i[1];
                            if (i[2]>vmax) vmax=i[2];
                            if (i[2]<vmin) vmin=i[2];
							vb->SetIndices(n,i[0],i[1],i[2]);
							n++;
						}
						
						vmin-=1;
						if (vmin<0) vmin=0;
						vmax+=1;
						if (vmax>nv) vmax=nv;
						nfo.vStart=vmin;
						nfo.vEnd=vmax;
						nfo.iEnd=n*3;
						vb->ListeSE.Add(nfo);
					}
				}

				tmp=mapgroups.GetNext();
			}
			vb->UnlockIndices();

			for (tag=0;tag<=TAG;tag++) delete [] corres[tag];

			tmp=mapgroups.GetFirst();
			while (tmp)
			{
				for (tg=0;tg<8;tg++) { if (tmp->array[tg]) delete []  tmp->array[tg]; }
				tmp=mapgroups.GetNext();
			}
			mapgroups.Free();
			vb->Grouped=true;
		}
	}
	else  // NO LMS
	{
        int strip=0;

        if ((typ&API3D_NOREFTAGONE)&&
            ((typ&API3D_ENVMAPPING)==0)&&
            ((typ&API3D_TEXCOO3BUMP)==0)&&
            ((typ&API3D_TEXCOO4DATAS)==0)&&
            ((typ&API3D_TEXCOO2LIGHTMAP)==0)&&
            ((typ&API3D_TEXCOODATAS2)==0)
            )
        {
            if ((typ&API3D_TEXTURE_NT2)==0)
            {
                int tag=0;
                int tex=obj->Faces[0].nT;
                int ref=obj->Faces[0].ref;
                
                for (n=0;(n<obj->nFaces)&&(tag==0);n++)
                    if ((obj->Faces[n].nT!=tex)||(obj->Faces[n].ref!=ref)) tag=1;
                
                if (tag==0)
                {
                    vb=new CVertexBuffer;
                    vb->SetAPI(this);
                    vb->CreateFrom2(obj,typ-API3D_NOREFTAGONE);

                    nfo.vStart=0;
                    nfo.vEnd=obj->nVertices;
                    nfo.iStart=0;
                    nfo.iEnd=n*3;
                    
                    nfo.strip=0;
                    nfo.ref=ref;
                    nfo.nT=tex;

                    vb->ListeSE.Add(nfo);
                    vb->Grouped=true;
                    
                    return vb;
                }
            }
            else
            {
                int tag=0;
                int tex=obj->Faces[0].nT;
                int tex2=obj->Faces[0].nT2;
                int ref=obj->Faces[0].ref;
                
                for (n=0;(n<obj->nFaces)&&(tag==0);n++)
                    if ((obj->Faces[n].nT!=tex)||(obj->Faces[n].nT2!=tex2)||(obj->Faces[n].ref!=ref)) tag=1;
                
                if (tag==0)
                {
                    vb=new CVertexBuffer;
                    vb->SetAPI(this);
                    vb->CreateFrom2(obj,typ-API3D_NOREFTAGONE);

                    nfo.vStart=0;
                    nfo.vEnd=obj->nVertices;
                    nfo.iStart=0;
                    nfo.iEnd=n*3;
                    
                    nfo.strip=0;
                    nfo.ref=ref;
                    nfo.nT=tex;
                    nfo.nT2=tex2;

                    vb->ListeSE.Add(nfo);
                    vb->Grouped=true;
                    
                    return vb;
                }
            }
        }
        
        //glEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX);
        //glDrawElements(GL_TRIANGLE_STRIP, 11, GL_UNSIGNED_SHORT, 0);
        
		if ((typ&API3D_NOREFTAGONE)||(typ&API3D_STREAMS))
		{
			vb=new CVertexBuffer;
			vb->SetAPI(this);
			if (typ&API3D_NOREFTAGONE) vb->SetType(typ-API3D_NOREFTAGONE);
			else vb->SetType(typ);

			if (typ&API3D_ENABLEUPDATE) vb->CorresVertices=new int[obj->nVertices];
			
			nv=obj->nVertices;
            
            if (strip)
            {
                if (typ&API3D_STREAMS) vb->Init(obj->nVertices,obj->nFaces*6,obj->nKeys);
                else vb->Init(obj->nVertices,obj->nFaces*6);
            }
            else
            {
                if (typ&API3D_STREAMS) vb->Init(obj->nVertices,obj->nFaces*3,obj->nKeys);
                else vb->Init(obj->nVertices,obj->nFaces*3);
            }
			vb->LockVertices();
            
			if ((typ&API3D_TEXCOO3BUMP)&&((typ&API3D_TEXCOO4DATAS)==0))
			{
				for (n=0;n<obj->nVertices;n++)
				{
					vb->SetColor(n,1,1,1);
					vb->SetVertex(n,obj->Vertices[n].Stok);
					vb->SetTexCoo(n,obj->Vertices[n].Map);
				}
			}
			else
			{
				for (n=0;n<obj->nVertices;n++)
				{
                    if (typ&API3D_DIFFUSEASSTOK0)
                    {
                        if (typ&API3D_COLORDATAS4) vb->SetColor(n,obj->Vertices[n].Stok0.x,obj->Vertices[n].Stok0.y,obj->Vertices[n].Stok0.z,obj->Vertices[n].coef1);
                        else if (typ&API3D_COLORDATAS) vb->SetColor(n,obj->Vertices[n].Stok0.x,obj->Vertices[n].Stok0.y,obj->Vertices[n].Stok0.z);
                    }
                    else
                    {
                        if (typ&API3D_COLORDATAS4) vb->SetColor(n,obj->Vertices[n].Diffuse.r,obj->Vertices[n].Diffuse.g,obj->Vertices[n].Diffuse.b,obj->Vertices[n].Diffuse.a);
                        else if (typ&API3D_COLORDATAS) vb->SetColor(n,obj->Vertices[n].Diffuse.r,obj->Vertices[n].Diffuse.g,obj->Vertices[n].Diffuse.b);
                    }

					if (typ&API3D_NORMALDATAS)
					{ 
						if (typ&API3D_VERTEXCALC) vb->SetNormal(n,obj->Vertices[n].NormCalc); 
						else vb->SetNormal(n,obj->Vertices[n].Norm); 
					}

					if (typ&API3D_VERTEXCALC) vb->SetVertex(n,obj->Vertices[n].Calc);
					else vb->SetVertex(n,obj->Vertices[n].Stok);

					if (typ&API3D_ENABLEUPDATE) vb->CorresVertices[n]=n;
					if (typ&API3D_TEXCOODATAS) vb->SetTexCoo(n,obj->Vertices[n].Map);
					if (typ&API3D_TEXCOODATAS2) vb->SetTexCoo2(n,obj->Vertices[n].Map2);

					if (typ&API3D_BLENDING)
					{
						vb->SetWeights(n,0,obj->Vertices[n].Weight[0]);
						vb->SetWeights(n,1,obj->Vertices[n].Weight[1]);
						vb->SetWeights(n,2,obj->Vertices[n].Weight[2]);
						vb->SetWeights(n,3,obj->Vertices[n].Weight[3]);
						vb->SetMatrixIndex(n,0,obj->Vertices[n].Index[0]);
						vb->SetMatrixIndex(n,1,obj->Vertices[n].Index[1]);
						vb->SetMatrixIndex(n,2,obj->Vertices[n].Index[2]);
						vb->SetMatrixIndex(n,3,obj->Vertices[n].Index[3]);
					}
				}
			}
            
            // TAGREFONE
            
            int full=0;
            if (typ&API3D_TEXCOO2LIGHTMAP) full=1;
            if (typ&API3D_TEXCOODATAS2) full=1;
            if (typ&API3D_ENVMAPPING) full=1;
            if (typ&API3D_TEXTURE_NT2) full=1;
            if (typ&API3D_TEXCOO3BUMP) full=1;

            if (full)
            {
                for (n=0;n<obj->nFaces;n++)
                {
                    f=&(obj->Faces[n]);
                    n0=f->v0;
                    n1=f->v1;
                    n2=f->v2;
                    LM=LMV=NULL;

                    if (typ&API3D_TEXCOO2LIGHTMAP)
                    {
                        if (f->nL>=Lightmaps->Length()) LM=(*Lightmaps)[0]; else LM=(*Lightmaps)[f->nL];
                        float stlm=LM->sizx*size_texture_lightmap4;
                        x0=LM->x*size_texture_lightmap + LM->offx*size_texture_lightmap4;
                        y0=LM->y*size_texture_lightmap + LM->offy*size_texture_lightmap4;
                        vb->SetTexCoo2(n0,x0 + f->v[0]->Map2.x*stlm,y0 + f->v[0]->Map2.y*stlm);
                        vb->SetTexCoo2(n1,x0 + f->v[1]->Map2.x*stlm,y0 + f->v[1]->Map2.y*stlm);
                        vb->SetTexCoo2(n2,x0 + f->v[2]->Map2.x*stlm,y0 + f->v[2]->Map2.y*stlm);
                    }

                    if (typ&API3D_TEXCOO3BUMP)
                    {
                        if (f->nLVectors>=Lightmaps->Length()) LMV=(*Lightmaps)[0]; else LMV=(*Lightmaps)[f->nLVectors];
                        float stlmv=LMV->sizx*size_texture_lightmap4;
                        x0=LMV->x*size_texture_lightmap + LMV->offx*size_texture_lightmap4;
                        y0=LMV->y*size_texture_lightmap + LMV->offy*size_texture_lightmap4;
                        vb->SetTexCoo3(n0,x0 + f->v[0]->Map2.x*stlmv,y0 + f->v[0]->Map2.y*stlmv);
                        vb->SetTexCoo3(n1,x0 + f->v[1]->Map2.x*stlmv,y0 + f->v[1]->Map2.y*stlmv);
                        vb->SetTexCoo3(n2,x0 + f->v[2]->Map2.x*stlmv,y0 + f->v[2]->Map2.y*stlmv);
                    }

                    if (typ&API3D_TEXCOO4DATAS)
                    {
                        CVector2 mp1,mp2;
                        float sg1=1.0f;
                        float sg2=1.0f;
                        float ss;
                        mp1=f->v[1]->Map - f->v[0]->Map;
                        mp2=f->v[2]->Map - f->v[0]->Map;
                        ss=mp1.x*mp2.y - mp1.y*mp2.x;
                        if (ss>0) sg1=1.0f;	else sg1=-1.0f;
                        vb->SetTexCoo4(n0,sg1,sg2);
                        vb->SetTexCoo4(n1,sg1,sg2);
                        vb->SetTexCoo4(n2,sg1,sg2);
                    }

                    id=f->nT;
                    id=id<<SFT;
                    if (LM) if (typ&API3D_TEXCOO2LIGHTMAP) id+=LM->nt;
                    if (typ&API3D_TEXCOODATAS2) id+=f->nT2;
                    if (typ&API3D_ENVMAPPING) id+=f->nT2;
                    if (typ&API3D_TEXTURE_NT2) id+=f->nT2;
                    id=id<<SFT;
                    if (LMV) if (typ&API3D_TEXCOO3BUMP) id+=LMV->nt;
                    id=id<<2;
                    id+=f->ref;

                    if (id!=previd)
                    {
                        tmp=mapgroups[id];
                        previd=id;
                    }
                    
                    if (tmp->array[0]==NULL) tmp->array[0]=new int[obj->nFaces];
                    tmp->array[0][tmp->narray[0]++]=n;
                }
                
                vb->UnlockVertices();
            }
            else
            {
                vb->UnlockVertices();
                
                for (n=0;n<obj->nFaces;n++)
                {
                    f=&(obj->Faces[n]);
                    n0=f->v0;
                    n1=f->v1;
                    n2=f->v2;
                    
                    id=f->nT;
                    id=id<<(SFT+SFT+2);
                    id+=f->ref;
                    
                    if (id!=previd)
                    {
                        tmp=mapgroups[id];
                        previd=id;
                    }
                    
                    if (tmp->array[0]==NULL) tmp->array[0]=new int[obj->nFaces];
                    tmp->array[0][tmp->narray[0]++]=n;
                }
            }

			if (typ&API3D_STREAMS)
			{
				for (int k=0;k<obj->nKeys;k++)
				{
					vb->LockStream(k);
					for (n=0;n<obj->nVertices;n++)
					{								
						vb->SetNormal(n,obj->VerticesKeys[k][n].Norm); 
						vb->SetVertex(n,obj->VerticesKeys[k][n].Stok);

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
						vb->SetTexCoo(n,obj->Vertices[n].Map);
#endif
					}
					vb->UnlockStream();
				}
			}
        
            
            if (full)
            {
                if (strip)
                {
                    int k;
                    int count=0;
                    CObject3D * group=obj->Duplicate2();
                    
                    vb->LockIndices();
                    
                    tmp=mapgroups.GetFirst();
                    n=0;
                    while (tmp)
                    {
                        id=mapgroups.GetId();
                        nfo.tag=0;
                        nfo.strip=1;
                        nfo.iStart=n;
                        nfo.ref=(id&0x3);
                        if (typ&API3D_TEXCOO3BUMP) nfo.nLV=((id>>2)&0x3FF);
                        if (typ&API3D_TEXCOO2LIGHTMAP) nfo.nL=(id>>(SFT+2))&0x3FF;
                        if (typ&API3D_TEXCOODATAS2) nfo.nT2=(id>>(SFT+2))&0x3FF;
                        if (typ&API3D_TEXTURE_NT2) nfo.nT2=(id>>(SFT+2))&0x3FF;
                        if (typ&API3D_ENVMAPPING) nfo.nT2=(id>>(SFT+2))&0x3FF;
                        nfo.nT=(id>>(SFT+SFT+2))&0x3FF;
                        vmin=100000000;
                        vmax=-1;
                                                                        
                        CFace *tmpfaces=group->Faces;
                        
                        group->Faces=new CFace[tmp->narray[0]];
                        for (k=0;k<tmp->narray[0];k++)
                        {
                            group->Faces[k]=tmpfaces[tmp->array[0][k]];
                            group->Faces[k].tag=0;
                        }

                        group->nFaces=tmp->narray[0];
                        group->SetFaces();
                        group->SetF012();
                        
                        int *list=new int[group->nFaces*3];
                            
                        for (k=0;k<group->nFaces;k++)
                        if (group->Faces[k].tag==0)
                        {
                            int nb=GetListIndexGroupStrip(group,list,k);
                            
                            vb->SetIndice(n,list[0]);
                            n++;
                            vb->SetIndice(n,list[1]);
                            n++;
                            vb->SetIndice(n,list[2]);
                            n++;
                            
                            for (int ii=0;ii<nb;ii++)
                            {
                                if (list[ii]>vmax) vmax=list[ii];
                                if (list[ii]<vmin) vmin=list[ii];

                                if (ii>=3)
                                {
                                    vb->SetIndice(n,list[ii]);
                                    n++;
                                }
                            }
                                
                            vb->SetIndice(n,-1);
                            n++;

                            count++;
                        }
                        
                        delete [] list;
                        
                        delete [] group->Faces;
                        group->Faces=tmpfaces;
                        
                        vmin-=1;
                        if (vmin<0) vmin=0;
                        vmax+=1;
                        if (vmax>obj->nVertices) vmax=obj->nVertices;
                        nfo.vStart=vmin;
                        nfo.vEnd=vmax;
                        nfo.iEnd=n;
                        vb->ListeSE.Add(nfo);

                        tmp=mapgroups.GetNext();
                    }
                                        
                    vb->nIndicesActif=vb->nIndices=n;
                    vb->UnlockIndices();
                    group->nFaces=obj->nFaces;
                    group->Free();
                    delete group;
                }
                else
                {
                    vb->LockIndices();
                    
                    tmp=mapgroups.GetFirst();
                    n=0;
                    while (tmp)
                    {
                        id=mapgroups.GetId();
                        nfo.tag=0;
                        nfo.iStart=n*3;
                        nfo.ref=(id&0x3);
                        if (typ&API3D_TEXCOO3BUMP) nfo.nLV=((id>>2)&0x3FF);
                        if (typ&API3D_TEXCOO2LIGHTMAP) nfo.nL=(id>>(SFT+2))&0x3FF;
                        if (typ&API3D_TEXCOODATAS2) nfo.nT2=(id>>(SFT+2))&0x3FF;
                        if (typ&API3D_TEXTURE_NT2) nfo.nT2=(id>>(SFT+2))&0x3FF;
                        if (typ&API3D_ENVMAPPING) nfo.nT2=(id>>(SFT+2))&0x3FF;
                        nfo.nT=(id>>(SFT+SFT+2))&0x3FF;
                        vmin=100000000;
                        vmax=-1;

                        for (int k=0;k<tmp->narray[0];k++)
                        {
                            i[0]=obj->Faces[tmp->array[0][k]].v0;
                            i[1]=obj->Faces[tmp->array[0][k]].v1;
                            i[2]=obj->Faces[tmp->array[0][k]].v2;
                            if (i[0]>vmax) vmax=i[0];
                            if (i[0]<vmin) vmin=i[0];
                            if (i[1]>vmax) vmax=i[1];
                            if (i[1]<vmin) vmin=i[1];
                            if (i[2]>vmax) vmax=i[2];
                            if (i[2]<vmin) vmin=i[2];
                            vb->SetIndices(n,i[0],i[1],i[2]);
                            n++;
                        }
                        
                        vmin-=1;
                        if (vmin<0) vmin=0;
                        vmax+=1;
                        if (vmax>obj->nVertices) vmax=obj->nVertices;
                        nfo.vStart=vmin;
                        nfo.vEnd=vmax;
                        nfo.iEnd=n*3;
                        vb->ListeSE.Add(nfo);

                        tmp=mapgroups.GetNext();
                    }
                    
                    vb->UnlockIndices();
                }
            }
            else
            {
                if (strip)
                {
                    int k;
                    int count=0;
                    CObject3D * group=obj->Duplicate2();
                    
                    vb->LockIndices();
                    tmp=mapgroups.GetFirst();
                    n=0;
                    while (tmp)
                    {
                        id=mapgroups.GetId();
                        nfo.tag=0;
                        nfo.strip=1;
                        nfo.iStart=n;
                        nfo.ref=(id&0x3);
                        nfo.nT=(id>>(SFT+SFT+2))&0x3FF;
                        vmin=100000000;
                        vmax=-1;
                        
                        CFace *tmpfaces=group->Faces;
                        group->Faces=new CFace[tmp->narray[0]];
                        for (k=0;k<tmp->narray[0];k++)
                        {
                            group->Faces[k]=tmpfaces[tmp->array[0][k]];
                            group->Faces[k].tag=0;
                        }

                        group->nFaces=tmp->narray[0];
                        group->SetFaces();
                        group->SetF012();
                        
                        int *list=new int[group->nFaces*3];
                            
                        for (k=0;k<group->nFaces;k++)
                        if (group->Faces[k].tag==0)
                        {
                            int nb=GetListIndexGroupStrip(group,list,k);
                            
                            vb->SetIndice(n,list[0]);
                            n++;
                            vb->SetIndice(n,list[1]);
                            n++;
                            vb->SetIndice(n,list[2]);
                            n++;
                            
                            for (int ii=0;ii<nb;ii++)
                            {
                                if (list[ii]>vmax) vmax=list[ii];
                                if (list[ii]<vmin) vmin=list[ii];

                                if (ii>=3)
                                {
                                    vb->SetIndice(n,list[ii]);
                                    n++;
                                }
                            }
                                
                            vb->SetIndice(n,-1);
                            n++;
                            
                            count++;
                        }
                        
                        //printf("count:%d\n",count);
                        
                        delete [] list;
                        
                        delete [] group->Faces;
                        group->Faces=tmpfaces;
                        
                        vmin-=1;
                        if (vmin<0) vmin=0;
                        vmax+=1;
                        if (vmax>obj->nVertices) vmax=obj->nVertices;
                        nfo.vStart=vmin;
                        nfo.vEnd=vmax;
                        nfo.iEnd=n;
                        vb->ListeSE.Add(nfo);
                        
                        tmp=mapgroups.GetNext();
                        
                    }
                    
                    vb->nIndicesActif=vb->nIndices=n;
                    vb->UnlockIndices();
                    group->nFaces=obj->nFaces;
                    group->Free();
                    delete group;
                }
                else
                {
                    vb->LockIndices();
                    tmp=mapgroups.GetFirst();
                    n=0;
                    while (tmp)
                    {
                        id=mapgroups.GetId();
                        nfo.tag=0;
                        nfo.iStart=n*3;
                        nfo.ref=(id&0x3);
                        nfo.nT=(id>>(SFT+SFT+2))&0x3FF;
                        vmin=100000000;
                        vmax=-1;
                            
                        for (int k=0;k<tmp->narray[0];k++)
                        {
                            i[0]=obj->Faces[tmp->array[0][k]].v0;
                            i[1]=obj->Faces[tmp->array[0][k]].v1;
                            i[2]=obj->Faces[tmp->array[0][k]].v2;
                            if (i[0]>vmax) vmax=i[0];
                            if (i[0]<vmin) vmin=i[0];
                            if (i[1]>vmax) vmax=i[1];
                            if (i[1]<vmin) vmin=i[1];
                            if (i[2]>vmax) vmax=i[2];
                            if (i[2]<vmin) vmin=i[2];
                            
                            vb->SetIndices(n,i[0],i[1],i[2]);
                            n++;
                        }
                        
                        vmin-=1;
                        if (vmin<0) vmin=0;
                        vmax+=1;
                        if (vmax>obj->nVertices) vmax=obj->nVertices;
                        nfo.vStart=vmin;
                        nfo.vEnd=vmax;
                        nfo.iEnd=n*3;
                        vb->ListeSE.Add(nfo);
                        
                        tmp=mapgroups.GetNext();
                    }
                    vb->UnlockIndices();
                }
            }
                
			tmp=mapgroups.GetFirst();
			while (tmp)
			{
				delete [] tmp->array[0];
				tmp=mapgroups.GetNext();
			}
			mapgroups.Free();

			vb->Grouped=true;
		}
		else
		{
			// Normal vb create 

			vb=new CVertexBuffer;
			vb->SetAPI(this);
			vb->SetType(typ);

			TAG=0;
			for (n=0;n<obj->nFaces;n++) { if (obj->Faces[n].tag>TAG) TAG=obj->Faces[n].tag; }
			if (TAG>8) TAG=8;

			nv=0;
			for (tag=0;tag<=TAG;tag++)
			{
				for (n=0;n<obj->nVertices;n++) obj->Vertices[n].tag=0;

				for (n=0;n<obj->nFaces;n++)
				{
					f=&(obj->Faces[n]);
					if (f->tag==tag) { f->v[0]->tag=1; f->v[1]->tag=1; f->v[2]->tag=1; }
				}

				for (n=0;n<obj->nVertices;n++)
					if (obj->Vertices[n].tag==1) nv++;
			}

			if (typ&API3D_ENABLEUPDATE) vb->CorresVertices=new int[nv];
			
			vb->Init(nv,obj->nFaces*3);
			vb->LockVertices();

			n0=0;
			for (tag=0;tag<=TAG;tag++)
			{
				corres[tag]=new int[obj->nVertices];
				for (n=0;n<obj->nVertices;n++) corres[tag][n]=-1;
				for (n=0;n<obj->nVertices;n++) obj->Vertices[n].tag=0;

				for (n=0;n<obj->nFaces;n++)
				{
					f=&(obj->Faces[n]);
					if (f->tag==tag) { f->v[0]->tag=1; f->v[1]->tag=1; f->v[2]->tag=1;	}
				}

				if ((typ&API3D_TEXCOO3BUMP)&&((typ&API3D_TEXCOO4DATAS)==0))
				{
					for (n=0;n<obj->nVertices;n++)
						if (obj->Vertices[n].tag==1) 
						{
                            if (typ&API3D_DIFFUSEASSTOK0)
                            {
                                vb->SetColor(n0,obj->Vertices[n].Stok0.x,obj->Vertices[n].Stok0.y,obj->Vertices[n].Stok0.z);
                            }
                            else
                            {
                                vb->SetColor(n0,obj->Vertices[n].Diffuse.r,obj->Vertices[n].Diffuse.g,obj->Vertices[n].Diffuse.b);
                            }

							
							vb->SetVertex(n0,obj->Vertices[n].Stok);
							vb->SetTexCoo(n0,obj->Vertices[n].Map);
							corres[tag][n]=n0;
							n0++;
						}
				}
				else
				{
					for (n=0;n<obj->nVertices;n++)
						if (obj->Vertices[n].tag==1) 
						{
                            if (typ&API3D_DIFFUSEASSTOK0)
                            {
                                if (typ&API3D_COLORDATAS4) vb->SetColor(n0,obj->Vertices[n].Stok0.x,obj->Vertices[n].Stok0.y,obj->Vertices[n].Stok0.z,obj->Vertices[n].coef1);
                                else if (typ&API3D_COLORDATAS) vb->SetColor(n0,obj->Vertices[n].Stok0.x,obj->Vertices[n].Stok0.y,obj->Vertices[n].Stok0.z);
                            }
                            else
                            {
                                if (typ&API3D_COLORDATAS4) vb->SetColor(n0,obj->Vertices[n].Diffuse.r,obj->Vertices[n].Diffuse.g,obj->Vertices[n].Diffuse.b,obj->Vertices[n].Diffuse.a);
                                else if (typ&API3D_COLORDATAS) vb->SetColor(n0,obj->Vertices[n].Diffuse.r,obj->Vertices[n].Diffuse.g,obj->Vertices[n].Diffuse.b);
                            }
                            
							if (typ&API3D_NORMALDATAS)
							{ 
								if (typ&API3D_VERTEXCALC) vb->SetNormal(n0,obj->Vertices[n].NormCalc); 
								else vb->SetNormal(n0,obj->Vertices[n].Norm); 
							}
							if (typ&API3D_VERTEXCALC) vb->SetVertex(n0,obj->Vertices[n].Calc);
							else vb->SetVertex(n0,obj->Vertices[n].Stok);
							if (typ&API3D_ENABLEUPDATE) vb->CorresVertices[n0]=n;
							if (typ&API3D_TEXCOODATAS) vb->SetTexCoo(n0,obj->Vertices[n].Map);
							if (typ&API3D_TEXCOODATAS2) vb->SetTexCoo2(n0,obj->Vertices[n].Map2);
							if (typ&API3D_BLENDING)
							{
								vb->SetWeights(n0,0,obj->Vertices[n].Weight[0]);
								vb->SetWeights(n0,1,obj->Vertices[n].Weight[1]);
								vb->SetWeights(n0,2,obj->Vertices[n].Weight[2]);
								vb->SetWeights(n0,3,obj->Vertices[n].Weight[3]);
								vb->SetMatrixIndex(n0,0,obj->Vertices[n].Index[0]);
								vb->SetMatrixIndex(n0,1,obj->Vertices[n].Index[1]);
								vb->SetMatrixIndex(n0,2,obj->Vertices[n].Index[2]);
								vb->SetMatrixIndex(n0,3,obj->Vertices[n].Index[3]);
							}
							corres[tag][n]=n0;
							n0++;
						}
				}
			}

			for (n=0;n<obj->nFaces;n++)
			{
				f=&(obj->Faces[n]);
				n0=f->v0;
				n1=f->v1;
				n2=f->v2;
				int an1=corres[f->tag][n0];
				int an2=corres[f->tag][n1];
				int an3=corres[f->tag][n2];
				LM=LMV=NULL;

				if (typ&API3D_TEXCOO2LIGHTMAP)
				{
					if (f->nL>=Lightmaps->Length()) LM=(*Lightmaps)[0]; else LM=(*Lightmaps)[f->nL];
					float stlm=LM->sizx*size_texture_lightmap4;
					x0=LM->x*size_texture_lightmap + LM->offx*size_texture_lightmap4;
					y0=LM->y*size_texture_lightmap + LM->offy*size_texture_lightmap4;
					vb->SetTexCoo2(an1,x0 + f->v[0]->Map2.x*stlm,y0 + f->v[0]->Map2.y*stlm);
					vb->SetTexCoo2(an2,x0 + f->v[1]->Map2.x*stlm,y0 + f->v[1]->Map2.y*stlm);
					vb->SetTexCoo2(an3,x0 + f->v[2]->Map2.x*stlm,y0 + f->v[2]->Map2.y*stlm);
				}

				if (typ&API3D_TEXCOO3BUMP)
				{
					if (f->nLVectors>=Lightmaps->Length()) LMV=(*Lightmaps)[0]; else LMV=(*Lightmaps)[f->nLVectors];
					//LMV=(*Lightmaps)[f->nLVectors];
					float stlmv=LMV->sizx*size_texture_lightmap4;
					x0=LMV->x*size_texture_lightmap + LMV->offx*size_texture_lightmap4;
					y0=LMV->y*size_texture_lightmap + LMV->offy*size_texture_lightmap4;
					vb->SetTexCoo3(an1,x0 + f->v[0]->Map2.x*stlmv,y0 + f->v[0]->Map2.y*stlmv);
					vb->SetTexCoo3(an2,x0 + f->v[1]->Map2.x*stlmv,y0 + f->v[1]->Map2.y*stlmv);
					vb->SetTexCoo3(an3,x0 + f->v[2]->Map2.x*stlmv,y0 + f->v[2]->Map2.y*stlmv);
				}

				if (typ&API3D_TEXCOO4DATAS)
				{
					CVector2 mp1,mp2;
					float sg1=1.0f;
					float sg2=1.0f;
					float ss;
					mp1=f->v[1]->Map - f->v[0]->Map;
					mp2=f->v[2]->Map - f->v[0]->Map;
					ss=mp1.x*mp2.y - mp1.y*mp2.x;
					if (ss>0) sg1=1.0f;	else sg1=-1.0f;
					vb->SetTexCoo4(an1,sg1,sg2);
					vb->SetTexCoo4(an2,sg1,sg2);
					vb->SetTexCoo4(an3,sg1,sg2);
				}

				id=f->nT;
				id=id<<SFT;
				if (LM) if (typ&API3D_TEXCOO2LIGHTMAP) id+=LM->nt;
				if (typ&API3D_TEXCOODATAS2) id+=f->nT2;
				if (typ&API3D_ENVMAPPING) id+=f->nT2;
				if (typ&API3D_TEXTURE_NT2) id+=f->nT2;
				id=id<<SFT;
				if (LMV) if (typ&API3D_TEXCOO3BUMP) id+=LMV->nt;
				id=id<<2;
				id+=f->ref;

                if (id!=previd)
                {
                    tmp=mapgroups[id];
                    previd=id;
                }
                
				if (tmp->array[f->tag]==NULL) tmp->array[f->tag]=new int[obj->nFaces];
				tmp->array[f->tag][tmp->narray[f->tag]++]=n;
			}
			vb->UnlockVertices();

			vb->LockIndices();
			tmp=mapgroups.GetFirst();
			n=0;
			while (tmp)
			{
				id=mapgroups.GetId();

				for (tg=0;tg<=TAG;tg++)
				{
					if (tmp->narray[tg]>0)
					{
						nfo.tag=tg;
						nfo.iStart=n*3;
						nfo.ref=(id&0x3);
						if (typ&API3D_TEXCOO3BUMP) nfo.nLV=((id>>2)&0x1FF);
						if (typ&API3D_TEXCOO2LIGHTMAP) nfo.nL=(id>>(SFT+2))&0x1FF;
						if (typ&API3D_TEXCOODATAS2) nfo.nT2=(id>>(SFT+2))&0x1FF;
						if (typ&API3D_TEXTURE_NT2) nfo.nT2=(id>>(SFT+2))&0x1FF;
						if (typ&API3D_ENVMAPPING) nfo.nT2=(id>>(SFT+2))&0x1FF;
						nfo.nT=(id>>(SFT+SFT+2))&0x7FF;
						vmin=100000000;
						vmax=-1;

						for (int k=0;k<tmp->narray[tg];k++)
						{
							i[0]=corres[obj->Faces[tmp->array[tg][k]].tag][obj->Faces[tmp->array[tg][k]].v0];
							i[1]=corres[obj->Faces[tmp->array[tg][k]].tag][obj->Faces[tmp->array[tg][k]].v1];
							i[2]=corres[obj->Faces[tmp->array[tg][k]].tag][obj->Faces[tmp->array[tg][k]].v2];
                            if (i[0]>vmax) vmax=i[0];
                            if (i[0]<vmin) vmin=i[0];
                            if (i[1]>vmax) vmax=i[1];
                            if (i[1]<vmin) vmin=i[1];
                            if (i[2]>vmax) vmax=i[2];
                            if (i[2]<vmin) vmin=i[2];
							vb->SetIndices(n,i[0],i[1],i[2]);
							n++;
						}
						
						vmin-=1;
						if (vmin<0) vmin=0;
						vmax+=1;
						if (vmax>nv) vmax=nv;
						nfo.vStart=vmin;
						nfo.vEnd=vmax;
						nfo.iEnd=n*3;
						vb->ListeSE.Add(nfo);
					}
				}

				tmp=mapgroups.GetNext();
			}
			vb->UnlockIndices();

			for (tag=0;tag<=TAG;tag++) delete [] corres[tag];

			tmp=mapgroups.GetFirst();
			while (tmp)
			{
				for (tg=0;tg<8;tg++) { if (tmp->array[tg]) delete [] tmp->array[tg]; }
				tmp=mapgroups.GetNext();
			}
			mapgroups.Free();
			vb->Grouped=true;
		}
	}

	CIndicesSE *se=vb->ListeSE.GetFirst();
	while (se)
	{
		if (se->ref!=0)
		{
			vb->HasRef=true;
			return vb;
		}
		se=vb->ListeSE.GetNext();
	}

	vb->HasRef=false;

	return vb;
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		material functions associated with textures

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void CMaterial::setAmbient(float r,float g,float b,float a)
{
	if (this)
	{
		ambient[0]=r;
		ambient[1]=g;
		ambient[2]=b;
		ambient[3]=a;
	}
}

void CMaterial::setDiffuse(float r,float g,float b,float a)
{
	if (this)
	{
		diffuse[0]=r;
		diffuse[1]=g;
		diffuse[2]=b;
		diffuse[3]=a;
	}
}

void CMaterial::setSpecular(float r,float g,float b,float a)
{
	if (this)
	{

		specular[0]=r;
		specular[1]=g;
		specular[2]=b;
		specular[3]=a;
	}
}

void CMaterial::setPower(int p)
{
	if (this) power=p;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

		load proj matrix

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::LoadProjMatrix(CMatrix M)
{
	PROJ=M;
#ifdef API3D_OPENGL
//------------------------------------------------------------------------------------------------ OPEN GL -----------
    GLfloat m[16];

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	m[0 + 4* 0]= M.a[0][0];
	m[1 + 4* 0]= M.a[0][1];
	m[2 + 4* 0]= M.a[0][2];
	m[3 + 4* 0]= M.a[0][3];

	m[0 + 4* 1]= M.a[1][0];
	m[1 + 4* 1]= M.a[1][1];
	m[2 + 4* 1]= M.a[1][2];
	m[3 + 4* 1]= M.a[1][3];

	m[0 + 4* 2]= M.a[2][0];
	m[1 + 4* 2]= M.a[2][1];
	m[2 + 4* 2]= M.a[2][2];
	m[3 + 4* 2]= M.a[2][3];

	m[0 + 4* 3]= M.a[3][0];
	m[1 + 4* 3]= M.a[3][1];
	m[2 + 4* 3]= M.a[3][2];
	m[3 + 4* 3]= M.a[3][3];

    glLoadMatrixf(m);

    glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

#endif
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
#if defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_METAL)
	projectionMatrix=M;
#else
	D3DXMATRIX m;

	m._11=M.a[0][0];
	m._12=M.a[0][1];
	m._13=M.a[0][2];
	m._14=M.a[0][3];

	m._21=M.a[1][0];
	m._22=M.a[1][1];
	m._23=M.a[1][2];
	m._24=M.a[1][3];

	m._31=M.a[2][0];
	m._32=M.a[2][1];
	m._33=M.a[2][2];
	m._34=M.a[2][3];

	m._41=M.a[3][0];
	m._42=M.a[3][1];
	m._43=M.a[3][2];
	m._44=M.a[3][3];
#ifdef API3D_DIRECT3D10
	projectionMatrix=m;
#else
	D3DDevice->SetTransform(D3DTS_PROJECTION,&m);
#endif
#endif
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	void C3DAPIBASE::SetTextureGroup(char *group)

	define texture group

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTextureGroup(char *group)
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	TextureContainer->setGroup(group);
#else
	NameGroup=group;
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	void C3DAPIBASE::GetTextureGroup(char *group)

	define texture group

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

char * C3DAPIBASE::GetTextureGroup()
{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	return TextureContainer->getGroup();
#else
	return NameGroup;
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	void C3DAPIBASE::SetScreenRatio(float ratio)

	set ratio for larger screen

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetScreenRatio(float ratio)
{
	SCREEN_Ratio=ratio;
}

#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
void C3DAPIBASE::SetTextureContainer(CTextureAPIContainer * tc)
{
	Flush();
	TextureContainer=tc;
	tc->init(this);
	cTexture.setTCAPI(tc);
	iTexture.setTCAPI(tc);
	Texture.setTCAPI(tc);
}


void C3DAPIBASE::SetLightmapContainer(CTextureAPIContainer * tc)
{
	Flush();
	LightmapContainer=tc;
	tc->init(this);
	Lightmap.setTCAPI(tc);
	iLightmap.setTCAPI(tc);
	cLightmap.setTCAPI(tc);
}

#endif

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	CRGBA C3DAPIBASE::Lighting(CVector v,CVector N)
	
	calculate color

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::Light(CVector v,CVector N,float *cr,float *cg,float *cb)
{
	int n;
	float r,g,b;
	CVector u,Nm;
	float d,a,s;

	Nm=N;
	VECTORNORMALISE(Nm);	

	r=Ambient.r;
	g=Ambient.g;
	b=Ambient.b;

	for (n=0;n<nLights;n++)
	{
		if (Lights[n].enabled)
		{
			VECTORSUB(u,Lights[n].Pos,v);
			d=VECTORNORM(u);
			u/=d;
			s=DOT(u,Nm);
			if (d>Lights[n].Range) a=0;
			else
			{
				a=1.0f/(Lights[n].Attenuation*d);
				if (s<0) a=0;
			}

			r+=Lights[n].r*s*a;
			g+=Lights[n].g*s*a;
			b+=Lights[n].b*s*a;
		}
	}

	*cr=r;
	*cg=g;
	*cb=b;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	CRGBA C3DAPIBASE::Lighting(int nl,CVector v,CVector N)
	
	calculate color from one light

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::Light(int nl,CVector v,CVector N,float *cr,float *cg,float *cb)
{	
	float r,g,b;
	CVector u,Nm;
	float d,a,s;

	Nm=N;
	VECTORNORMALISE(Nm);

	r=g=b=0.0f;

	VECTORSUB(u,Lights[nl].Pos,v);
	d=VECTORNORM(u);
	u/=d;
	s=DOT(u,Nm);
	if (d>Lights[nl].Range) a=0;
	else
	{
		a=1.0f/(Lights[nl].Attenuation*d);
		if (s<0) a=0;
	}

	r+=Lights[nl].r*s*a;
	g+=Lights[nl].g*s*a;
	b+=Lights[nl].b*s*a;

	*cr=r;
	*cg=g;
	*cb=b;
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:


  void C3DAPIBASE::SetProjection2D(float x0,float y0,float dim_x,float dim_y,float n,float f)
	
	2D projection

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
#if defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_METAL)
void OrthoMatrix(CMatrix * ret,float l,float r,float b,float t,float n,float f,float med)
{
    float    Q;

/*
2/(r-l)      0            0           0
0            2/(t-b)      0           0
0            0            1/(zf-zn)   0
(l+r)/(l-r)  (t+b)/(b-t)  zn/(zn-zf)  1
*/
	
	Q=med/(f-n);
 
    ret->a[0][1]=0;
	ret->a[0][2]=0;
	ret->a[0][3]=0;

	ret->a[1][0]=0;
	ret->a[1][2]=0;
	ret->a[1][3]=0;

	ret->a[2][0]=0;
	ret->a[2][1]=0;
	ret->a[3][3]=0;


	ret->a[0][0]=med*2.0f/(r-l);
	ret->a[1][1]=med*2.0f/(t-b);

	ret->a[3][0]=med*(l+r)/(l-r);
	ret->a[3][1]=med*(t+b)/(b-t);

	ret->a[2][2]=Q;
	ret->a[3][2]=-Q*n;
	ret->a[2][3]=1.0f;

}
#else
void OrthoMatrix(D3DMATRIX * ret,float l,float r,float b,float t,float n,float f,float med)
{
    float    Q;

/*
2/(r-l)      0            0           0
0            2/(t-b)      0           0
0            0            1/(zf-zn)   0
(l+r)/(l-r)  (t+b)/(b-t)  zn/(zn-zf)  1
*/
	
	Q=med/(f-n);
 
    ret->_12=0;
	ret->_13=0;
	ret->_14=0;

	ret->_21=0;
	ret->_23=0;
	ret->_24=0;

	ret->_31=0;
	ret->_32=0;
	ret->_44=0;


	ret->_11=med*2.0f/(r-l);
	ret->_22=med*2.0f/(t-b);

	ret->_41=med*(l+r)/(l-r);
	ret->_42=med*(t+b)/(b-t);

	ret->_33=Q;
	ret->_43=-Q*n;
	ret->_34=1.0f;

}
#endif
#else
void OrthoMatrix(CMatrix *ret,float l,float r,float b,float t,float n,float f,float med)
{
    float    Q;
	
	Q=med/(f-n);
	
    ret->Id();
	
	ret->a[0][0]=med*2.0f/(r-l);
	ret->a[1][1]=med*2.0f/(t-b);
	
	ret->a[3][0]=med*(l+r)/(l-r);
	ret->a[3][1]=med*(t+b)/(b-t);
	
	ret->a[2][2]=Q;
	ret->a[3][2]=-Q*n;
	ret->a[2][3]=1.0f;
	
	ret->a[3][3]=1.0f;
}
#endif


void C3DAPIBASE::SetProjection2D(float x0,float y0,float dim_x,float dim_y,float n,float f,float z_plan2d)
{
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    UpdateLines();
#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
#if defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_METAL)

	worldMatrix.Id();
	viewMatrix.Id();
	OrthoMatrix(&projectionMatrix,x0,x0+dim_x,y0+dim_y,y0,n,f,z_plan2d);

#else
	D3DXMATRIX Id,proj;
	D3DXMatrixIdentity(&Id);

#ifdef API3D_DIRECT3D10
	worldMatrix=Id;
	viewMatrix=Id;
	OrthoMatrix(&proj,x0,x0+dim_x,y0+dim_y,y0,n,f,z_plan2d);
	projectionMatrix=proj;
#else
	D3DDevice->SetTransform(D3DTS_WORLD,&Id);
	D3DDevice->SetTransform(D3DTS_VIEW,&Id);

	OrthoMatrix(&proj,x0,x0+dim_x,y0+dim_y,y0,n,f,z_plan2d);
//	D3DXMatrixOrthoOffCenterLH(&proj,x0,x0+dim_x,y0+dim_y,y0,n,f);
	D3DDevice->SetTransform(D3DTS_PROJECTION,&proj);
#endif
#endif
#else
#if defined(API3D_OPENGL)
	GLfloat m[16];
	CMatrix M;
	
	OrthoMatrix(&M,x0,x0+dim_x,y0+dim_y,y0,n,f,z_plan2d);

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	
	m[0 + 4* 0]= M.a[0][0];
	m[1 + 4* 0]= M.a[0][1];
	m[2 + 4* 0]= M.a[0][2];
	m[3 + 4* 0]= M.a[0][3];
	
	m[0 + 4* 1]= M.a[1][0];
	m[1 + 4* 1]= M.a[1][1];
	m[2 + 4* 1]= M.a[1][2];
	m[3 + 4* 1]= M.a[1][3];
	
	m[0 + 4* 2]= M.a[2][0];
	m[1 + 4* 2]= M.a[2][1];
	m[2 + 4* 2]= M.a[2][2];
	m[3 + 4* 2]= M.a[2][3];
	
	m[0 + 4* 3]= M.a[3][0];
	m[1 + 4* 3]= M.a[3][1];
	m[2 + 4* 3]= M.a[3][2];
	m[3 + 4* 3]= M.a[3][3];
	
    glLoadMatrixf(m);
	
	PROJ=M;
	
    glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	
	VIEW.Id();
	pVIEW.Id();
	WORLD.Id();
#endif
#if defined(API3D_OPENGL20)
	CMatrix M;
	
	OrthoMatrix(&M,x0,x0+dim_x,y0+dim_y,y0,n,f,z_plan2d);

	projection[0 + 4* 0]= M.a[0][0];
	projection[1 + 4* 0]= M.a[0][1];
	projection[2 + 4* 0]= M.a[0][2];
	projection[3 + 4* 0]= M.a[0][3];
	
	projection[0 + 4* 1]= M.a[1][0];
	projection[1 + 4* 1]= M.a[1][1];
	projection[2 + 4* 1]= M.a[1][2];
	projection[3 + 4* 1]= M.a[1][3];
	
	projection[0 + 4* 2]= M.a[2][0];
	projection[1 + 4* 2]= M.a[2][1];
	projection[2 + 4* 2]= M.a[2][2];
	projection[3 + 4* 2]= M.a[2][3];
	
	projection[0 + 4* 3]= M.a[3][0];
	projection[1 + 4* 3]= M.a[3][1];
	projection[2 + 4* 3]= M.a[3][2];
	projection[3 + 4* 3]= M.a[3][3];

	PROJ=M;	
	VIEW.Id();
	pVIEW.Id();
	WORLD.Id();
#endif


#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

  void C3DAPIBASE::LoadMatrix2D(CMatrix M);


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::LoadMatrix2D(CMatrix MM)
{
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)

#if defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_METAL)
	viewMatrix=MM*MAIN_MATRIX2D;
#else
	CMatrix M;
	D3DMATRIX m;

	M=MM*MAIN_MATRIX2D;

	m._11=M.a[0][0];m._12=M.a[0][1];m._13=M.a[0][2];m._14=M.a[0][3];
	m._21=M.a[1][0];m._22=M.a[1][1];m._23=M.a[1][2];m._24=M.a[1][3];
	m._31=M.a[2][0];m._32=M.a[2][1];m._33=M.a[2][2];m._34=M.a[2][3];
	m._41=M.a[3][0];m._42=M.a[3][1];m._43=M.a[3][2];m._44=M.a[3][3];

#ifdef API3D_DIRECT3D10
	viewMatrix=m;
#else
	D3DDevice->SetTransform(D3DTS_VIEW,&m);
#endif
#endif
#else
#ifdef API3D_OPENGL20
	CMatrix M;
	
	M=MM*MAIN_MATRIX2D;
	
	modelview[0 + 4* 0]= M.a[0][0];
	modelview[1 + 4* 0]= M.a[0][1];
	modelview[2 + 4* 0]= M.a[0][2];
	modelview[3 + 4* 0]= M.a[0][3];
	
	modelview[0 + 4* 1]= M.a[1][0];
	modelview[1 + 4* 1]= M.a[1][1];
	modelview[2 + 4* 1]= M.a[1][2];
	modelview[3 + 4* 1]= M.a[1][3];
	
	modelview[0 + 4* 2]= M.a[2][0];
	modelview[1 + 4* 2]= M.a[2][1];
	modelview[2 + 4* 2]= M.a[2][2];
	modelview[3 + 4* 2]= M.a[2][3];
	
	modelview[0 + 4* 3]= M.a[3][0];
	modelview[1 + 4* 3]= M.a[3][1];
	modelview[2 + 4* 3]= M.a[3][2];
	modelview[3 + 4* 3]= M.a[3][3];
	
	VIEW=M;
	pVIEW=M;
#endif

#ifdef API3D_OPENGL
	GLfloat m[16];
	CMatrix M;
	
	M=MM*MAIN_MATRIX2D;
	
	glMatrixMode(GL_MODELVIEW);
	
	m[0 + 4* 0]= M.a[0][0];
	m[1 + 4* 0]= M.a[0][1];
	m[2 + 4* 0]= M.a[0][2];
	m[3 + 4* 0]= M.a[0][3];
	
	m[0 + 4* 1]= M.a[1][0];
	m[1 + 4* 1]= M.a[1][1];
	m[2 + 4* 1]= M.a[1][2];
	m[3 + 4* 1]= M.a[1][3];
	
	m[0 + 4* 2]= M.a[2][0];
	m[1 + 4* 2]= M.a[2][1];
	m[2 + 4* 2]= M.a[2][2];
	m[3 + 4* 2]= M.a[2][3];
	
	m[0 + 4* 3]= M.a[3][0];
	m[1 + 4* 3]= M.a[3][1];
	m[2 + 4* 3]= M.a[3][2];
	m[3 + 4* 3]= M.a[3][3];
	
    glLoadMatrixf(m);
	
	VIEW=M;
	pVIEW=M;
#endif

#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

  void C3DAPIBASE::LoadMatrix2D(CMatrix M);


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::LoadMainMatrix2D(CMatrix M)
{
	MAIN_MATRIX2D=M;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

  CVector4 C3DAPIBASE::Project(CVector v)
  

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

CVector4 C3DAPIBASE::Project(CVector v)
{
	CVector4 vec;
	vec.Init(v);

	vec=vec*WORLD;
	vec=vec*VIEW;
	vec=vec*PROJ;
	vec=vec*VIEWPORT;

	return vec;
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

  CVector2 C3DAPIBASE::Project2D(CVector v)
  

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

CVector2 C3DAPIBASE::Project2D(CVector v)
{
	CVector2 proj;
	CVector4 vec;
	vec.Init(v);

	vec=vec*WORLD;
	vec=vec*VIEW;
	vec=vec*PROJ;
	vec=vec*VIEWPORT;

	proj.x=vec.x;
	proj.y=vec.y;
	return proj;
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

  void C3DAPIBASE::Flush()
  

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::Flush()
{
    if (whileFlush) return;

	///////////////////////////////////////////////////////// Quads pseudo 3D
	if ((nMultiQuadsXYZ>0)&&(nMultiQuads<=0))
	{
#if defined(API3D_DIRECT3D12)
        dirtyCRCState=true;
#endif
        vbquadsXYZ.nVerticesActif=nMultiQuadsXYZ*4;
		vbquadsXYZ.nIndicesActif=nMultiQuadsXYZ*3*2;
        vbquadsXYZ.UnlockVertices();

        whileFlush=true;

		CVertexBuffer * actual=ActualVertexBuffer;
		CVertexBuffer * eff=ActualEffect;
        
		if (OverClassQuadZ)
		{
#ifdef API3D_DIRECT3D9
			OverClassQuadZ->setTexture("Tex",aT);
#else
			if (lT<0) OverClassQuadZ->setTexture("Tex",aT);
			else OverClassQuadZ->setLightmap("Tex",lT);
#endif		 
			OverClassQuadZ->setFloat("ALPHA",val_alphatest);
            OverClassQuadZ->setMatrix("PROJ",ProjOrtho);
			SetEffect(OverClassQuadZ);

			SetVertexBuffer(&vbquadsXYZ);
			DrawVertexBuffer();
		}

		ActualVertexBuffer=actual;
		ActualEffect=eff;
		vbquadsXYZ.LockVertices();
        
#if defined(API3D_DIRECT3D12)
        dirtyCRCState=true;
#endif
		nMultiQuadsXYZ=0;
		whileFlush=false;
	}

#if !defined(API3D_OPENGL)
#if defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)||defined(API3D_METAL)
 
    if (!vbdraw_line)
    {
        UpdateLines();
    }

	///////////////////////////////////////////////////////// Quads Normal
	if (nMultiQuads>0)
	{
#if defined(API3D_DIRECT3D12)
        dirtyCRCState=true;
#endif
        vbquads.nVerticesActif=nMultiQuads*4;
		vbquads.nIndicesActif=nMultiQuads*3*2;
        vbquads.UnlockVertices();

        whileFlush=true;

		CVertexBuffer * actual=ActualVertexBuffer;
		CVertexBuffer * eff=ActualEffect;
        
		if (OverClassQuadZ)
		{
			if (lT<0) OverClassQuadZ->setTexture("Tex",aT);
			else OverClassQuadZ->setLightmap("Tex",lT);
			 
			OverClassQuadZ->setFloat("ALPHA",val_alphatest);
            OverClassQuadZ->setMatrix("PROJ",ProjOrtho);
			SetEffect(OverClassQuadZ);
		}
		else
		{
			if (set_alphatest)
			{
				if (lT<0) effect_hll_quads_alphatest.setTexture("Tex",aT);
				else effect_hll_quads_alphatest.setLightmap("Tex",lT);

				effect_hll_quads_alphatest.setFloat("ALPHA",val_alphatest);
				effect_hll_quads_alphatest.setMatrix("PROJ",ProjOrtho);
				SetEffect(&effect_hll_quads_alphatest);
			}
			else
			{
				if (aT<0)
				{
					effect_hll_quads_snd.setTexture("Tex",aT);
					effect_hll_quads_snd.setMatrix("PROJ",ProjOrtho);
					SetEffect(&effect_hll_quads_snd);
				}
				else
				{
					if (states(RENDER_BLEND_NO_ALPHA))
					{
						if (lT<0) effect_hll_quads_blend.setTexture("Tex",aT);
						else effect_hll_quads_blend.setLightmap("Tex",lT);
						effect_hll_quads_blend.setMatrix("PROJ",ProjOrtho);
						SetEffect(&effect_hll_quads_blend);
					}
					else
					{
						if (lT<0) effect_hll_quads.setTexture("Tex",aT);
						else effect_hll_quads.setLightmap("Tex",lT);
						effect_hll_quads.setMatrix("PROJ",ProjOrtho);
						SetEffect(&effect_hll_quads);
					}
				}
			}
		}
        if (OverClassQuadZ==NULL)
            if (MultiQuadsZbuffer==0) SetParams(API3D_ZBUFFER,OFF);
		SetVertexBuffer(&vbquads);

		DrawVertexBuffer();
        if (OverClassQuadZ==NULL)
            if (MultiQuadsZbuffer==0) SetParams(API3D_ZBUFFER,ON);
		ActualVertexBuffer=actual;
		ActualEffect=eff;
		vbquads.LockVertices();
#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)
		MultiQuads=(struct CUSTOMVERTEX0 *)vbquads.pVertices;
#endif
        
#if defined(API3D_DIRECT3D12)
        dirtyCRCState=true;
#endif

		nMultiQuads=0;
		MultiQuadsZbuffer=0;
        
		whileFlush=false;
	}
#ifdef API3D_METAL
    MTLFlush();
#endif
#else

	if (nMultiQuads>0)
	{
//------------------------------------------------------------------------------------------------ DIRECT3D ----------
		whileFlush=true;

		vbquads.UnlockVertices();
		vbquads.nIndicesActif=nMultiQuads*3*2;
	
		CVertexBuffer * actual=ActualVertexBuffer;
		CVertexBuffer * eff=ActualEffect;

		if (OverClassQuadZ)
		{
			OverClassQuadZ->setTexture("Tex",aT);
			OverClassQuadZ->setFloat("ALPHA",val_alphatest);
			OverClassQuadZ->setMatrix("PROJ",ProjOrtho);
			SetEffect(OverClassQuadZ);
		}
		else
		{
			if (set_alphatest)
			{
				D3DDevice->SetRenderState(D3DRS_ALPHATESTENABLE,TRUE);
				int av=(int)(val_alphatest*255);
				D3DDevice->SetRenderState(D3DRS_ALPHAREF,av);
				
			}

			QuadEffect->setTexture("Tex",aT);	
			QuadEffect->setMatrix("PROJ",ProjOrtho);
			SetEffect(QuadEffect);
		}

		if (MultiQuadsZbuffer==0) SetParams(API3D_ZBUFFER,OFF);
		SetVertexBuffer(&vbquads);
		DrawVertexBuffer();
		if (MultiQuadsZbuffer==0) SetParams(API3D_ZBUFFER,ON);
		
		ActualVertexBuffer=actual;
		ActualEffect=eff;

		if (set_alphatest)
			D3DDevice->SetRenderState(D3DRS_ALPHATESTENABLE,FALSE);

		vbquads.LockVertices();

//		MultiQuads=(struct CUSTOMVERTEX0 *)vbquads.pVertices;

		nMultiQuads=0;
		MultiQuadsZbuffer=0;

		whileFlush=false;

/*
	#ifdef TOGGLE_ZBUFFER
		D3DDevice->SetRenderState(D3DRS_ZENABLE,D3DZB_FALSE);
		D3DDevice->SetRenderState(D3DRS_ZWRITEENABLE,0);
	#endif

	#ifdef API3D_DIRECT3D9
		D3DDevice->SetFVF( D3DFVF_CUSTOMVERTEX0 );
	#else
		D3DDevice->SetVertexShader( D3DFVF_CUSTOMVERTEX0 );
	#endif

		D3DDevice->DrawPrimitiveUP( D3DPT_TRIANGLELIST,nMultiQuads,MultiQuads ,sizeof(CUSTOMVERTEX0));

	#ifdef TOGGLE_ZBUFFER
		D3DDevice->SetRenderState(D3DRS_ZENABLE,D3DZB_TRUE);
		D3DDevice->SetRenderState(D3DRS_ZWRITEENABLE,1);
	#endif
		nMultiQuads=0;
/**/
	}

#endif
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

  void C3DAPIBASE::Blur(...)
  

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::Blur(float x,float y,float sx,float sy,float decal,float r,float g,float b,float a)
{
#if defined(API3D_OPENGL)||defined(WEBASM)

	Quad(x,y,sx,sy,	0.0f+decal,	0.0f+decal,	1.0f,		1.0f,		r,g,b,a);
	Quad(x,y,sx,sy,	0.0f,		0.0f+decal,	1.0f-decal,	1.0f,		r,g,b,a);
	Quad(x,y,sx,sy,	0.0f+decal,	0.0f,		1.0f,		1.0f-decal,	r,g,b,a);
	Quad(x,y,sx,sy,	0.0f,		0.0f,		1.0f-decal,	1.0f-decal,	r,g,b,a);

#endif

#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D12)

	vbquadblur.LockVertices();
	struct CUSTOMVERTEXBLUR * Vertices=(struct CUSTOMVERTEXBLUR *)vbquadblur.pVertices;

	float xx=x-VIEWPORT.a[3][0];
	float yy=y-VIEWPORT.a[3][1];

	float x1,y1,x2,y2;

	D3DCOLOR c=D3DCOLOR_COLORVALUE(r,g,b,a);

	Vertices[0].color=c;
	Vertices[1].color=c;
	Vertices[2].color=c;
	Vertices[3].color=c;

	Vertices[0].x=xx;
	Vertices[0].y=yy;
	Vertices[0].z=0.5f;

	Vertices[1].x=(xx+sx);
	Vertices[1].y=yy;
	Vertices[1].z=0.5f;

	Vertices[2].x=(xx+sx);
	Vertices[2].y=(yy+sy);
	Vertices[2].z=0.5f;

	Vertices[3].x=(xx);
	Vertices[3].y=(yy+sy);
	Vertices[3].z=0.5f;

	x1=0.0f+decal;y1=0.0f+decal;x2=1.0f;y2=1.0f;
	Vertices[0].xm0=x1;Vertices[0].ym0=y1;
	Vertices[1].xm0=x2;Vertices[1].ym0=y1;
	Vertices[2].xm0=x2;Vertices[2].ym0=y2;
	Vertices[3].xm0=x1;Vertices[3].ym0=y2;


	x1=0.0f;y1=0.0f+decal;x2=1.0f-decal;y2=1.0f;
	Vertices[0].xm1=x1;Vertices[0].ym1=y1;
	Vertices[1].xm1=x2;Vertices[1].ym1=y1;
	Vertices[2].xm1=x2;Vertices[2].ym1=y2;
	Vertices[3].xm1=x1;Vertices[3].ym1=y2;
		
		
	x1=0.0f+decal;y1=0.0f;x2=1.0f;y2=1.0f-decal;
	Vertices[0].xm2=x1;Vertices[0].ym2=y1;
	Vertices[1].xm2=x2;Vertices[1].ym2=y1;
	Vertices[2].xm2=x2;Vertices[2].ym2=y2;
	Vertices[3].xm2=x1;Vertices[3].ym2=y2;

		
	x1=0.0f;y1=0.0f;x2=1.0f-decal;y2=1.0f-decal;
	Vertices[0].xm3=x1;Vertices[0].ym3=y1;
	Vertices[1].xm3=x2;Vertices[1].ym3=y1;
	Vertices[2].xm3=x2;Vertices[2].ym3=y2;
	Vertices[3].xm3=x1;Vertices[3].ym3=y2;

	vbquadblur.UnlockVertices();

	whileFlush=true;
    
#if defined(API3D_DIRECT3D12)
    dirtyCRCState=true;
#endif

	CVertexBuffer * actual=ActualVertexBuffer;
	CVertexBuffer * eff=ActualEffect;

	effect_hll_quadblur.setTexture("Tex",aT);
	effect_hll_quadblur.setMatrix("PROJ",ProjOrtho);
	SetEffect(&effect_hll_quadblur);

	SetVertexBuffer(&vbquadblur);
	DrawVertexBuffer();

#if defined(API3D_DIRECT3D12)
    dirtyCRCState=true;
#endif

	ActualVertexBuffer=actual;
	ActualEffect=eff;

	whileFlush=false;

#endif


#if defined(API3D_OPENGL20)&&!defined(WEBASM)

    float xx,yy1,yy2;
    
	vbquadblur.LockVertices();
	xx=x-VIEWPORT.a[3][0];
    if (SelectedRenderTarget==-1)
    {
        yy1=y-VIEWPORT.a[3][1];
        yy2=(y+sy)-VIEWPORT.a[3][1];
        
    }
    else
    {
        yy1=VIEWPORT.a[1][1]*2-y-VIEWPORT.a[3][1];
        yy2=VIEWPORT.a[1][1]*2-(y+sy)-VIEWPORT.a[3][1];
        
    }

	float x1,y1,x2,y2;

	vbquadblur.SetColor(0,r,g,b,a);
	vbquadblur.SetColor(1,r,g,b,a);
	vbquadblur.SetColor(2,r,g,b,a);
	vbquadblur.SetColor(3,r,g,b,a);
	
	vbquadblur.SetVertex(0,xx,yy1,0.5f);
	vbquadblur.SetVertex(1,xx+sx,yy1,0.5f);
	vbquadblur.SetVertex(2,xx+sx,yy2,0.5f);
	vbquadblur.SetVertex(3,xx,yy2,0.5f);

	x1=0.0f+decal;y1=0.0f+decal;x2=1.0f;y2=1.0f;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo(0,x1,y1);
	vbquadblur.SetTexCoo(1,x2,y1);
	vbquadblur.SetTexCoo(2,x2,y2);
	vbquadblur.SetTexCoo(3,x1,y2);
	
	x1=0.0f;y1=0.0f+decal;x2=1.0f-decal;y2=1.0f;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo2(0,x1,y1);
	vbquadblur.SetTexCoo2(1,x2,y1);
	vbquadblur.SetTexCoo2(2,x2,y2);
	vbquadblur.SetTexCoo2(3,x1,y2);		
		
	x1=0.0f+decal;y1=0.0f;x2=1.0f;y2=1.0f-decal;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo3(0,x1,y1);
	vbquadblur.SetTexCoo3(1,x2,y1);
	vbquadblur.SetTexCoo3(2,x2,y2);
	vbquadblur.SetTexCoo3(3,x1,y2);
		
	x1=0.0f;y1=0.0f;x2=1.0f-decal;y2=1.0f-decal;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo4(0,x1,y1);
	vbquadblur.SetTexCoo4(1,x2,y1);
	vbquadblur.SetTexCoo4(2,x2,y2);
	vbquadblur.SetTexCoo4(3,x1,y2);

	vbquadblur.UnlockVertices();

	whileFlush=true;

	CVertexBuffer * actual=ActualVertexBuffer;
	CVertexBuffer * eff=ActualEffect;

	effect_hll_quadblur.setTexture("Tex",aT);
	effect_hll_quadblur.setMatrix("PROJ",ProjOrtho);
	SetEffect(&effect_hll_quadblur);

	SetVertexBuffer(&vbquadblur);
	DrawVertexBuffer();

	ActualVertexBuffer=actual;
	ActualEffect=eff;

	whileFlush=false;

#endif

#if defined(API3D_METAL)

    float xx,yy1,yy2;
    
	vbquadblur.LockVertices();
	xx=x-VIEWPORT.a[3][0];
    yy1=y-VIEWPORT.a[3][1];
    yy2=(y+sy)-VIEWPORT.a[3][1];
        
	float x1,y1,x2,y2;

	vbquadblur.SetColor(0,r,g,b,a);
	vbquadblur.SetColor(1,r,g,b,a);
	vbquadblur.SetColor(2,r,g,b,a);
	vbquadblur.SetColor(3,r,g,b,a);
	
	vbquadblur.SetVertex(0,xx,yy1,0.5f);
	vbquadblur.SetVertex(1,xx+sx,yy1,0.5f);
	vbquadblur.SetVertex(2,xx+sx,yy2,0.5f);
	vbquadblur.SetVertex(3,xx,yy2,0.5f);

	x1=0.0f+decal;y1=0.0f+decal;x2=1.0f;y2=1.0f;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo(0,x1,y1);
	vbquadblur.SetTexCoo(1,x2,y1);
	vbquadblur.SetTexCoo(2,x2,y2);
	vbquadblur.SetTexCoo(3,x1,y2);
	
	x1=0.0f;y1=0.0f+decal;x2=1.0f-decal;y2=1.0f;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo2(0,x1,y1);
	vbquadblur.SetTexCoo2(1,x2,y1);
	vbquadblur.SetTexCoo2(2,x2,y2);
	vbquadblur.SetTexCoo2(3,x1,y2);		
		
	x1=0.0f+decal;y1=0.0f;x2=1.0f;y2=1.0f-decal;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo3(0,x1,y1);
	vbquadblur.SetTexCoo3(1,x2,y1);
	vbquadblur.SetTexCoo3(2,x2,y2);
	vbquadblur.SetTexCoo3(3,x1,y2);
		
	x1=0.0f;y1=0.0f;x2=1.0f-decal;y2=1.0f-decal;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo4(0,x1,y1);
	vbquadblur.SetTexCoo4(1,x2,y1);
	vbquadblur.SetTexCoo4(2,x2,y2);
	vbquadblur.SetTexCoo4(3,x1,y2);

	vbquadblur.UnlockVertices();

	whileFlush=true;

	CVertexBuffer * actual=ActualVertexBuffer;
	CVertexBuffer * eff=ActualEffect;

	effect_hll_quadblur.setTexture("Tex",aT);
	effect_hll_quadblur.setMatrix("PROJ",ProjOrtho);
	SetEffect(&effect_hll_quadblur);

	SetVertexBuffer(&vbquadblur);
	DrawVertexBuffer();

	ActualVertexBuffer=actual;
	ActualEffect=eff;

	whileFlush=false;

#endif

#ifdef API3D_DIRECT3D
	const char psh_blur[] = 
		"ps.1.4\n"
		"def c0,1.0,0.0,0.0,0.0\n"
		"texld r0,t0\n"
		"texld r1,t1\n"
		"texld r2,t2\n"
		"texld r3,t3\n"
		"mul r0.rgb,r0,v0\n"
		"mad r0.rgb,r1,v0,r0\n"
		"mad r0.rgb,r2,v0,r0\n"
		"mad r0.rgb,r3,v0,r0\n"
		"mov r0.a,c0.r\n"
		"\n";

	if (G_PS)
	{
		float x1,y1,x2,y2;
		struct CUSTOMVERTEXBLUR Vertices[4];

		Vertices[0].color=D3DCOLOR_COLORVALUE(r,g,b,a);
		Vertices[1].color=Vertices[0].color;
		Vertices[2].color=Vertices[0].color;
		Vertices[3].color=Vertices[0].color;

		Vertices[0].x=x;
		Vertices[0].y=y;
		Vertices[0].rhw=(float) 2/(Front+Back);
		Vertices[0].z=0.5f;

		Vertices[1].x=(x+sx);
		Vertices[1].y=y;
		Vertices[1].rhw=Vertices[0].rhw;
		Vertices[1].z=0.5f;

		Vertices[2].x=(x+sx);
		Vertices[2].y=(y+sy);
		Vertices[2].rhw=Vertices[0].rhw;
		Vertices[2].z=0.5f;

		Vertices[3].x=(x);
		Vertices[3].y=(y+sy);
		Vertices[3].rhw=Vertices[0].rhw;
		Vertices[3].z=0.5f;


		x1=0.0f+decal;y1=0.0f+decal;x2=1.0f;y2=1.0f;
		Vertices[0].xm0=x1;Vertices[0].ym0=y1;
		Vertices[1].xm0=x2;Vertices[1].ym0=y1;
		Vertices[2].xm0=x2;Vertices[2].ym0=y2;
		Vertices[3].xm0=x1;Vertices[3].ym0=y2;


		x1=0.0f;y1=0.0f+decal;x2=1.0f-decal;y2=1.0f;
		Vertices[0].xm1=x1;Vertices[0].ym1=y1;
		Vertices[1].xm1=x2;Vertices[1].ym1=y1;
		Vertices[2].xm1=x2;Vertices[2].ym1=y2;
		Vertices[3].xm1=x1;Vertices[3].ym1=y2;
		
		
		x1=0.0f+decal;y1=0.0f;x2=1.0f;y2=1.0f-decal;
		Vertices[0].xm2=x1;Vertices[0].ym2=y1;
		Vertices[1].xm2=x2;Vertices[1].ym2=y1;
		Vertices[2].xm2=x2;Vertices[2].ym2=y2;
		Vertices[3].xm2=x1;Vertices[3].ym2=y2;

		
		x1=0.0f;y1=0.0f;x2=1.0f-decal;y2=1.0f-decal;
		Vertices[0].xm3=x1;Vertices[0].ym3=y1;
		Vertices[1].xm3=x2;Vertices[1].ym3=y1;
		Vertices[2].xm3=x2;Vertices[2].ym3=y2;
		Vertices[3].xm3=x1;Vertices[3].ym3=y2;


		D3DDevice->SetVertexShader( D3DFVF_CUSTOMVERTEXBLUR );

		if (PixelShaderBlur==0)
		{
			LPD3DXBUFFER pCode;
			LPD3DXBUFFER pErrors;
			D3DXAssembleShader(psh_blur,sizeof(psh_blur)-1,0,NULL,&pCode,&pErrors);
			D3DDevice->CreatePixelShader((DWORD*)pCode->GetBufferPointer(),&PixelShaderBlur);
		}
		D3DDevice->SetPixelShader(PixelShaderBlur);

		D3DDevice->GetTexture(0,&Texture0);
		D3DDevice->SetTexture(1,Texture0);
		D3DDevice->SetTexture(2,Texture0);
		D3DDevice->SetTexture(3,Texture0);


		D3DDevice->DrawPrimitiveUP( D3DPT_TRIANGLEFAN,2,Vertices,sizeof(CUSTOMVERTEXBLUR));

		D3DDevice->SetTexture(1,NULL);
		D3DDevice->SetTexture(2,NULL);
		D3DDevice->SetTexture(3,NULL);

		D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

		D3DDevice->SetPixelShader(NULL);


		Texture0->Release();

	}
	else
	{
		Quad(x,y,sx,sy,	0.0f+decal,	0.0f+decal,	1.0f,		1.0f,		r,g,b,a);
		Quad(x,y,sx,sy,	0.0f,		0.0f+decal,	1.0f-decal,	1.0f,		r,g,b,a);
		Quad(x,y,sx,sy,	0.0f+decal,	0.0f,		1.0f,		1.0f-decal,	r,g,b,a);
		Quad(x,y,sx,sy,	0.0f,		0.0f,		1.0f-decal,	1.0f-decal,	r,g,b,a);
	}
#endif

#ifdef API3D_DIRECT3D9

const char psh_blur[] = 
		"ps.1.4\n"
		"def c0,1.0,0.0,0.0,0.0\n"
		"texld r0,t0\n"
		"texld r1,t1\n"
		"texld r2,t2\n"
		"texld r3,t3\n"
		"mul r0.rgb,r0,v0\n"
		"mad r0.rgb,r1,v0,r0\n"
		"mad r0.rgb,r2,v0,r0\n"
		"mad r0.rgb,r3,v0,r0\n"
		"mov r0.a,c0.r\n"
		"\n";

	if (G_PS)
	{
		float x1,y1,x2,y2;
		struct CUSTOMVERTEXBLUR Vertices[4];

		Vertices[0].color=D3DCOLOR_COLORVALUE(r,g,b,a);
		Vertices[1].color=Vertices[0].color;
		Vertices[2].color=Vertices[0].color;
		Vertices[3].color=Vertices[0].color;

		Vertices[0].x=x;
		Vertices[0].y=y;
		Vertices[0].rhw=(float) 2/(Front+Back);
		Vertices[0].z=0.5f;

		Vertices[1].x=(x+sx);
		Vertices[1].y=y;
		Vertices[1].rhw=Vertices[0].rhw;
		Vertices[1].z=0.5f;

		Vertices[2].x=(x+sx);
		Vertices[2].y=(y+sy);
		Vertices[2].rhw=Vertices[0].rhw;
		Vertices[2].z=0.5f;

		Vertices[3].x=(x);
		Vertices[3].y=(y+sy);
		Vertices[3].rhw=Vertices[0].rhw;
		Vertices[3].z=0.5f;


		x1=0.0f+decal;y1=0.0f+decal;x2=1.0f;y2=1.0f;
		Vertices[0].xm0=x1;Vertices[0].ym0=y1;
		Vertices[1].xm0=x2;Vertices[1].ym0=y1;
		Vertices[2].xm0=x2;Vertices[2].ym0=y2;
		Vertices[3].xm0=x1;Vertices[3].ym0=y2;


		x1=0.0f;y1=0.0f+decal;x2=1.0f-decal;y2=1.0f;
		Vertices[0].xm1=x1;Vertices[0].ym1=y1;
		Vertices[1].xm1=x2;Vertices[1].ym1=y1;
		Vertices[2].xm1=x2;Vertices[2].ym1=y2;
		Vertices[3].xm1=x1;Vertices[3].ym1=y2;
		
		
		x1=0.0f+decal;y1=0.0f;x2=1.0f;y2=1.0f-decal;
		Vertices[0].xm2=x1;Vertices[0].ym2=y1;
		Vertices[1].xm2=x2;Vertices[1].ym2=y1;
		Vertices[2].xm2=x2;Vertices[2].ym2=y2;
		Vertices[3].xm2=x1;Vertices[3].ym2=y2;

		
		x1=0.0f;y1=0.0f;x2=1.0f-decal;y2=1.0f-decal;
		Vertices[0].xm3=x1;Vertices[0].ym3=y1;
		Vertices[1].xm3=x2;Vertices[1].ym3=y1;
		Vertices[2].xm3=x2;Vertices[2].ym3=y2;
		Vertices[3].xm3=x1;Vertices[3].ym3=y2;


		D3DDevice->SetFVF( D3DFVF_CUSTOMVERTEXBLUR );

		if (PixelShaderBlur==0)
		{
			LPD3DXBUFFER pCode;
			LPD3DXBUFFER pErrors;
			D3DXAssembleShader(psh_blur,sizeof(psh_blur)-1,NULL,NULL,0,&pCode,&pErrors);
			D3DDevice->CreatePixelShader((DWORD*)pCode->GetBufferPointer(),&PixelShaderBlur);
		}
		D3DDevice->SetPixelShader(PixelShaderBlur);

		D3DDevice->GetTexture(0,&Texture0);
		D3DDevice->SetTexture(1,Texture0);
		D3DDevice->SetTexture(2,Texture0);
		D3DDevice->SetTexture(3,Texture0);


		D3DDevice->DrawPrimitiveUP( D3DPT_TRIANGLEFAN,2,Vertices,sizeof(CUSTOMVERTEXBLUR));

		D3DDevice->SetTexture(1,NULL);
		D3DDevice->SetTexture(2,NULL);
		D3DDevice->SetTexture(3,NULL);

		D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

		D3DDevice->SetPixelShader(NULL);

		Texture0->Release();
	}
	else
	{
		Quad(x,y,sx,sy,	0.0f+decal,	0.0f+decal,	1.0f,		1.0f,		r,g,b,a);
		Quad(x,y,sx,sy,	0.0f,		0.0f+decal,	1.0f-decal,	1.0f,		r,g,b,a);
		Quad(x,y,sx,sy,	0.0f+decal,	0.0f,		1.0f,		1.0f-decal,	r,g,b,a);
		Quad(x,y,sx,sy,	0.0f,		0.0f,		1.0f-decal,	1.0f-decal,	r,g,b,a);
	}
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

  void C3DAPIBASE::Blur(...)
  

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */


void C3DAPIBASE::Blur(float x,float y,float sx,float sy,float decalx,float decaly,float r,float g,float b,float a)
{
#if defined(API3D_OPENGL)||defined(WEBASM)

	Quad(x,y,sx,sy,	0.0f+decalx,	0.0f+decaly,	1.0f,			1.0f,			r,g,b,a);
	Quad(x,y,sx,sy,	0.0f,			0.0f+decaly,	1.0f-decalx,	1.0f,			r,g,b,a);
	Quad(x,y,sx,sy,	0.0f+decalx,	0.0f,			1.0f,			1.0f-decaly,	r,g,b,a);
	Quad(x,y,sx,sy,	0.0f,			0.0f,			1.0f-decalx,	1.0f-decaly,	r,g,b,a);

#endif

#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)

	vbquadblur.LockVertices();
	struct CUSTOMVERTEXBLUR * Vertices=(struct CUSTOMVERTEXBLUR *)vbquadblur.pVertices;

	float xx=x-VIEWPORT.a[3][0];
	float yy=y-VIEWPORT.a[3][1];

	float x1,y1,x2,y2;

	D3DCOLOR c=D3DCOLOR_COLORVALUE(r,g,b,a);

	Vertices[0].color=c;
	Vertices[1].color=c;
	Vertices[2].color=c;
	Vertices[3].color=c;

	Vertices[0].x=xx;
	Vertices[0].y=yy;
	Vertices[0].z=0.5f;

	Vertices[1].x=(xx+sx);
	Vertices[1].y=yy;
	Vertices[1].z=0.5f;

	Vertices[2].x=(xx+sx);
	Vertices[2].y=(yy+sy);
	Vertices[2].z=0.5f;

	Vertices[3].x=(xx);
	Vertices[3].y=(yy+sy);
	Vertices[3].z=0.5f;

	x1=0.0f+decalx;y1=0.0f+decaly;x2=1.0f;y2=1.0f;
	Vertices[0].xm0=x1;Vertices[0].ym0=y1;
	Vertices[1].xm0=x2;Vertices[1].ym0=y1;
	Vertices[2].xm0=x2;Vertices[2].ym0=y2;
	Vertices[3].xm0=x1;Vertices[3].ym0=y2;


	x1=0.0f;y1=0.0f+decaly;x2=1.0f-decalx;y2=1.0f;
	Vertices[0].xm1=x1;Vertices[0].ym1=y1;
	Vertices[1].xm1=x2;Vertices[1].ym1=y1;
	Vertices[2].xm1=x2;Vertices[2].ym1=y2;
	Vertices[3].xm1=x1;Vertices[3].ym1=y2;
		
		
	x1=0.0f+decalx;y1=0.0f;x2=1.0f;y2=1.0f-decaly;
	Vertices[0].xm2=x1;Vertices[0].ym2=y1;
	Vertices[1].xm2=x2;Vertices[1].ym2=y1;
	Vertices[2].xm2=x2;Vertices[2].ym2=y2;
	Vertices[3].xm2=x1;Vertices[3].ym2=y2;

		
	x1=0.0f;y1=0.0f;x2=1.0f-decalx;y2=1.0f-decaly;
	Vertices[0].xm3=x1;Vertices[0].ym3=y1;
	Vertices[1].xm3=x2;Vertices[1].ym3=y1;
	Vertices[2].xm3=x2;Vertices[2].ym3=y2;
	Vertices[3].xm3=x1;Vertices[3].ym3=y2;

	vbquadblur.UnlockVertices();

	whileFlush=true;

	CVertexBuffer * actual=ActualVertexBuffer;
	CVertexBuffer * eff=ActualEffect;

	effect_hll_quadblur.setTexture("Tex",aT);
	effect_hll_quadblur.setMatrix("PROJ",ProjOrtho);
	SetEffect(&effect_hll_quadblur);

	SetVertexBuffer(&vbquadblur);
	DrawVertexBuffer();

	ActualVertexBuffer=actual;
	ActualEffect=eff;

	whileFlush=false;

#endif

#if defined(API3D_OPENGL20)&&!defined(WEBASM)

    float xx,yy1,yy2;
    
	vbquadblur.LockVertices();
	xx=x-VIEWPORT.a[3][0];
    if (SelectedRenderTarget==-1)
    {
        yy1=y-VIEWPORT.a[3][1];
        yy2=(y+sy)-VIEWPORT.a[3][1];
        
    }
    else
    {
        yy1=VIEWPORT.a[1][1]*2-y-VIEWPORT.a[3][1];
        yy2=VIEWPORT.a[1][1]*2-(y+sy)-VIEWPORT.a[3][1];
        
    }

	float x1,y1,x2,y2;

	vbquadblur.SetColor(0,r,g,b,a);
	vbquadblur.SetColor(1,r,g,b,a);
	vbquadblur.SetColor(2,r,g,b,a);
	vbquadblur.SetColor(3,r,g,b,a);
	
	vbquadblur.SetVertex(0,xx,yy1,0.5f);
	vbquadblur.SetVertex(1,xx+sx,yy1,0.5f);
	vbquadblur.SetVertex(2,xx+sx,yy2,0.5f);
	vbquadblur.SetVertex(3,xx,yy2,0.5f);

	x1=0.0f+decalx;y1=0.0f+decaly;x2=1.0f;y2=1.0f;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo(0,x1,y1);
	vbquadblur.SetTexCoo(1,x2,y1);
	vbquadblur.SetTexCoo(2,x2,y2);
	vbquadblur.SetTexCoo(3,x1,y2);

	x1=0.0f;y1=0.0f+decaly;x2=1.0f-decalx;y2=1.0f;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo2(0,x1,y1);
	vbquadblur.SetTexCoo2(1,x2,y1);
	vbquadblur.SetTexCoo2(2,x2,y2);
	vbquadblur.SetTexCoo2(3,x1,y2);		
		
	x1=0.0f+decalx;y1=0.0f;x2=1.0f;y2=1.0f-decaly;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo3(0,x1,y1);
	vbquadblur.SetTexCoo3(1,x2,y1);
	vbquadblur.SetTexCoo3(2,x2,y2);
	vbquadblur.SetTexCoo3(3,x1,y2);
		
	x1=0.0f;y1=0.0f;x2=1.0f-decalx;y2=1.0f-decaly;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo4(0,x1,y1);
	vbquadblur.SetTexCoo4(1,x2,y1);
	vbquadblur.SetTexCoo4(2,x2,y2);
	vbquadblur.SetTexCoo4(3,x1,y2);

	vbquadblur.UnlockVertices();

	whileFlush=true;

	CVertexBuffer * actual=ActualVertexBuffer;
	CVertexBuffer * eff=ActualEffect;

	effect_hll_quadblur.setTexture("Tex",aT);
	effect_hll_quadblur.setMatrix("PROJ",ProjOrtho);
	SetEffect(&effect_hll_quadblur);

	SetVertexBuffer(&vbquadblur);
	DrawVertexBuffer();

	ActualVertexBuffer=actual;
	ActualEffect=eff;

	whileFlush=false;

#endif

#if defined(API3D_METAL)

    float xx,yy1,yy2;
    
	vbquadblur.LockVertices();
	xx=x-VIEWPORT.a[3][0];
    yy1=y-VIEWPORT.a[3][1];
    yy2=(y+sy)-VIEWPORT.a[3][1];
        
	float x1,y1,x2,y2;

	vbquadblur.SetColor(0,r,g,b,a);
	vbquadblur.SetColor(1,r,g,b,a);
	vbquadblur.SetColor(2,r,g,b,a);
	vbquadblur.SetColor(3,r,g,b,a);
	
	vbquadblur.SetVertex(0,xx,yy1,0.5f);
	vbquadblur.SetVertex(1,xx+sx,yy1,0.5f);
	vbquadblur.SetVertex(2,xx+sx,yy2,0.5f);
	vbquadblur.SetVertex(3,xx,yy2,0.5f);

	x1=0.0f+decalx;y1=0.0f+decaly;x2=1.0f;y2=1.0f;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo(0,x1,y1);
	vbquadblur.SetTexCoo(1,x2,y1);
	vbquadblur.SetTexCoo(2,x2,y2);
	vbquadblur.SetTexCoo(3,x1,y2);

	x1=0.0f;y1=0.0f+decaly;x2=1.0f-decalx;y2=1.0f;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo2(0,x1,y1);
	vbquadblur.SetTexCoo2(1,x2,y1);
	vbquadblur.SetTexCoo2(2,x2,y2);
	vbquadblur.SetTexCoo2(3,x1,y2);		
		
	x1=0.0f+decalx;y1=0.0f;x2=1.0f;y2=1.0f-decaly;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo3(0,x1,y1);
	vbquadblur.SetTexCoo3(1,x2,y1);
	vbquadblur.SetTexCoo3(2,x2,y2);
	vbquadblur.SetTexCoo3(3,x1,y2);
		
	x1=0.0f;y1=0.0f;x2=1.0f-decalx;y2=1.0f-decaly;
    if (aT<0) { y1=1-y1; y2=1-y2; }
	vbquadblur.SetTexCoo4(0,x1,y1);
	vbquadblur.SetTexCoo4(1,x2,y1);
	vbquadblur.SetTexCoo4(2,x2,y2);
	vbquadblur.SetTexCoo4(3,x1,y2);

	vbquadblur.UnlockVertices();

	whileFlush=true;

	CVertexBuffer * actual=ActualVertexBuffer;
	CVertexBuffer * eff=ActualEffect;

	effect_hll_quadblur.setTexture("Tex",aT);
	effect_hll_quadblur.setMatrix("PROJ",ProjOrtho);
	SetEffect(&effect_hll_quadblur);

	SetVertexBuffer(&vbquadblur);
	DrawVertexBuffer();

	ActualVertexBuffer=actual;
	ActualEffect=eff;

	whileFlush=false;

#endif

#ifdef API3D_DIRECT3D
	const char psh_blur[] = 
		"ps.1.4\n"
		"def c0,1.0,0.0,0.0,0.0\n"
		"texld r0,t0\n"
		"texld r1,t1\n"
		"texld r2,t2\n"
		"texld r3,t3\n"
		"mul r0.rgb,r0,v0\n"
		"mad r0.rgb,r1,v0,r0\n"
		"mad r0.rgb,r2,v0,r0\n"
		"mad r0.rgb,r3,v0,r0\n"
		"mov r0.a,c0.r\n"
		"\n";

	if (G_PS)
	{
		float x1,y1,x2,y2;
		struct CUSTOMVERTEXBLUR Vertices[4];

		Vertices[0].color=D3DCOLOR_COLORVALUE(r,g,b,a);
		Vertices[1].color=Vertices[0].color;
		Vertices[2].color=Vertices[0].color;
		Vertices[3].color=Vertices[0].color;

		Vertices[0].x=x;
		Vertices[0].y=y;
		Vertices[0].rhw=(float) 2/(Front+Back);
		Vertices[0].z=0.5f;

		Vertices[1].x=(x+sx);
		Vertices[1].y=y;
		Vertices[1].rhw=Vertices[0].rhw;
		Vertices[1].z=0.5f;

		Vertices[2].x=(x+sx);
		Vertices[2].y=(y+sy);
		Vertices[2].rhw=Vertices[0].rhw;
		Vertices[2].z=0.5f;

		Vertices[3].x=(x);
		Vertices[3].y=(y+sy);
		Vertices[3].rhw=Vertices[0].rhw;
		Vertices[3].z=0.5f;


		x1=0.0f+decalx;y1=0.0f+decaly;x2=1.0f;y2=1.0f;
		Vertices[0].xm0=x1;Vertices[0].ym0=y1;
		Vertices[1].xm0=x2;Vertices[1].ym0=y1;
		Vertices[2].xm0=x2;Vertices[2].ym0=y2;
		Vertices[3].xm0=x1;Vertices[3].ym0=y2;


		x1=0.0f;y1=0.0f+decaly;x2=1.0f-decalx;y2=1.0f;
		Vertices[0].xm1=x1;Vertices[0].ym1=y1;
		Vertices[1].xm1=x2;Vertices[1].ym1=y1;
		Vertices[2].xm1=x2;Vertices[2].ym1=y2;
		Vertices[3].xm1=x1;Vertices[3].ym1=y2;
		
		
		x1=0.0f+decalx;y1=0.0f;x2=1.0f;y2=1.0f-decaly;
		Vertices[0].xm2=x1;Vertices[0].ym2=y1;
		Vertices[1].xm2=x2;Vertices[1].ym2=y1;
		Vertices[2].xm2=x2;Vertices[2].ym2=y2;
		Vertices[3].xm2=x1;Vertices[3].ym2=y2;

		
		x1=0.0f;y1=0.0f;x2=1.0f-decalx;y2=1.0f-decaly;
		Vertices[0].xm3=x1;Vertices[0].ym3=y1;
		Vertices[1].xm3=x2;Vertices[1].ym3=y1;
		Vertices[2].xm3=x2;Vertices[2].ym3=y2;
		Vertices[3].xm3=x1;Vertices[3].ym3=y2;


		D3DDevice->SetVertexShader( D3DFVF_CUSTOMVERTEXBLUR );

		if (PixelShaderBlur==0)
		{
			LPD3DXBUFFER pCode;
			LPD3DXBUFFER pErrors;
			D3DXAssembleShader(psh_blur,sizeof(psh_blur)-1,0,NULL,&pCode,&pErrors);
			D3DDevice->CreatePixelShader((DWORD*)pCode->GetBufferPointer(),&PixelShaderBlur);
		}
		D3DDevice->SetPixelShader(PixelShaderBlur);

		D3DDevice->GetTexture(0,&Texture0);
		D3DDevice->SetTexture(1,Texture0);
		D3DDevice->SetTexture(2,Texture0);
		D3DDevice->SetTexture(3,Texture0);


		D3DDevice->DrawPrimitiveUP( D3DPT_TRIANGLEFAN,2,Vertices,sizeof(CUSTOMVERTEXBLUR));

		D3DDevice->SetTexture(1,NULL);
		D3DDevice->SetTexture(2,NULL);
		D3DDevice->SetTexture(3,NULL);

		D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

		D3DDevice->SetPixelShader(NULL);


		Texture0->Release();

	}
	else
	{
		Quad(x,y,sx,sy,	0.0f+decal,	0.0f+decal,	1.0f,		1.0f,		r,g,b,a);
		Quad(x,y,sx,sy,	0.0f,		0.0f+decal,	1.0f-decal,	1.0f,		r,g,b,a);
		Quad(x,y,sx,sy,	0.0f+decal,	0.0f,		1.0f,		1.0f-decal,	r,g,b,a);
		Quad(x,y,sx,sy,	0.0f,		0.0f,		1.0f-decal,	1.0f-decal,	r,g,b,a);
	}
#endif

#ifdef API3D_DIRECT3D9

const char psh_blur[] = 
		"ps.1.4\n"
		"def c0,1.0,0.0,0.0,0.0\n"
		"texld r0,t0\n"
		"texld r1,t1\n"
		"texld r2,t2\n"
		"texld r3,t3\n"
		"mul r0.rgb,r0,v0\n"
		"mad r0.rgb,r1,v0,r0\n"
		"mad r0.rgb,r2,v0,r0\n"
		"mad r0.rgb,r3,v0,r0\n"
		"mov r0.a,c0.r\n"
		"\n";

	if (G_PS)
	{
		float x1,y1,x2,y2;
		struct CUSTOMVERTEXBLUR Vertices[4];

		Vertices[0].color=D3DCOLOR_COLORVALUE(r,g,b,a);
		Vertices[1].color=Vertices[0].color;
		Vertices[2].color=Vertices[0].color;
		Vertices[3].color=Vertices[0].color;

		Vertices[0].x=x;
		Vertices[0].y=y;
		Vertices[0].rhw=(float) 2/(Front+Back);
		Vertices[0].z=0.5f;

		Vertices[1].x=(x+sx);
		Vertices[1].y=y;
		Vertices[1].rhw=Vertices[0].rhw;
		Vertices[1].z=0.5f;

		Vertices[2].x=(x+sx);
		Vertices[2].y=(y+sy);
		Vertices[2].rhw=Vertices[0].rhw;
		Vertices[2].z=0.5f;

		Vertices[3].x=(x);
		Vertices[3].y=(y+sy);
		Vertices[3].rhw=Vertices[0].rhw;
		Vertices[3].z=0.5f;


		x1=0.0f+decalx;y1=0.0f+decaly;x2=1.0f;y2=1.0f;
		Vertices[0].xm0=x1;Vertices[0].ym0=y1;
		Vertices[1].xm0=x2;Vertices[1].ym0=y1;
		Vertices[2].xm0=x2;Vertices[2].ym0=y2;
		Vertices[3].xm0=x1;Vertices[3].ym0=y2;


		x1=0.0f;y1=0.0f+decaly;x2=1.0f-decalx;y2=1.0f;
		Vertices[0].xm1=x1;Vertices[0].ym1=y1;
		Vertices[1].xm1=x2;Vertices[1].ym1=y1;
		Vertices[2].xm1=x2;Vertices[2].ym1=y2;
		Vertices[3].xm1=x1;Vertices[3].ym1=y2;
		
		
		x1=0.0f+decalx;y1=0.0f;x2=1.0f;y2=1.0f-decaly;
		Vertices[0].xm2=x1;Vertices[0].ym2=y1;
		Vertices[1].xm2=x2;Vertices[1].ym2=y1;
		Vertices[2].xm2=x2;Vertices[2].ym2=y2;
		Vertices[3].xm2=x1;Vertices[3].ym2=y2;

		
		x1=0.0f;y1=0.0f;x2=1.0f-decalx;y2=1.0f-decaly;
		Vertices[0].xm3=x1;Vertices[0].ym3=y1;
		Vertices[1].xm3=x2;Vertices[1].ym3=y1;
		Vertices[2].xm3=x2;Vertices[2].ym3=y2;
		Vertices[3].xm3=x1;Vertices[3].ym3=y2;


		D3DDevice->SetFVF( D3DFVF_CUSTOMVERTEXBLUR );

		if (PixelShaderBlur==0)
		{
			LPD3DXBUFFER pCode;
			LPD3DXBUFFER pErrors;
			D3DXAssembleShader(psh_blur,sizeof(psh_blur)-1,NULL,NULL,0,&pCode,&pErrors);
			D3DDevice->CreatePixelShader((DWORD*)pCode->GetBufferPointer(),&PixelShaderBlur);
		}
		D3DDevice->SetPixelShader(PixelShaderBlur);

		D3DDevice->GetTexture(0,&Texture0);
		D3DDevice->SetTexture(1,Texture0);
		D3DDevice->SetTexture(2,Texture0);
		D3DDevice->SetTexture(3,Texture0);


		D3DDevice->DrawPrimitiveUP( D3DPT_TRIANGLEFAN,2,Vertices,sizeof(CUSTOMVERTEXBLUR));

		D3DDevice->SetTexture(1,NULL);
		D3DDevice->SetTexture(2,NULL);
		D3DDevice->SetTexture(3,NULL);

		D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

		D3DDevice->SetPixelShader(NULL);

		Texture0->Release();
	}
	else
	{
		Quad(x,y,sx,sy,	0.0f+decalx,	0.0f+decaly,	1.0f,			1.0f,			r,g,b,a);
		Quad(x,y,sx,sy,	0.0f,			0.0f+decaly,	1.0f-decalx,	1.0f,			r,g,b,a);
		Quad(x,y,sx,sy,	0.0f+decalx,	0.0f,			1.0f,			1.0f-decaly,	r,g,b,a);
		Quad(x,y,sx,sy,	0.0f,			0.0f,			1.0f-decalx,	1.0f-decaly,	r,g,b,a);
	}
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

  void C3DAPIBASE::DoBump(...)

  draw multi layer bump mapping on primary render surface
  

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::DoBump(float x,float y,float sx,float sy,int nt_tex,int nt_color,int nt_bump,int nt_lightdir,float r,float g,float b,float a)
{

	int n;
	int active_surface=GetSurfaceActive();
	float x1[4],x2[4],y1[4],y2[4];
	int tex[4];

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)

	tex[0]=nt_color;
	tex[1]=nt_bump;
	tex[2]=nt_lightdir;
	tex[3]=nt_tex;

	if (states(LAYER_DIMENSION)==0)
	{
		for (n=0;n<4;n++)
		{
			if (tex[n]>=0) { x1[n]=0.0f;y1[n]=0.0f;x2[n]=1.0f;y2[n]=1.0f; }
			else { x1[n]=0.0f;y1[n]=1.0f;x2[n]=1.0f;y2[n]=0.0f; }
		}
	}
	else
	{
		for (n=0;n<4;n++)
		{
			if (tex[n]>=0) { x1[n]=0.0f;y1[n]=0.0f;x2[n]=1.0f;y2[n]=1.0f; }
			else 
			{ 
				x1[n]=0.0f;
				y1[n]=(float) SCREEN_Y/tile_secondarysurfacesW[-1-tex[n]];
				x2[n]=(float) SCREEN_X/tile_secondarysurfacesH[-1-tex[n]];
				y2[n]=0.0f; 
			}
		}
	}

#else
#if !defined(API3D_DIRECT3D10)&&!defined(API3D_DIRECT3D11)&&!defined(API3D_DIRECT3D12)
	float xx1,yy1,xx2,yy2;
#endif
	tex[0]=nt_color;
	tex[1]=nt_bump;
	tex[2]=nt_lightdir;
	tex[3]=nt_tex;

	if (states(LAYER_DIMENSION)==0)
	{
		for (n=0;n<4;n++)
		{
			x1[n]=0.0f;y1[n]=0.0f;x2[n]=1.0f;y2[n]=1.0f;
		}
	}
	else
	{
		for (n=0;n<4;n++)
		{
			if (tex[n]>=0) { x1[n]=0.0f;y1[n]=0.0f;x2[n]=1.0f;y2[n]=1.0f; }
			else 
			{ 
				x1[n]=0.0f;
				y1[n]=0.0f; 
				x2[n]=((float) SCREEN_X)/tile_secondarysurfacesW[-1-tex[n]];
				y2[n]=((float) SCREEN_Y)/tile_secondarysurfacesH[-1-tex[n]];
			}
		}
	}

#endif

#if defined(API3D_DIRECT3D11) || defined(API3D_DIRECT3D10) || defined(API3D_OPENGL20) || defined(API3D_METAL) || defined(API3D_DIRECT3D12)

	float xx=x-VIEWPORT.a[3][0];
	float yy=y-VIEWPORT.a[3][1];

	vbquadblur.LockVertices();

	vbquadblur.SetColor(0,r,g,b,a);
	vbquadblur.SetColor(1,r,g,b,a);
	vbquadblur.SetColor(2,r,g,b,a);
	vbquadblur.SetColor(3,r,g,b,a);
	
	vbquadblur.SetVertex(0,xx,yy,0.5f);
	vbquadblur.SetVertex(1,xx+sx,yy,0.5f);
	vbquadblur.SetVertex(2,xx+sx,yy+sy,0.5f);
	vbquadblur.SetVertex(3,xx,yy+sy,0.5f);

	vbquadblur.SetTexCoo(0,x1[0],y1[0]);
	vbquadblur.SetTexCoo(1,x2[0],y1[0]);
	vbquadblur.SetTexCoo(2,x2[0],y2[0]);
	vbquadblur.SetTexCoo(3,x1[0],y2[0]);

	vbquadblur.SetTexCoo2(0,x1[1],y1[1]);
	vbquadblur.SetTexCoo2(1,x2[1],y1[1]);
	vbquadblur.SetTexCoo2(2,x2[1],y2[1]);
	vbquadblur.SetTexCoo2(3,x1[1],y2[1]);

	vbquadblur.SetTexCoo3(0,x1[2],y1[2]);
	vbquadblur.SetTexCoo3(1,x2[2],y1[2]);
	vbquadblur.SetTexCoo3(2,x2[2],y2[2]);
	vbquadblur.SetTexCoo3(3,x1[2],y2[2]);

	vbquadblur.SetTexCoo4(0,x1[3],y1[3]);
	vbquadblur.SetTexCoo4(1,x2[3],y1[3]);
	vbquadblur.SetTexCoo4(2,x2[3],y2[3]);
	vbquadblur.SetTexCoo4(3,x1[3],y2[3]);
	
	vbquadblur.UnlockVertices();

	whileFlush=true;

	CVertexBuffer * actual=ActualVertexBuffer;
	CVertexBuffer * eff=ActualEffect;

	effect_hll_quadbump.setTexture("Colors",tex[0]);
	effect_hll_quadbump.setTexture("Bump",tex[1]);
	effect_hll_quadbump.setTexture("Vectors",tex[2]);
	effect_hll_quadbump.setTexture("Tex",tex[3]);

	effect_hll_quadbump.setMatrix("PROJ",ProjOrtho);
	SetEffect(&effect_hll_quadbump);

	SetVertexBuffer(&vbquadblur);
	DrawVertexBuffer();

	ActualVertexBuffer=actual;
	ActualEffect=eff;

	whileFlush=false;

#endif

#ifdef API3D_OPENGL
#ifndef GLES
	const char fp_bump[]=
		"!!ARBfp1.0\n"
		"PARAM half = { 0.5, 0.5, 0.5, 0.0 };\n"
		"TEMP r0;\n"
		"TEMP r1;\n"
		"TEMP r2;\n"
		"TEMP r3;\n"
		"TEMP r4;\n"
		"TEX r0,fragment.texcoord[0],texture[0],2D;\n"
		"TEX r1,fragment.texcoord[1],texture[1],2D;\n"
		"TEX r2,fragment.texcoord[2],texture[2],2D;\n"
		"TEX r3,fragment.texcoord[3],texture[3],2D;\n"
		"SUB r1,r1,half;\n"
		"SUB r2,r2,half;\n"
		"ADD r1,r1,r1;\n"
		"ADD r2,r2,r2;\n"
		"DP3 r4,r1,r2;\n"
		"MUL r0,r0,r4;\n"
		"MUL r0,r0,r3;\n"
		"MUL r0,r0,fragment.color;\n"
		"MOV result.color.rgb,r0;\n"
		"MOV result.color.a,fragment.color.a;\n"
		"END\n";

	bool fp=false;
	
	if ((G_PS)&&(PixelShaderBump!=0xFFFFFFFF))
	{
		GLint errorPos,isNative;

		if (PixelShaderBump==0)
		{
			glEnable(GL_FRAGMENT_PROGRAM_ARB);
			int len=strlen(fp_bump);
			glGenProgramsARB(1,&PixelShaderBump);
			glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB,PixelShaderBump);
			glProgramStringARB(GL_FRAGMENT_PROGRAM_ARB,GL_PROGRAM_FORMAT_ASCII_ARB,len,(const void*)fp_bump);
			glGetIntegerv(GL_PROGRAM_ERROR_POSITION_ARB,&errorPos);
			glGetProgramivARB(GL_FRAGMENT_PROGRAM_ARB,GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB,&isNative);
			if ((errorPos==-1)&&(isNative==1)) fp=true;
			else 
			{
				glDeleteProgramsARB(1,&PixelShaderBump); 
				PixelShaderBump=0xFFFFFFFF;
			}
			glDisable(GL_FRAGMENT_PROGRAM_ARB);
		}
		else fp=true;

		if (fp)
		{
			for (n=0;n<4;n++)
			{
				glActiveTextureARB(GL_TEXTURE0_ARB+n);
				glEnable(GL_TEXTURE_2D);
				if (tex[n]>=0) glBindTexture(GL_TEXTURE_2D,Texture[tex[n]]);
				else
				{
#ifdef OPENGL_PBUFFERS
					pbufferBind(-(tex[n]+1));
#endif
#ifdef OPENGL_FRAMEBUFFERS
					glBindTexture(GL_TEXTURE_2D,renderedTexture[-(tex[n]+1)]);
#endif
				}
				glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);
			}

			glMatrixMode(GL_PROJECTION);
			glPushMatrix();
			glMatrixMode(GL_MODELVIEW);
			glPushMatrix();
			glMatrixMode(GL_PROJECTION);
			glLoadIdentity();
			glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
			glMatrixMode(GL_MODELVIEW);
			glLoadIdentity();

			glDisable(GL_DEPTH_TEST);

			glEnable(GL_FRAGMENT_PROGRAM_ARB);
			glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB,PixelShaderBump);

			glBegin(GL_QUADS);

			glColor4f(r,g,b,a);

			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1[0],y1[0]);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,x1[1],y1[1]);
			glMultiTexCoord2fARB(GL_TEXTURE2_ARB,x1[2],y1[2]);
			glMultiTexCoord2fARB(GL_TEXTURE3_ARB,x1[3],y1[3]);
			glVertex3f((float) x,(float) (SCREEN_Y-y),0);

			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2[0],y1[0]);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,x2[1],y1[1]);
			glMultiTexCoord2fARB(GL_TEXTURE2_ARB,x2[2],y1[2]);
			glMultiTexCoord2fARB(GL_TEXTURE3_ARB,x2[3],y1[3]);
			glVertex3f((float) (x+sx),(float) (SCREEN_Y-y),0);

			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2[0],y2[0]);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,x2[1],y2[1]);
			glMultiTexCoord2fARB(GL_TEXTURE2_ARB,x2[2],y2[2]);
			glMultiTexCoord2fARB(GL_TEXTURE3_ARB,x2[3],y2[3]);
			glVertex3f((float) (x+sx),(float) (SCREEN_Y-(y+sy)),0);

			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1[0],y2[0]);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,x1[1],y2[1]);
			glMultiTexCoord2fARB(GL_TEXTURE2_ARB,x1[2],y2[2]);
			glMultiTexCoord2fARB(GL_TEXTURE3_ARB,x1[3],y2[3]);
			glVertex3f((float) x,(float) (SCREEN_Y-(y+sy)),0);

			glEnd();

			glDisable(GL_FRAGMENT_PROGRAM_ARB);

			glMatrixMode(GL_MODELVIEW);
			glPopMatrix();
			glMatrixMode(GL_PROJECTION);
			glPopMatrix();

			glEnable(GL_DEPTH_TEST);

			glActiveTextureARB(GL_TEXTURE0_ARB);

#ifdef OPENGL_PBUFFERS
			if (tex[0]<0) pbufferRelease(-(tex[0]+1));
#endif
			glDisable(GL_TEXTURE_2D);

			glActiveTextureARB(GL_TEXTURE1_ARB);
#ifdef OPENGL_PBUFFERS
			if (tex[1]<0) pbufferRelease(-(tex[1]+1));
#endif
			glDisable(GL_TEXTURE_2D);

			glActiveTextureARB(GL_TEXTURE2_ARB);
#ifdef OPENGL_PBUFFERS
			if (tex[2]<0) pbufferRelease(-(tex[2]+1));
#endif
			glDisable(GL_TEXTURE_2D);

			glActiveTextureARB(GL_TEXTURE3_ARB);
#ifdef OPENGL_PBUFFERS
			if (tex[3]<0) pbufferRelease(-(tex[3]+1));
#endif
			glDisable(GL_TEXTURE_2D);
		}
	}

	if (!fp)
	{
		SetTexture(tex[0]);
		SetTexture2(tex[3]);

		glMatrixMode(GL_PROJECTION);
		glPushMatrix();
		glMatrixMode(GL_MODELVIEW);
		glPushMatrix();
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
		glMatrixMode(GL_MODELVIEW);
		glLoadIdentity();
		glDisable(GL_DEPTH_TEST);

		glBegin(GL_QUADS);

		glColor4f(r,g,b,a);

		glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1[0],y1[0]);
		glMultiTexCoord2fARB(GL_TEXTURE1_ARB,x1[3],y1[3]);
		glVertex3f((float) x,(float) (SCREEN_Y-y),0);

		glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2[0],y1[0]);
		glMultiTexCoord2fARB(GL_TEXTURE1_ARB,x2[3],y1[3]);
		glVertex3f((float) (x+sx),(float) (SCREEN_Y-y),0);

		glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2[0],y2[0]);
		glMultiTexCoord2fARB(GL_TEXTURE1_ARB,x2[3],y2[3]);
		glVertex3f((float) (x+sx),(float) (SCREEN_Y-(y+sy)),0);

		glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1[0],y2[0]);
		glMultiTexCoord2fARB(GL_TEXTURE1_ARB,x1[3],y2[3]);
		glVertex3f((float) x,(float) (SCREEN_Y-(y+sy)),0);

		glEnd();

		glMatrixMode(GL_MODELVIEW);
		glPopMatrix();
		glMatrixMode(GL_PROJECTION);
		glPopMatrix();

		glEnable(GL_DEPTH_TEST);

		glActiveTextureARB(GL_TEXTURE0_ARB);
#ifdef OPENGL_PBUFFERS
		if (tex[0]<0) pbufferRelease(-(tex[0]+1));
#endif
		glDisable(GL_TEXTURE_2D);
		glActiveTextureARB(GL_TEXTURE1_ARB);
#ifdef OPENGL_PBUFFERS
		if (tex[3]<0) pbufferRelease(-(tex[3]+1));
#endif
		glDisable(GL_TEXTURE_2D);
	}
#endif
#endif

#ifdef API3D_DIRECT3D

	const char psh_bump[] = 
		"ps.1.4\n"
		"texld r0,t0\n"
		"texld r1,t1\n"
		"texld r2,t2\n"
		"texld r3,t3\n"
		"dp3 r4.rgb,r1_bx2,r2_bx2\n"
		"mul_x2 r0.rgb,r0,r4\n"
		"mul r0.rgb,r0,v0\n"
		"mul r0.rgb,r0,r3\n"
		"mov r0.a,v0.a\n"
		"\n";

	bool simple=false;

	if (G_PS)
	{
		struct CUSTOMVERTEXBLUR Vertices[4];

		Vertices[0].color=D3DCOLOR_COLORVALUE(r,g,b,a);
		Vertices[1].color=Vertices[0].color;
		Vertices[2].color=Vertices[0].color;
		Vertices[3].color=Vertices[0].color;

		Vertices[0].x=x;
		Vertices[0].y=y;
		Vertices[0].rhw=(float) 2/(Front+Back);
		Vertices[0].z=0.5f;

		Vertices[1].x=(x+sx);
		Vertices[1].y=y;
		Vertices[1].rhw=Vertices[0].rhw;
		Vertices[1].z=0.5f;

		Vertices[2].x=(x+sx);
		Vertices[2].y=(y+sy);
		Vertices[2].rhw=Vertices[0].rhw;
		Vertices[2].z=0.5f;

		Vertices[3].x=(x);
		Vertices[3].y=(y+sy);
		Vertices[3].rhw=Vertices[0].rhw;
		Vertices[3].z=0.5f;

		Vertices[0].xm0=x1[0];Vertices[0].ym0=y1[0];
		Vertices[1].xm0=x2[0];Vertices[1].ym0=y1[0];
		Vertices[2].xm0=x2[0];Vertices[2].ym0=y2[0];
		Vertices[3].xm0=x1[0];Vertices[3].ym0=y2[0];

		Vertices[0].xm1=x1[1];Vertices[0].ym1=y1[1];
		Vertices[1].xm1=x2[1];Vertices[1].ym1=y1[1];
		Vertices[2].xm1=x2[1];Vertices[2].ym1=y2[1];
		Vertices[3].xm1=x1[1];Vertices[3].ym1=y2[1];

		Vertices[0].xm2=x1[2];Vertices[0].ym2=y1[2];
		Vertices[1].xm2=x2[2];Vertices[1].ym2=y1[2];
		Vertices[2].xm2=x2[2];Vertices[2].ym2=y2[2];
		Vertices[3].xm2=x1[2];Vertices[3].ym2=y2[2];

		Vertices[0].xm3=x1[3];Vertices[0].ym3=y1[3];
		Vertices[1].xm3=x2[3];Vertices[1].ym3=y1[3];
		Vertices[2].xm3=x2[3];Vertices[2].ym3=y2[3];
		Vertices[3].xm3=x1[3];Vertices[3].ym3=y2[3];

		D3DDevice->SetVertexShader( D3DFVF_CUSTOMVERTEXBLUR );

		if (PixelShaderBump==0)
		{
			LPD3DXBUFFER pCode;
			LPD3DXBUFFER pErr;
			D3DXAssembleShader(psh_bump,sizeof(psh_bump)-1,0,NULL,&pCode,&pErr);
			D3DDevice->CreatePixelShader((DWORD*)pCode->GetBufferPointer(),&PixelShaderBump);
		}
		D3DDevice->SetPixelShader(PixelShaderBump);

		if (nt_color>=0) D3DDevice->SetTexture(0,Texture[nt_color]);
		else D3DDevice->SetTexture(0,D3DTextureSecondary[-(nt_color+1)]);

		if (nt_bump>=0) D3DDevice->SetTexture(1,Texture[nt_bump]);
		else D3DDevice->SetTexture(1,D3DTextureSecondary[-(nt_bump+1)]);

		if (nt_lightdir>=0) D3DDevice->SetTexture(2,Texture[nt_lightdir]);
		else D3DDevice->SetTexture(2,D3DTextureSecondary[-(nt_lightdir+1)]);

		if (nt_tex>=0) D3DDevice->SetTexture(3,Texture[nt_tex]);
		else D3DDevice->SetTexture(3,D3DTextureSecondary[-(nt_tex+1)]);

		if (states(LAYER_DIMENSION)==0)
		{
			D3DDevice->SetTextureStageState(0,D3DTSS_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(0,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetTextureStageState(0,D3DTSS_MINFILTER,D3DTEXF_LINEAR);

			D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(1,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetTextureStageState(1,D3DTSS_MINFILTER,D3DTEXF_LINEAR);

			D3DDevice->SetTextureStageState(2,D3DTSS_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(2,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetTextureStageState(2,D3DTSS_MINFILTER,D3DTEXF_LINEAR);

			D3DDevice->SetTextureStageState(3,D3DTSS_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(3,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetTextureStageState(3,D3DTSS_MINFILTER,D3DTEXF_LINEAR);
		}
		else
		{
			D3DDevice->SetTextureStageState(0,D3DTSS_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(0,D3DTSS_MAGFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(0,D3DTSS_MINFILTER,D3DTEXF_NONE);

			D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(1,D3DTSS_MAGFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(1,D3DTSS_MINFILTER,D3DTEXF_NONE);

			D3DDevice->SetTextureStageState(2,D3DTSS_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(2,D3DTSS_MAGFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(2,D3DTSS_MINFILTER,D3DTEXF_NONE);

			D3DDevice->SetTextureStageState(3,D3DTSS_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(3,D3DTSS_MAGFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(3,D3DTSS_MINFILTER,D3DTEXF_NONE);
		}

		D3DDevice->DrawPrimitiveUP( D3DPT_TRIANGLEFAN,2,Vertices,sizeof(CUSTOMVERTEXBLUR));


		D3DDevice->SetTextureStageState( 0,D3DTSS_TEXCOORDINDEX ,0);
		D3DDevice->SetTextureStageState( 1,D3DTSS_TEXCOORDINDEX ,1);
		D3DDevice->SetTextureStageState( 2,D3DTSS_TEXCOORDINDEX ,2);
		D3DDevice->SetTextureStageState( 3,D3DTSS_TEXCOORDINDEX ,3);

		D3DDevice->SetTexture(0,NULL);
		D3DDevice->SetTexture(1,NULL);
		D3DDevice->SetTexture(2,NULL);
		D3DDevice->SetTexture(3,NULL);

		if (states(LAYER_DIMENSION)==1)
		{
			D3DDevice->SetTextureStageState(0,D3DTSS_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(0,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetTextureStageState(0,D3DTSS_MINFILTER,D3DTEXF_LINEAR);

			D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(1,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetTextureStageState(1,D3DTSS_MINFILTER,D3DTEXF_LINEAR);

			D3DDevice->SetTextureStageState(2,D3DTSS_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(2,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetTextureStageState(2,D3DTSS_MINFILTER,D3DTEXF_LINEAR);

			D3DDevice->SetTextureStageState(3,D3DTSS_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetTextureStageState(3,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetTextureStageState(3,D3DTSS_MINFILTER,D3DTEXF_LINEAR);
		}

		D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

		D3DDevice->SetPixelShader(NULL);
	}
	else
	{
		D3DDevice->SetTextureStageState( 0,D3DTSS_TEXCOORDINDEX ,0);
		D3DDevice->SetTextureStageState( 1,D3DTSS_TEXCOORDINDEX ,1);

		if (G_Dot3)
		{			
			if (temporary_secondary_surface!=666)
			{
				SetParams(API3D_RENDERTARGET,temporary_secondary_surface);

				SetParams(API3D_BLEND,OFF);
				SetParams(API3D_CULL,OFF);

				SetTexture(nt_bump);
				SetTexture2(nt_lightdir);

				D3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );

				D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DOTPRODUCT3 );
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );

				D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
				D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_CURRENT );

				if (states(LAYER_DIMENSION)) Quad2(0,0,(float) sx,(float) sy,x1[1],y1[1],x2[1],y2[1],x1[2],y1[2],x2[2],y2[2],1,1,1,1);
				else Quad2(0,0,(float) GetWidth(),(float) GetHeight(),x1[1],y1[1],x2[1],y2[1],x1[2],y1[2],x2[2],y2[2],1,1,1,1);

				SetParams(API3D_TEXTURING,OFF);
				SetParams(API3D_TEXTURING2,OFF);
				SetTexture(nt_color);

				SetParams(API3D_BLEND,BLEND_COLOR);

				SetParams(API3D_CULL,OFF);

				if (states(LAYER_DIMENSION)) Quad(0,0,(float) sx,(float) sy,x1[0],y1[0],x2[0],y2[0],1,1,1,1);
				else Quad(0,0,(float) GetWidth(),(float) GetHeight(),x1[0],y1[0],x2[0],y2[0],1,1,1,1);

				SetParams(API3D_RENDERTARGET,active_surface);

				SetTexture(nt_tex);

				xx1=0.0f; yy1=0.0f; xx2=1.0f; yy2=1.0f;

				switch (temporary_secondary_surface)
				{
					case SECONDARY1:
						SetTexture2(SECONDARYTEXTURE1);
						break;
					case SECONDARY2:
						SetTexture2(SECONDARYTEXTURE2);
						break;
					case SECONDARY3:
						SetTexture2(SECONDARYTEXTURE3);
						break;
					case SECONDARY4:
						SetTexture2(SECONDARYTEXTURE4);
						break;
					case SECONDARY5:
						SetTexture2(SECONDARYTEXTURE5);
						break;
					case SECONDARY6:
						SetTexture2(SECONDARYTEXTURE6);
						break;
					case SECONDARY7:
						SetTexture2(SECONDARYTEXTURE7);
						break;
					case SECONDARY8:
						SetTexture2(SECONDARYTEXTURE8);
						break;
					case SECONDARY9:
						SetTexture2(SECONDARYTEXTURE9);
						break;
					case SECONDARY10:
						SetTexture2(SECONDARYTEXTURE10);
						break;
				};

				if (states(LAYER_DIMENSION)) 
				{ 
					xx1=0.0f; 
					yy1=0.0f; 
					xx2=(float) sx/tile_secondarysurfacesW[temporary_secondary_surface-SECONDARY1]; 
					yy2=(float) sy/tile_secondarysurfacesH[temporary_secondary_surface-SECONDARY1]; 
				}


				SetParams(API3D_BLEND,BLEND_GOURAUD);

				D3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );

				D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_MODULATE );
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );

				D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
				D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_CURRENT );
				
				SetParams(API3D_CULL,CCW);

				Quad2(x,y,sx,sy,x1[3],y1[3],x2[3],y2[3],xx1,yy1,xx2,yy2,r,g,b,a);
			}
			else simple=true;
		}
		else simple=true;
	}

	if (simple)
	{
		SetParams(API3D_RENDERTARGET,active_surface);
		SetParams(API3D_BLEND,BLEND_COLOR);
		SetParams(API3D_CULL,CCW);
		SetTexture(nt_tex);
		SetTexture2(nt_color);
		Quad2(x,y,sx,sy,x1[3],y1[3],x2[3],y2[3],x1[0],y1[0],x2[0],y2[0],r,g,b,a);
		SetParams(API3D_TEXTURING,OFF);
		SetParams(API3D_TEXTURING2,OFF);

	}

#endif

#ifdef API3D_DIRECT3D9

	const char psh_bump[] = 
		"ps.1.4\n"
		"texld r0,t0\n"
		"texld r1,t1\n"
		"texld r2,t2\n"
		"texld r3,t3\n"
		"dp3 r4.rgb,r1_bx2,r2_bx2\n"
		"mul_x2 r0.rgb,r0,r4\n"
		"mul r0.rgb,r0,v0\n"
		"mul r0.rgb,r0,r3\n"
		"mov r0.a,v0.a\n"
		"\n";

	bool simple=false;

	if (G_PS)
	{
		struct CUSTOMVERTEXBLUR Vertices[4];

		Vertices[0].color=D3DCOLOR_COLORVALUE(r,g,b,a);
		Vertices[1].color=Vertices[0].color;
		Vertices[2].color=Vertices[0].color;
		Vertices[3].color=Vertices[0].color;

		Vertices[0].x=x;
		Vertices[0].y=y;
		Vertices[0].rhw=(float) 2/(Front+Back);
		Vertices[0].z=0.5f;

		Vertices[1].x=(x+sx);
		Vertices[1].y=y;
		Vertices[1].rhw=Vertices[0].rhw;
		Vertices[1].z=0.5f;

		Vertices[2].x=(x+sx);
		Vertices[2].y=(y+sy);
		Vertices[2].rhw=Vertices[0].rhw;
		Vertices[2].z=0.5f;

		Vertices[3].x=(x);
		Vertices[3].y=(y+sy);
		Vertices[3].rhw=Vertices[0].rhw;
		Vertices[3].z=0.5f;
		
		Vertices[0].xm0=x1[0];Vertices[0].ym0=y1[0];
		Vertices[1].xm0=x2[0];Vertices[1].ym0=y1[0];
		Vertices[2].xm0=x2[0];Vertices[2].ym0=y2[0];
		Vertices[3].xm0=x1[0];Vertices[3].ym0=y2[0];

		Vertices[0].xm1=x1[1];Vertices[0].ym1=y1[1];
		Vertices[1].xm1=x2[1];Vertices[1].ym1=y1[1];
		Vertices[2].xm1=x2[1];Vertices[2].ym1=y2[1];
		Vertices[3].xm1=x1[1];Vertices[3].ym1=y2[1];

		Vertices[0].xm2=x1[2];Vertices[0].ym2=y1[2];
		Vertices[1].xm2=x2[2];Vertices[1].ym2=y1[2];
		Vertices[2].xm2=x2[2];Vertices[2].ym2=y2[2];
		Vertices[3].xm2=x1[2];Vertices[3].ym2=y2[2];

		Vertices[0].xm3=x1[3];Vertices[0].ym3=y1[3];
		Vertices[1].xm3=x2[3];Vertices[1].ym3=y1[3];
		Vertices[2].xm3=x2[3];Vertices[2].ym3=y2[3];
		Vertices[3].xm3=x1[3];Vertices[3].ym3=y2[3];

		D3DDevice->SetFVF( D3DFVF_CUSTOMVERTEXBLUR );

		if (PixelShaderBump==0)
		{
			LPD3DXBUFFER pCode;
			LPD3DXBUFFER pErr;
			D3DXAssembleShader(psh_bump,sizeof(psh_bump)-1,NULL,NULL,0,&pCode,&pErr);
			D3DDevice->CreatePixelShader((DWORD*)pCode->GetBufferPointer(),&PixelShaderBump);
		}
		D3DDevice->SetPixelShader(PixelShaderBump);

		if (nt_color>=0) D3DDevice->SetTexture(0,Texture[nt_color]);
		else D3DDevice->SetTexture(0,D3DTextureSecondary[-(nt_color+1)]);

		if (nt_bump>=0) D3DDevice->SetTexture(1,Texture[nt_bump]);
		else D3DDevice->SetTexture(1,D3DTextureSecondary[-(nt_bump+1)]);

		if (nt_lightdir>=0) D3DDevice->SetTexture(2,Texture[nt_lightdir]);
		else D3DDevice->SetTexture(2,D3DTextureSecondary[-(nt_lightdir+1)]);

		if (nt_tex>=0) D3DDevice->SetTexture(3,Texture[nt_tex]);
		else D3DDevice->SetTexture(3,D3DTextureSecondary[-(nt_tex+1)]);

		D3DDevice->SetTextureStageState( 0,D3DTSS_TEXCOORDINDEX ,0);
		D3DDevice->SetTextureStageState( 1,D3DTSS_TEXCOORDINDEX ,1);
		D3DDevice->SetTextureStageState( 2,D3DTSS_TEXCOORDINDEX ,2);
		D3DDevice->SetTextureStageState( 3,D3DTSS_TEXCOORDINDEX ,3);

		if (states(LAYER_DIMENSION)==0)
		{
			D3DDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(0,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetSamplerState(0,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);

			D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(1,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetSamplerState(1,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);

			D3DDevice->SetSamplerState(2,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(2,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetSamplerState(2,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);

			D3DDevice->SetSamplerState(3,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(3,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetSamplerState(3,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);
		}
		else
		{
			D3DDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(0,D3DSAMP_MAGFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(0,D3DSAMP_MINFILTER,D3DTEXF_NONE);

			D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(1,D3DSAMP_MAGFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(1,D3DSAMP_MINFILTER,D3DTEXF_NONE);

			D3DDevice->SetSamplerState(2,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(2,D3DSAMP_MAGFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(2,D3DSAMP_MINFILTER,D3DTEXF_NONE);

			D3DDevice->SetSamplerState(3,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(3,D3DSAMP_MAGFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(3,D3DSAMP_MINFILTER,D3DTEXF_NONE);
		}


		D3DDevice->DrawPrimitiveUP( D3DPT_TRIANGLEFAN,2,Vertices,sizeof(CUSTOMVERTEXBLUR));

		D3DDevice->SetTexture(0,NULL);
		D3DDevice->SetTexture(1,NULL);
		D3DDevice->SetTexture(2,NULL);
		D3DDevice->SetTexture(3,NULL);

		if (states(LAYER_DIMENSION)==1)
		{
			D3DDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(0,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetSamplerState(0,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);

			D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(1,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetSamplerState(1,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);

			D3DDevice->SetSamplerState(2,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(2,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetSamplerState(2,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);

			D3DDevice->SetSamplerState(3,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
			D3DDevice->SetSamplerState(3,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
			D3DDevice->SetSamplerState(3,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);
		}

		D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 2, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 2, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 3, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 3, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

		D3DDevice->SetPixelShader(NULL);
	}
	else
	{
		D3DDevice->SetTextureStageState( 0,D3DTSS_TEXCOORDINDEX ,0);
		D3DDevice->SetTextureStageState( 1,D3DTSS_TEXCOORDINDEX ,1);

		if (G_Dot3)
		{			
			if (temporary_secondary_surface!=666)
			{
				SetParams(API3D_RENDERTARGET,temporary_secondary_surface);

				SetParams(API3D_BLEND,OFF);
				SetParams(API3D_CULL,OFF);

				SetTexture(nt_bump);
				SetTexture2(nt_lightdir);

				D3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );

				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );

				D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DOTPRODUCT3 );
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );

				D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
				D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_CURRENT );
				
				if (states(LAYER_DIMENSION)) Quad2(0,0,(float) sx,(float) sy,x1[1],y1[1],x2[1],y2[1],x1[2],y1[2],x2[2],y2[2],1,1,1,1);
				else Quad2(0,0,(float) GetWidth(),(float) GetHeight(),x1[1],y1[1],x2[1],y2[1],x1[2],y1[2],x2[2],y2[2],1,1,1,1);

				SetParams(API3D_TEXTURING,OFF);
				SetParams(API3D_TEXTURING2,OFF);
				SetTexture(nt_color);

				SetParams(API3D_BLEND,BLEND_COLOR);

				SetParams(API3D_CULL,OFF);

				if (states(LAYER_DIMENSION)) Quad(0,0,(float) sx,(float) sy,x1[0],y1[0],x2[0],y2[0],1,1,1,1);
				else Quad(0,0,(float) GetWidth(),(float) GetHeight(),x1[0],y1[0],x2[0],y2[0],1,1,1,1);

				SetParams(API3D_RENDERTARGET,active_surface);

				SetTexture(nt_tex);

				xx1=0.0f; yy1=0.0f; xx2=1.0f; yy2=1.0f;

				switch (temporary_secondary_surface)
				{
					case SECONDARY1:
						SetTexture2(SECONDARYTEXTURE1);
						break;
					case SECONDARY2:
						SetTexture2(SECONDARYTEXTURE2);
						break;
					case SECONDARY3:
						SetTexture2(SECONDARYTEXTURE3);
						break;
					case SECONDARY4:
						SetTexture2(SECONDARYTEXTURE4);
						break;
					case SECONDARY5:
						SetTexture2(SECONDARYTEXTURE5);
						break;
					case SECONDARY6:
						SetTexture2(SECONDARYTEXTURE6);
						break;
					case SECONDARY7:
						SetTexture2(SECONDARYTEXTURE7);
						break;
					case SECONDARY8:
						SetTexture2(SECONDARYTEXTURE8);
						break;
					case SECONDARY9:
						SetTexture2(SECONDARYTEXTURE9);
						break;
					case SECONDARY10:
						SetTexture2(SECONDARYTEXTURE10);
						break;
				};


				if (states(LAYER_DIMENSION)) 
				{ 
					xx1=0.0f; 
					yy1=0.0f; 
					xx2=(float) sx/tile_secondarysurfacesW[temporary_secondary_surface-SECONDARY1]; 
					yy2=(float) sy/tile_secondarysurfacesH[temporary_secondary_surface-SECONDARY1]; 
				}

				SetParams(API3D_BLEND,BLEND_GOURAUD);

				D3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_MODULATE );
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
				D3DDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );
				D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
				D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_CURRENT );
				
				SetParams(API3D_CULL,CCW);
				Quad2(x,y,sx,sy,x1[3],y1[3],x2[3],y2[3],xx1,yy1,xx2,yy2,r,g,b,a);
			}
			else simple=true;
		}
		else simple=true;

	}

	if (simple)
	{
		SetParams(API3D_RENDERTARGET,active_surface);
		SetParams(API3D_BLEND,BLEND_COLOR);
		SetParams(API3D_CULL,CCW);
		SetTexture(nt_tex);
		SetTexture2(nt_color);
		Quad2(x,y,sx,sy,x1[3],y1[3],x2[3],y2[3],x1[0],y1[0],x2[0],y2[0],r,g,b,a);
		SetParams(API3D_TEXTURING,OFF);
		SetParams(API3D_TEXTURING2,OFF);
	}

#endif

}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

  void C3DAPIBASE::DoSpecular(...)

  draw multi layer specular bump mapping on primary render surface
  

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::DoSpecular(float x,float y,float sx,float sy,int nt_bump,int nt_light,float r,float g,float b,float a)
{
	int n;
	int active_surface=GetSurfaceActive();
	float x1[2],x2[2],y1[2],y2[2];
	int tex[2];

	tex[0]=nt_bump;
	tex[1]=nt_light;

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)

	for (n=0;n<2;n++)
	{
		if (states(LAYER_DIMENSION)==0)
		{
			if (tex[n]>=0) { x1[n]=0.0f;y1[n]=0.0f;x2[n]=1.0f;y2[n]=1.0f; }
			else { x1[n]=0.0f;y1[n]=1.0f;x2[n]=1.0f;y2[n]=0.0f; }
		}
		else
		{
			if (tex[n]>=0) { x1[n]=0.0f;y1[n]=0.0f;x2[n]=1.0f;y2[n]=1.0f; }
			else 
			{ 
				x1[n]=0.0f;
				y1[n]=(float) SCREEN_Y/tile_secondarysurfacesW[-1-tex[n]];
				x2[n]=(float) SCREEN_X/tile_secondarysurfacesH[-1-tex[n]];
				y2[n]=0.0f; 
			}
		}
	}

#else

	for (n=0;n<2;n++)
	{
		if (states(LAYER_DIMENSION)==0) { x1[n]=0.0f;y1[n]=0.0f;x2[n]=1.0f;y2[n]=1.0f; }
		else
		{
			if (tex[n]>=0) { x1[n]=0.0f;y1[n]=0.0f;x2[n]=1.0f;y2[n]=1.0f; }
			else 
			{ 
				x1[n]=0.0f;
				y1[n]=0.0f; 
				x2[n]=((float) SCREEN_X)/tile_secondarysurfacesW[-1-tex[n]];
				y2[n]=((float) SCREEN_Y)/tile_secondarysurfacesH[-1-tex[n]];
			}
		}
	}

#endif


#if defined(API3D_DIRECT3D11) ||  defined(API3D_DIRECT3D10) || defined(API3D_OPENGL20) || defined(API3D_METAL)

	float xx=x-VIEWPORT.a[3][0];
	float yy=y-VIEWPORT.a[3][1];

	vbquad2.LockVertices();

	vbquad2.SetColor(0,r,g,b,a);
	vbquad2.SetColor(1,r,g,b,a);
	vbquad2.SetColor(2,r,g,b,a);
	vbquad2.SetColor(3,r,g,b,a);
	
	vbquad2.SetVertex(0,xx,yy,0.5f);
	vbquad2.SetVertex(1,xx+sx,yy,0.5f);
	vbquad2.SetVertex(2,xx+sx,yy+sy,0.5f);
	vbquad2.SetVertex(3,xx,yy+sy,0.5f);

	vbquad2.SetTexCoo(0,x1[0],y1[0]);
	vbquad2.SetTexCoo(1,x2[0],y1[0]);
	vbquad2.SetTexCoo(2,x2[0],y2[0]);
	vbquad2.SetTexCoo(3,x1[0],y2[0]);

	vbquad2.SetTexCoo2(0,x1[1],y1[1]);
	vbquad2.SetTexCoo2(1,x2[1],y1[1]);
	vbquad2.SetTexCoo2(2,x2[1],y2[1]);
	vbquad2.SetTexCoo2(3,x1[1],y2[1]);
	
	vbquad2.UnlockVertices();

	whileFlush=true;

	CVertexBuffer * actual=ActualVertexBuffer;
	CVertexBuffer * eff=ActualEffect;

	effect_hll_quadspec.setTexture("Bump",tex[0]);
	effect_hll_quadspec.setTexture("Vectors",tex[1]);

	effect_hll_quadspec.setMatrix("PROJ",ProjOrtho);
	SetEffect(&effect_hll_quadspec);

	SetVertexBuffer(&vbquad2);
	DrawVertexBuffer();

	ActualVertexBuffer=actual;
	ActualEffect=eff;

	whileFlush=false;

#endif


#ifdef API3D_OPENGL
#ifndef GLES
	const char fp_sbump[]=
		"!!ARBfp1.0\n"
		"PARAM c0 = { 0.3, 0.3, 0.0, 0.0 };\n"
		"PARAM c1 = { 0.75, 0.75, 0.75, 0.0 };\n"
		"PARAM half = { 0.5, 0.5, 0.0, 0.0 };\n"
		"TEMP r0;\n"
		"TEMP r1;\n"
		"TEMP r2;\n"
		"TEX r0,fragment.texcoord[0],texture[0],2D;\n"
		"MOV r2.rg,fragment.texcoord[1];\n"
		"SUB r0,r0,half;\n"
		"MAD r2.rg,c0,r0,r2;\n"
		"TEX r1,r2,texture[1],2D;\n"
		"MUL result.color.rgb,r1,c1;\n"
		"MOV result.color.a,fragment.color.a;\n"
		"END\n";

	bool fp=false;

	if ((G_PS)&&(PixelShaderBump!=0xFFFFFFFF))
	{
		GLint errorPos,isNative;

		if (PixelShaderBumpSpec==0)
		{
			glEnable(GL_FRAGMENT_PROGRAM_ARB);
			int len=strlen(fp_sbump);
			glGenProgramsARB(1,&PixelShaderBumpSpec);
			glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB,PixelShaderBumpSpec);
			glProgramStringARB(GL_FRAGMENT_PROGRAM_ARB,GL_PROGRAM_FORMAT_ASCII_ARB,len,(const void*)fp_sbump);
			glGetIntegerv(GL_PROGRAM_ERROR_POSITION_ARB,&errorPos);
			glGetProgramivARB(GL_FRAGMENT_PROGRAM_ARB,GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB,&isNative);
			if ((errorPos==-1)&&(isNative==1)) fp=true;
			else 
			{
				glDeleteProgramsARB(1,&PixelShaderBumpSpec); 
				PixelShaderBumpSpec=0xFFFFFFFF;
			}
			glDisable(GL_FRAGMENT_PROGRAM_ARB);
		}
		else fp=true;

		if (fp)
		{
			glActiveTextureARB(GL_TEXTURE0_ARB+0);
			glEnable(GL_TEXTURE_2D);
			if (tex[0]>=0) glBindTexture(GL_TEXTURE_2D,Texture[tex[0]]);
			else
			{
#ifdef OPENGL_PBUFFERS
				pbufferBind(-(tex[0]+1));
#endif
#ifdef OPENGL_FRAMEBUFFERS
				glBindTexture(GL_TEXTURE_2D,renderedTexture[-(tex[0]+1)]);
#endif
			}
			glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);

			glActiveTextureARB(GL_TEXTURE0_ARB+1);
			glEnable(GL_TEXTURE_2D);
			if (tex[1]>=0) glBindTexture(GL_TEXTURE_2D,Texture[tex[1]]);
			else
			{
#ifdef OPENGL_PBUFFERS
				pbufferBind(-(tex[1]+1));
#endif
#ifdef OPENGL_FRAMEBUFFERS
				glBindTexture(GL_TEXTURE_2D,renderedTexture[-(tex[1]+1)]);
#endif
			}

			glTexEnvi(GL_TEXTURE_ENV,GL_TEXTURE_ENV_MODE,GL_MODULATE);

			glMatrixMode(GL_PROJECTION);
			glPushMatrix();
			glMatrixMode(GL_MODELVIEW);
			glPushMatrix();
			glMatrixMode(GL_PROJECTION);
			glLoadIdentity();
			glOrtho(0.0f,SCREEN_X,0.0f,SCREEN_Y,-1.0f,1.0f);
			glMatrixMode(GL_MODELVIEW);
			glLoadIdentity();

			glDisable(GL_DEPTH_TEST);

			glEnable(GL_FRAGMENT_PROGRAM_ARB);
			glBindProgramARB(GL_FRAGMENT_PROGRAM_ARB,PixelShaderBumpSpec);

			glBegin(GL_QUADS);

			glColor4f(r,g,b,a);

			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1[0],y1[0]);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,x1[1],y1[1]);
			glVertex3f((float) x,(float) (SCREEN_Y-y),0);

			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2[0],y1[0]);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,x2[1],y1[1]);
			glVertex3f((float) (x+sx),(float) (SCREEN_Y-y),0);

			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x2[0],y2[0]);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,x2[1],y2[1]);
			glVertex3f((float) (x+sx),(float) (SCREEN_Y-(y+sy)),0);

			glMultiTexCoord2fARB(GL_TEXTURE0_ARB,x1[0],y2[0]);
			glMultiTexCoord2fARB(GL_TEXTURE1_ARB,x1[1],y2[1]);
			glVertex3f((float) x,(float) (SCREEN_Y-(y+sy)),0);

			glEnd();

			glDisable(GL_FRAGMENT_PROGRAM_ARB);

			glMatrixMode(GL_MODELVIEW);
			glPopMatrix();
			glMatrixMode(GL_PROJECTION);
			glPopMatrix();

			glEnable(GL_DEPTH_TEST);

			glActiveTextureARB(GL_TEXTURE0_ARB);
			if (tex[0]<0)
			{
#ifdef OPENGL_PBUFFERS
				pbufferRelease(-(tex[0]+1));
#endif
			}
			glDisable(GL_TEXTURE_2D);

			glActiveTextureARB(GL_TEXTURE1_ARB);
			if (tex[1]<0)
			{
#ifdef OPENGL_PBUFFERS
				pbufferRelease(-(tex[1]+1));
#endif
			}
			glDisable(GL_TEXTURE_2D);

		}
	}
#endif
#endif

#ifdef API3D_DIRECT3D

	const char psh_sbump[] = 
		"ps.1.4\n"
		"def c0,0.15,0.15,0.0,0.0\n"
		"texld r0,t0\n"
		"texcrd r5.rgb,t1.xyz\n"
		"mad r5.rg,c0,r0_bx2,r5\n"
		"phase\n"
		"texld r1,r5\n"
		"mov r0.rgb,r1\n"
		"mov r0.a,v0.a\n"
		"\n";

	if (G_PS)
	{
		struct CUSTOMVERTEXBLUR Vertices[4];

		Vertices[0].color=D3DCOLOR_COLORVALUE(r,g,b,a);
		Vertices[1].color=Vertices[0].color;
		Vertices[2].color=Vertices[0].color;
		Vertices[3].color=Vertices[0].color;

		Vertices[0].x=x;
		Vertices[0].y=y;
		Vertices[0].rhw=(float) 2/(Front+Back);
		Vertices[0].z=0.5f;

		Vertices[1].x=(x+sx);
		Vertices[1].y=y;
		Vertices[1].rhw=Vertices[0].rhw;
		Vertices[1].z=0.5f;

		Vertices[2].x=(x+sx);
		Vertices[2].y=(y+sy);
		Vertices[2].rhw=Vertices[0].rhw;
		Vertices[2].z=0.5f;

		Vertices[3].x=(x);
		Vertices[3].y=(y+sy);
		Vertices[3].rhw=Vertices[0].rhw;
		Vertices[3].z=0.5f;

		Vertices[0].xm0=x1[0];Vertices[0].ym0=y1[0];
		Vertices[1].xm0=x2[0];Vertices[1].ym0=y1[0];
		Vertices[2].xm0=x2[0];Vertices[2].ym0=y2[0];
		Vertices[3].xm0=x1[0];Vertices[3].ym0=y2[0];

		Vertices[0].xm1=x1[1];Vertices[0].ym1=y1[1];
		Vertices[1].xm1=x2[1];Vertices[1].ym1=y1[1];
		Vertices[2].xm1=x2[1];Vertices[2].ym1=y2[1];
		Vertices[3].xm1=x1[1];Vertices[3].ym1=y2[1];

		D3DDevice->SetVertexShader( D3DFVF_CUSTOMVERTEXBLUR );

		if (PixelShaderBumpSpec==0)
		{
			LPD3DXBUFFER pCode;
			D3DXAssembleShader(psh_sbump,sizeof(psh_sbump)-1,0,NULL,&pCode,NULL);
			D3DDevice->CreatePixelShader((DWORD*)pCode->GetBufferPointer(),&PixelShaderBumpSpec);
		}
		D3DDevice->SetPixelShader(PixelShaderBumpSpec);

		if (nt_bump>=0) D3DDevice->SetTexture(0,Texture[nt_bump]);
		else D3DDevice->SetTexture(0,D3DTextureSecondary[-(nt_bump+1)]);

		if (nt_light>=0) D3DDevice->SetTexture(1,Texture[nt_light]);
		else D3DDevice->SetTexture(1,D3DTextureSecondary[-(nt_light+1)]);

		D3DDevice->SetTextureStageState(0,D3DTSS_MIPFILTER,D3DTEXF_NONE);
		D3DDevice->SetTextureStageState(0,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
		D3DDevice->SetTextureStageState(0,D3DTSS_MINFILTER,D3DTEXF_LINEAR);

		D3DDevice->SetTextureStageState(1,D3DTSS_MIPFILTER,D3DTEXF_NONE);
		D3DDevice->SetTextureStageState(1,D3DTSS_MAGFILTER,D3DTEXF_LINEAR);
		D3DDevice->SetTextureStageState(1,D3DTSS_MINFILTER,D3DTEXF_LINEAR);

		D3DDevice->SetTextureStageState( 0,D3DTSS_TEXCOORDINDEX ,0);
		D3DDevice->SetTextureStageState( 1,D3DTSS_TEXCOORDINDEX ,1);

		D3DDevice->DrawPrimitiveUP( D3DPT_TRIANGLEFAN,2,Vertices,sizeof(CUSTOMVERTEXBLUR));

		D3DDevice->SetTexture(0,NULL);
		D3DDevice->SetTexture(1,NULL);

		D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );

		D3DDevice->SetPixelShader(NULL);
	}

#endif

#ifdef API3D_DIRECT3D9

	const char psh_sbump[] = 
		"ps.1.4\n"
		"def c0,0.15,0.15,0.0,0.0\n"
		"texld r0,t0\n"
		"texcrd r5.rgb,t1.xyz\n"
		"mad r5.rg,c0,r0_bx2,r5\n"
		"phase\n"
		"texld r1,r5\n"
		"mov r0.rgb,r1\n"
		"mov r0.a,v0.a\n"
		"\n";


	if (G_PS)
	{
		struct CUSTOMVERTEXBLUR Vertices[4];

		Vertices[0].color=D3DCOLOR_COLORVALUE(r,g,b,a);
		Vertices[1].color=Vertices[0].color;
		Vertices[2].color=Vertices[0].color;
		Vertices[3].color=Vertices[0].color;
		Vertices[0].x=x;
		Vertices[0].y=y;
		Vertices[0].rhw=(float) 2/(Front+Back);
		Vertices[0].z=0.5f;
		Vertices[1].x=(x+sx);
		Vertices[1].y=y;
		Vertices[1].rhw=Vertices[0].rhw;
		Vertices[1].z=0.5f;
		Vertices[2].x=(x+sx);
		Vertices[2].y=(y+sy);
		Vertices[2].rhw=Vertices[0].rhw;
		Vertices[2].z=0.5f;
		Vertices[3].x=(x);
		Vertices[3].y=(y+sy);
		Vertices[3].rhw=Vertices[0].rhw;
		Vertices[3].z=0.5f;
		Vertices[0].xm0=x1[0];Vertices[0].ym0=y1[0];
		Vertices[1].xm0=x2[0];Vertices[1].ym0=y1[0];
		Vertices[2].xm0=x2[0];Vertices[2].ym0=y2[0];
		Vertices[3].xm0=x1[0];Vertices[3].ym0=y2[0];
		Vertices[0].xm1=x1[1];Vertices[0].ym1=y1[1];
		Vertices[1].xm1=x2[1];Vertices[1].ym1=y1[1];
		Vertices[2].xm1=x2[1];Vertices[2].ym1=y2[1];
		Vertices[3].xm1=x1[1];Vertices[3].ym1=y2[1];

		D3DDevice->SetFVF( D3DFVF_CUSTOMVERTEXBLUR );

		if (PixelShaderBumpSpec==0)
		{
			LPD3DXBUFFER pCode;
			D3DXAssembleShader(psh_sbump,sizeof(psh_sbump)-1,NULL,NULL,0,&pCode,NULL);
			D3DDevice->CreatePixelShader((DWORD*)pCode->GetBufferPointer(),&PixelShaderBumpSpec);
		}

		D3DDevice->SetPixelShader(PixelShaderBumpSpec);

		if (nt_bump>=0) D3DDevice->SetTexture(0,Texture[nt_bump]);
		else D3DDevice->SetTexture(0,D3DTextureSecondary[-(nt_bump+1)]); 

		if (nt_light>=0) D3DDevice->SetTexture(1,Texture[nt_light]);
		else D3DDevice->SetTexture(1,D3DTextureSecondary[-(nt_light+1)]);

		D3DDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
		D3DDevice->SetSamplerState(0,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
		D3DDevice->SetSamplerState(0,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);
		D3DDevice->SetSamplerState(1,D3DSAMP_MIPFILTER,D3DTEXF_NONE);
		D3DDevice->SetSamplerState(1,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
		D3DDevice->SetSamplerState(1,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);
		D3DDevice->SetTextureStageState( 0,D3DTSS_TEXCOORDINDEX ,0);
		D3DDevice->SetTextureStageState( 1,D3DTSS_TEXCOORDINDEX ,1);
		D3DDevice->DrawPrimitiveUP( D3DPT_TRIANGLEFAN,2,Vertices,sizeof(CUSTOMVERTEXBLUR));
		D3DDevice->SetTexture(0,NULL);
		D3DDevice->SetTexture(1,NULL);
		D3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
		D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1,   D3DTA_TEXTURE );
		D3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG2,   D3DTA_DIFFUSE );
		D3DDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
		D3DDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
		D3DDevice->SetPixelShader(NULL);
	}

#endif
}


void C3DAPIBASE::Stating()
{
	PreviousRS.Stencil=_UNDEFINED;
	PreviousRS.ShadeMode=_UNDEFINED;
	PreviousRS.Zfunc=_UNDEFINED;
	PreviousRS.ZBufferWrite=_UNDEFINED;
	PreviousRS.ZBuffer=_UNDEFINED;

	PreviousRS.RenderTarget=_UNDEFINED;
	PreviousRS.TextCoord[0]=_UNDEFINED;
	PreviousRS.TextCoord[1]=_UNDEFINED;
	PreviousRS.TextCoord[2]=_UNDEFINED;
	PreviousRS.TextCoord[3]=_UNDEFINED;
	PreviousRS.Mip[0]=_UNDEFINED;
	PreviousRS.Min[0]=_UNDEFINED;
	PreviousRS.Mag[0]=_UNDEFINED;
	PreviousRS.Mip[1]=_UNDEFINED;
	PreviousRS.Min[1]=_UNDEFINED;
	PreviousRS.Mag[1]=_UNDEFINED;
	PreviousRS.Mip[2]=_UNDEFINED;
	PreviousRS.Min[2]=_UNDEFINED;
	PreviousRS.Mag[2]=_UNDEFINED;
	PreviousRS.Mip[3]=_UNDEFINED;
	PreviousRS.Min[3]=_UNDEFINED;
	PreviousRS.Mag[3]=_UNDEFINED;
	PreviousRS.SrcBlend=_UNDEFINED;
	PreviousRS.DstBlend=_UNDEFINED;
	PreviousRS.Dither=_UNDEFINED;
	PreviousRS.Cull=_UNDEFINED;
	PreviousRS.COp[0]=_UNDEFINED;
	PreviousRS.CArg1[0]=_UNDEFINED;
	PreviousRS.CArg2[0]=_UNDEFINED;
	PreviousRS.COp[1]=_UNDEFINED;
	PreviousRS.CArg1[1]=_UNDEFINED;
	PreviousRS.CArg2[1]=_UNDEFINED;
	PreviousRS.COp[2]=_UNDEFINED;
	PreviousRS.CArg1[2]=_UNDEFINED;
	PreviousRS.CArg2[2]=_UNDEFINED;
	PreviousRS.COp[3]=_UNDEFINED;
	PreviousRS.CArg1[3]=_UNDEFINED;
	PreviousRS.CArg2[3]=_UNDEFINED;
	PreviousRS.Blend=_UNDEFINED;	
	PreviousRS.AlphaTest=_UNDEFINED;
	PreviousRS.AlphaRef=_UNDEFINED;
	PreviousRS.AlphaFunc=_UNDEFINED;
	PreviousRS.AddressV[0]=_UNDEFINED;
	PreviousRS.AddressU[0]=_UNDEFINED;
	PreviousRS.AddressV[1]=_UNDEFINED;
	PreviousRS.AddressU[1]=_UNDEFINED;
	PreviousRS.AddressV[2]=_UNDEFINED;
	PreviousRS.AddressU[2]=_UNDEFINED;
	PreviousRS.AddressV[3]=_UNDEFINED;
	PreviousRS.AddressU[3]=_UNDEFINED;
	PreviousRS.AArg1[0]=_UNDEFINED;
	PreviousRS.AArg2[0]=_UNDEFINED;
	PreviousRS.AOp[0]=_UNDEFINED;
	PreviousRS.AArg1[1]=_UNDEFINED;
	PreviousRS.AArg2[1]=_UNDEFINED;
	PreviousRS.AOp[1]=_UNDEFINED;
	PreviousRS.AArg1[2]=_UNDEFINED;
	PreviousRS.AArg2[2]=_UNDEFINED;
	PreviousRS.AOp[2]=_UNDEFINED;
	PreviousRS.AArg1[3]=_UNDEFINED;
	PreviousRS.AArg2[3]=_UNDEFINED;
	PreviousRS.AOp[3]=_UNDEFINED;
	
	*states[RENDER_BLEND_NO_ALPHA]=0;

	*states[RENDER_TARGET_OPTIONS]=RENDER;

	*states[MIPMAP_ACTIVE]=1;

	*states[LIGHTMAP_LAYERS]=1;

	*states[TRIVIAL_ELIMINATION_STENCIL]=1;
	*states[LAYER_DIMENSION]=0;
	*states[RENDER_TARGET]=PRIMARY;
	*states[SHADERS]=1;
	*states[VERTICAL_RETRACE]=1;
	*states[ZBUFFERING]=1;
	*states[SCALE_SCREEN]=1;
	*states[BLENDING]=0;
	*states[RENDER_BIT_DEPTH]=0;
	*states[CULLING]=0;

	*states[HARDWARE_VERTEX_PROCESSING_E]=1;
	*states[HARDWARE_VERTEX_PROCESSING]=0;
	*states[HARDWARE_VERTEX_PROCESSING_MIPMAP]=0;

	*states[ZBUFFER_TEST_STENCIL]=0;
#ifdef API3D_METAL
    C3DAPIBASE_ZBUFFER_TEST_STENCIL=0;
#endif
	*states[TEXTURES_32BITS]=0;
	*states[TEXTURES_MIPMAP_ACTIVE]=0;
	*states[TEXTURES_CLAMPING]=0;
	*states[TEXTURES_DITHERING]=0;

	*states[TEXTURE_MAX_WIDTH]=256;

	*states[SPECIAL_FASTDRAW]=0;
	*states[SPECIAL_ENHANCED]=0;
	*states[SPECIAL_ANIMATED]=0;

	*states[SHADOW_BUFFERING]=1;
	*states[UNKNOWN]=0;
	*states[ALGO_STENCIL_SHADOWING]=ALGO_ALTERNATIVE;

	*states[ALPHA_MULTI_GROUP_DRAW]=1;
	*states[ENV_SHADERS]=1;

	*states[LIGHTMAP_BACKUPS]=1;

	*states[TWOSIDED_STENCIL]=0;

	*states[PIXELSHADER2]=0;

}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	bool C3DAPIBASE::CheckDevice(int tag)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

bool C3DAPIBASE::CheckDevice(int tag)
{
	bool res=false;

	switch (tag)
	{
	case DEV_STENCILBUFFER:
		res=StencilBuffer;
		break;
	case DEV_MULTITEXTURE:
		res=G_Multitexture;
		break;
	case DEV_SECONDARIES:
		res=SecondarySurface;
		break;
	case DEV_DOTPRODUCT:
		res=G_Dot3;
		break;
	case DEV_PIXELSHADERS:
		res=G_PS;
		break;
	case DEV_TEXTURESUP256:
		if (states(TEXTURE_MAX_WIDTH)>256) res=true;
		else res=false;
		break;

	case DEV_BUMPENVMAP:
#if defined(API3D_OPENGL) || defined(API3D_OPENGL20) || defined(API3D_METAL)
		res=false;
#else
		if (G_BumpEnvMap)
		{
			res=true;
#if !defined(API3D_DIRECT3D10)&&!defined(API3D_DIRECT3D11)&&!defined(API3D_DIRECT3D12)
			D3DDevice->SetTextureStageState( 0, D3DTSS_BUMPENVMAT00, F2DW(0.2f) );
			D3DDevice->SetTextureStageState( 0, D3DTSS_BUMPENVMAT01, F2DW(0.0f) );
			D3DDevice->SetTextureStageState( 0, D3DTSS_BUMPENVMAT10, F2DW(0.0f) );
			D3DDevice->SetTextureStageState( 0, D3DTSS_BUMPENVMAT11, F2DW(0.2f) );

			D3DDevice->SetTextureStageState( 1, D3DTSS_BUMPENVMAT00, F2DW(0.2f) );
			D3DDevice->SetTextureStageState( 1, D3DTSS_BUMPENVMAT01, F2DW(0.0f) );
			D3DDevice->SetTextureStageState( 1, D3DTSS_BUMPENVMAT10, F2DW(0.0f) );
			D3DDevice->SetTextureStageState( 1, D3DTSS_BUMPENVMAT11, F2DW(0.2f) );
#endif
		}
		else res=false;
#endif

		break;
	case DEV_PIXELSHADERS2:
#ifdef API3D_DIRECT3D9
		res=(states(PIXELSHADER2)==1);
#endif
		break;
	};

	return res;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:


  void C3DAPIBASE::BumpMappingStates()

  internal

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::BumpMappingStates()
{
#ifdef API3D_DIRECT3D12
	// TODO
#else
#ifdef API3D_DIRECT3D11
	// HIP
#else
#ifdef API3D_DIRECT3D10
	// HIP
#else


#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
	if (BML)
	{
#ifdef API3D_DIRECT3D9
		D3DXHANDLE base;
#else
		D3DXTECHNIQUE_DESC tt;
#endif
		LPD3DXEFFECT eff;

		eff=BMLa;


#ifdef API3D_DIRECT3D9

		if (states(RENDER_TARGET)==STENCIL) 
		{
			base=eff->GetTechniqueByName("T4");
		}
		else
		{
			if (states(SPECIAL_FASTDRAW)==1) 
			{
				if (G_Multitexture) base=eff->GetTechniqueByName("T2");
				else base=eff->GetTechniqueByName("T3");
			}
			else
			if (states(SPECIAL_FASTDRAW)==2) 
			{
				if (G_Multitexture) base=eff->GetTechniqueByName("T2");
				else base=eff->GetTechniqueByName("T3");
			}
			else
			{
				if (G_PS) base=eff->GetTechniqueByName("T0");
				else
				{
					if (G_Dot3) base=eff->GetTechniqueByName("T1");
					else 
					{
						if (G_Multitexture) base=eff->GetTechniqueByName("T2");
						else base=eff->GetTechniqueByName("T3");
					}
				}
			}
		}

		eff->SetTechnique(base);
#else

		if (states(RENDER_TARGET)==STENCIL) 
		{
			eff->GetTechniqueDesc("T4",&tt);
		}
		else
		{
			if (states(SPECIAL_FASTDRAW)==1) 
			{
				if (G_Multitexture) eff->GetTechniqueDesc("T2",&tt);
				else eff->GetTechniqueDesc("T3",&tt);
			}
			else
			if (states(SPECIAL_FASTDRAW)==2) 
			{
				if (G_Multitexture) eff->GetTechniqueDesc("T2",&tt);
				else eff->GetTechniqueDesc("T3",&tt);
			}
			else
			{
				if (G_PS) eff->GetTechniqueDesc("T0",&tt);
				else
				{
					if (G_Dot3) eff->GetTechniqueDesc("T1",&tt);
					else 
					{
						if (G_Multitexture) eff->GetTechniqueDesc("T2",&tt);
						else eff->GetTechniqueDesc("T3",&tt);
					}
				}
			}
		}
		eff->SetTechnique(tt.Index);
			
/*
		if (states(RENDER_TARGET)==STENCIL)
		{
			if (FAILED(eff->FindNextValidTechnique("T1",&tt))) return;
			eff->SetTechnique(tt.Index);
		}
		else
		{
			if (states(SPECIAL_FASTDRAW)==1)
			{
				if (FAILED(eff->FindNextValidTechnique("T1",&tt))) return;
				eff->SetTechnique(tt.Index);
			}
			else
			if (states(SPECIAL_FASTDRAW)==2)
			{
				if (FAILED(eff->FindNextValidTechnique("T2",&tt))) return;
				eff->SetTechnique(tt.Index);
			}
			else
			{
				if (FAILED(eff->FindNextValidTechnique(NULL,&tt))) return;
				eff->SetTechnique(tt.Index);
			}
		}
		*/
#endif

		eff=BML;

#ifdef API3D_DIRECT3D9

		if (states(RENDER_TARGET)==STENCIL) 
		{
			base=eff->GetTechniqueByName("T4");
		}
		else
		{
			if (states(SPECIAL_FASTDRAW)==1) 
			{
				if (G_Multitexture) base=eff->GetTechniqueByName("T2");
				else base=eff->GetTechniqueByName("T3");
			}
			else
			if (states(SPECIAL_FASTDRAW)==2) 
			{
				if (G_Multitexture) base=eff->GetTechniqueByName("T2");
				else base=eff->GetTechniqueByName("T3");
			}
			else
			{
				if (G_PS) base=eff->GetTechniqueByName("T0");
				else
				{
					if (G_Dot3) base=eff->GetTechniqueByName("T1");
					else 
					{
						if (G_Multitexture) base=eff->GetTechniqueByName("T2");
						else base=eff->GetTechniqueByName("T3");
					}
				}
			}
			eff->SetTechnique(base);
		}

#else
/*
		if (states(RENDER_TARGET)==STENCIL)
		{
			if (FAILED(eff->FindNextValidTechnique("T1",&tt))) return;
			eff->SetTechnique(tt.Index);
		}
		else
		{
			if (states(SPECIAL_FASTDRAW)==1)
			{
				if (FAILED(eff->FindNextValidTechnique("T1",&tt))) return;
				eff->SetTechnique(tt.Index);
			}
			else
			if (states(SPECIAL_FASTDRAW)==2)
			{
				if (FAILED(eff->FindNextValidTechnique("T2",&tt))) return;
				eff->SetTechnique(tt.Index);
			}
			else
			{
				if (FAILED(eff->FindNextValidTechnique(NULL,&tt))) return;
				eff->SetTechnique(tt.Index);
			}
		}
		/**/

		if (states(RENDER_TARGET)==STENCIL) 
		{
			eff->GetTechniqueDesc("T4",&tt);
		}
		else
		{
			if (states(SPECIAL_FASTDRAW)==1) 
			{
				if (G_Multitexture) eff->GetTechniqueDesc("T2",&tt);
				else eff->GetTechniqueDesc("T3",&tt);
			}
			else
			if (states(SPECIAL_FASTDRAW)==2) 
			{
				if (G_Multitexture) eff->GetTechniqueDesc("T2",&tt);
				else eff->GetTechniqueDesc("T3",&tt);
			}
			else
			{
				if (G_PS) eff->GetTechniqueDesc("T0",&tt);
				else
				{
					if (G_Dot3) eff->GetTechniqueDesc("T1",&tt);
					else 
					{
						if (G_Multitexture) eff->GetTechniqueDesc("T2",&tt);
						else eff->GetTechniqueDesc("T3",&tt);
					}
				}
			}
		}
		eff->SetTechnique(tt.Index);

#endif

		if (states(SPECIAL_ANIMATED)) eff=BMLa;
		else eff=BML;

		EffectBumpMapping=eff;

	}

	char ssT[4];
	LPD3DXEFFECT eff=BMLD;

#ifdef API3D_DIRECT3D9

	if (BMLD)
	{
		D3DXHANDLE base,hndl;

		if (states(RENDER_TARGET)==STENCIL) base=eff->GetTechniqueByName("T7");
		else
		{

			if (states(SPECIAL_ENHANCED)<3)
			{
				if (states(SPECIAL_ENHANCED)==0) base=NULL;
				else
				{
					sprintf(ssT,"T%d",states(SPECIAL_ENHANCED)-1);
					base=eff->GetTechniqueByName(ssT);
				}
			}
			else
			{
				
				if (states(SPECIAL_FASTDRAW)) base=eff->GetTechniqueByName("T4");
				else
				{
					base=eff->GetTechniqueByName("T2");
				}
			}
		}
		eff->SetTechnique(base);
		if (FAILED(eff->FindNextValidTechnique(base,&hndl))) return;
		
		eff->SetTechnique(hndl);

		EffectBumpMappingDisplaceSS=eff;
	}
#else
	if (BMLD)
	{
		D3DXTECHNIQUE_DESC tt;

		if (states(RENDER_TARGET)==STENCIL)
		{
			if (FAILED(eff->FindNextValidTechnique("T7",&tt))) return;
			eff->SetTechnique(tt.Index);
		}
		else
		{
			if (states(SPECIAL_FASTDRAW))
			{
				if (FAILED(eff->FindNextValidTechnique("T4",&tt))) return;
				eff->SetTechnique(tt.Index);
			}
			else
			{
				if (states(SPECIAL_ENHANCED)==0)
				{
					if (FAILED(eff->FindNextValidTechnique(NULL,&tt))) return;
				}
				else
				{
					sprintf(ssT,"T%d",states(SPECIAL_ENHANCED));
					if (FAILED(eff->FindNextValidTechnique(ssT,&tt))) return;
				}
				eff->SetTechnique(tt.Index);
			}
		}

		EffectBumpMappingDisplaceSS=eff;
	}

#endif
#endif
#endif
#endif
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:


  void C3DAPIBASE::SetTileSecondary(int tile)

  set dimension of all secondary surfaces

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTileSecondary(int tile)
{
	tag_tile=true;
	for (int n=0;n<MAX_SECONDARIES;n++)
	{
		if (n==0) tile_secondarysurfaces[n]=tile/2;
		else tile_secondarysurfaces[n]=tile;

		tile_secondarysurfacesW[n]=tile_secondarysurfaces[n];
		tile_secondarysurfacesH[n]=tile_secondarysurfaces[n];
	}

	TILE_SecondarySurface=tile;
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:


  void C3DAPIBASE::SetTileSecondary(int ns,int tile)

  set the dimension of a secondary surface

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTileSecondary(int ns,int tile)
{
	int n=ns-SECONDARY1;
	tile_secondarysurfaces[n]=tile;
	tile_secondarysurfacesW[n]=tile_secondarysurfaces[n];
	tile_secondarysurfacesH[n]=tile_secondarysurfaces[n];
	tag_tile=true;
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:


  void C3DAPIBASE::SetTileSecondary(int ns,int tilex,int tiley)

  set the dimension of a secondary surface

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTileSecondary(int ns,int tilex,int tiley)
{
	int n=ns-SECONDARY1;
	tile_secondarysurfaces[n]=tilex;
	tile_secondarysurfacesW[n]=tilex;
	tile_secondarysurfacesH[n]=tiley;
	tag_tile=true;
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	void C3DAPIBASE::SetSecondaryAsTemporary(int ns)


  set the temporary secondary surface in order to render bump mapping technique "dobump"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetSecondaryAsTemporary(int ns)
{
	temporary_secondary_surface=ns;
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	int C3DAPIBASE::GetWidth()

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

int C3DAPIBASE::GetWidth()
{
#if defined(API3D_OPENGL)||defined(API3D_OPENGL20)||defined(API3D_METAL)
	if (SelectedRenderTarget==-1)
	{
#if defined(GOOGLEVR)||defined(API3D_VR)
	    if (catseyes) return viewportVR[2];
	    else return SCREEN_X;
#else
		return SCREEN_X;
#endif
	}
	else
	{
		return tile_secondarysurfacesW[SelectedRenderTarget];
	}
#else

	if (SelectedRenderTarget==PRIMARY)
	{
		return SCREEN_X;
	}
	else
	{
		int ns=SelectedRenderTarget-SECONDARY1;
		return tile_secondarysurfacesW[ns];
	}
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	int C3DAPIBASE::GetHeight()

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

int C3DAPIBASE::GetHeight()
{

#if defined(API3D_OPENGL)||defined(API3D_OPENGL20)||defined(API3D_METAL)
	if (SelectedRenderTarget==-1)
	{
#if defined(GOOGLEVR)||defined(API3D_VR)
	    if (catseyes) return viewportVR[3];
	    else return SCREEN_Y;
#else
		return SCREEN_Y;
#endif
	}
	else
	{
		return tile_secondarysurfacesH[SelectedRenderTarget];
	}
#else

	if (SelectedRenderTarget==PRIMARY)
	{
		return SCREEN_Y;
	}
	else
	{
		int ns=SelectedRenderTarget-SECONDARY1;
		return tile_secondarysurfacesH[ns];
	}
#endif
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	int C3DAPIBASE::GetHeight()

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

int C3DAPIBASE::GetSurfaceActive()
{
#if defined(API3D_OPENGL)||defined(API3D_OPENGL20)||defined(API3D_METAL)
	if (SelectedRenderTarget==-1)
	{
		return PRIMARY;
	}
	else
	{
		return SECONDARY1+SelectedRenderTarget;
	}
#else
	return SelectedRenderTarget;
#endif
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	void C3DAPIBASE::SetFixedContextParameters(int stage,int (*fn)(int tag,int nt,int nt2,int nl,int nl2))

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetFixedContextParameters(int stage,int (*fn)(int nt,int nt2,int nl,int nlv,int tag))
{
	switch (stage)
	{
	case -1:
		fn_stage_draw=fn;
		break;
	case 0:
		fn_stage0=fn;
		break;
	case 1:
		fn_stage1=fn;
		break;
	case 2:
		fn_stage2=fn;
		break;
	case 3:
		fn_stage3=fn;
		break;
	case 4:
		fn_stage4=fn;
		break;
	case 5:
		fn_stage5=fn;
		break;
	};
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	void C3DAPIBASE::SetEffectContext(CContextEffectParameters * CEP)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetEffectContext(CContextEffectParameters * CEP)
{
	ContextEffect=CEP;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	void C3DAPIBASE::SetTextureTranslate(int dc)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetTextureTranslate(int dc)
{
	Decal_nt=dc;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	void SetVertexBuffer(CVertexBuffer * vb)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetVertexBuffer(CVertexBuffer * vb)
{
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
    if (!vbdraw_line) UpdateLines();
#endif

    if (LevelOfDetail)
    {
        if (vb)
        {
            if (vb->lod) ActualVertexBuffer=vb->lod;
            else ActualVertexBuffer=vb;
        }
        else ActualVertexBuffer=vb;
    }
	else ActualVertexBuffer=vb;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 
 function:
 
 void SetLOD(bool activate)
 
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetLOD(bool activate)
{
    LevelOfDetail=activate;
}

/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	void SetEffect(CVertexBuffer *eff) 

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetEffect(CVertexBuffer *eff) 
{
	ActualEffect=eff;
}


/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	void SetPointCloud(int nT,CVector SC)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetPointCloud(int nT,CVector SC)
{
#if defined(API3D_DIRECT3D12) || defined(API3D_DIRECT3D11) || defined(API3D_DIRECT3D10) || defined(API3D_OPENGL20) || defined(API3D_METAL)
	ActualEffect=&effect_hll_point_cloud;
#else
	if (effect_hll_point_cloud==NULL)
	{
		effect_hll_point_cloud=new CVertexBuffer;
		effect_hll_point_cloud->SetAPI(this);
		effect_hll_point_cloud->BasicEffect();
		effect_hll_point_cloud->SetVertexProgram(shader_hll_point_cloud);
	}

	ActualEffect=effect_hll_point_cloud;
#endif

	ActualEffect->setMatrixWorldViewProj("MODEL");
	ActualEffect->setMatrix("WORLDVIEW",WORLD*VIEW);
	ActualEffect->setVector("PSIZE",SC);
	ActualEffect->setTexture("Tex",nT);
}



/* ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  function:

	SetOverClassQuadEffect(CVertexBuffer *overclass)

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */

void C3DAPIBASE::SetOverClassQuadEffect(CVertexBuffer *overclass)
{
	Flush();
	OverClassQuadZ=overclass;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::CalcViewProj(CMatrix *m)
{
#if defined(API3D_OPENGL)||defined(API3D_OPENGL20)
	*m=pVIEW*pPROJ;
#else

	CMatrix view;

	view.a[0][0]=VIEW.a[0][0];
	view.a[0][1]=-VIEW.a[0][1];
	view.a[0][2]=VIEW.a[0][2];
	view.a[0][3]=VIEW.a[0][3];

	view.a[1][0]=VIEW.a[1][0];
	view.a[1][1]=-VIEW.a[1][1];
	view.a[1][2]=VIEW.a[1][2];
	view.a[1][3]=VIEW.a[1][3];

	view.a[2][0]=VIEW.a[2][0];
	view.a[2][1]=-VIEW.a[2][1];
	view.a[2][2]=VIEW.a[2][2];
	view.a[2][3]=VIEW.a[2][3];

	view.a[3][0]=VIEW.a[3][0];
	view.a[3][1]=-VIEW.a[3][1];
	view.a[3][2]=VIEW.a[3][2];
	view.a[3][3]=VIEW.a[3][3];

	*m=view*PROJ;
#endif
	
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool C3DAPIBASE::IsPrimarySurface()
{
#if defined(API3D_OPENGL)||defined(API3D_OPENGL20)||defined(API3D_METAL)
    if (SelectedRenderTarget == -1) return true;
#else
	if (SelectedRenderTarget == PRIMARY) return true;
#endif		    
	return false;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::SaveStates()
{
    _aT=aT;
    _aT2=aT2;
    _aT3=aT3;
    _aT4=aT4;
    _aT5=aT5;
    _aT6=aT6;
    _aT7=aT7;
    _aT8=aT8;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::ReloadStates()
{
    aT=_aT;
    aT2=_aT2;
    aT3=_aT3;
    aT4=_aT4;
    aT5=_aT5;
    aT6=_aT6;
    aT7=_aT7;
    aT8=_aT8;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int SecondaryTextureFromSurface(int snd)
{
    for (int n=0;n<24;n++)
        if (snd==SECONDARY1+n) return SECONDARYTEXTURE1-n;
	return SECONDARYTEXTURE1;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void C3DAPIBASE::SetFlag(int fl)
{
    valueflag=fl;
}

#if !defined(WEBASM)&&!defined(API3D_SDL2)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef WINDOWS_PHONE
#ifdef WINDOWS_STORE
int WindowsPhoneProcessorNumber=4;
#else
extern int WindowsPhoneProcessorNumber;
#endif
#else
#ifdef _WIN32
#include <windows.h>
#elif MACOS
#include <sys/param.h>
#include <sys/sysctl.h>
#else
#include <unistd.h>
#endif
#endif
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Found on the web !
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int getNumCores() {
#ifdef WINDOWS_PHONE
	return (WindowsPhoneProcessorNumber/2);
#else
#ifdef WIN32
    SYSTEM_INFO sysinfo;
    GetSystemInfo(&sysinfo);
    return sysinfo.dwNumberOfProcessors;
#elif MACOS
    int nm[2];
    size_t len = 4;
    uint32_t count;

    nm[0] = CTL_HW; nm[1] = HW_AVAILCPU;
    sysctl(nm, 2, &count, &len, NULL, 0);

    if(count < 1) {
        nm[1] = HW_NCPU;
        sysctl(nm, 2, &count, &len, NULL, 0);
        if(count < 1) { count = 1; }
    }
    return count;
#else
    return sysconf(_SC_NPROCESSORS_ONLN);
#endif
#endif
}
#endif
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
