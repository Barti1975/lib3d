////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//	  <3D Librairies developped during 2002-2021>
//	  Copyright (C) <2021>  <Laurent Cancé Francis, 10/08/1975>
//	  laurent.francis.cance@outlook.fr
//
//    This program is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    This program is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with this program.  If not, see <http://www.gnu.org/licenses/>.
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define LIB3D_VERSION "2.0"

/*?///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

<b>Annex</b>

basic concepts:

	Direct3D,OpenGL or vector maths fundementals are requiered.


	<hr> Transforms:
	
	setting the up vector :

		<i>Init_WorldUp(x,y,z);</i>

		in most of sub-libs the vector is considered to be (x,y,z)=(0,-1,0)

	setting transforms, basic modelling :

		.SetProjection() fix the projection matrix, viewport matrix is by default set (see InitViewPort())
		.LoadViewMatrix(CMatrix M) fix the camera transform (see CMatrix Class and Maths functions <A href="maths.html">MATHS</A>)
		.LoadWorldMatrix(CMatrix M) fix the object transformation in world (rotation,scaling,translation)
		
		some functions exist to set your own projection matrix (Arnaud query)

		at the initialisation the culling is OFF.

		.SetParams(API3D_CULL,ON/OFF) change this state (D3D warpper don't need this initialisation)
		.SetParams(API3D_CULL,CW/CCW) sets the orientation.

		lighting is OFF too.

		.SetParams(API3D_LIGHTING,ON/OFF)
		.SetParams(API3D_SPECULAR,ON/OFF)

		lights are set by .SetLightPoint() .SetLightDirectionnal() functions.

	<hr> Rendering basics:

	# preparing to render :

	CObject3d is the structure/class that store informations about a 3D object
		processing modules work with this structure not vertex buffer
		(see CObject3D,CBSPLights,CBSPVolumic,CGenerator,etc members)

	CVertexBuffer is the translation data to be rendered

	CVertexBuffer can be set manually by locking vertex array or index array or can be generated by :

	single texture object:
	
		CVertexBuffer.CreateFrom(CObject3D * obj,int tag,int type);
		CVertexBuffer.CreateFrom2(CObject3D * obj,int type);

	old method for environnent map object:
	
		CVertexBuffer.PhongVertexBuffer(CObject3D * obj);

	degenerated edges for shadowing, highlights:

		CVertexBuffer.CreateDegeneratedEdges(CObject3D * obj);
		CVertexBuffer.CreateDegeneratedEdges(CObject3D * obj,unsigned int flags);
		CVertexBuffer.CreateDegeneratedEdgesDynamic(CObject3D * obj);
		CVertexBuffer.CreateDegeneratedEdgesDynamic(CObject3D * obj,unsigned int flags);
		CVertexBuffer.CreateDegeneratedEdgesDynamicFacing(CObject3D * obj,unsigned int flags);
		CVertexBuffer.CreateDegeneratedEdgesDynamicFacing(CObject3D * obj);
		CVertexBuffer.CreateDegeneratedEdgesDynamicMerged(CObject3D * obj);
		CVertexBuffer.CreateDegeneratedEdgesDynamicMerged(CObject3D * obj,unsigned int flags);

	or 

	multi texture, smoothing group, lightmapped, dynamic object: (main function, this is to be used most of the time)

	CObject3D *obj;

	obj->Faces[n].tag=0..7 smoothing groups, mapping settings, vertex doubling for precalculated shadows
	obj->faces[n].ref=0,1,2 (blending, transparency)

	CVertexBuffer* C3DAPIBASE.CreateMultiGroupFrom(CObject3D * obj,unsigned int typ);


	vertex buffer exemples:

	for lighting TnL:

		the vertex buffer is to be set with those flags: 	
		API3D_VERTEXDATAS|API3D_NORMALDATAS|API3D_TEXCOODATAS|API3D_TEXPERVERTEX
		lighting or sepcular ON

	for environment mapping:

		API3D_VERTEXDATAS|API3D_NORMALDATAS|API3D_TEXCOODATAS|API3D_TEXPERVERTEX|API3D_ENVMAPPING
		.SetParams(API3D_SHADERS,DYNAMIC_ENV/FIXED_ENV) set the method for reflection.

	multi groups/vertex program:

	affiliates a vertex program:

		CVertexBuffer->SetVertexProgram(char *script_pseudo_code);

		(for more informations about pseudo_code see <A href="shaders.html">SHADERS</A>)

	cloning a previously set vertex program

		CVertexBuffer->CloneVertexProgram(CVertexBuffer *effect);

	vertex programs work like effects in Direct3D, even in OpenGL.


	multi texture support for vertex/pixel programs/shaders:

		CVertexBuffer->resetAssignation();
		CVertexBuffer->setTextureAssociation("Tex",TEXTURE_FROM_NT);
		CVertexBuffer->setTextureAssociation("Bump",TEXTURE_FROM_NT2);

		(see CVertexBuffer class <A href="vertexbuffer.html">VERTEX BUFFERS</A>)

	<hr> rendering basic loop

	while (1)
	{
		read events ()

		if (.BEGIN())
		{
			.SetParams(API3D_ZBUFFER,ON);
			.ClearVideoAndZBuffer();
			# .ClearStencilBuffer() optionnal

			.SetParams(API3D_RENERTARGET,RENDER);

			#setting view transform
	
			M.Id();
			M.View(Camera,(Target-Camera),roll);

			.SetProjection();
			.LoadViewMatrix(M);

			# basic rendering calls:

			for (n=0;n<#objects;n++)
			{
				.LoadWorldMatrix(Matrix of transformation of object n);
				.SetVertexBuffer(vertex buffer n);
				.DrawVertexBuffer();
			}

			.END();
			.FlipDoubleBuffer();
		}
	}

<hr>
*/

/*
comments:

	bug: emulated vertex programs errors on some shaders

adds:

	- secondary surfaces : the first one is initialised with 1/2 width and height values

  [20/06/2003] (begining of modification notice)
	- script object build implemented
	- shadows improved ; owner allocated vertex buffer for shadowing enabled ; facegroup cutting implemented ; 
	  multi texture per object managed

  [21/06/2003]
	- CreateMultiGroupFrom() finalised
	- multitexturing managed on all cards for all kind of vertex buffer

  [24/06/2003]
	- bump/ligthmap implemented in openGL
	- stencil shadow volume optimized with degenerated edges method / see CVertexBuffer remarks
		Note:

			Stencil shadowing is a two pass algorithm; The shadows are drawn by a pass with compare Stencil buffer to a ref
			value while drawing on render target :

			Render.SetParams(API3D_RENDERTARGET,BOTH);
			Render.SetParams(API3D_STENCIL,NOT_ZERO);

		default:
			
			Render.SetParams(API3D_RENDERTARGET,RENDER);
			

	- sphere tree generation from object added 
	- projective mapping added to C3DAPI class : texture projection, textured object project on object, on Cmesh
	- functionnality added to CGenerator::ReadScript()

  [25/06/2003]
	- added fixed and dynamic environment mapping D3D/GL (see nexts adds (31/08))
	- added new parameter API3D_SHADERS to set api own vertex shaders spefs

  [09/07/2003]
	- added support for hardware vertex processing on D3D 
	- bump mapping, dynamic environment fixed for opengl and d3d
	- shadowing bugs fixed with fpu precision
	- boolean bugs fixed too
	- heavy use of secondary texture/buffers fails on opengl
	- fix of all high level rendering functions
	- a new function added to ReadScript()
	- lightmap bugs fixed in open gl
	- added: .3d format from voidexporter/flexporter reader 
	- added: spherical texgen, object normalize to sph�re function, etc.
	- added: API3D_ENABLEUPDATE to vertex buffer / CorresVertices stands for indices in vertexbuffer of original object vertices

  [10/07/2003]
	- added functions to readscript for diffuse precalc
	- render to texture bug fixed
	- init windowed for SDL/OPENGL fixed
	- opengl bugs for envmap, polygon offset and stencil buffer init fixed
	
  [14/07/2003]
	- added high level vertex program compiler for direct3d and opengl

  [17/07/2003]
	- finished vertex program handling
	- added emulation vertex program to enable them on "ARB_vertex_program" string missing opengl driver : slow.
	- vertexprogram.cpp should be compiled with "fastcall" method of code generation
	
  [25/08/2003]
    - added macro fonctionnalities to vertex program :  
	
		1) macro style functions can be defined to enhance readability of v.p.
			syntax:

			[MACROS]
				Tangente(v)                          // name(params,...)  
	    			{
			    			temp=tgt(up,v);          // all new registers will be temporary register
			    			temp;                    // return value
					}
    
		2) conditionnal test;
			syntax:
			
			if (a>b) 
			{
				r=a;
			}
			else
			{
				r=b;
			}

			or 

			r=0;					// initialisation is needed to prevent shader register error
			if (a>b) 
			{
				r=1;
			}


    - bug fix of tlk_scene.h and added dostuffs undostuffs to read textures and applyies texture transforms
    - bug fix of shadowing 

  [26/08/2003]
	- bug fix for dostuffs and undostuffs

  [27/08/2003]

	- alpha blending state to command drawing
  
		.SetParams(API3D_ALPHAMULTIGROUP,DONT_DRAW);	// alpha ref!=0 no draw
		.SetParams(API3D_ALPHAMULTIGROUP,DRAW);			// draw all groups
		.SetParams(API3D_ALPHAMULTIGROUP,ONLY);			// alpha ref!=0 only draw


  [31/08/2003]

	- when using API3D_ENVMAPPING: added 2 new options (for automatic use of .3D scene)

		Render.SetParams(API3D_ENVMULTIGROUP,INTERN);
		Render.SetParams(API3D_ENVMULTIGROUP,EXTERN);

		INTERN specifies that the envmap number will be token in .nT2 on the vertex buffer
		EXTERN involves .DrawVertexBuffer() to use first stage texture specified by the user with .SetTexture()

		Note: the L vector inside the vertex buffer set the reference point to environment mapping
		(this is for use with normal environement mapping method)

		You can use dynamic reflection by setting : Render.SetParams(API3D_SHADERS,DYNAMIC_ENV);
		The basic method set at the initialisation is FIXED_ENV
	

	- add parameter settings to DoStuffs in TLK3D_scene

		void TLK3D::SetFlag(int name,int value)

		name:
			LOAD_TEXTURES
			APPLY_TEXTURE_TRANSFORM


		value:
			ACTIVATED
			DESACTIVATED
		
	[14/04/2004]

	- bug fixed
	- mac os X opengl/sdl support
	- directX9 compatibility added
	- add multi-sizing lightmaps
	- multiple texture vertex buffer optimisations
	- carmack reverse stencil shadowing implementation (directX only)
	- automatic generation of dynamic open object edges vertex buffer added
	- triangularisation bugs fixed
	- several figures test functions added
	- bsp2d implementation
	- vertex programs bug fixed
	- pixel shaders implementation in both lib build-in special effects and on vertex program (GL implemntation can not be tested)
	- several morphs and other vertex buffer automatic updates added
	- tga support added
	- bsp light, bsp_volumic bug fixed
	- texture management improved
	- TLK3D save functionnality added
	- shadow projection functions for bump lightmappped objects added in C3DAPI
	- physic static object parameters added
	- TLK3D support of environment mapped objects
	- data container classes added

	[22/04/2004]

	- added opengl carmack stencil shadow reverse support
	- gl viewport matrix update
	- gl extended stencil function support
	- new class of vertex buffers for d3d displacement specular dynamic diffuse bump mapping 
	- full gl multitexturing support comparatively to d3d support

	[10/05/2004]

	- API3D_MORPH vertex buffer gl/dx8/dx9 option added allowing vertex tweening in carmack reverse stencil
	shadow volume drawing through CreateDegeneratedEdgesDynamicFacing(CObject3D * obj,API3D_VERTEXDATAS|API3D_NORMALDATAS|API3D_TEXCOODATAS|API3D_EDGESDG|API3D_MORPH);
	and in API3D_VERTEXDATAS|API3D_NORMALDATAS|API3D_TEXCOODATAS TNL drawing.
	
	[24/09/2004]

	- added multiple texture container support
	- added support to rectangular texture
	- added support to 32bits textures
	- bug fix on shaders for opengl (fragment program)
	- added multiple file in-built shaders
	- added basic effect, creating a generic vertex buffer by calling BasicEffect method
	- added alternative stencil shadowing method
	- added multiple effect support by calling SetEffect(BASIC_EFFECT / NULL) function
	- added blur() method
	- added dobump() method
	- added gentexture in misc components
	- added genvegetal in misc components
	- directx9 bug fixes
	- added dll compilation option
	- physic engine upgrade
	- added support to full object/collisionmesh collision in physic engine
	- bsp volumic bug fixes
	- added fast boolean method
	- bsp light improvements (trivial tests to speed up calculation)

	[07/11/2004]

	- opengl dobump bug fixes
	- opengl vertex program/drawvertexbuffer() bug fixes
	- opengl/d3d dospecular function added
	- plenty of optimisations on vector and matrix classes
	- added some usefull morph vertex buffer functions
	- comments before each functions
	- getWidth() getHeight() functions
	- CheckDevice() function
	- API3D_CONSTANT flag for vertexbuffer witch are allocated dynamic by default
	- some optimisations on dynamic vertexbuffers

	[14/01/2004]

	- alternative stencil shadow volume finished
	- full boolean approximation
	- bug fix in triangularisation etc.
	- lightmaps improvments

	[01/03/2005]

	- improvments and bug fixes in special renderer functions
	- improvments in soft renderer
	- upgrade of secondary surfaces management

	[15/04/2005]

	- bsp light optimizations
	- projection shadowing optimizations
	- add gen vegetals functionnality
	- memory leaks fix

	[30/06/2005]

	- add API3D_TEXTUREFILTERS parameters usefull for layer rendering

	[12/07/2005]

	- context vertex buffer parametrization added

	[2008/2009]

	- iPhone support (gles 1.1)

	[2011]

	- ANDROID support (gles 1.1)

	[10/2012]

	- upgrade of secondary surfaces management (gl) with FRAMEBUFFERS
	- adding support for shader model 2.x and glsl
	- metaballs bug fixes

	[09/2013]

	- fastboolean2a functions (boolean operations)
	- support for multithreading
	- multithreaded physics
	- metaballs optimisations
	
	[10/2013]

	- adding function calls support with shadermodel 2.x and glsl
	- adding support for shader model 3.0 and glsl
		rep endrep iter(stage) break continue and full function support
	- bug fixes in compilation of shaders

	[11/2013]
	
	- update to Direct3D 10 and 10.1
	- built-in shaders preverving compatibility
	- support only for power in materials during TNL process
	- compatibility to shader model 4
	- compatibility GLES2.0 (Android, iPhone)

	The system of lib3d/ned is now compatible with : DX8.1, DX9, DX9c, DX10, DX10.1, OpenGL, OpenGLES1.1, OpenGLES2.0
	
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/

#ifndef _3D_API_BASE_H_
#define _3D_API_BASE_H_

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	3DAPI global defs
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// internal vertex buffer size
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define		NUMBER_MAX_INDICES_SHADOW			20000
#define		NUMBER_MAX_VERTICES_SHADOW			20000
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define		MAX_SECONDARIES						24
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "include.h"
#include "list.h"
#include "vertexprogram.h"
#include "vertexbuffer.h"
#include "statement.h"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//													CLASSES
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

#ifdef GLES20
#ifndef GL_MODULATE
#define GL_MODULATE 0
#define GL_ADD 1
#endif
#endif
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// internals
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef API3D_DIRECT3D
class API3D_STUB CDisplayMode
{
public:
	D3DFORMAT RenderFormat;
	D3DFORMAT ZbufferFormat;
};
#endif


#ifdef API3D_DIRECT3D9
class API3D_STUB CDisplayMode
{
public:
	D3DFORMAT RenderFormat;
	D3DFORMAT ZbufferFormat;
};
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "texture.h"
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//#define HEAP_DYNAMIC_BUFFERS_SIZE (1024*1024*4)
#define D3D_NBUFFERS 2
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//													LIGHTSOURCE CLASS
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

class API3D_STUB CLight
{
public:
	CVector					Pos;
	float					r,g,b;
	float					Attenuation,Range; // range doesn't work in openGL
	// added
	bool					directionnal;
	int						enabled;
	float					color[4];
	float					colorsave[4];
	float					specular[4];
	float					variation;
	int						emit_shadows;

	CLight() { enabled=0; emit_shadows=1; }
};

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//													VIEWPORT
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 

#ifdef API3D_METAL
class CViewport
{
public:

    float					TopLeftX;
    float					TopLeftY;
	float					Width;
    float					Height;
    float					MinDepth;
    float					MaxDepth;

	CViewport() { MinDepth=0.0f; MaxDepth=1.0f; }
};
#endif

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//													RENDER CLASS
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//! Render class
//! This wrap functions from API like DirectX8,9 or OpenGL.
//! This is intermediate level of interface for coding graphic cards.
//! Althought this class provides some extended functionnality, it consists 
//! of a low level api in order to dialog with OpenGl or Direct3D 8/9. 
//! Due to the equivalence of some functionnality in those api and to the few discordances, 
//! the wrapper 00 merge the GL and D3D form in single that is some of specific artefact
//! of D3D are main method form and vice versa.

//! <a href="lib3d_base.pdf"><B>Modules Graphs</B></a>
//! <a href="lib3d_data.pdf"><B>Data interfaces</B></a>

class API3D_STUB C3DAPIBASE
{
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// internals

public:

	CStatement				states;
	float					FPS;
	char*					NameGroup;
	int						OptionAffichage;
	int						SelectedRenderTarget;
	char *					SecondaryRenderTargetBits;
	int						bumpmap_settexture;
	bool					StencilBuffer;
	bool					Lighting;
	bool					VertexPrograms;
	int						nSecondaries;
	int						projSCREENX,projSCREENY;
	char					tagLights[1024];
	CList <CLightmap>		DefaultLightmaps;
	CList <CLightmap>		*Lightmaps;
	int						ACTUAL_LIGHTMAP;
	int						ACTUAL_LIGHTMAP2;
	bool					MultiTexture;
	bool					Specular;
	int						bump_displace;
	int						bump_horizon;
	int						count_nv,count_nf,count_nfavoid,count_nvb;
	unsigned char *			grids[NBRE_MAX_TEXTURES];
	CMatrix					MAIN_MATRIX2D;
	int						Decal_nt;
	int						Decal_nt2;
	int						tile_secondarysurfaces[MAX_SECONDARIES];
	int						tile_secondarysurfacesW[MAX_SECONDARIES];
	int						tile_secondarysurfacesH[MAX_SECONDARIES];
	bool					tag_tile;
	unsigned int			texture_memory_size;
	int						temporary_secondary_surface;
    bool                    AutomaticallyCloneShaders;

	int						(*fn_stage_draw)(int nt,int nt2,int nl,int nlv,int tag);
	int						(*fn_stage0)(int nt,int nt2,int nl,int nlv,int tag);
	int						(*fn_stage1)(int nt,int nt2,int nl,int nlv,int tag);
	int						(*fn_stage2)(int nt,int nt2,int nl,int nlv,int tag);
	int						(*fn_stage3)(int nt,int nt2,int nl,int nlv,int tag);
	int						(*fn_stage4)(int nt,int nt2,int nl,int nlv,int tag);
	int						(*fn_stage5)(int nt,int nt2,int nl,int nlv,int tag);
	CContextEffectParameters * ContextEffect;

    float                   SwitchRetinaDisplay;
    bool                    force_reloc;
    
    bool                    LevelOfDetail;
    
#ifndef _DEFINES_API_CODE_TEXTURE_MANAGER_
	CTexture*				iTexture[NBRE_MAX_TEXTURES];
	unsigned char			cTexture[NBRE_MAX_TEXTURES];
#endif

#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
	CTextureAPIContainer*	TextureContainer;
	CTextureAPIContainer*	DefaultTextureContainer;
	iCTextureAPIContainer	iTexture;
	tCTextureAPIContainer	Texture;
	cCTextureAPIContainer	cTexture;
	CTextureAPIContainer*	LightmapContainer;
	CTextureAPIContainer*	DefaultLightmapContainer;
	iCTextureAPIContainer	iLightmap;
	tCTextureAPIContainer	Lightmap;
	cCTextureAPIContainer	cLightmap;
#endif

#ifdef API3D_DIRECT3D
	DWORD					PixelShaderBlur;
	DWORD					PixelShaderBump;
	DWORD					PixelShaderBumpSpec;
	DWORD					handle_morph_cr;
	DWORD					handle_morph;
	int						nMultiQuads;
	struct CUSTOMVERTEX0	*MultiQuads;
	struct CUSTOMVERTEX0	*TempMultiQuads;
	
	LPD3DXEFFECT			EffectBumpMapping;
	LPD3DXEFFECT			EffectBumpMappingDisplaceSS;
	LPD3DXEFFECT			Effect_ENV_VSH;
	LPD3DXEFFECT			Effect_ENV2_VSH;
	LPD3DXEFFECT			MULTI00,MULTI01,MULTI10,MULTI11;
	LPD3DXEFFECT			BML,BMLa,BMLD;
	LPD3DXEFFECT			SHDVOLUME,SHDVOLUMEc;
	LPD3DXEFFECT			SHDVOLUMEn,SHDVOLUMEcn;
	LPD3DXEFFECT			SHDVOLUMEm,SHDVOLUMEmc;
	LPD3DXEFFECT			SHDVOLUME_CR1,SHDVOLUME_CR2;
	LPD3DXEFFECT			SHDVOLUME_CR1m,SHDVOLUME_CR2m;
	D3DXTECHNIQUE_DESC		tech_ENV_VSH;
	bool					ENV_VSH_activated;
	int						SETTINGS_ADAPTER;
	int						RGBbits;
	int						DoubleTexture;
	D3DFORMAT				SurfaceBackFormat;
	D3DFORMAT				SecondaryFormat;
	D3DFORMAT				SecondaryFormatZ;
	CDisplayMode			rgb16,rgb24,rgb32;
#ifndef _DEFINES_API_CODE_TEXTURE_MANAGER_
	LPDIRECT3DTEXTURE8		Lightmap[NBRE_MAX_TEXTURES];
	CTexture				iLightmap[NBRE_MAX_TEXTURES];
	LPDIRECT3DTEXTURE8		Texture[NBRE_MAX_TEXTURES];
#endif
	LPDIRECT3DTEXTURE8		Noir,Blanc;
	LPDIRECT3DBASETEXTURE8	Texture0,Texture1,Texture2,Texture3,Texture4,Texture5,Texture6,Texture7;
	LPDIRECT3D8				D3D;
	LPDIRECT3DDEVICE8       D3DDevice; 
	LPDIRECT3DSURFACE8      SurfaceBack,PreviousRenderTarget,PreviousZbuffer; 
	LPDIRECT3DTEXTURE8		D3DTextureSecondary[MAX_SECONDARIES];
	LPDIRECT3DSURFACE8		D3DSecondary[MAX_SECONDARIES],D3DSecondaryZbuffer[MAX_SECONDARIES];
	D3DVIEWPORT8			SecondaryViewport[MAX_SECONDARIES];
	D3DCAPS8				caps;
	D3DDISPLAYMODE			d3ddm;
	D3DPRESENT_PARAMETERS	d3dpp; 
	D3DVIEWPORT8			ViewPort,PreviousViewport;
	LPDIRECT3DVERTEXBUFFER8 D3DVB_XYZCOLORTEX;
	LPDIRECT3DVERTEXBUFFER8 D3DVB_XYZCOLOR;
	DWORD					LevelTexture0,LevelTexture1;
	HWND					hWindow;
	HINSTANCE				hInstance;
#endif



#ifdef API3D_DIRECT3D9
	LPDIRECT3DPIXELSHADER9	PixelShaderBlur;
	LPDIRECT3DPIXELSHADER9	PixelShaderBump;
	LPDIRECT3DPIXELSHADER9	PixelShaderBumpSpec;
	LPDIRECT3DVERTEXDECLARATION9 TNL_VD;
	LPDIRECT3DVERTEXDECLARATION9 CR_VD;
	DWORD					handle_morph_cr;
	DWORD					handle_morph;
	int						nMultiQuads;
	int						MultiQuadsZbuffer;
	//struct CUSTOMVERTEX0	*MultiQuads;
	//struct CUSTOMVERTEX0	*TempMultiQuads;
	bool					whileFlush;
	int						set_alphatest;
	float					val_alphatest;
	CVertexBuffer			vbquads;
	CVertexBuffer			*QuadEffect;
	CMatrix					ProjOrtho;
	LPD3DXEFFECT			EffectBumpMapping;
	LPD3DXEFFECT			EffectBumpMappingDisplaceSS;
	LPD3DXEFFECT			Effect_ENV_VSH;
	LPD3DXEFFECT			Effect_ENV2_VSH;
	LPD3DXEFFECT			MULTI00,MULTI01,MULTI10,MULTI11;
	LPD3DXEFFECT			BML,BMLa,BMLD;
	LPD3DXEFFECT			SHDVOLUME,SHDVOLUMEc;
	LPD3DXEFFECT			SHDVOLUMEn,SHDVOLUMEcn;
	LPD3DXEFFECT			SHDVOLUMEm,SHDVOLUMEmc;
	LPD3DXEFFECT			SHDVOLUME_CR1,SHDVOLUME_CR2;
	LPD3DXEFFECT			SHDVOLUME_CR1m,SHDVOLUME_CR2m;
	D3DXTECHNIQUE_DESC		tech_ENV_VSH;
	bool					ENV_VSH_activated;
	int						SETTINGS_ADAPTER;
	int						RGBbits;
	int						DoubleTexture;
	D3DFORMAT				SurfaceBackFormat;
	D3DFORMAT				SecondaryFormat;
	D3DFORMAT				SecondaryFormatZ;
	CDisplayMode			rgb16,rgb24,rgb32;
#ifndef _DEFINES_API_CODE_TEXTURE_MANAGER_
	LPDIRECT3DTEXTURE9		Lightmap[NBRE_MAX_TEXTURES];
	CTexture				iLightmap[NBRE_MAX_TEXTURES];
	LPDIRECT3DTEXTURE9		Texture[NBRE_MAX_TEXTURES];
#endif
	LPDIRECT3DTEXTURE9		Noir,Blanc;
	LPDIRECT3DBASETEXTURE9	Texture0,Texture1,Texture2,Texture3,Texture4,Texture5,Texture6,Texture7;
	LPDIRECT3D9				D3D;
	LPDIRECT3DDEVICE9       D3DDevice; 
	LPDIRECT3DTEXTURE9		D3DTextureSecondary[MAX_SECONDARIES];
	LPDIRECT3DTEXTURE9		D3DTextureZBufferSecondary[MAX_SECONDARIES];
	LPDIRECT3DSURFACE9		D3DSecondary[MAX_SECONDARIES],D3DSecondaryZbuffer[MAX_SECONDARIES];
	D3DVIEWPORT9			SecondaryViewport[MAX_SECONDARIES];
	LPDIRECT3DSURFACE9		SurfaceBack,PreviousRenderTarget,PreviousZbuffer;
	D3DCAPS9				caps;
	D3DDISPLAYMODE			d3ddm;
	D3DPRESENT_PARAMETERS	d3dpp; 
	D3DVIEWPORT9			ViewPort,PreviousViewport;
	LPDIRECT3DVERTEXBUFFER9 D3DVB_XYZCOLORTEX;
	LPDIRECT3DVERTEXBUFFER9 D3DVB_XYZCOLOR;
	DWORD					LevelTexture0,LevelTexture1;
	HWND					hWindow;
	HINSTANCE				hInstance;
    RECT                    scissor;
#endif

#ifdef API3D_DIRECT3D10

	int						nMultiQuads;
	struct CUSTOMVERTEX0	*MultiQuads;
	int						MultiQuadsZbuffer;
	CMatrix					ProjOrtho;

	CVertexBuffer			vbquads;
	CVertexBuffer			vbquadblur;
	CVertexBuffer			vbquad2;
	CVertexBuffer			vbline;
	CVertexBuffer           vbline3d;
	int                     nbline,nbline3d;
	CVertexBuffer			vbquad_xyzcolor;
	CVertexBuffer			vbquad_xyzcolortex;

	bool					vbdraw_line;
	
	int						set_alphatest;
	float					val_alphatest;

	int						lT,lT2;
	DWORD					LevelTexture0,LevelTexture1;
	HWND					hWindow;
	HINSTANCE				hInstance;

	ID3D10Texture2D*		renderTargetTexture[MAX_SECONDARIES];
	ID3D10RenderTargetView* renderSndTargetView[MAX_SECONDARIES];
	ID3D10ShaderResourceView* shaderResourceView[MAX_SECONDARIES];
	ID3D10ShaderResourceView* shaderResourceViewDepth[MAX_SECONDARIES];
	D3D10_TEXTURE2D_DESC	rdepthBufferDesc[MAX_SECONDARIES];
	ID3D10Texture2D*		renderDepthStencilBuffer[MAX_SECONDARIES];
	ID3D10DepthStencilView* renderDepthStencilView[MAX_SECONDARIES];
	D3D10_DEPTH_STENCIL_VIEW_DESC rdepthStencilViewDesc[MAX_SECONDARIES];
	D3D10_VIEWPORT			SndViewport[MAX_SECONDARIES];

	DWORD					StencilREF;
	int						ZBufferTmp;

	ID3D10ShaderResourceView* Texture0;
	ID3D10ShaderResourceView* Texture1;
	ID3D10ShaderResourceView* Texture2;
	ID3D10ShaderResourceView* Texture3;
	ID3D10ShaderResourceView* Texture4;
	ID3D10ShaderResourceView* Texture5;
	ID3D10ShaderResourceView* Texture6;
	ID3D10ShaderResourceView* Texture7;

	D3DXMATRIX				projectionMatrix;
	D3DXMATRIX				viewMatrix;
	D3DXMATRIX				worldMatrix;
	D3DXMATRIX				viewportMatrix;

	IDXGISwapChain*			swapChain;
#ifdef API3D_VERSION_DX10_1
	ID3D10Device1*			device;
#else
	ID3D10Device*			device;
#endif
	ID3D10RenderTargetView*	renderTargetView;

	ID3D10RenderTargetView*	render;
	ID3D10DepthStencilView* depthstencil;

	ID3D10Texture2D*		depthStencilBuffer;
	ID3D10DepthStencilState*depthStencilState;
	
	ID3D10DepthStencilView* depthStencilView;
	ID3D10RasterizerState*	rasterState;

	DXGI_SWAP_CHAIN_DESC	swapChainDesc;
	ID3D10Texture2D*		backBufferPtr;
	D3D10_TEXTURE2D_DESC	depthBufferDesc;

	D3D10_DEPTH_STENCIL_DESC depthStencilDesc;

	D3D10_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;
	D3D10_VIEWPORT			Viewport;
	D3D10_RASTERIZER_DESC	rasterDesc;

	D3D10_BLEND_DESC		blendStateDesc;

	ID3D10BlendState*		blendStateTMP;
	ID3D10BlendState*		blendStateOFF;
	ID3D10BlendState*		blendStateON;
	ID3D10BlendState*		blendStateCOLOR;
	ID3D10BlendState*		blendStateINVERSE;
	ID3D10BlendState*		blendStateGOURAUD;
	ID3D10BlendState*		blendStateADD;
	ID3D10BlendState*		blendStateDISCARD;

    RECT                    scissor;
    
	float					factors[8];

	ID3D10InputLayout*		layout[64];

	float					aBack,aFront;
	int						RESET;

	bool					whileFlush;

#endif

#ifdef API3D_DIRECT3D11

	int						nMultiQuads;
	struct CUSTOMVERTEX0	*MultiQuads;
	int						MultiQuadsZbuffer;
	CMatrix					ProjOrtho;

	CVertexBuffer			vbquads;
	CVertexBuffer			vbquadblur;
	CVertexBuffer			vbquad2;
	CVertexBuffer			vbline;
	CVertexBuffer           vbline3d;
	int                     nbline,nbline3d;
	CVertexBuffer			vbquad_xyzcolor;
	CVertexBuffer			vbquad_xyzcolortex;

	bool					vbdraw_line;
	
	int						set_alphatest;
	float					val_alphatest;

	int						lT,lT2;
	DWORD					LevelTexture0,LevelTexture1;
	HWND					hWindow;
	HINSTANCE				hInstance;

	ID3D11Texture2D*		renderTargetTexture[MAX_SECONDARIES];
	ID3D11RenderTargetView* renderSndTargetView[MAX_SECONDARIES];
	ID3D11ShaderResourceView* shaderResourceView[MAX_SECONDARIES];
	ID3D11ShaderResourceView* shaderResourceViewDepth[MAX_SECONDARIES];
	D3D11_TEXTURE2D_DESC	rdepthBufferDesc[MAX_SECONDARIES];
	ID3D11Texture2D*		renderDepthStencilBuffer[MAX_SECONDARIES];
	ID3D11DepthStencilView* renderDepthStencilView[MAX_SECONDARIES];
	D3D11_DEPTH_STENCIL_VIEW_DESC rdepthStencilViewDesc[MAX_SECONDARIES];
	D3D11_VIEWPORT			SndViewport[MAX_SECONDARIES];

	DWORD					StencilREF;
	int						ZBufferTmp;

	ID3D11ShaderResourceView* Texture0;
	ID3D11ShaderResourceView* Texture1;
	ID3D11ShaderResourceView* Texture2;
	ID3D11ShaderResourceView* Texture3;
	ID3D11ShaderResourceView* Texture4;
	ID3D11ShaderResourceView* Texture5;
	ID3D11ShaderResourceView* Texture6;
	ID3D11ShaderResourceView* Texture7;

	CMatrix					projectionMatrix;
	CMatrix					viewMatrix;
	CMatrix					worldMatrix;
	CMatrix					viewportMatrix;

#ifdef WINDOWS_PHONE
	ID3D11Device2*			device;
	ID3D11DeviceContext2*	devicecontext;
#else
	IDXGISwapChain*			swapChain;
	ID3D11Device*			device;
	ID3D11DeviceContext*	devicecontext;
#endif

	ID3D11RenderTargetView*	renderTargetView;

	ID3D11RenderTargetView*	render;
	ID3D11DepthStencilView* depthstencil;

	ID3D11Texture2D*		depthStencilBuffer;
	ID3D11DepthStencilState*depthStencilState;
	
	ID3D11DepthStencilView* depthStencilView;
	ID3D11RasterizerState*	rasterState;

#ifndef WINDOWS_PHONE
	DXGI_SWAP_CHAIN_DESC	swapChainDesc;
#endif

	ID3D11Texture2D*		backBufferPtr;
	D3D11_TEXTURE2D_DESC	depthBufferDesc;

	D3D11_DEPTH_STENCIL_DESC depthStencilDesc;

	D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;
	D3D11_VIEWPORT			Viewport;
	D3D11_RASTERIZER_DESC	rasterDesc;

	D3D11_BLEND_DESC		blendStateDesc;

	ID3D11BlendState*		blendStateTMP;
	ID3D11BlendState*		blendStateOFF;
	ID3D11BlendState*		blendStateON;
	ID3D11BlendState*		blendStateCOLOR;
	ID3D11BlendState*		blendStateINVERSE;
	ID3D11BlendState*		blendStateGOURAUD;
	ID3D11BlendState*		blendStateADD;
	ID3D11BlendState*		blendStateDISCARD;
    
    RECT                    scissor;

	float					factors[8];

	ID3D11InputLayout*		layout[64];

	float					aBack,aFront;
	int						RESET;

	bool					whileFlush;

#endif

#ifdef API3D_DIRECT3D12

	int						nMultiQuads;
	struct CUSTOMVERTEX0	*MultiQuads;
	int						MultiQuadsZbuffer;
	CMatrix					ProjOrtho;

	CVertexBuffer			vbquads;
	CVertexBuffer			vbquadblur;
	CVertexBuffer			vbquad2;

	CVertexBuffer			vbline;
    CVertexBuffer           vbline3d;
    int                     nbline,nbline3d;

	CVertexBuffer			vbquad_xyzcolor;
	CVertexBuffer			vbquad_xyzcolortex;

	bool					vbdraw_line;
	
	int						set_alphatest;
	float					val_alphatest;

	int						lT,lT2;
	DWORD					LevelTexture0,LevelTexture1;
	HWND					hWindow;
	HINSTANCE				hInstance;
    int                     CRCState;
    bool                    dirtyCRCState;
    
    CVertexBuffer *         prevEffect;

	DescriptorHeapHandleContainer *heap;
	DescriptorHeapHandleContainer HandleContainer;

	IDXGIFactory4*			factory;
	DXGI_SWAP_CHAIN_DESC1	swapChainDesc;

	ID3D12Resource*			renderTargetTexture[MAX_SECONDARIES];
	DescriptorHeapHandle	shaderResourceView[MAX_SECONDARIES];
	DescriptorHeapHandle	shaderResourceViewDepth[MAX_SECONDARIES];

	CD3DX12_CPU_DESCRIPTOR_HANDLE	renderSndTargetView[MAX_SECONDARIES];
	CD3DX12_CPU_DESCRIPTOR_HANDLE	renderDepthStencilView[MAX_SECONDARIES];

    CD3DX12_CPU_DESCRIPTOR_HANDLE   rtvSurface;
	CD3DX12_CPU_DESCRIPTOR_HANDLE   prevSurface;
    CD3DX12_CPU_DESCRIPTOR_HANDLE   dsvDepthStencil;

    CD3DX12_CPU_DESCRIPTOR_HANDLE   rtv_rendertargets[D3D_NBUFFERS];
    CD3DX12_CPU_DESCRIPTOR_HANDLE   dsv_depthstencil[D3D_NBUFFERS];

	ID3D12Resource*			renderDepthStencilBuffer[MAX_SECONDARIES];
	CD3DX12_VIEWPORT		SndViewport[MAX_SECONDARIES];
	CD3DX12_RECT			SndScissorRect[MAX_SECONDARIES];

	bool					commandsexecuted[D3D_NBUFFERS];

	CList <CVertexBuffer*>  VBVP;

    CD3DX12_VIEWPORT        Viewport;
    CD3DX12_RECT            ScissorRect;

    CD3DX12_VIEWPORT        ViewportActual;
    CD3DX12_RECT            ScissorRectActual;

	IDXGISwapChain3*		swapChain;
	ID3D12Device*			device;
	ID3D12Resource*			resTarget,*prevTarget;
	ID3D12Resource*			resDepth,*prevDepth;
	ID3D12Resource*			renderTargets[D3D_NBUFFERS];
	ID3D12Resource*			depthstencil[D3D_NBUFFERS];
	ID3D12CommandAllocator* commandAllocator;
	ID3D12CommandAllocator* commandAllocators[D3D_NBUFFERS];
	ID3D12CommandQueue*		commandQueue;


	CList <CVertexBuffer*>  TemporaryVertexBuffers[D3D_NBUFFERS];

	int						CounterCommandList;

	CList<ID3D12Resource*>	ConstantBuffers[D3D_NBUFFERS][1024];
	CList<DescriptorHeapHandle>	ConstantBuffersId[D3D_NBUFFERS][1024];
	CList<UINT8*>			ConstantBuffersPtr[D3D_NBUFFERS][1024];
	//unsigned long			ofsConstantBuffers[2];
	//ID3D12Resource*			heapConstantBuffers[2];
	//UINT8*					pdataConstantBuffer[2];

	bool					primaryneeds;
	int						alphablendingref;

	ID3D12PipelineState*	previouspipe;

	CList <ID3DFXEffect*>   ActualEffects;

	bool					rendering;
	
	ID3D12DescriptorHeap*	rtvHeap;
	ID3D12DescriptorHeap*	dsvHeap;
	D3D12_GRAPHICS_PIPELINE_STATE_DESC	GlobalPipelineDesc;
    D3D12_GRAPHICS_PIPELINE_STATE_DESC  PreviousPipelineDesc;
	CList <ID3D12PipelineState*>		pipelineState[D3D_NBUFFERS];
	ID3D12GraphicsCommandList*			commandList;

	int						nbpiplelines;
	ID3D12PipelineState*	actualpipeline;
	CList <ID3D12Resource*>	TexturesFreeing;

	CList <ID3D12Resource*>	DynamicResources[D3D_NBUFFERS];
	CList <DescriptorHeapHandle> DynamicResourcesId[D3D_NBUFFERS];

	unsigned int			max_videomemory_used;

	UINT					rtvDescriptorSize;
	UINT					dsvDescriptorSize;

	DWORD					StencilREF;
	int						ZBufferTmp;

	bool					viewportmodified;

	DescriptorHeapHandle*	Texture0;
	DescriptorHeapHandle*	Texture1;
	DescriptorHeapHandle*	Texture2;
	DescriptorHeapHandle*	Texture3;
	DescriptorHeapHandle*	Texture4;
	DescriptorHeapHandle*	Texture5;
	DescriptorHeapHandle*	Texture6;
	DescriptorHeapHandle*	Texture7;

	UINT					frameIndex,oldframeIndex;

	HANDLE					fenceEvent[D3D_NBUFFERS];
	ID3D12Fence*			fence[D3D_NBUFFERS];
	UINT64					fenceValue[D3D_NBUFFERS];

	HANDLE					fenceEvent2;
	ID3D12Fence*			fence2;

	CMatrix					projectionMatrix;
	CMatrix					viewMatrix;
	CMatrix					worldMatrix;
	CMatrix					viewportMatrix;

	//ID3D11Texture2D*		backBufferPtr;

	float					factors[8];

	D3D12_INPUT_ELEMENT_DESC	layout[64];

	float					aBack,aFront;
	int						RESET;

	bool					whileFlush;

#endif

#ifdef API3D_METAL

	int						nMultiQuads;
	int						MultiQuadsZbuffer;
	CMatrix					ProjOrtho;
    
    int                     Blanc;
    
    int                     BLEND_GL;

	CVertexBuffer			vbquads;
	CVertexBuffer			vbquadblur;
	CVertexBuffer			vbquad2;
	CVertexBuffer           vbline;
    CVertexBuffer           vbline3d;
    int                     nbline,nbline3d;
	CVertexBuffer			vbquad_xyzcolor;
	CVertexBuffer			vbquad_xyzcolortex;

	bool					vbdraw_line;
	
	int						set_alphatest;
	float					val_alphatest;

	int						lT,lT2;
	unsigned int			LevelTexture0,LevelTexture1;

	CViewport				SndViewport[MAX_SECONDARIES];

	unsigned int			StencilREF;
	int						ZBufferTmp;

	CMatrix					projectionMatrix;
	CMatrix					viewMatrix;
	CMatrix					worldMatrix;
	CMatrix					viewportMatrix;

	CViewport				Viewport;

	float					factors[8];

	float					aBack,aFront;
	int						RESET;

	bool					whileFlush;

#endif

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
	int						TAG_RESET;
	GLuint					vp_stencilshadow;
	GLuint					fp_renderbml;
	int						BLEND_GL;

#ifdef API3D_OPENGL20
	int						nMultiQuads;
	int						MultiQuadsZbuffer;
	CMatrix					ProjOrtho;
    
	CVertexBuffer			vbquads;
	CVertexBuffer			vbquadblur;
	CVertexBuffer			vbquad2;
	CVertexBuffer			vbline;
	CVertexBuffer           vbline3d;
	int                     nbline,nbline3d;
	CVertexBuffer			vbquad_xyzcolor;
	CVertexBuffer			vbquad_xyzcolortex;

	bool					vbdraw_line;
	
	int						set_alphatest;
	float					val_alphatest;

	int						lT,lT2;

	bool					whileFlush;

	GLfloat					projection[16];
	GLfloat					modelview[16];
#endif

#ifndef _DEFINES_API_CODE_TEXTURE_MANAGER_
	unsigned int 			Texture[NBRE_MAX_TEXTURES];
	unsigned int    		Lightmap[NBRE_MAX_TEXTURES];
#endif
	
	GLuint					PixelShaderBump;
	GLuint					PixelShaderBumpSpec;
	
	GLclampf				alpha_value;
	GLint					value_alpha;

	GLfloat					RGBA[4];
#ifdef OPENGL_PBUFFERS
	HDC						hGLDC;
	HGLRC					hGLRC;
	HPBUFFERARB				hPBuffer[MAX_SECONDARIES];
	HDC						hPBufferDC[MAX_SECONDARIES];
	HGLRC					hPBufferRC[MAX_SECONDARIES];
	GLuint					pbufferTextureID[MAX_SECONDARIES];
	bool					pbufferInitialized[MAX_SECONDARIES];
#endif

#ifdef OPENGL_GLSL
#if !defined(GLES)&&!defined(GLES20)
#ifdef OCULUS
	GLint					glslprogram_sv;
	GLint					vert_shader_sv;
#else
	GLhandleARB				glslprogram_sv;
	GLhandleARB				vert_shader_sv;
#endif
#endif
#endif

#if defined(IOS)
    GLint                   defaultFBO;
#endif

#if defined(GOOGLEVR)||defined(API3D_VR)
    int                     viewportVR[4];
    GLint                   defaultFBO;
	GLint					defaultFBOPrimary;
    bool                    catseyes;
#endif

#ifdef OPENGL_FRAMEBUFFERS
	GLuint					FramebufferName[MAX_SECONDARIES];
	GLuint					renderedTexture[MAX_SECONDARIES];
	GLuint					depthrenderbuffer[MAX_SECONDARIES];
    GLuint                  depthrenderTexture[MAX_SECONDARIES];

	bool					framesurfacetexture;

#ifdef VR_SCREENPROJ
	GLuint					FramebufferNameSPVR;
	GLuint					renderedTextureSPVR;
	GLuint					depthrenderbufferSPVR;
	int						SPVRw,SPVRh;
#endif

#endif

	int						LevelTexture0,LevelTexture1;
	bool					dot3;
	unsigned int			Noir,Blanc;
#ifndef _DEFINES_OPENGL_NO_SDL_INIT_
	SDL_Surface *			screen;
#endif
#endif

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// interfacing

	int						SCREEN_X,SCREEN_Y;

	int                     X1base,Y1base;
	int                     X2base,Y2base;

	int						ntmax;

	float					SCREEN_Ratio;
	float					Distance;
	float					Front,Back;
	bool					SecondarySurface;
	int						TILE_SecondarySurface;
	CLight					Lights[1024];
	int						nLights;
	CVertexBuffer *			ActualVertexBuffer;
	CVertexBuffer *			ShadowVertexBuffer;

	CVertexBuffer			SHADOW_VOLUME;
	CVertexBuffer			SHADOW_FLAT;
	CVertexBuffer			SHADOW_MAPPING;
	CVertexBuffer			SHADOW_MAPPINGBL;
	int						aT,aT2,aT3,aT4;
	int						aT5,aT6,aT7,aT8;

    int                     _aT,_aT2,_aT3,_aT4;
    int                     _aT5,_aT6,_aT7,_aT8;

    CMatrix					VIEW,pVIEW,WORLD,WORLDWITHOUT,PROJ,pPROJ,VIEWPORT,REFLECTION,BASEPROJ;
	CRGBA					Ambient;
	CVertexBuffer *			ActualEffect;
	
	CVertexBuffer *			PreviousEffect;
	int						MachineState;
	vpRenderState 			PreviousRS;

	int						zb;
	int						zbw;

	int						PreviousBlend;

	int						PreviousNT;
	int						PreviousNT2;
	int						PreviousBUMP;
	
	int						lm_layers_count;
	int						lm_layers_nt[16];

	float					decals_quads_x;
	float					decals_quads_y;
    
    float                   decals_lines_x;
    float                   decals_lines_y;

	bool					StencilClear;

	CVertexBuffer *			OverClassQuadZ;

	bool					initframebuffer;

	bool					DEFER_VP;

	int						ZBiasComment;
    
    bool                    Active;
    
    int                     valueflag;
    
    float                   overscanX;
    float                   overscanY;


	/// Quads 3D
	int						nMultiQuadsXYZ;
	CVertexBuffer			vbquadsXYZ;
    
    int                     OverClass;

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// constructors

	~C3DAPIBASE()
	{
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
		delete DefaultTextureContainer;
		delete DefaultLightmapContainer;
#endif
	}

	C3DAPIBASE() 
	{
		int n;

#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
		framesurfacetexture=false;
#endif        
        OverClass=0;
        
        LevelOfDetail=false;
        
        AutomaticallyCloneShaders=false;

		nMultiQuadsXYZ=0;
        
        overscanX=0.0f;
        overscanY=0.0f;
        
        valueflag=-1;

#if defined(IOS)&&!defined(API3D_METAL)
        defaultFBO=0;
#endif

#if defined(GOOGLEVR)||defined(API3D_VR)
        defaultFBO=0;
        catseyes=true;
#endif
		zb=zbw=1;
        
        Active=true;

		ntmax=0;
		ZBiasComment=-666;

		X1base=Y1base=0;
		X2base=Y2base=0;

		PreviousNT=-1;
		PreviousNT2=-1;
		PreviousBUMP=-1;

		DEFER_VP=false;

		MachineState=0;
		PreviousBlend=-1;

		initframebuffer=false;

		OverClassQuadZ=NULL;

		StencilClear=false;

		projSCREENX=-1;
		projSCREENY=-1;

		REFLECTION.Id();

		texture_memory_size=-1;

		temporary_secondary_surface=666;

		tag_tile=false;
		for (n=0;n<MAX_SECONDARIES;n++)
		{
			if (n==0) tile_secondarysurfaces[n]=128;
			else tile_secondarysurfaces[n]=256;
		}

		fn_stage0=NULL;
		fn_stage1=NULL;
		fn_stage2=NULL;
		fn_stage3=NULL;
		fn_stage4=NULL;
		fn_stage5=NULL;

		ActualEffect=NULL;
		ContextEffect=NULL;

#if defined(API3D_DIRECT3D10)||defined(API3D_DIRECT3D11)
		blendStateTMP=NULL;
#endif

#if defined(API3D_DIRECT3D12)

		rendering=false;

		commandList=NULL;
		actualpipeline=NULL;
		nbpiplelines=0;
		max_videomemory_used=0;
		primaryneeds=true;
		alphablendingref=0;
		commandsexecuted[0]=false;
		commandsexecuted[1]=false;
        
        dirtyCRCState=true;
        CRCState=0;

		viewportmodified=true;
#endif

		decals_quads_x=0;
		decals_quads_y=0;
        
        decals_lines_x=0;
        decals_lines_y=0;

		Stating();
		MAIN_MATRIX2D.Id();
		bump_displace=0;
		bump_horizon=0;
		for (n=0;n<NBRE_MAX_TEXTURES;n++) grids[n]=NULL;
		SCREEN_Ratio=1.0f;
		NameGroup=NULL;
		Decal_nt=0;
		Decal_nt2=0;
		bumpmap_settexture=1;
		nLights=0;

		Lightmaps=&DefaultLightmaps;
		
#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_

		DefaultLightmapContainer=new CTextureAPIContainer;
		DefaultLightmapContainer->init(this);
		LightmapContainer=DefaultLightmapContainer;
		Lightmap.setTCAPI(LightmapContainer);
		iLightmap.setTCAPI(LightmapContainer);
		cLightmap.setTCAPI(LightmapContainer);

		DefaultTextureContainer=new CTextureAPIContainer;
		DefaultTextureContainer->init(this);
		TextureContainer=DefaultTextureContainer;
		cTexture.setTCAPI(TextureContainer);
		iTexture.setTCAPI(TextureContainer);
		Texture.setTCAPI(TextureContainer);
#else
		for (int i=0;i<NBRE_MAX_TEXTURES;i++)
		{
			iTexture[i]=NULL;
#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20)
			Texture[i]=NULL;
#else
			Texture[i]=((unsigned int) -1);
#endif
		}

#endif
		
		Specular=true;
		aT=-555;
		aT2=-555;
		aT3=-555;
		aT4=-555;

		aT5=-555;
		aT6=-555;
		aT7=-555;
		aT8=-555;

		SecondarySurface=false;
		nSecondaries=0;
		SCREEN_X=1024;
		SCREEN_Y=768;
		Distance=768;
		Front=0.1f;
		Back=3000;
#ifndef GLES
		whileFlush=false;
#endif
#ifdef API3D_DIRECT3D9
		TNL_VD=NULL;
		CR_VD=NULL;
#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#ifndef API3D_DIRECT3D10
#ifndef API3D_DIRECT3D11
#ifndef API3D_DIRECT3D12
		EffectBumpMapping=NULL;
		EffectBumpMappingDisplaceSS=NULL;
		PixelShaderBlur=0;
		PixelShaderBump=0;
		PixelShaderBumpSpec=0;
		nMultiQuads=-1;
//		MultiQuads=NULL;
//		TempMultiQuads=NULL;
		handle_morph=0;
		handle_morph_cr=0;
		VertexPrograms=true;
		SETTINGS_ADAPTER=-1;
		ENV_VSH_activated=false;		
		LevelTexture0=D3DTOP_MODULATE;
		LevelTexture1=D3DTOP_MODULATE;
		MULTI00=NULL; MULTI01=NULL; MULTI10=NULL; MULTI11=NULL;
		BML=NULL; BMLD=NULL; BMLa=NULL;
		SHDVOLUME=NULL; SHDVOLUMEc=NULL;
		SHDVOLUMEn=NULL; SHDVOLUMEcn=NULL;
		SHDVOLUMEm=NULL; SHDVOLUMEmc=NULL;
		SHDVOLUME_CR1=NULL; SHDVOLUME_CR2=NULL; SHDVOLUME_CR1m=NULL; SHDVOLUME_CR2m=NULL;

		set_alphatest=0;
		val_alphatest=0.0625;

		SurfaceBack=NULL;
		D3D=NULL;
		D3DDevice=NULL;
		for (n=0;n<MAX_SECONDARIES;n++) { D3DTextureSecondary[n]=NULL; D3DSecondary[n]=NULL; D3DSecondaryZbuffer[n]=NULL; }
		Texture0=NULL; Texture1=NULL; Texture2=NULL; Texture3=NULL;	Texture4=NULL; Texture5=NULL; Texture6=NULL; Texture7=NULL;
#else
		// DX12 init
#endif
#else
		// DX11 init
		device=NULL;
		devicecontext=NULL;
		StencilREF=1;
		RESET=0;
		set_alphatest=0;
		val_alphatest=0.0625;
		lT=lT2=-666;
		whileFlush=false;
		vbdraw_line=false;
		MultiQuadsZbuffer=0;
		LevelTexture0=0;
		LevelTexture1=0;
#endif
#else
		// DX10 init
		device=NULL;
		StencilREF=1;
		RESET=0;
		set_alphatest=0;
		val_alphatest=0.0625;
		lT=lT2=-666;
		whileFlush=false;
		vbdraw_line=false;
		MultiQuadsZbuffer=0;
		LevelTexture0=0;
		LevelTexture1=0;
#endif
#endif

#if defined(API3D_METAL)
		StencilREF=1;
		RESET=0;
		set_alphatest=0;
		val_alphatest=0.0625;
		lT=lT2=-666;
		whileFlush=false;
		vbdraw_line=false;
		MultiQuadsZbuffer=0;
		LevelTexture0=0;
		LevelTexture1=0;
        BLEND_GL=-1;
#endif
		MultiTexture=true;
		TILE_SecondarySurface=256;
		SecondaryRenderTargetBits=NULL;

#if defined(API3D_OPENGL20)
		lT=lT2=-666;
        force_reloc=true;
		whileFlush=false;
		vbdraw_line=false;
#endif
#if defined(API3D_OPENGL) || defined(API3D_OPENGL20)
		value_alpha=GL_ALWAYS;
		alpha_value=0;
		fp_renderbml=0;
		PixelShaderBump=0;
		PixelShaderBumpSpec=0;
		TAG_RESET=0;
		vp_stencilshadow=0;
		VertexPrograms=false;
		dot3=false;
		
#ifdef OPENGL_PBUFFERS
		hGLDC=NULL;
		hGLRC=NULL;
#endif		
		BLEND_GL=0;
#ifndef _DEFINES_OPENGL_NO_SDL_INIT_
		screen=NULL;
#endif
#ifdef OPENGL_PBUFFERS
		for (n=0;n<MAX_SECONDARIES;n++)
		{
			hPBuffer[n]=NULL; hPBufferDC[n]=NULL; hPBufferRC[n]=NULL;
			pbufferTextureID[n]=((unsigned int) -1);
			pbufferInitialized[n]=false;
		}
#endif
		LevelTexture0=GL_MODULATE;
		LevelTexture1=GL_MODULATE;
		
#endif
		StencilBuffer=false;
        
        SwitchRetinaDisplay=1;
	};

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Internals, initialisation

		// internal
		void Stating();
#if defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)||defined(API3D_METAL)
		void MultiTextureShaders(CIndicesSE * nfo,CVertexBuffer *eff);
#endif

#ifdef VR_SCREENPROJ
		void setupRenderTextureSPVR(int w,int h);
#endif
		bool setupRenderTexture(int nt,int w,int h);
		void cleanRenderTexture(int nt);

#ifdef API3D_DIRECT3D10
		int SetLayouts(CVertexBuffer * vb,D3D10_INPUT_ELEMENT_DESC *layout);
		void SetRenderState(vpRenderState * RS,int multi);
#endif

#ifdef API3D_DIRECT3D11
		int SetLayouts(CVertexBuffer * vb,D3D11_INPUT_ELEMENT_DESC *layout);
		void SetRenderState(vpRenderState * RS,int multi);
#endif
		
#ifdef API3D_DIRECT3D12
		void CleanPipelines();

		int SetLayouts(CVertexBuffer * vb,D3D12_INPUT_ELEMENT_DESC *layout);
		void SetRenderState(vpRenderState * RS,int multi);

        bool PipelineDescChanges();
        void PipelineDescBackup();
    
		ID3D12GraphicsCommandList* CreatePipelineState(CVertexBuffer *vb,ID3D12GraphicsCommandList* cmdbase,int p,D3D12_INPUT_ELEMENT_DESC *layout,UINT nblayout,bool lines);
        ID3D12GraphicsCommandList* CreatePreviousSetCommandList(CVertexBuffer *vb,ID3D12GraphicsCommandList* cmd);
		void GraphicDescriptorTable(CVertexBuffer *vb,ID3D12GraphicsCommandList* cmd);
		void CreateRootSignature(CVertexBuffer *vb);
		void FreePipelinesandSignatures();
		void CloseAndExecuteCommandList(ID3D12GraphicsCommandList* cmd);
		void CloseAndExecuteCommandListNoRelease(ID3D12GraphicsCommandList* cmd);
		void ExecuteIndirect(CVertexBuffer *vb,CVertexBuffer *eff,int istart,int iend,ID3D12GraphicsCommandList* cmd);
		void CloseOpenedCommandList();
		void CloseOpenedCommandListFence();
		int GetCrcStates();
#endif

#if !defined(API3D_OPENGL) && !defined(API3D_OPENGL20) && !defined(API3D_METAL)
#ifndef WINDOWS_PHONE
		void	SetHandleWindow(HWND hwnd);				// needed with directx
		void	SetHandleInstance(HINSTANCE hInst);		// needed with directx
#endif
#else
#ifdef OPENGL_PBUFFERS
		//! internal opengl pbuffer function 
		void	pbufferEnable(int n);
		//! internal opengl pbuffer function 
		void	pbufferDestroy(int n);
		//! internal opengl pbuffer function 
		void	pbufferRelease(int n);
		//! internal opengl pbuffer function 
		void	pbufferDisable(int n);
		//! internal opengl pbuffer function 
		void	pbufferBind(int n);
		//! internal opengl pbuffer function 
		bool	pbufferInit(int n);
#endif
#endif
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? initialisation DIRECT3D (8 or 9) and OPENGL-SDL

		//! function called by Initvideo
		void	Misc();
		//! function called by Initvideo
		void	MiscFree();

		//! free api inteface and video
		//! To be called at the end of application. Free all ressources allocated by the class.
		//! (no parameter)
		void	FreeVideo();
		//! need to be called when video mode settings change on opengl
		//! (no parameter)
		void	DeInitVideo();

		//! proc adresses/ settings
#if defined(API3D_OPENGL)||defined(API3D_OPENGL20)
#ifndef GLES
		int		openglstuff();
#endif
#endif
		//! init video
		//! A double usage function. Set video mode on specified resolution or reset device to change it.
		//! @param sx : width of screen
		//! @param sy : height of screen
		//! @param depth : RGB32BITS or RGB16BITS ou RGB16BITSSTENCIL
		int		InitVideo(int Sx,int Sy,int F);
#ifndef GLES		
		//! init video
		//! A double usage function. Set video mode on specified resolution or reset device to change it.
		//! @param sx : width of screen
		//! @param sy : height of screen
		//! @param depth : RGB32BITS or RGB16BITS ou RGB16BITSSTENCIL
		int		InitVideoWindowed(int Sx,int Sy,int F);
#endif
#ifdef API3D_OPENGL20
        //! internal
        void setPO(CMatrix *m,float w,float h);
#endif
		//! init viewport
		//! Function to initialise the viewport at full screen. To be called after InitVideo.
		//! (no parameter)
		void	InitViewport();
		//! set viewport
		//! @param x1 : uppper left corner
		//! @param y1 : uppper left corner
		//! @param x2 : bottom right corner
		//! @param y2 : bottom right corner
		void	SetViewport(int x1,int y1,int x2,int y2);
        //! set scissor
        //! @param x1 : uppper left corner
        //! @param y1 : uppper left corner
        //! @param x2 : bottom right corner
        //! @param y2 : bottom right corner
        void    SetScissor(int x1,int y1,int x2,int y2);
		//! screen ration is usefull for wide screens
		//! @param ratio : whidth/height on desktop window
		void	SetScreenRatio(float ratio);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Rendering process
		
		//! A function to be called before all primitives drawing.
		//! (no parameter)
		bool	BEGIN();
		
		//!	Close drawing cession. This must be followed by FlipDoubleBuffer to show backbuffer on screen.
		//! (no parameter)
		void	END();
#if (!defined(GLES))||defined(GLESFULL)
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Screenshots : automatic file names numbering
			
		//! save a screenhot in .TGA
		//! @param name : file name
		void	SaveScreenTGA(char * name);
		
		//! save a screenhot in .PNG
		//! @param name : file name
		void	SaveScreenPNG(char * name);

		//! save a thumbnail of the screen in PNG		
		//! @param name : file name
		void	SaveThumbnailPNG(char * name);

		//! retrieve the screen data drawn
		//! @param im : IMAGE_DATAS
		void	GetScreenRAW(struct IMAGE_DATAS *im);		
#endif

		void	GetDataSecondary(int ns,unsigned char **pbits,int *w,int *h);
        void    GetDataSecondaryFast(int ns,unsigned char **pbits,int *w,int *h);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Textures and Bump Map

		/*!	Create a squared texture from a raw rgba bitmap of dimension Sizeptr.
			creates only square textures, n specifies the number [0..1023] : ptrRGBA type: char [Sizeptr*Sizeptr*4] order :rgba
			Alpha=ALPHA or NO_ALPHA to set akpha component.
			The texture container consist in a array of texture class wrapping GL or D3D stuffs.
			N represents the texture number in the array, other texture fonctions can be used to automaticaly genrate texture number.
		*/

		//! retrieve dimension of textures
		//! @param n: n� of texture
		int		GetWidthTexture(int n);
		//! retrieve dimension of textures
		//! @param n: n� of texture
		int		GetHeightTexture(int n);

		//! create a texture
		//! @param n: n� of texture
		//! @param size: texture width=height
		//! @param ptrRGBA: raw data
		//! @param size_ptrRGBA: texture width=height of raw data
		//! @param Alpha: ALPHA or NO_ALPHA flag of texture creation
		void	CreateTexture(int n,int Size,char * ptrRGBA,int Sizeptr,int Alpha); 		
		//! create a texture
		//! @param n: n� of texture
		//! @param sizex: texture width
		//! @param sizey: texture height
		//! @param ptrRGBA: raw data
		//! @param size_ptrRGBA_x: texture width of raw data
		//! @param size_ptrRGBA_y: texture height of raw data
		//! @param Alpha: ALPHA or NO_ALPHA flag of texture creation
		void	CreateTexture(int n,int Sizex,int Sizey,char * ptrRGBA,int Sizeptrx,int Sizeptry,int Alpha); 

		//! free a texture
		//! @param n: n� of texture		
		void	FreeTexture(int n);

		//! test if texture active
		//! @param n: n� of texture
		bool	IsActiveTexture(int n);

		//! automatic square texture creation
		//! @param size: texture width=height
		//! @param ptrRGBA: raw data
		//! @param size_ptrRGBA: texture width=height of raw data
		//! @param Alpha: ALPHA or NO_ALPHA flag of texture creation
		int		AddTexture(int Size,char * ptrRGBA,int Sizeptr,int Alpha);

		//! automatic texture creation		
		//! @param sizex: texture width
		//! @param sizey: texture height
		//! @param ptrRGBA: raw data
		//! @param size_ptrRGBA_x: texture width of raw data
		//! @param size_ptrRGBA_y: texture height of raw data
		//! @param Alpha: ALPHA or NO_ALPHA flag of texture creation
		int		AddTexture(int Sizex,int Sizey,char * ptrRGBA,int Sizeptrx,int Sizeptry,int Alpha);

		//! free all textures due to group 
		//! (no parameter)
		void	FreeAllTextures();

		//! for double usage of data with multiple materials
		//!	Duplicate a texture in order to affect some diff�rent mat�rial, 
		//! the texture data remains the same and nothing is allocated except primary info of texture.
        //!	Returns the texture number.
		//! @param n: n� of texture
		int		CloneTexture(int nt);

		//! for double usage of data with multiple materials
		//! @param n : n� of texture destination
		//! @param nt: n�  of texture source
		void	DuplicateTexture(int n,int nt);

		//! from grayscale bitmap
		//! @param nt: n� of texture
		//! @param sizex: width
		//! @param sizey: height
		//! @param scale: scaling on depth map
		void	CreateBumpMap(int nt,char * ptr,int sizex,int sizey,float scale);
		//! from grayscale bitmap
		//! @param nt: n� of texture
		//! @param size: width/height		
		//! @param scale: scaling on depth map
		void	CreateBumpMap(int nt,char * ptr,int size,float scale);

		//! from grayscale bitmap
		//! @param nt: n� of texture
		//! @param sizex: width
		//! @param sizey: height
		//! @param scale: scaling on depth map
		int		AddBumpMap(char * ptr,int sizex,int sizey,float scale);

		//! from grayscale bitmap
		//! @param nt: n� of texture
		//! @param size: width/height		
		//! @param scale: scaling on depth map
		int		AddBumpMap(char * ptr,int size,float scale);

		//! set texture at level 0
		//! can specify SECONDARYTEXTUREn
		//! note: opengl mapping coord. are (x,1-y) with secondary textures (automatic for env mapping)
		//! @param n: n� of texture
		void	SetTexture(int n);

		//! set texture at level 1
		//! can specify SECONDARYTEXTUREn
		//! @param n: n� of texture
		void	SetTexture2(int n);

		//! set texture at level 2
		//! can specify SECONDARYTEXTUREn
		//! @param n: n� of texture
		void	SetTexture3(int n);

		//! set texture at level 3
		//! can specify SECONDARYTEXTUREn
		//! @param n: n� of texture
		void	SetTexture4(int n);

		//! set texture at level 4
		//! can specify SECONDARYTEXTUREn
		//! @param n: n� of texture
		void	SetTexture5(int n);

		//! set texture at level 5
		//! can specify SECONDARYTEXTUREn
		//! @param n: n� of texture
		void	SetTexture6(int n);

		//! set texture at level 6
		//! can specify SECONDARYTEXTUREn
		//! @param n: n� of texture
		void	SetTexture7(int n);

		//! set texture at level 7
		//! can specify SECONDARYTEXTUREn
		//! @param n: n� of texture
		void	SetTexture8(int n);

		//! set texture at level (lvl)
		//! can specify SECONDARYTEXTUREn
		//! @param n: n� of texture
		void	SetTexture(int lvl,int n);

		//! modify a texture from a sizex*sizey*3 (*ptr), at x,y
		//! @param n: n� of texture
		//! @param x: uppper left corner in texture raw data values
		//! @param y: uppper left corner in texture raw data values
		//! @param sizex: width of region
		//! @param sizey: height of region
		//! @param ptr: raw data
		void	ModifyTextureFromMem_RGB(int n,int x,int y,int sizex,int sizey,char * ptr);

		//! modify a texture from a sizex*size*4 buffer (*ptr), at x,y
		//! @param n: n� of texture
		//! @param x: uppper left corner in texture raw data values
		//! @param y: uppper left corner in texture raw data values
		//! @param sizex: width of region
		//! @param sizey: height of region
		//! @param ptr: raw data
		void	ModifyTextureFromMem4_RGB(int n,int x,int y,int sizex,int sizey,char * ptr);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Control parameters

		//! states
		/*!

			<B>API3D_ZBUFFER</B>
			<I>ZBuffer</I>
			(ON,OFF,WRITEOFF)

			<B>API3D_SHADING</B>
			<I>Shading</I>
			(ON,OFF)

			<B>API3D_CULL</B>
			<I>Culling</I>
			(ON,OFF,CW,CCW)

			<B>API3D_TEXTURING</B>
			<I>Texture Stage 0</I>
			(ON,OFF,T_MODULATE,T_ADD,T_BLEND)

			<B>API3D_BLEND</B>
			<I>Blending : Automatic set of Src,Dst</I>
			(ON,OFF,BLEND_GOURAUD,BLEND_COLOR,BLEND_ADD)

			<B>API3D_CREATETEXTURE</B>
			<I>Options when creating texture</I>
			(CLAMP,REPEAT,DITHERING,NODITHERING,NO_MIPMAP,MIPMAP)

			<B>API3D_SECONDARYSURFACE</B>
			<I>Options used at InitVideo</I>
			(ON,OFF,SECONDARYx,NO_SCALE,SCALE)

			<B>API3D_RENDERTARGET</B>
			<I>Render target and Stencil Buffer</I>
			(PRIMARY,SECONDARYx,STENCIL_NO_ZTEST,STENCIL,ZBUFFER,RENDER,BOTH)	

			<B>API3D_LIGHTING</B>
			<I>Transform & Lighting</I>
			(ON,OFF)	

			<B>API3D_ZBIAS</B>
			<I>ZBias</I>
			( x,0 )

			<B>API3D_STENCIL</B>
			<I>Stencil buffer test and render</I>
			(EQUAL_ONE,ALWAYS,NOT_ONE,NOT_ZERO,LESSEQUAL_ONE,
			GREATEREQUAL_ONE,EQUAL_ZERO,INCREMENT,INCREMENTSAT,SET_ONE,DECREMENT,DECREMENTSAT)		

			<B>API3D_DITHERING</B>
			<I>Dithering des primitives </I>
			(ON,OFF)

			<B>API3D_TEXTURING2</B>
			<I>Texture Stage 1</I>
			(ON,OFF,T_MODULATE,T_ADD,T_BLEND)

			<B>API3D_SPECULAR</B>
			<I>TnL Specular</I>
			(ON,OFF)

			<B>API3D_SHADERS</B>
			<I>Set EnvMapping method</I>
			(DYNAMIC_ENV,FIXED_ENV)

			<B>API3D_SHADOWING</B>
			<I>Set api shadowing param</I>
			(DRAW,DONT_DRAW)

			<B>API3D_ALPHAMULTIGROUP</B>
			<I>Set multi group alpha ref drawing</I>
			(DRAW,DONT_DRAW,ONLY)

			<B>API3D_ENVMULTIGROUP</B>
			<I>Set multi group envmap drawing</I>
			(EXTERN,INTERN)

			<B>API3D_HARDWAREVERTEXPROCESSING</B>
			<I>Set Hardware vertex processing</I>
			(ON,OFF) before InitVideo..()

			<B>API3D_BUMP_DISPLACE_SETTEXTURE</B>
			<I>Decal to texture index for diplacement mapping texture in vb associated</I>
			integer
											
			<B>API3D_HORIZON_MAPS_SETTEXTURE</B>
			<I>Decal to texture index for horizon map</I>
			integer

			<B>API3D_MULTIQUADS</B>
			<I>Optimizations for 2D Quads</I>
			(ON,OFF)

			<B>API3D_MISC</B>
			<I>Some states before initVideo</I>
			(VBL_SYNCHRO,VBL_NOSYNCHRO,VBL_INTERVAL_TWO,VBL_INTERVAL_THREE)

			<B>API3D_LIGHTMAPS</B>
			<I>Active backup for lightmap texture</I>
			(BACKUP,NO_BACKUP)

			<B>API3D_REPLACE_STENCIL</B>
			<I>Clear stencil int the same time drawing vertex buffer for STENCIL BOTH NOT_ZERO</I>
			(ON,OFF)
											
			<B>API3D_CLIPPING</B>
			<I>Active/Desactive Clipping</I>		
			(ON,OFF)

			<B>API3D_FILL</B>
			<I>Support for wireframe</I>		
			(SOLID,WIREFRAME)

			<B>API3D_BUMPMAPPINGSH</B>
			<I>Settings for bump mapping methods</I>
			(SH_BUMPY,SH_DISPLACE,SH_SELFSHADOWED,SH_CARTOON,SH_NORMAL)
			(ANIMATED,FASTDRAW,FULLDRAW,STATIC_LIGHTING)
																					
			<B>API3D_STENCILSHADOWVOLUME</B>
			<I>Stencil shadow extrusion method</I>
			(SIMPLE,ALTERNATIVE,REVERSE)

		*/
		void	SetParams(int Quoi,int Comment);
    
        void    SaveStates();
        void    ReloadStates();
    
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        void    SetFlag(int fl);
    
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Primitives

		//! 	Draw a line taking view and world matrix in consideration.
		//! @param A: point 1
		//! @param B: point 2
		//! @param r,g,b: color
		void    Line(CVector A,CVector B,float r,float g,float b);
    
#if defined(API3D_METAL)||defined(API3D_DIRECT3D12)||defined(API3D_DIRECT3D11)||defined(API3D_DIRECT3D10)||defined(API3D_OPENGL20)
        void    UpdateLines();
#endif
    
#ifndef GLES
		//! 	Draw a line strength taking view and world matrix in consideration.
		//! @param A: point 1
		//! @param B: point 2
		//! @param r,g,b: color
		void	Line2(CVector A,CVector B,float r,float g,float b);
#endif
		//!		Draw a gradient line taking view and world matrix in consideration
		//! @param A: point 1
		//! @param B: point 2
		//! @param r,g,b: color 1
		//! @param r2,g2,b2: color 2
		void	Line(CVector A,CVector B,float r,float g,float b,float r2,float g2,float b2);
		//! 	Draw a line directly to render surface. No transformation.
		//! @param x1,y1: point 1
		//! @param x2,y2: point 2
		//! @param r,g,b: color		
		void    Line(float x1,float y1,float x2,float y2,float r,float g,float b);
        void    Line(float x1,float y1,float x2,float y2,float r,float g,float b,float a);
#ifndef GLES
		void	Line(float x1,float y1,float z1,float w1,float x2,float y2,float z2,float w2,float r,float g,float b);
#endif
		//! 	Draw a line directly to render surface. No transformation.
		//! @param x1,y1: point 1
		//! @param x2,y2: point 2
		//! @param r,g,b: color 1
		//! @param r2,g2,b2: color 2
		void	Line(float x1,float y1,float x2,float y2,float r,float g,float b,float r2,float g2,float b2);
		
		//! square usefull to draw caracter or texts, sprites
		//! corresponding screen coordinates:
		//! (0,0) upper left (GetWidth(),GetHeight()) lower right
		//! @param x,y: center
		//! @param sizex,sizey: width and height
		//! @param ang: rotation angle
		//! @param x1,y1,x2,y2: mapping coo.
		//! @param r,g,b: color
		void QuadRot(float x0,float y0,float sizex,float sizey,float ang,float x1,float y1,float x2,float y2,float r,float g,float b,float a);
		//! square usefull to draw caracter or texts, sprites
		//! corresponding screen coordinates:
		//! (0,0) upper left (GetWidth(),GetHeight()) lower right
		//! @param x,y: upper left corner
		//! @param sizex,sizey: width and height
		//! @param x1,y1,x2,y2: mapping coo.
		//! @param r,g,b: color
		void	Quad(float x,float y,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b);
		//! square usefull to draw caracter or texts, sprites
		//! corresponding screen coordinates:
		//! (0,0) upper left (GetWidth(),GetHeight()) lower right
		//! @param x,y: upper left corner
		//! @param sizex,sizey: width and height
		//! @param x1,y1,x2,y2: mapping coo.
		//! @param r,g,b,a: color
		void	Quad(float x,float y,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b,float a);
		//! square usefull to draw caracter or texts, sprites
		//! corresponding screen coordinates:
		//! (0,0) upper left (GetWidth(),GetHeight()) lower right
		//! @param x,y: upper left corner
		//! @param sizex,sizey: width and height
		//! @param x1,y1,x2,y2: mapping coo.
		//! @param r,g,b,a: color
		void	QuadTaper(float x0,float y0,float taper,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b,float a);

		//! square usefull to draw caracter or texts, sprites
		//! corresponding screen coordinates:
		void	QuadGradient(float x0,float y0,float sizex,float sizey,float x1,float y1,float x2,float y2,float r,float g,float b,float a,float r2,float g2,float b2,float a2,int hv);

		//! square usefull to draw caracter or texts, sprites, grids
		//! corresponding screen coordinates:
		void	QuadDef(float xA,float yA,float xB,float yB,float xC,float yC,float xD,float yD,float x1,float y1,float x2,float y2,float r,float g,float b,float a);

		//! square usefull to draw caracter or texts, sprites, grids
		//! corresponding screen coordinates:
		void	QuadFour(float x0,float y0,float sizex,float sizey,float x1,float y1,float x2,float y2,float x3,float y3,float x4,float y4,float r,float g,float b,float a);

		//! square usefull to draw caracter or texts, sprites
		//! corresponding screen coordinates:
		//! (0,0) upper left (GetWidth(),GetHeight()) lower right
		//! @param x,y: upper left corner
		//! @param sizex,sizey: width and height
		//! @param x1,y1,x2,y2: mapping coo. stage 0
		//! @param x1,y1,x2,y2: mapping coo. stage 1
		//! @param r,g,b,a: color
		void	Quad2(float x,float y,float sizex,float sizey,float x1,float y1,float x2,float y2,float px1,float py1,float px2,float py2,float r,float g,float b,float a);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Buffers

		//! clearing buffers
		void	ClearStencilBuffer();
		// clearing buffers
		//! Clear backbuffer. To be called after BEGIN method.
		void	ClearVideoAndZBuffer();

        // clearing buffers
        //! Clear backbuffer. To be called after BEGIN method.
        //! @param r,g,b: color
        void    ClearVideoAndZBuffer(float r,float g,float b);

        // clearing buffers
        //! Clear backbuffer. To be called after BEGIN method.
        //! @param r,g,b: color
        void    ClearVideoAndZBuffer(float r,float g,float b,float a);

        //! clearing buffers
		void	ClearZBuffer();
		//! clearing buffers
		void ClearZBuffer(int x1,int y1,int x2,int y2);

		//! swap double buffer
		void	FlipDoubleBuffer();

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Main matrices

		//! conventionnal projection matrix parameter : (.Distance) is set in screen dimension
		//! specification for secondary textures:
		//! SCALE	: aspect = 1
		//! NO_SCALE : aspect = screenx/screeny
		void	SetProjection();
		void	SetProjection2();
		void    SetProjectionFov(float Fov);
    
        void    SetProjectionFov(float Fov,float aspect);

		//! conventionnal projection matrix parameter : (.Distance) is set in screen dimension
		//! specification for secondary textures:
		void	SetOrthoProjection(float sizex,float sizey);

		//! conventionnal projection matrix parameter : (.Distance) is set in screen dimension
		//! specification for secondary textures:
		//! SCALE	: aspect = 1
		//! NO_SCALE : aspect = screenx/screeny
		void	SetProjection(int SCX,int SCY);
		void	SetProjection2(int SCX, int SCY);
		//! the matrix are stored in WORLD & VIEW CMatrix
		void	LoadModelViewMatrix(CMatrix M);
		//! load matrix
		//! REFLEC = M
		void	LoadReflectionMatrix(CMatrix M);
		//! load matrix
		//! WORLD = M
		void	LoadWorldMatrix(CMatrix M);
		//! load matrix
		//! WORLD = Id
		void	LoadWorldMatrixId();
		//! load matrix
		//! VIEW = M
		void	LoadViewMatrix(CMatrix M);
		//! load matrix
		//! PROJ = M
		void	LoadProjMatrix(CMatrix M);
    
        //! get View Proj Matrix
        CMatrix GetViewProj();

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Vertex buffer

		//! draws a vb due to creation parameters
		//! use SetVertexBuffer to specify the VB to use in drawing
		void	DrawVertexBuffer();

		//! affect size dest
		void	DrawVertexBufferSetupSizeDest(CVertexBuffer *eff,CIndicesSE * nfo);

		//! specifies witch vb to draw
		//! @param vb: vertex buffer
		void	SetVertexBuffer(CVertexBuffer * vb);
    
        //! specifies witch vb to draw if lod or not
        void    SetLOD(bool activate);

		//! force use of special effect
		//! @param eff: vertex buffer / effect buffer
		void    SetEffect(CVertexBuffer *eff);
		
		//! force use of pointcloud rendering
		//! @param nT : motif
		//! @param SC : (scale x,scale y,0)
		void	SetPointCloud(int nT,CVector SC);

		//! force use of special effect
		//! @param eff: vertexbuffer effect
		void    SetOverClassQuadEffect(CVertexBuffer *overclass);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Vertex buffer creation
		//! Create a mutli textured,transparent allowed,smoothing group allowed vertex buffer.
		//! create a sort of drawing list due to texture affected in faces[].nT lightmaps (faces[].nL) , faces[].tag faces[].ref(as reflection)
		//! obj's faces tag to set smoothing group 0..7.
		//! obj's faces .ref to set transparency 0,1,2.
		//! obj's faces .nT to set texture. Etc.
		//! @param obj: mesh to convert
		//! @param type: format of destination vertex buffer
		CVertexBuffer* CreateMultiGroupFrom(CObject3D * obj,unsigned int typ);

		//! Create a mutli textured,transparent allowed,smoothing group allowed vertex buffer.
		//! @param obj: mesh to convert
		//! @param type: format of destination vertex buffer
		//! @param LMs: (CLightmap *) array
		CVertexBuffer* CreateMultiGroupFrom(CObject3D * obj,unsigned int typ,CLightmap **LMs);


		//! Create a point cloud (x,y,z r,g,b)
		//! @param obj: mesh to convert
		//! @param type: 
		CVertexBuffer* CreatePointCloudVertexBuffer(CObject3D * obj,unsigned int typ);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////	
		void	SetColorBlend(float r,float g,float b,float a);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Lights

		//! setting lights
		//! @param r,g,b: color
		void	SetAmbient(float r,float g,float b);
		//! setting lights
		//! @param n : index
		//! @param p : position
		//! @param r,g,b: color
		//! @param A,R : attenuation, range
		void	SetLightPoint(int n,CVector p,float r,float g,float b,float A,float R);	// A stands for attenuation R, range
		//! setting lights
		//! @param n : index
		//! @param p : position
		//! @param r,g,b: color
		//! @param A,R : attenuation, range
		void	SetLightPoint(int n,CVector p,float r,float g,float b,float sr,float sg,float sb,float A,float R);
		//! setting lights
		//! @param n : index
		//! @param p : position
		//! @param r,g,b: color
		void	SetLightDirectionnal(int n,CVector p,float r,float g,float b);

		//! setting lights
		//! @param n: index of light
		void	DisableLight(int n);
		//! setting lights
		//! @param n: index of light
		void	EnableLight(int n);
		//! setting lights
		//! enabling specular only
		//! @param n: index of light
		void	EnableLightSpecular(int n);

		//! setting lights
		//! @param n: index of light
		void	DisableShadowLight(int n);
		//! setting lights
		//! @param n: index of light
		void	EnableShadowLight(int n);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Texture-image processing

		//! do blur from a texture to screen
		//! settexture sets the texture to use
		//! @param x,y: upper left corner
		//! @param sizex,sizey: width and height
		//! @param decal: decal in mapping coo. level
		//! @param r,g,b,a: color
		void	Blur(float x,float y,float sx,float sy,float decal,float r,float g,float b,float a);

		void	Blur(float x,float y,float sx,float sy,float decalx,float decaly,float r,float g,float b,float a);

		//! do blur from a texture to screen
		//! settexture sets the texture to use
		//! @param x,y: upper left corner
		//! @param sizex,sizey: width and height
		//! @param K2 HL MISC
		void	Glow(float x,float y,float sx,float sy,float K2,int HL,float MISC,float RATIO);
        void    GlowPow2(float x,float y,float sx,float sy,float K2,int HL,float MISC,float RATIO);
        //! Blur pow 2
        void    BlurTmp(float x,float y,float sx,float sy,float decalx,float decaly,float r,float g,float b,float a);
		//! do full screen bump mapping
		//! @param x,y: upper left corner
		//! @param sizex,sizey: width and height
		//! @param nt_tex : texture surface (can be secondary texture or simplier texture)
		//! @param nt_bump : bump surface (can be secondary texture or simplier texture)
		//! @param nt_color : color diffuse surface (can be secondary texture or simplier texture)
		//! @param nt_lightdir : vectors surface (can be secondary texture or simplier texture)
		//! @param r,g,b,a: color
		void	DoBump(float x,float y,float sx,float sy,int nt_tex,int nt_color,int nt_bump,int nt_lightdir,float r,float g,float b,float a);

		//! do full screen fake specular bump mapping
		//! @param x,y: upper left corner
		//! @param sizex,sizey: width and height
		//! @param nt_bump : bump surface (can be secondary texture or simplier texture)
		//! @param nt_light : light specular color surface (can be secondary texture or simplier texture)
		//! @param r,g,b,a: color
		void	DoSpecular(float x,float y,float sx,float sy,int nt_bump,int nt_light,float r,float g,float b,float a);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Lightmaps

		//! this is to use with CreateMultiGroupFrom() who creates the right texture coordinates due to encapsuling small texture in a 256x256 one.
		//! see SIZE_LIGHTMAP
		//! main fonctions to create
		void	BeginLightmaps();

		//! see SIZE_LIGHTMAP
		//! @param r,g,b,a: color
		void	BeginLightmapsCache(float r,float g,float b);

		//! see SIZE_LIGHTMAP
		//! @param r,g,b,a: color ambient
		//! @param r,g,b,a: color underwater
		//! @param r,g,b,a: color second ambient
		void BeginLightmapsCache3(float r,float g,float b,
								  float r1,float g1,float b1,
								  float r2,float g2,float b2);

		//! main fonctions to create
		//! allocate a SIZE_LIGHTMAP*SIZE_LIGHTMAP texture in a 256x256 texture
		int		CreateNewLightmap();	
		
		//! main fonctions to create
		//! allocate a SIZE_LIGHTMAP*SIZE_LIGHTMAP texture in a 256x256 texture
		//! @param size: 1, 2 or 4
		int		CreateNewLightmap(int size);

		//! create a 256x256 texture - internal use
		//! @param n: index
		void	CreateTextureLightmap(int n);

		//! create a 256x256 texture - internal use
		//! @param n: index
		//! @param r,g,b: color
		void	CreateTextureLightmapCache(int n,float r,float g,float b);
		
		//! patch a SIZE_LIGHTMAP*SIZE_LIGHTMAP texture in a 256x256 texture
		//! @param nl: n� of lightmap (shared in texture layers)
		//! @param ptr: raw data
		void	PatchLightmap(int nl,char * ptr);
		//! patch a SIZE_LIGHTMAP*SIZE_LIGHTMAP texture in a 256x256 texture
		//! @param nl: n� of lightmap (shared in texture layers)
		//! @param ptr: raw data RGB
		void	PatchLightmapRGB(int nl,char * ptr);

		//! free ressources
		void	ReleaseLightmaps();

		//! set the lightmap 256x256 texture
		//! @param n: index
		void	SetLightmap(int n);

		//! set the lightmap 256x256 texture
		//! @param n: index
		void	SetLightmap2(int n);

		//! release lightmap backups (backups use enourmously big quantities of memory...)
		void	ReleaseLightmapBackups();

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//? Misc


		//! quad upper left point
		void SetQuadDecals(float xx,float yy);

		//! (internal)
		void	Flush();

		//! group name setting
		//! Define the group of all next allocated/desallocated texture.
		//! For example the name group can be set to "PRESENT" to allocate presentation textures and "GAME" 
		//! to allocate game texture.
		//! This implies that when you need to free one or the other group of texture you simply need to set
		//! correct texture name group and call FreeAllTextures().
		//! @param group: class char name of group of creation affectation		
		void	SetTextureGroup(char *group);

		//! group name retrieve
		char *	GetTextureGroup();

		//! 2D projective functions
		//! @param M: matrix
		void	LoadMainMatrix2D(CMatrix M);
		//! 2D projective functions
		//! @param M: matrix
		void	LoadMatrix2D(CMatrix MM);
		//! 2D projective functions
		//! @param x0,y0: upper left corner
		//! @param dim_x,dim_y: width and height
		//! @param n,f: near, far
		//! @param z: plane
		void	SetProjection2D(float x0,float y0,float dim_x,float dim_y,float n,float f,float z_plan2d);
		
		//! Set material properties.
		//! accessing material of texture nt; NULL if no texture defined
		//! Specular, Specular power, diffuse and ambient for the material can be set.
		//! @param nt: material
		CMaterial * Material(int nt); 

		//! true if primary
		bool IsPrimarySurface();

#ifdef _DEFINES_API_CODE_TEXTURE_MANAGER_
		//! Set actual texture container.
		void	SetTextureContainer(CTextureAPIContainer * tc);
		void	SetLightmapContainer(CTextureAPIContainer * tc);
#endif

		//! get viewport vector from 2d coordinates
		//! @param x,y: stands for x,y mouse cursor for example, the result is the pointer vector 
		CVector PickVecteur(float x,float y);
		CVector PickVecteur(float x,float y,int SCX,int SCY);
    
        //! get viewport frustumvectors
        CVector* GetFrustum();

		//! project and tranform a vector
		//! @param v: vector
		CVector4 Project(CVector v);
		//! project and tranform a vector
		//! @param v: vector
		CVector2 Project2D(CVector v);
		//! calculate lighting for a point
		//! @param v: vector
		//! @param N: normal
		//! @param &cr,&cg,&cb: color
		void	Light(CVector v,CVector N,float *cr,float *cg,float *cb);

		//! calculate lighting for a point from one light
		//! @param v: vector
		//! @param N: normal
		//! @param &cr,&cg,&cb: color
		void	Light(int nl,CVector v,CVector N,float *cr,float *cg,float *cb);

		//! (internal)
		void	CalcViewProj(CMatrix *m);

		//! (internal)
		void	BumpMappingStates();

		//! check device main capabilities
		//! @param tag: on of those values
		//!	DEV_STENCILBUFFER,
		//!	DEV_MULTITEXTURE,
		//!	DEV_SECONDARIES,
		//!	DEV_DOTPRODUCT,
		//!	DEV_PIXELSHADERS,
		//!	DEV_TEXTURESUP256,
		//!	DEV_PIXELSHADERS2,
		//!	DEV_BUMPENVMAP
		bool	CheckDevice(int tag);

		//! set secondary surface tile : affect all surfaces
		//! @param tile: integer for size
		void	SetTileSecondary(int tile);
		//! set secondary surface tile
		//! @param tile: integer for size
		void	SetTileSecondary(int ns,int tile);
		//! set secondary surface tile
		//! @param tilex: integer for size
		//! @param tiley: integer for size
		void	SetTileSecondary(int ns,int tilex,int tiley);

		//! define temporary secondary surface for effects
		//! some effects need an auxiliary surface to proceed
		void	SetSecondaryAsTemporary(int ns);

		//! returns height of actual surface
		int		GetHeight();

		//! returns width of actual surface
		int		GetWidth();

		//! returns id of actual surface
		int		GetSurfaceActive();

		//! context parameters on vertex buffer created by CreateMultiGroupFrom()
		//! @param stage : define texture stage for the function
		//! @param fn : function that returns the texture index from values, nT etc becomes virtual values.
		void	SetFixedContextParameters(int stage,int (*fn)(int nt,int nt2,int nl,int nlv,int tag));

		//! context parameters for effect on vertex buffer created by CreateMultiGroupFrom()
		void	SetEffectContext(CContextEffectParameters * CEP);

		//! define the texture translation applied on nT value for multi group vertexbuffer
		void	SetTextureTranslate(int dc);
};


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//				Enums
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

enum
{
	// SetParams (Quoi ,..)
	API3D_NONE						=	0,		
	API3D_ZBUFFER					=	1,
	API3D_SHADING 					=	3,
	API3D_CULL    					=	4,
	API3D_TEXTURING					=	5,		// first texture level
	API3D_BLEND						=	6,
	API3D_CREATETEXTURE				=	7,
	API3D_SECONDARYSURFACE			=	8,
	API3D_RENDERTARGET				=	9,
	API3D_LIGHTING					=	10,
	API3D_ZBIAS						=	11,
	API3D_STENCIL					=	12,
	API3D_DITHERING					=	13,
	API3D_TEXTURING2				=	14,		// second texture level
	API3D_SPECULAR					=	15,		// toggle du specular
	API3D_SHADERS					=	16,
	API3D_SHADOWING					=	17,
	API3D_ALPHAMULTIGROUP			=	18,
	API3D_ENVMULTIGROUP				=	19,
	API3D_BUMP_SETTEXTURE			=	20,
	API3D_ALPHATEST					=	21,
	API3D_HARDWAREVERTEXPROCESSING	=	22,
	API3D_BUMPMAPPINGSH				=	23,
	API3D_STENCILSHADOWVOLUME		=	24,
	API3D_BUMP_DISPLACE_SETTEXTURE	=	25,
	API3D_HORIZON_MAPS_SETTEXTURE	=	26,
	API3D_MULTIQUADS				=	27,
	API3D_MISC						=	28,
	API3D_LIGHTMAPS					=	29,
	API3D_REPLACE_STENCIL			=	30,
	API3D_CLIPPING					=	31,
	API3D_ANTIALIASING				=	32,
	API3D_MULTILAYEREFFECTS			=	33,
	API3D_TEXTUREFILTERS			=	34,
	API3D_LIGHTMAPLAYERS			=	35,
	API3D_TEXTUREMIPMAP    			=	36,
	API3D_FILL		    			=	37,
	API3D_VIRTUALSCREEN				=	38
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
enum
{
	// SetTexture(n)

	SECONDARYTEXTURE1				=	-1,		// set texture values
	SECONDARYTEXTURE2				=	-2,
	SECONDARYTEXTURE3				=	-3,
	SECONDARYTEXTURE4				=	-4,
	SECONDARYTEXTURE5				=	-5,
	SECONDARYTEXTURE6				=	-6,
	SECONDARYTEXTURE7				=	-7,
	SECONDARYTEXTURE8				=	-8,
	SECONDARYTEXTURE9				=	-9,
	SECONDARYTEXTURE10				=	-10,
	SECONDARYTEXTURE11				=	-11,
	SECONDARYTEXTURE12				=	-12,
	SECONDARYTEXTURE13				=	-13,
	SECONDARYTEXTURE14				=	-14,
	SECONDARYTEXTURE15				=	-15,
	SECONDARYTEXTURE16				=	-16,
	SECONDARYTEXTURE17				=	-17,
	SECONDARYTEXTURE18				=	-18,
	SECONDARYTEXTURE19				=	-19,
	SECONDARYTEXTURE20				=	-20,
	SECONDARYTEXTURE21				=	-21,
	SECONDARYTEXTURE22				=	-22,
	SECONDARYTEXTURE23				=	-23,
	SECONDARYTEXTURE24				=	-24,

	SECONDARYTEXTURESPVR			=	-666,	

	// SetParams (..,Comment)

	ON								=	1,		// enable option
	OFF								=	0,		// disable option
	WRITEONLY						=	2,
	READONLY						=	3,
	CW								=	4,		// cull parameters (can be ON and OFF too)
	CCW								=	5,
	T_MODULATE						=	6,		// diffuse*mapping,  API3D_TEXTURING parameter
	T_BLEND							=	7,		// diffuse*mapping,  API3D_TEXTURING parameter (opengl)
	CLAMP							=	8,		// API3D_CREATETEXTURE parameter
	REPEAT							=	9,		// API3D_CREATETEXTURE parameter
	DOUBLETEXTURAGE					=	10,		// ??
	DITHERING						=	11,		// API3D_CREATETEXTURE parameter (automatic texture dithering for 16bits)
	NODITHERING						=	12,		// API3D_CREATETEXTURE parameter
	PRIMARY							=	13,		// API3D_RENDERTARGET parameter
	SECONDARY						=	14,		// obsolete
	MIPMAP							=	15,		// API3D_CREATETEXTURE parameter
	NO_MIPMAP						=	16,		// API3D_CREATETEXTURE parameter
	WRITEOFF						=	17,		// API3D_ZBUFFER parameter
	BLEND_GOURAUD					=	18,		// API3D_BLEND parameter ( added transparency vs modulated transparency with ON)

	STENCIL							=	19,		// API3D_RENDERTARGET parameter
	RENDER							=	20,		// API3D_RENDERTARGET parameter
	BOTH							=	21,		// API3D_RENDERTARGET parameter

	INCREMENT						=	22,		// API3D_STENCIL parameters
	DECREMENT						=	23,		
	SET_ONE							=	24,
	EQUAL_ZERO						=	25,
	EQUAL_ONE						=	26,
	
	NOT_ONE							=	28,
	NOT_ZERO						=	29,
	LESSEQUAL_ONE					=	30,
	GREATEREQUAL_ONE				=	31,
	INCREMENTSAT					=	32,
	DECREMENTSAT					=	33,
	STENCIL_NO_ZTEST				=	34,		// API3D_RENDERTARGET parameter
	ZBUFFER							=	35,		// API3D_RENDERTARGET parameter


	SCALE							=	36,		// aspect; API3D_SECONDARYSURFACE parameters
	NO_SCALE						=	37,
	ASPECT_PRIMARY_BUFFER			=	36,
	ASPECT_RECTANGULAR_BUFFER		=	37,		

	SECONDARY1						=	50038,		// API3D_RENDERTARGET parameter
	SECONDARY2						=	50039,
	SECONDARY3						=	50040,
	SECONDARY4						=	50041,
	SECONDARY5						=	50042,
	SECONDARY6						=	50043,
	SECONDARY7						=	50044,
	SECONDARY8						=	50045,
	SECONDARY9						=	50046,
	SECONDARY10						=	50047,
	SECONDARY11						=	50048,
	SECONDARY12						=	50049,
	SECONDARY13						=	50050,
	SECONDARY14						=	50051,
	SECONDARY15						=	50052,
	SECONDARY16						=	50053,
	SECONDARY17						=	50054,
	SECONDARY18						=	50055,
	SECONDARY19						=	50056,
	SECONDARY20						=	50057,
	SECONDARY21						=	50058,
	SECONDARY22						=	50059,
	SECONDARY23						=	50060,
	SECONDARY24						=	50061,

	BLEND_COLOR						=	62,

	FIXED_ENV						=	63,
	DYNAMIC_ENV						=	64,

	DRAW							=	65,
	DONT_DRAW						=	66,
	ONLY							=	67,
	EXTERN							=	68,
	INTERN							=	69,

	LESS							=	256,	// API3D_CMP parameter
	GREATER							=	257,
	ALWAYS							=	258,
	LESSEQUAL						=	259,
	GREATEREQUAL					=	260,
	EQUAL							=	261,
	NOTEQUAL						=	262,
	NEVER							=	263,
	ENABLE							=	264,
	DISABLE							=	265,
	REINIT							=	266,

	BOTH_WRITE_Z					=	70,
	BLEND_INVERSE					=	71,

	ANIMATED						=	72,
	FASTDRAW						=	73,
	FULLDRAW						=	74,
	STATIC_LIGHTING					=	75,

	REVERSE							=	76,
	SIMPLE							=	77,
	SET_ZERO						=	78,


	STENCIL_SET						=	1000,
	STENCIL_EQUAL					=	2000,

	TEXTURE16BITS					=	79,
	TEXTURE32BITS					=	80,

	SH_BUMPY						=	1024,
	SH_DISPLACE						=	1024*2,
	SH_SELFSHADOWED					=	1024*4,
	SH_CARTOON						=	1024*8,
	SH_NORMAL						=	1024*16,

	VBL_SYNCHRO						=	81,
	VBL_NOSYNCHRO					=	82,
	VBL_INTERVAL_TWO				=	83,
	VBL_INTERVAL_THREE				=	84,

	DIRTYDRAW						=	85,

	BACKUP							=	86,
	NO_BACKUP						=	87,


	ALTERNATIVE						=	88,
	INVERT							=	89,

	NOT_ZERO_REPLACE				=	90,
	EQUAL_ZERO_REPLACE				=	91,

	FIT_RENDERER_DIMENSION			=	92,
	FULL_RENDERING					=	93,

	TRIVIAL_ELIMINATION_ON			=	94,
	TRIVIAL_ELIMINATION_OFF			=	95,

	T_ADD							=	96,		// API3D_TEXTURING parameter
	WRAP							=	97,
	NO_WRAP							=	98,

	STAGE0_ON						=	99,
	STAGE1_ON						=	100,

	STAGE0_OFF						=	101,
	STAGE1_OFF						=	102,	
	
	TOGGLE							=	103,

	BLEND_ADD						=	104,

	ALTERNATIVE_GPU					=	105,

	BLEND_NO_ALPHA					=	106,

	TWOSIDED_ALTERNATIVE			=	107,
	TWOSIDED_REVERSE				=	108,


	DEV_STENCILBUFFER				=	1,
	DEV_MULTITEXTURE				=	2,
	DEV_SECONDARIES					=	3,
	DEV_DOTPRODUCT					=	4,
	DEV_PIXELSHADERS				=	5,
	DEV_TEXTURESUP256				=	6,
	DEV_PIXELSHADERS2				=	7,
	DEV_BUMPENVMAP					=	8,

	WIREFRAME						=	333,
	SOLID							=	334,

	ALGO_ALTERNATIVE				=	0,
	ALGO_REVERSE					=	1,
	ALGO_SIMPLE						=	2

};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define RGB16BITS				1
#define RGB24BITS				2
#define RGB32BITS				3
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef API3D_DIRECT3D
extern void SetDEVICE(LPDIRECT3DDEVICE8 Device);

#endif
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define TWOSIDED_STENCIL					'A'
#define LIGHTMAP_LAYERS						'B'
#define MIPMAP_ACTIVE_CULLING				'C'
#define TEXTURE_MAX_WIDTH					'D'
#define SHADOW_BUFFERING					'E'
#define ALGO_STENCIL_SHADOWING				'F'
#define UNKNOWN								'G'
#define TRIVIAL_ELIMINATION_STENCIL			'H'
#define LAYER_DIMENSION						'I'
#define RENDER_TARGET						'J'
#define SHADERS								'K'
#define VERTICAL_RETRACE					'L'
#define SCALE_SCREEN						'M'
#define BLENDING							'N'
#define RENDER_BIT_DEPTH					'O'
#define CULLING								'P'
#define ZBUFFERING							'Q'
#define HARDWARE_VERTEX_PROCESSING_E		'R'
#define HARDWARE_VERTEX_PROCESSING_MIPMAP	'S'
#define HARDWARE_VERTEX_PROCESSING			'T'
#define ZBUFFER_TEST_STENCIL				'U'
#define LIGHTMAP_BACKUPS					'V'
#define TEXTURES_32BITS						'W'
#define TEXTURES_MIPMAP_ACTIVE				'X'
#define TEXTURES_CLAMPING					'Y'
#define TEXTURES_DITHERING					'Z'
#define SPECIAL_FASTDRAW					'a'
#define SPECIAL_ANIMATED					'b'
#define SPECIAL_ENHANCED					'c'
#define ALPHA_MULTI_GROUP_DRAW				'd'
#define ENV_SHADERS							'e'
#define MIPMAP_ACTIVE						'f'
#define REPLACE_ACTIVE						'g'
#define RENDER_TARGET_OPTIONS				'h'
#define RENDER_BLEND_NO_ALPHA				'i'
#define PIXELSHADER2                        'j'
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define PS2 "Pixel Shaders 2.0"
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//				D�finitions des param�tres de controle d'affichage des objets
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// obsolete

#define DIFFUSE_ONE							1
#define DIFFUSE_NORM						2
#define MAPPING_PER_VERTEX					4
#define	MAPPING_PER_FACE					8
#define ENVIRONMENT							16
#define GOURAUD_MAPPING						32
#define GOURAUD_SEUL						64
#define DIFFUSE_LIGHTING					128
#define PROPRIETES_PHYSIQUES				256
#define PROPRIETES_MATRICES					512

#define STCL_SET(k)							(STENCIL_SET+k)
#define STCL_EQUAL(k)						(STENCIL_EQUAL+k)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef API3D_DIRECT3D10

#ifndef D3DCOLOR_DEFINED
typedef DWORD D3DCOLOR;
#define D3DCOLOR_DEFINED
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define D3DCOLOR_RGBA(r,g,b,a) \
    ((D3DCOLOR)((((a)&0xff)<<24)|(((b)&0xff)<<16)|(((g)&0xff)<<8)|((r)&0xff)))

#define D3DCOLOR_COLORVALUE(r,g,b,a) \
    D3DCOLOR_RGBA((DWORD)((r)*255.f),(DWORD)((g)*255.f),(DWORD)((b)*255.f),(DWORD)((a)*255.f))

#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
unsigned int VideoMem();
int SecondaryTextureFromSurface(int snd);
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef LINUX
void GLVersionForTexturesSize();
#endif


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
